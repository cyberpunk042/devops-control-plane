# Pod Template Audit ‚Äî Container Grouping & Volume Assembly

> Every unique code path inside `_build_pod_template`, traced for correctness.

---

## Container Assembly

There are **5 distinct container insertion paths** in `_build_pod_template`. 
They all feed into two lists: `pod_spec["containers"]` and `pod_spec["initContainers"]`.

### Path 1: Main Container (line 2248)
```
main_container = {name, image}
  + ports (if port)
  + command/args (if command ‚Äî Job/CronJob)
  + resources (if any limits/requests)
  + readinessProbe / livenessProbe (if configured)
  + env (from _build_env_vars)
  + envFrom (from translator ‚Äî ConfigMap/Secret bulk refs)
  + volumeMounts (assembled last from all volume paths)
‚Üí pod_spec["containers"][0] = main_container
```
**Risk**: ‚úÖ No issues. Main container is always first in the list.

### Path 2: Init Containers (line 2302)
```
For each ic in spec.initContainers:
  ic_spec = {name, image, command: ["sh", "-c", cmd]}
‚Üí init_containers_list.append(ic_spec)
```
**Risk**: ‚ö†Ô∏è BUG ‚Äî if `ic.command` is already a list (from dependency wait-for
init containers generated by translator), wrapping it in `["sh", "-c", cmd]`
would produce `["sh", "-c", "echo 'Waiting...'; until nc -z ..."]` ‚Äî which
is actually correct for shell commands. BUT the translator sets it as a raw
string field `command`, not as a pre-built list. So the `["sh", "-c", cmd]`
wrapping here is correct.

**HOWEVER**: The translator generates wait-for init containers with a
`command` STRING field. When `_build_pod_template` processes these, it
wraps them in `["sh", "-c", cmd]`. This means the init containers list
has TWO sources:
1. User-defined init containers (from wizard, string `command`)
2. Dependency wait-for init containers (from translator, string `command`)

Both arrive in `spec.initContainers` (merged by translator as `all_init`).
Both get the same `["sh", "-c", cmd]` treatment. ‚úÖ Consistent.

### Path 3: Sidecar Containers (line 2330)
```
For each sc in spec.sidecars:
  sc_spec = {name, image}
  + command (if set)
  + shared volume handling:
    - Add emptyDir vol if not already present
    - Add volumeMount to sidecar
    - Add volumeMount to main container
  IF nativeSidecar=true:
    sc_spec.restartPolicy = "Always"
    ‚Üí init_containers_list.append(sc_spec)    # K8s ‚â•1.28 native sidecar
  ELSE:
    ‚Üí pod_spec["containers"].append(sc_spec)  # regular sidecar
```
**Risks**:
- ‚ö†Ô∏è BUG: `nativeSidecar` defaults to `True` (line 2351: `if sc.get("nativeSidecar", True)`).
  This means if the wizard doesn't set `nativeSidecar`, it defaults to native.
  Is this intentional? The wizard checkbox defaults to `true` (checked), so this
  matches. ‚úÖ But worth documenting.
- ‚ö†Ô∏è TIMING BUG: `init_containers_list` is finalized and assigned to
  `pod_spec["initContainers"]` at line 2360 (`if init_containers_list: ...`).
  But this happens BEFORE the sidecar loop at line 2330. No wait ‚Äî
  let me re-read the ordering...

  Actually looking more carefully:
  - Line 2302: init containers loop ‚Üí appends to `init_containers_list`
  - Line 2330: sidecar loop ‚Üí native sidecars append to `init_containers_list`
  - Line 2359: `if init_containers_list: pod_spec["initContainers"] = init_containers_list`
  - Line 2362: companion loop ‚Üí companion wait-for appends to `init_containers_list` (line 2447)

  **üî¥ BUG**: Line 2359 assigns `init_containers_list` to `pod_spec["initContainers"]`.
  Then at line 2447, companion wait-for init containers `append` to `init_containers_list`.
  Since Python lists are reference types, these appends DO modify `pod_spec["initContainers"]`
  because it's the same list object. So this actually works by accident.

  BUT: if `init_containers_list` was empty at line 2359 (no user init containers AND
  no native sidecars), the assignment is skipped. Then companion wait-fors at line 2447
  append to `init_containers_list`, but `pod_spec` has no reference to it. The companion
  wait-for init containers are **silently dropped**.

  **üî¥ CONFIRMED BUG**: If a pod has NO init containers and NO native sidecars,
  but HAS companions with `dependsOn`, the companion wait-for init containers
  are never added to the pod spec.

### Path 4: Companion Containers (line 2362)
```
For each comp in spec.companions:
  comp_spec = {name, image}
  + ports (if port)
  + env (from _build_env_vars ‚Äî no svc_name convention!)
  + resources (if configured)
  + volumeMounts (from companion-specific volumes)
‚Üí pod_spec["containers"].append(comp_spec)
```
**Risks**:
- ‚ö†Ô∏è Companion env vars use `_build_env_vars(comp.get("env"))` without `svc_name`.
  This means they generate raw env vars, not ConfigMap/Secret refs. The translator
  does NOT generate companion-specific ConfigMap/Secret resources. For companion
  env vars, this is actually fine ‚Äî companions are within the same pod, so their
  env vars are typically simple (DATABASE_URL, etc). But if a companion has
  `type: "secret"` env vars, they would generate `secretKeyRef` pointing to
  a Secret that doesn't exist (because `_svc_env_to_resources` is never called
  for companion env vars).
  
  **‚ö†Ô∏è POTENTIAL BUG**: Companion secret env vars generate refs to non-existent
  Secrets. Low priority ‚Äî companions rarely have secrets.

### Path 5: Companion wait-for (line 2434)
```
If comp.dependsOn and dependsOn != "__main__":
  wait_host = dependsOn (infra name)
  wait_port = comp.dependsOnPort or spec.port
  ‚Üí init_containers_list.append(wait-for init container)
```
**Risks**:
- üî¥ BUG (same as above): If the init_containers_list assignment was skipped
  at line 2359, these appends go nowhere.
- ‚ö†Ô∏è `wait_host` uses raw `dependsOn` name, same DNS resolution issue as
  the dependency wait-for (StatefulSet ‚Üí wrong DNS). Lower priority since
  companion dependsOn is typically a simple infra name within the same pod.

---

## Volume Assembly

There are **5 distinct volume sources**, all feeding into two lists:
- `volumes` (pod-level volume definitions)
- `volume_mounts_main` (main container's volumeMounts)

### Source 1: Direct API volumes (line 2316)
```
volumes = list(spec.get("_pod_volumes") or [])
volume_mounts_main = list(spec.get("volumeMounts") or [])
```
Rarely used (for direct API callers). ‚úÖ No issues.

### Source 2: Wizard volumes (line 2321)
```
For each wv in spec.wizardVolumes:
  _build_wizard_volume(wv, index, svc_name) ‚Üí (pod_vol, vm)
  Dedup by vol name ‚Üí volumes.append(), volume_mounts_main.append()
```
**Risk**: ‚úÖ Dedup correctly prevents duplicate pod volumes. Volume mounts
are not deduped but that's correct (multiple mounts of same volume at
different paths is valid).

### Source 3: Sidecar shared volumes (line 2339)
```
If sidecar has sharedVolume + sharedMount:
  Add emptyDir to volumes (if not already present)
  Add volumeMount to sc_spec (sidecar container)
  Add volumeMount to volume_mounts_main (main container)
```
**Risk**: ‚úÖ Dedup by vol_names set. Both containers get the mount.

### Source 4: Companion volumes (line 2394)
```
For each companion volume:
  Add to pod-level volumes (if not present, based on type)
  Add volumeMount to companion container
```
**Risk**: ‚ö†Ô∏è PVC companion volumes use `claimName: vol_name` without
svc_name prefix. This would need to match whatever PVC is actually
generated. But companion PVC volumes are not processed by
`_svc_volumes_to_pvc_resources` in the translator. The PVC resource
for a companion volume is never generated.

**‚ö†Ô∏è POTENTIAL BUG**: Companion PVC volumes reference PVCs that
don't exist. However, most companion volumes are `emptyDir`
(e.g. redis-data in the example), so this is low priority.

### Source 5: VCT volumeMounts (line 2453)
```
For each VCT in spec.volumeClaimTemplates:
  Add volumeMount to volume_mounts_main (NO pod volume needed)
```
**Risk**: ‚úÖ Correct ‚Äî VCTs don't need pod volumes.

---

## Summary of Bugs Found

### üî¥ ‚úÖ FIXED: Companion wait-for init containers dropped

**Location**: Lines 2359 + 2447 (before fix)
**Condition**: Pod has no user init containers AND no native sidecars,
but HAS companions with `dependsOn`.
**Effect**: The companion wait-for init container is appended to
`init_containers_list` but never referenced by `pod_spec`, because
the assignment at line 2359 was skipped (empty list ‚Üí falsy).
**Fix**: Moved `pod_spec["initContainers"]` assignment to AFTER all
init container sources (user, sidecar, companion) have been processed.

### ‚ö†Ô∏è Medium: Companion secret env vars reference non-existent Secret

**Location**: Line 2370, `_build_env_vars(comp.get("env"))`
**Condition**: Companion has env vars with `type: "secret"`
**Effect**: The container spec includes `secretKeyRef` pointing to a
Secret that was never generated.
**Fix**: Either (a) generate companion-specific Secrets in the translator,
or (b) document that companion secrets are not supported (use `envFrom`).
Low priority ‚Äî companions rarely have secrets.

### ‚ö†Ô∏è Low: Companion PVC volumes reference non-existent PVCs

**Location**: Lines 2408-2412
**Condition**: Companion has a pvc-dynamic/pvc-static volume
**Effect**: Pod references a PVC that was never generated.
**Fix**: Process companion PVC volumes in the translator. Low priority.

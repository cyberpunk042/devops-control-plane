"""
Terraform scaffolding â€” HCL template generation.

Generates main.tf, variables.tf, outputs.tf, and .gitignore
for a new Terraform project.
"""

from __future__ import annotations

from pathlib import Path

from src.core.services.audit_helpers import make_auditor

_audit = make_auditor("terraform")


# â”€â”€ Templates â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€


_MAIN_TF_TEMPLATE = '''# â”€â”€ Main Terraform Configuration â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Generated by DevOps Control Plane

terraform {{
  required_version = ">= 1.5.0"

  required_providers {{
    {provider_block}
  }}

  {backend_block}
}}

provider "{provider}" {{
  {provider_config}
}}

# â”€â”€ Resources â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# Add your resources here
'''

_VARIABLES_TF_TEMPLATE = '''# â”€â”€ Variables â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Generated by DevOps Control Plane

variable "project" {{
  description = "Project name"
  type        = string
  default     = "{project_name}"
}}

variable "environment" {{
  description = "Environment (dev, staging, production)"
  type        = string
  default     = "dev"

  validation {{
    condition     = contains(["dev", "staging", "production"], var.environment)
    error_message = "Environment must be dev, staging, or production."
  }}
}}

variable "region" {{
  description = "Cloud region"
  type        = string
  default     = "{default_region}"
}}

variable "tags" {{
  description = "Common resource tags"
  type        = map(string)
  default = {{
    Project     = "{project_name}"
    ManagedBy   = "terraform"
  }}
}}
'''

_OUTPUTS_TF_TEMPLATE = '''# â”€â”€ Outputs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Generated by DevOps Control Plane

# output "example_id" {{
#   description = "ID of the example resource"
#   value       = resource_type.resource_name.id
# }}
'''


# â”€â”€ Data access â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€


def _provider_blocks() -> dict[str, dict]:
    """Terraform cloud provider configs â€” loaded from DataRegistry."""
    from src.core.data import get_registry
    return get_registry().terraform_providers


def _backend_blocks() -> dict[str, str]:
    """Terraform backend HCL templates â€” loaded from DataRegistry."""
    from src.core.data import get_registry
    return get_registry().terraform_backends


# â”€â”€ Generator â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€


def generate_terraform(
    project_root: Path,
    provider: str = "aws",
    *,
    backend: str = "local",
    project_name: str = "",
) -> dict:
    """Generate Terraform scaffolding.

    Returns:
        {"ok": True, "files": [{path, content, reason}, ...]}
    """
    from src.core.models.template import GeneratedFile

    if not project_name:
        project_name = project_root.name

    providers = _provider_blocks()
    prov_config = providers.get(provider)
    if not prov_config:
        return {"error": f"Unknown provider: {provider}. Available: {', '.join(providers.keys())}"}

    # Build provider block
    provider_block = f"""{provider} = {{
      source  = "{prov_config['source']}"
      version = "{prov_config['version']}"
    }}"""

    # Build backend block
    backends = _backend_blocks()
    backend_template = backends.get(backend, backends["local"])
    backend_block = backend_template.format(
        project=project_name.replace("-", "").replace("_", ""),
        region=prov_config.get("default_region", "us-east-1"),
    )

    # main.tf
    main_content = _MAIN_TF_TEMPLATE.format(
        provider_block=provider_block,
        backend_block=backend_block,
        provider=provider,
        provider_config=prov_config["config"],
    )

    # variables.tf
    vars_content = _VARIABLES_TF_TEMPLATE.format(
        project_name=project_name,
        default_region=prov_config.get("default_region", "us-east-1"),
    )

    files: list[dict] = []

    files.append(GeneratedFile(
        path="terraform/main.tf",
        content=main_content,
        overwrite=False,
        reason=f"Terraform main config ({provider} provider, {backend} backend)",
    ).model_dump())

    files.append(GeneratedFile(
        path="terraform/variables.tf",
        content=vars_content,
        overwrite=False,
        reason="Terraform variables with validation",
    ).model_dump())

    files.append(GeneratedFile(
        path="terraform/outputs.tf",
        content=_OUTPUTS_TF_TEMPLATE,
        overwrite=False,
        reason="Terraform outputs (template)",
    ).model_dump())

    # .gitignore for terraform
    tf_gitignore = """# Terraform
.terraform/
*.tfstate
*.tfstate.*
*.tfplan
crash.log
*.tfvars
!terraform.tfvars.example
.terraform.lock.hcl
"""
    files.append(GeneratedFile(
        path="terraform/.gitignore",
        content=tf_gitignore,
        overwrite=False,
        reason="Terraform .gitignore",
    ).model_dump())

    _audit(
        "ðŸ“ Terraform Generated",
        f"Scaffolding generated (provider={provider}, backend={backend})",
        action="generated", target="terraform",
        after_state={"provider": provider, "backend": backend},
    )
    return {"ok": True, "files": files}


# â”€â”€ Data access â€” K8s cluster catalog â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€


def _k8s_catalog() -> dict[str, dict]:
    """Per-provider K8s cluster HCL templates â€” loaded from DataRegistry."""
    from src.core.data import get_registry
    return get_registry().terraform_k8s


# â”€â”€ K8s + Terraform cross-domain generator â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€


def generate_terraform_k8s(
    project_root: Path,
    provider: str = "aws",
    *,
    backend: str = "local",
    project_name: str = "",
    namespace: str = "",
    services: list[dict] | None = None,
    node_count: int = 2,
    node_size: str = "",
    k8s_version: str = "",
) -> dict:
    """Generate Terraform IaC for K8s cluster provisioning.

    Cross-domain generator: takes K8s wizard state (namespace, services)
    and produces Terraform HCL that provisions the cloud infrastructure
    those workloads need (cluster, registry, namespace, outputs).

    Args:
        project_root: Project root directory.
        provider: Cloud provider â€” "aws", "google", or "azurerm".
        backend: Terraform state backend â€” "s3", "gcs", "azurerm", "local".
        project_name: Project name (defaults to dir name).
        namespace: K8s namespace from wizard â†’ kubernetes_namespace resource.
        services: K8s wizard _services list â†’ registry resource if images present.
        node_count: Cluster node count (default 2).
        node_size: Node instance type (auto-selected per provider if empty).
        k8s_version: Kubernetes version (auto-selected per provider if empty).

    Returns:
        {"ok": True, "files": [{path, content, reason}, ...]}
        or {"error": "..."} on failure.
    """
    from src.core.models.template import GeneratedFile

    if not project_name:
        project_name = project_root.name

    # â”€â”€ Validate provider â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    cloud_providers = _provider_blocks()
    prov_config = cloud_providers.get(provider)
    if not prov_config:
        return {
            "error": (
                f"Unknown provider: {provider}. "
                f"Available: {', '.join(cloud_providers.keys())}"
            ),
        }

    k8s_catalog = _k8s_catalog()
    k8s_config = k8s_catalog.get(provider)
    if not k8s_config:
        return {
            "error": (
                f"No K8s cluster template for provider: {provider}. "
                f"Available: {', '.join(k8s_catalog.keys())}"
            ),
        }

    # â”€â”€ Defaults from catalog â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if not node_size:
        node_size = k8s_config["default_node_size"]
    if not k8s_version:
        k8s_version = k8s_config["default_k8s_version"]

    default_region = prov_config.get("default_region", "us-east-1")
    if services is None:
        services = []
    has_images = any(svc.get("image") for svc in services)

    # â”€â”€ main.tf â€” provider + cluster + registry â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    provider_block = f"""{provider} = {{
      source  = "{prov_config['source']}"
      version = "{prov_config['version']}"
    }}"""

    # Kubernetes provider (for namespace resource)
    k8s_provider_block = """    kubernetes = {
      source  = "hashicorp/kubernetes"
      version = "~> 2.0"
    }"""

    backends = _backend_blocks()
    backend_template = backends.get(backend, backends["local"])
    backend_block = backend_template.format(
        project=project_name.replace("-", "").replace("_", ""),
        region=default_region,
    )

    cluster_hcl = k8s_config["cluster_hcl"]
    registry_hcl = k8s_config.get("registry_hcl", "")

    main_lines = [
        "# â”€â”€ K8s Cluster Infrastructure â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€",
        "# Generated by DevOps Control Plane (K8s + Terraform cross-domain)",
        "",
        "terraform {",
        '  required_version = ">= 1.5.0"',
        "",
        "  required_providers {",
        f"    {provider_block}",
        k8s_provider_block,
        "  }",
        "",
        f"  {backend_block}",
        "}",
        "",
        f'provider "{provider}" {{',
        f"  {prov_config['config']}",
        "}",
        "",
        "# â”€â”€ Cluster â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€",
        "",
        cluster_hcl,
    ]

    if has_images and registry_hcl:
        main_lines.extend([
            "",
            "# â”€â”€ Container Registry â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€",
            "",
            registry_hcl,
        ])

    main_content = "\n".join(main_lines) + "\n"

    # â”€â”€ variables.tf â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    vars_lines = [
        "# â”€â”€ Variables â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€",
        "# Generated by DevOps Control Plane (K8s + Terraform cross-domain)",
        "",
        'variable "project" {',
        '  description = "Project name"',
        "  type        = string",
        f'  default     = "{project_name}"',
        "}",
        "",
        'variable "region" {',
        '  description = "Cloud region"',
        "  type        = string",
        f'  default     = "{default_region}"',
        "}",
        "",
        'variable "k8s_version" {',
        '  description = "Kubernetes version"',
        "  type        = string",
        f'  default     = "{k8s_version}"',
        "}",
        "",
        'variable "node_count" {',
        '  description = "Number of cluster nodes"',
        "  type        = number",
        f"  default     = {node_count}",
        "}",
        "",
        'variable "node_size" {',
        '  description = "Node instance type"',
        "  type        = string",
        f'  default     = "{node_size}"',
        "}",
    ]

    if namespace:
        vars_lines.extend([
            "",
            'variable "namespace" {',
            '  description = "Kubernetes namespace"',
            "  type        = string",
            f'  default     = "{namespace}"',
            "}",
        ])

    # AWS EKS needs subnet_ids
    if provider == "aws":
        vars_lines.extend([
            "",
            'variable "subnet_ids" {',
            '  description = "VPC subnet IDs for the EKS cluster"',
            "  type        = list(string)",
            "  default     = []",
            "}",
        ])

    vars_content = "\n".join(vars_lines) + "\n"

    # â”€â”€ outputs.tf â€” cross-domain outputs for K8s â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    kubeconfig_cmd = k8s_config["kubeconfig_command"]
    output_endpoint = k8s_config["output_endpoint"]
    output_ca = k8s_config["output_ca"]

    outputs_lines = [
        "# â”€â”€ Outputs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€",
        "# Generated by DevOps Control Plane (K8s + Terraform cross-domain)",
        "# These outputs are consumed by K8s tooling (kubectl, Skaffold, Helm).",
        "",
        'output "cluster_endpoint" {',
        '  description = "Kubernetes cluster API endpoint"',
        f"  value       = {output_endpoint}",
        "}",
        "",
        'output "cluster_ca_certificate" {',
        '  description = "Cluster CA certificate (base64)"',
        f"  value       = {output_ca}",
        "  sensitive   = true",
        "}",
        "",
        'output "kubeconfig_command" {',
        '  description = "CLI command to configure kubectl"',
        f'  value       = "{kubeconfig_cmd}"',
        "}",
    ]

    if has_images:
        output_registry = k8s_config.get("output_registry", "")
        outputs_lines.extend([
            "",
            'output "registry_url" {',
            '  description = "Container registry URL for docker push"',
            f"  value       = {output_registry}",
            "}",
        ])

    outputs_content = "\n".join(outputs_lines) + "\n"

    # â”€â”€ k8s.tf â€” kubernetes provider + namespace â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    k8s_tf_lines = [
        "# â”€â”€ Kubernetes Provider + Namespace â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€",
        "# Generated by DevOps Control Plane (K8s + Terraform cross-domain)",
        "",
        "provider \"kubernetes\" {",
        f"  host                   = {output_endpoint}",
        f"  cluster_ca_certificate = base64decode({output_ca})",
        "}",
    ]

    if namespace:
        k8s_tf_lines.extend([
            "",
            'resource "kubernetes_namespace" "main" {',
            "  metadata {",
            "    name = var.namespace",
            "",
            "    labels = {",
            f'      project   = "{project_name}"',
            '      managedBy = "terraform"',
            "    }",
            "  }",
            "}",
        ])

    k8s_tf_content = "\n".join(k8s_tf_lines) + "\n"

    # â”€â”€ Assemble files â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    files: list[dict] = []

    files.append(GeneratedFile(
        path="terraform/main.tf",
        content=main_content,
        overwrite=False,
        reason=f"K8s cluster infrastructure ({provider}, {k8s_config['cluster_resource']})",
    ).model_dump())

    files.append(GeneratedFile(
        path="terraform/variables.tf",
        content=vars_content,
        overwrite=False,
        reason="Terraform variables for K8s cluster provisioning",
    ).model_dump())

    files.append(GeneratedFile(
        path="terraform/outputs.tf",
        content=outputs_content,
        overwrite=False,
        reason="Cross-domain outputs (cluster endpoint, CA, kubeconfig, registry)",
    ).model_dump())

    files.append(GeneratedFile(
        path="terraform/k8s.tf",
        content=k8s_tf_content,
        overwrite=False,
        reason="Kubernetes provider + namespace resource",
    ).model_dump())

    tf_gitignore = """# Terraform
.terraform/
*.tfstate
*.tfstate.*
*.tfplan
crash.log
*.tfvars
!terraform.tfvars.example
.terraform.lock.hcl
"""
    files.append(GeneratedFile(
        path="terraform/.gitignore",
        content=tf_gitignore,
        overwrite=False,
        reason="Terraform .gitignore",
    ).model_dump())

    _audit(
        "ðŸ“ Terraform K8s Generated",
        f"K8s cluster IaC generated (provider={provider}, namespace={namespace or 'none'})",
        action="generated", target="terraform-k8s",
        after_state={
            "provider": provider, "backend": backend,
            "namespace": namespace, "has_registry": has_images,
        },
    )

    return {"ok": True, "files": files}


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#  Cross-domain: Terraform â†’ Docker registry config
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


# Provider â†’ Docker CI registry mapping
_DOCKER_REGISTRY_MAP: dict[str, dict] = {
    "aws": {
        "registry_type": "ecr",
        "url_template": "{account_id}.dkr.ecr.{region}.amazonaws.com/{project}",
        "url_default": "${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.us-east-1.amazonaws.com/{project}",
        "credentials": {
            "AWS_ACCESS_KEY_ID": "${{ secrets.AWS_ACCESS_KEY_ID }}",
            "AWS_SECRET_ACCESS_KEY": "${{ secrets.AWS_SECRET_ACCESS_KEY }}",
        },
        "login_step": (
            "aws ecr get-login-password --region {region} | "
            "docker login --username AWS --password-stdin "
            "{registry_url}"
        ),
    },
    "google": {
        "registry_type": "gar",
        "url_template": "{region}-docker.pkg.dev/{project}/{project}",
        "url_default": "us-central1-docker.pkg.dev/{project}/{project}",
        "credentials": {
            "GOOGLE_CREDENTIALS": "${{ secrets.GOOGLE_CREDENTIALS }}",
        },
        "login_step": (
            "echo '${{ secrets.GOOGLE_CREDENTIALS }}' | "
            "docker login -u _json_key --password-stdin https://{region}-docker.pkg.dev"
        ),
    },
    "azurerm": {
        "registry_type": "acr",
        "url_template": "{project_clean}.azurecr.io/{project}",
        "url_default": "{project_clean}.azurecr.io/{project}",
        "credentials": {
            "ACR_USERNAME": "${{ secrets.ACR_USERNAME }}",
            "ACR_PASSWORD": "${{ secrets.ACR_PASSWORD }}",
        },
        "login_step": (
            "docker login {project_clean}.azurecr.io "
            "-u ${{ secrets.ACR_USERNAME }} "
            "-p ${{ secrets.ACR_PASSWORD }}"
        ),
    },
}


def terraform_to_docker_registry(
    provider: str,
    *,
    project_name: str = "",
    region: str = "",
) -> dict:
    """Map Terraform provider to Docker CI registry configuration.

    Cross-domain bridge: takes the cloud provider used for Terraform
    infrastructure provisioning and returns the matching Docker CI
    registry configuration (type, URL, credentials, login step).

    Args:
        provider: Cloud provider ('aws', 'google', 'azurerm').
        project_name: Project name for registry URL construction.
        region: Cloud region (defaults per provider if empty).

    Returns:
        {
            "ok": bool,
            "registry_type": str,     # 'ecr' | 'gar' | 'acr'
            "registry_url": str,      # Push target URL
            "credentials": dict,      # Secret name â†’ value pairs
            "login_step": str,        # Docker login command
            "login_action": str,      # GHA action if applicable
        }
    """
    spec = _DOCKER_REGISTRY_MAP.get(provider)
    if not spec:
        return {
            "ok": False,
            "registry_type": "",
            "registry_url": "",
            "credentials": {},
            "login_step": "",
            "login_action": "",
            "error": f"Unknown provider: {provider}",
        }

    # Default regions per provider
    default_regions = {
        "aws": "us-east-1",
        "google": "us-central1",
        "azurerm": "eastus",
    }
    effective_region = region or default_regions.get(provider, "us-east-1")

    # Clean project name for Azure (no hyphens in ACR names)
    project_clean = project_name.replace("-", "").replace("_", "")

    # Build URLs
    template_vars = {
        "project": project_name,
        "project_clean": project_clean,
        "region": effective_region,
        "account_id": "${{ secrets.AWS_ACCOUNT_ID }}",
    }

    if region:
        registry_url = spec["url_template"].format(**template_vars)
    else:
        registry_url = spec["url_default"].format(**template_vars)

    login_step = spec["login_step"].format(
        region=effective_region,
        registry_url=registry_url,
        project_clean=project_clean,
    )

    return {
        "ok": True,
        "registry_type": spec["registry_type"],
        "registry_url": registry_url,
        "credentials": spec["credentials"],
        "login_step": login_step,
        "login_action": "docker/login-action@v3",
    }

[
    {
        "context": "wizard/welcome",
        "title": "Welcome to the Setup Wizard",
        "icon": "ğŸ§™",
        "content": "6 steps to shape your project. Everything starts here â€” your project's identity, where it lives, and how it's organized.\n\nTake your time. Nothing is saved until you hit Finish on the last step, so feel free to explore and come back.",
        "children": [
            {
                "id": "project-name",
                "title": "Project Name",
                "icon": "âœï¸",
                "selector": "#wiz-name",
                "content": "This is your project's identity â€” the name that follows it everywhere.",
                "expanded": "It shows up in Docker image tags, CI/CD pipeline names, Helm chart metadata, generated folder structures, and every config file the control plane produces.\n\nPick something lowercase, hyphen-separated â€” like my-api or data-pipeline. Spaces and special characters can cause issues in Docker tags and file paths downstream.\n\nğŸ’¡ Changing this later is possible but ripples through generated configs. Best to get it right now.",
                "children": []
            },
            {
                "id": "description",
                "title": "Description",
                "icon": "ğŸ“",
                "selector": "#wiz-desc",
                "content": "A short summary of what this project does â€” one or two sentences is perfect.",
                "expanded": "This text appears in your README header, package metadata (package.json, pyproject.toml), GitHub repository description, and Helm chart annotations.\n\nIt's not required, but it's the kind of thing you'll appreciate having when someone new looks at the project six months from now.\n\nğŸ’¡ Write it for a colleague who's never seen this repo before.",
                "children": []
            },
            {
                "id": "repository",
                "title": "Repository",
                "icon": "ğŸ”—",
                "selector": "#wiz-repo",
                "content": "Your Git remote â€” this connects the project to its home on GitHub, GitLab, or wherever it lives.",
                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-detail\" class=\"state-wrap\"><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">The control plane uses this for:</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;font-size:0.75rem\"><span class=\"state-key\">CI/CD webhooks</span><span>triggering pipelines on push</span><span class=\"state-key\">GitHub integration</span><span>PR management, secrets sync, Actions dispatch</span><span class=\"state-key\">Docker registry paths</span><span>deriving container image names</span><span class=\"state-key\">Generated configs</span><span>embedding the repo URL in Helm charts, Dockerfiles, and CI workflows</span></div><div class=\"state-text\">Format: github.com/owner/repo (without https://). If you're using GitHub, the control plane can often auto-detect this from your local git remote.</div></div></div>",
                "children": []
            },
            {
                "id": "domains",
                "title": "Domains",
                "icon": "ğŸ·ï¸",
                "selector": "#wiz-domains",
                "separator": true,
                "content": "Domains are logical groupings for your codebase â€” not internet domains, more like folders of purpose.",
                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">When you add modules in Step 2, each one belongs to a domain. Think of it as organizing your project by responsibility:</div><div class=\"state-grid\"><span class=\"state-key\">library</span><span>shared utilities, core business logic</span><span class=\"state-key\">ops</span><span>DevOps tooling, scripts, CI/CD configs</span><span class=\"state-key\">docs</span><span>documentation, guides, Docusaurus sites</span><span class=\"state-key\">services</span><span>microservices, APIs, workers</span></div><div class=\"state-text\">You've got {{domainCount}} so far. You can always add more later â€” this just shapes how modules are categorized in the dashboard.</div></div></div>",
                "dynamic": true,
                "childTemplate": {
                    "title": "{{name}}",
                    "content": "One of your project domains. Modules assigned to this domain will be grouped together in the dashboard and reports.",
                    "selector": "#wiz-domains > span"
                },
                "children": [
                    {
                        "id": "add-domain",
                        "title": "Add domainâ€¦",
                        "icon": "â•",
                        "selector": "#wiz-new-domain",
                        "content": "Type a name and press Enter or click + Add.",
                        "expanded": "Good domain names are short and describe a purpose, not a technology. Think library over python, or services over backend.\n\nğŸ’¡ You don't need to plan this perfectly. Domains can be added, renamed, or reorganized anytime.",
                        "children": []
                    }
                ]
            },
            {
                "id": "environments",
                "title": "Environments",
                "icon": "ğŸ“‹",
                "selector": "#wiz-envs",
                "separator": true,
                "content": "Environments scope your secrets and deployment variables. Your project configuration, integrations, and generated files are shared across all of them â€” what changes per environment are the credentials and endpoint values.",
                "expanded": "So your DB_HOST might be localhost:5432 in development but prod-db.internal in production. Same Dockerfile, same CI pipeline, different .env file per environment.\n\nEach environment gets its own encrypted .env file managed by the Vault in Step 3. The control plane keeps them separate â€” secrets from one environment never leak into another.\n\nYou've got {{envCount}} set up. Most projects need at least development and production. Add staging or preview if your workflow needs intermediate deployment targets.",
                "dynamic": true,
                "childTemplate": {
                    "title": "{{name}}",
                    "content": "The {{name}} environment â€” one of your deployment targets. It gets its own .env file with credentials and endpoint values scoped specifically to this context.",
                    "expanded": "When you define secrets and variables in Step 3, each environment has its own set of values. So your API keys, database URLs, and feature flags can differ between environments while sharing the same project config and generated files.\n\nğŸ’¡ Click the name or description to edit. Use Ã— to remove this environment.",
                    "selector": "#wiz-envs > div"
                },
                "children": [
                    {
                        "id": "add-env-name",
                        "title": "Environment name",
                        "icon": "â•",
                        "selector": "#wiz-new-env-name",
                        "content": "Add another deployment target â€” staging, qa, preview, or whatever your workflow needs.",
                        "expanded": "Keep it lowercase, no spaces. This name becomes part of your .env file path (.env.staging), GitHub deployment environment name, and CI/CD workflow target.\n\nEach new environment gets its own secret values in Step 3.\n\nğŸ’¡ Common patterns: development + production for simple projects. Add staging for a QA gate, or preview for PR-based ephemeral environments.",
                        "children": []
                    },
                    {
                        "id": "add-env-desc",
                        "title": "Environment description",
                        "icon": "ğŸ“",
                        "selector": "#wiz-new-env-desc",
                        "content": "A human-readable label â€” helps your team know what each environment is for at a glance.",
                        "expanded": "Examples: \"Local development and testing\", \"Pre-production staging\", \"Live customer-facing\".\n\nThis shows up in the dashboard environment selector and in the Vault management view. It's optional but makes life easier when you have 3+ environments.",
                        "children": []
                    }
                ]
            }
        ]
    },
    {
        "context": "wizard/modules",
        "title": "Modules",
        "icon": "ğŸ”",
        "content": "Modules are the building blocks of your project â€” each one maps to a directory in your codebase with its own stack and purpose.\n\nThe control plane uses them to decide what to generate: Dockerfiles, CI pipelines, linting configs, audit scans, and dashboard structure all flow from what you define here.",
        "children": [
            {
                "id": "auto-detect",
                "title": "Auto-Detect",
                "icon": "ğŸ”",
                "selector": "button[onclick='wizardDetect()']",
                "content": "Scans your project root for recognizable structures â€” pyproject.toml, package.json, docker-compose.yml, Makefile, docs folders â€” and creates module entries from what it finds.",
                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-detail\" class=\"state-wrap\"><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">Detection looks at file signatures:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ pyproject.toml or setup.py â†’ python-lib or python-cli</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ app.py / wsgi.py â†’ python-flask</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ package.json â†’ node</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ docker-compose.yml â†’ docker-compose</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ .md files in a docs/ folder â†’ markdown</div><div class=\"state-text\">It also reads descriptions from package metadata when available. Detection is non-destructive â€” it won't overwrite modules you've already added manually.</div><div class=\"state-text\">ğŸ’¡ If your project has an unusual structure, you can always add modules manually below.</div></div></div>",
                "children": []
            },
            {
                "id": "modules-list",
                "title": "Module List",
                "icon": "ğŸ“¦",
                "selector": "#wizard-modules-list",
                "content": "Your configured modules â€” {{moduleCount}} so far. Each one represents a directory the control plane knows about and manages.",
                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-detail\" class=\"state-wrap\"><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">Every module gets its own treatment in the pipeline:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Python modules get linting (ruff/flake8), type checking, and test runners</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Flask modules get Dockerfile generation, health check endpoints, and deployment configs</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Node modules get npm scripts, bundler configs, and dependency audits</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Docker-compose modules get service orchestration and K8s migration paths</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Markdown modules get Docusaurus site generation and content management</div><div class=\"state-text\">The control plane uses module paths to scope operations â€” when you run audit, lint, or generate configs, it targets the right directories.</div></div></div>",
                "dynamic": true,
                "childTemplate": {
                    "title": "{{name}}",
                    "content": "The {{name}} module â€” managed by the control plane as part of your project structure.",
                    "expanded": "This module's stack determines what the control plane generates for it: Dockerfiles, CI workflows, linting configs, and audit targets. Its domain assignment controls how it's grouped in the dashboard.\n\nğŸ’¡ Use Ã— to remove this module if it was detected incorrectly or is no longer needed.",
                    "selector": "#wizard-modules-list > div"
                },
                "children": []
            },
            {
                "id": "add-module",
                "title": "Add Module",
                "icon": "â•",
                "selector": "#wiz-add-module",
                "separator": true,
                "content": "Manually define a module the auto-detector missed, or add one for a directory you're about to create. Pick a stack from the dropdown to tell the control plane what technology this module uses.",
                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-detail\" class=\"state-wrap\"><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">Three fields define a module:</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;font-size:0.75rem\"><span class=\"state-key\">Name</span><span>appears in dashboard cards, CI pipeline names, and generated configs</span><span class=\"state-key\">Path</span><span>directory relative to project root (e.g. src/core, services/api)</span><span class=\"state-key\">Stack</span><span>the technology stack that drives everything the control plane generates</span></div><div class=\"state-text\">Available stacks (47 total):\nğŸ python Â· python-lib Â· python-cli Â· python-flask Â· python-fastapi Â· python-django\nğŸ“¦ node Â· node-express Â· node-nextjs Â· node-react Â· node-lib Â· typescript Â· typescript-lib\nğŸ¹ go Â· go-gin Â· go-fiber Â· go-cli Â· go-lib\nğŸ¦€ rust Â· rust-actix Â· rust-axum Â· rust-cli Â· rust-lib\nâš™ï¸ c Â· cpp Â· âš¡ zig Â· ğŸ swift\nâ˜• java-maven Â· java-maven-spring Â· java-gradle Â· java-gradle-spring\nğŸ”· dotnet Â· dotnet-aspnet Â· dotnet-blazor\nğŸ’ ruby Â· ruby-rails Â· ruby-sinatra Â· ğŸ’§ elixir Â· elixir-phoenix\nğŸ˜ php Â· ğŸ“¡ protobuf\nğŸ³ docker-compose Â· â˜¸ï¸ kubernetes Â· âˆ helm Â· ğŸ—ï¸ terraform\nğŸ“ markdown Â· ğŸŒ static-site</div><div class=\"state-text\">Flavored stacks inherit from their base and add framework-specific capabilities. Each is defined in stacks/<name>/stack.yml.</div></div></div>",
                "children": [
                    {
                        "id": "mod-name",
                        "title": "Module Name",
                        "icon": "âœï¸",
                        "selector": "#wiz-mod-name",
                        "content": "A short, descriptive name for this module â€” like core, api, web, or docs.",
                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-detail\" class=\"state-wrap\"><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">This name appears in:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Dashboard module cards</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ CI pipeline names (e.g. lint-core, test-api)</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Docker image tags when applicable</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Generated config references</div><div class=\"state-text\">Keep it lowercase, hyphen-separated. It doesn't need to match the directory name, but it helps.</div></div></div>",
                        "children": []
                    },
                    {
                        "id": "mod-path",
                        "title": "Module Path",
                        "icon": "ğŸ“‚",
                        "selector": "#wiz-mod-path",
                        "content": "The directory path relative to your project root â€” this is where the control plane looks for source files.",
                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-detail\" class=\"state-wrap\"><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">Must point to an actual directory (or one you plan to create). The control plane uses this to:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Scope linting and audit operations to the right files</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Generate Dockerfiles with correct COPY paths</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Set up CI workflows that only trigger on changes in this directory</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Resolve dependencies between modules</div><div class=\"state-text\">Examples: src/core, src/ui/web, services/auth, docs</div></div></div>",
                        "children": []
                    },
                    {
                        "id": "mod-stack",
                        "title": "Stack",
                        "icon": "ğŸ”§",
                        "selector": "#wiz-mod-stack",
                        "content": "A stack is a technology definition â€” it tells the control plane how to detect, build, lint, test, and deploy this module. Flavored stacks inherit capabilities from their base language.",
                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Each stack is defined in stacks/<name>/stack.yml. Flavored stacks declare a parent and inherit detection rules, requirements, and capabilities from their base â€” then add their own.</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">ğŸ Python</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;font-size:0.75rem\"><span class=\"state-key\">python</span><span>Generic Python project</span><span class=\"state-key\">python-lib</span><span>Library, no entry point (domain: library)</span><span class=\"state-key\">python-cli</span><span>Click/argparse CLI tool (+run)</span><span class=\"state-key\">python-flask</span><span>Flask web app (+serve)</span><span class=\"state-key\">python-fastapi</span><span>FastAPI app (+serve via uvicorn)</span><span class=\"state-key\">python-django</span><span>Django app (+serve, migrate, shell)</span></div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">ğŸ“¦ JavaScript / TypeScript</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;font-size:0.75rem\"><span class=\"state-key\">node</span><span>Node.js project</span><span class=\"state-key\">node-express</span><span>Express.js server (+serve)</span><span class=\"state-key\">node-nextjs</span><span>Next.js app (+dev, serve, build override)</span><span class=\"state-key\">node-react</span><span>React SPA (+dev)</span><span class=\"state-key\">node-lib</span><span>npm library (domain: library)</span><span class=\"state-key\">typescript</span><span>TypeScript project</span><span class=\"state-key\">typescript-lib</span><span>TS library (domain: library)</span></div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">ğŸ¹ Go</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;font-size:0.75rem\"><span class=\"state-key\">go</span><span>Go project (Go modules)</span><span class=\"state-key\">go-gin</span><span>Gin web framework (+serve)</span><span class=\"state-key\">go-fiber</span><span>Fiber web framework (+serve)</span><span class=\"state-key\">go-cli</span><span>CLI tool (Cobra/urfave)</span><span class=\"state-key\">go-lib</span><span>Library (domain: library)</span></div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">ğŸ¦€ Rust</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;font-size:0.75rem\"><span class=\"state-key\">rust</span><span>Rust project (Cargo)</span><span class=\"state-key\">rust-actix</span><span>Actix-web service (+serve)</span><span class=\"state-key\">rust-axum</span><span>Axum web service (+serve)</span><span class=\"state-key\">rust-cli</span><span>CLI tool (clap)</span><span class=\"state-key\">rust-lib</span><span>Library crate (domain: library)</span></div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">âš™ï¸ Systems</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;font-size:0.75rem\"><span class=\"state-key\">c</span><span>C project (Makefile/CMake)</span><span class=\"state-key\">cpp</span><span>C++ project (Makefile/CMake)</span><span class=\"state-key\">zig</span><span>Zig project</span><span class=\"state-key\">swift</span><span>Swift project (SPM)</span></div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">â˜• JVM & .NET</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;font-size:0.75rem\"><span class=\"state-key\">java-maven</span><span>Java (Maven build)</span><span class=\"state-key\">java-maven-spring</span><span>Spring Boot + Maven (+serve)</span><span class=\"state-key\">java-gradle</span><span>Java/Kotlin (Gradle build)</span><span class=\"state-key\">java-gradle-spring</span><span>Spring Boot + Gradle (+serve)</span><span class=\"state-key\">dotnet</span><span>.NET / C#</span><span class=\"state-key\">dotnet-aspnet</span><span>ASP.NET web app (+serve)</span><span class=\"state-key\">dotnet-blazor</span><span>Blazor app (+serve)</span></div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">ğŸ’ Other Languages</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;font-size:0.75rem\"><span class=\"state-key\">ruby</span><span>Ruby (Bundler)</span><span class=\"state-key\">ruby-rails</span><span>Rails (+serve, migrate, console)</span><span class=\"state-key\">ruby-sinatra</span><span>Sinatra (+serve)</span><span class=\"state-key\">elixir</span><span>Elixir (Mix)</span><span class=\"state-key\">elixir-phoenix</span><span>Phoenix (+serve, migrate, routes)</span><span class=\"state-key\">php</span><span>PHP (Composer)</span><span class=\"state-key\">protobuf</span><span>Protocol Buffers / gRPC</span></div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">ğŸ³ Infrastructure</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;font-size:0.75rem\"><span class=\"state-key\">docker-compose</span><span>Docker Compose orchestration</span><span class=\"state-key\">kubernetes</span><span>Kubernetes manifests</span><span class=\"state-key\">helm</span><span>Helm charts</span><span class=\"state-key\">terraform</span><span>Terraform infrastructure</span></div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">ğŸ“ Content</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;font-size:0.75rem\"><span class=\"state-key\">markdown</span><span>Documentation (Docusaurus/MkDocs)</span><span class=\"state-key\">static-site</span><span>Static site (HTML/CSS/JS)</span></div><div class=\"state-text\">Use \"Custom\" to type an unlisted stack name â€” you can create its YAML later.</div></div></div>",
                        "children": []
                    }
                ]
            }
        ]
    },
    {
        "context": "wizard/secrets",
        "title": "Secrets & Encryption",
        "icon": "ğŸ”",
        "content": "This step shows the state of your project's secrets infrastructure â€” one vault per environment, your GitHub connection, and the content encryption key.\n\nUnlike Step 1, some actions here take effect immediately when you click them. The + Create and ğŸ’¾ Save buttons write to disk right away â€” they don't wait for Finish.",
        "children": [
            {
                "id": "env-vault-status",
                "title": "Environment Vault Status",
                "icon": "ğŸŒ",
                "selector": "#wiz-env-vault-list",
                "separator": true,
                "content": "Each environment you defined in Step 1 gets its own encrypted vault file. In multi-environment mode, .env is a working copy of the active environment â€” when you switch environments, the control plane swaps the file automatically.",
                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-detail\" class=\"state-wrap\"><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">The file model:</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;font-size:0.75rem\"><span class=\"state-key\">.env</span><span>live working copy of whichever environment is active</span><span class=\"state-key\">.env.{name}</span><span>stored snapshot of each environment's secrets</span><span class=\"state-key\">.env.active</span><span>marker file recording which environment is selected</span></div><div class=\"state-text\">When you activate production, the control plane saves .env â†’ .env.development, then copies .env.production â†’ .env. In single-env mode, there's just .env â€” no swapping.</div><div class=\"state-text\">ğŸ’¡ Vault files (.env.vault) are the encrypted versions. The .gitignore excludes plaintext .env files, and encryption adds the real protection.</div></div></div>",
                "dynamic": true,
                "childTemplate": {
                    "title": "{{name}}",
                    "nameSelector": "code",
                    "content": "Vault file for the {{name}} environment.",
                    "expanded": "Checking statusâ€¦",
                    "selector": "#wiz-env-vault-list > div",
                    "variants": [
                        {
                            "when": {
                                "textContains": "unlocked",
                                "hasSelector": "[data-env-active]"
                            },
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ”“ unlocked Â· ACTIVE</div><div class=\"state-detail\">This is the active environment â€” .env is a live copy of this file right now. The vault is decrypted and ready for editing.\n\nAny changes you make in the ğŸ” Secrets tab modify this environment's .env directly. Remember to lock it when you're done.\n\nSwitching to another environment will save this file and swap in the new one.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "locked",
                                "hasSelector": "[data-env-active]"
                            },
                            "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">ğŸ”’ locked Â· ACTIVE</div><div class=\"state-detail\">This is the active environment but the vault is locked â€” .env is encrypted on disk.\n\nUnlock it from the ğŸ” Secrets tab to view or edit secrets. The vault passphrase decrypts it on demand.\n\nSwitching to another environment will keep this vault locked and swap in the new one.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "missing",
                                "hasSelector": "[data-env-active]"
                            },
                            "expanded": "<div class=\"assistant-state-card state-error\"><div class=\"state-label\">ğŸ“­ missing Â· ACTIVE</div><div class=\"state-detail\">This is the active environment but no .env file exists yet. Hit + Create to generate one â€” the file is written to disk immediately.\n\nThis is normal for new setups. Once created, you can add secrets through the ğŸ” Secrets tab.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "unlocked"
                            },
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ”“ unlocked</div><div class=\"state-detail\">This vault is decrypted and ready. You can view and edit secrets through the ğŸ” Secrets tab on the dashboard.\n\nRemember to lock it when you're done â€” plaintext .env files should never be committed to git. The .gitignore already excludes them, but encryption is the real protection.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "locked"
                            },
                            "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">ğŸ”’ locked</div><div class=\"state-detail\">This vault is encrypted â€” its contents are safe on disk. This is the expected state when you're not actively editing credentials.\n\nTo read or edit secrets, unlock it from the ğŸ” Secrets tab. The vault passphrase decrypts it on demand.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "missing"
                            },
                            "expanded": "<div class=\"assistant-state-card state-error\"><div class=\"state-label\">ğŸ“­ missing</div><div class=\"state-detail\">This vault doesn't exist yet. Hit + Create to generate it â€” the file is written to disk immediately with an auto-generated encryption key.\n\nThis is normal for new environments. You can add secrets afterwards through the ğŸ” Secrets tab.</div></div>"
                        }
                    ]
                },
                "children": []
            },
            {
                "id": "gh-integration",
                "title": "GitHub Integration",
                "icon": "ğŸ”—",
                "selector": "#wiz-gh-integration",
                "separator": true,
                "content": "GITHUB_REPOSITORY connects your local vault to your GitHub remote â€” it's how the control plane knows where to sync secrets and dispatch workflows.",
                "expanded": "This value stays local to your .env file. It's never pushed to GitHub secrets â€” it's the bridge between your local credentials and your remote repository.\n\nWith this set, you get secrets sync to GitHub Actions, workflow dispatch, and PR management from the dashboard.",
                "variants": [
                    {
                        "when": {
                            "textContains": "configured"
                        },
                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… configured</div><div class=\"state-detail\">Your repository is set in .env. The control plane can push secrets, dispatch workflows, and manage PRs.\n\nThis value stays local â€” it's never pushed to GitHub. It's the link between your local vault and your remote repo.</div></div>"
                    },
                    {
                        "when": {
                            "textContains": "detected"
                        },
                        "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš ï¸ detected but not saved</div><div class=\"state-detail\">Your git remote was auto-detected but isn't persisted in .env yet. Click ğŸ’¾ Save to .env to keep it â€” this takes effect immediately.\n\nWithout it saved, GitHub integration features won't know where to target on next startup.</div></div>"
                    },
                    {
                        "when": {
                            "textContains": "could not detect"
                        },
                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â“ not detected</div><div class=\"state-detail\">No git remote found. You can set GITHUB_REPOSITORY manually in your .env file as owner/repo (e.g., my-org/my-project).\n\nThis is needed for secrets sync, GitHub Actions dispatch, and PR management.</div></div>"
                    }
                ],
                "children": [
                    {
                        "id": "gh-deploy-envs",
                        "title": "Deployment Environments",
                        "icon": "ğŸŒ",
                        "selector": "#wiz-gh-deploy-envs",
                        "content": "GitHub Deployment Environments scope secrets to specific environments like development and production. Each environment in your project should have a matching GitHub environment.",
                        "expanded": "Without matching GitHub environments, you can't push environment-scoped secrets. Dev typically uses repo-level secrets, but production needs its own environment for isolation.\n\nğŸ’¡ Hit ğŸš€ Create to provision missing environments on GitHub directly from the wizard.",
                        "dynamic": true,
                        "childTemplate": {
                            "title": "{{name}}",
                            "nameSelector": "code",
                            "content": "GitHub deployment environment.",
                            "selector": "#wiz-gh-deploy-list > div",
                            "variants": [
                                {
                                    "when": {
                                        "textContains": "exists"
                                    },
                                    "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… exists</div><div class=\"state-detail\">This environment is provisioned on GitHub. You can push scoped secrets to it from the ğŸ” Secrets tab and use environment-level protection rules in GitHub Actions.</div></div>"
                                },
                                {
                                    "when": {
                                        "textContains": "not found"
                                    },
                                    "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš ï¸ not found</div><div class=\"state-detail\">This environment doesnâ€™t exist on GitHub yet. Hit ğŸš€ Create to provision it â€” this is required before you can push environment-scoped secrets.\n\nWithout it, secrets sync for this environment will fail.</div></div>"
                                }
                            ]
                        },
                        "children": []
                    }
                ]
            },
            {
                "id": "enc-key-status",
                "title": "Content Encryption Key",
                "icon": "ğŸ”‘",
                "selector": "#wiz-enc-key-status",
                "separator": true,
                "content": "CONTENT_VAULT_ENC_KEY is a general-purpose encryption key stored in your .env file. It enables on-demand encryption for any git-committed item â€” you toggle it per file or message, and the key does the rest.",
                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-detail\" class=\"state-wrap\"><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">This key protects multiple things across the control plane:</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;font-size:0.75rem\"><span class=\"state-key\">Content files</span><span>media, documents, assets in the content vault</span><span class=\"state-key\">Chat messages</span><span>encrypted at rest, decrypted on read</span><span class=\"state-key\">Backup archives</span><span>encrypted snapshots of your project</span><span class=\"state-key\">New vault seeding</span><span>auto-injected when creating environment vaults</span></div><div class=\"state-text\">It's separate from the vault passphrase that locks .env files. The vault passphrase protects secrets (API keys, database URLs). This key protects everything else you choose to encrypt.</div></div></div>",
                "variants": [
                    {
                        "when": {
                            "textContains": "configured"
                        },
                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… configured</div><div class=\"state-detail\">Your encryption key is active. You can encrypt content files, chat messages, and backup archives on demand.\n\nThis key is auto-injected into new environment vaults when you create them. As long as your .env file is backed up, anything encrypted with this key is recoverable.</div></div>"
                    },
                    {
                        "when": {
                            "textContains": "not set"
                        },
                        "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš ï¸ not set</div><div class=\"state-detail\">No encryption key configured. Without it, you can't encrypt content files, chat messages, or backup archives.\n\nEnter your own key (at least 8 characters) or hit ğŸ² Generate for a strong random one. Either way, it's stored in .env â€” keep that file safe.\n\nâš ï¸ Losing this key means losing access to everything encrypted with it. There's no recovery mechanism.\n\nIf you don't need any of these encryption features, you can safely skip this.</div></div>"
                    }
                ],
                "children": []
            },
            {
                "id": "secrets-list",
                "title": "Detected Secret Files",
                "icon": "ğŸ“„",
                "selector": "#wiz-secrets-list",
                "separator": true,
                "content": "These are secret files found in your project â€” .env files, encrypted vaults, and related artifacts. This is a read-only snapshot of whatâ€™s on disk right now.",
                "expanded": "In multi-environment mode, .env is a live copy of the active environment â€” it will match one of the .env.{name} files. The other .env.{name} files hold each environment's stored secrets.\n\nFor full vault management â€” locking, unlocking, adding keys, pushing secrets to GitHub â€” use the ğŸ” Secrets tab on the dashboard after you finish the wizard.\n\nğŸ’¡ Encrypted files are safe to commit (theyâ€™re ciphertext). Plaintext files should be locked before pushing to git.",
                "dynamic": true,
                "childTemplate": {
                    "title": "{{name}}",
                    "nameSelector": "code",
                    "content": "A secret file in your project.",
                    "selector": "#wiz-detected-files > div",
                    "variants": [
                        {
                            "when": {
                                "textContains": "= .env."
                            },
                            "content": "This is the live working copy of the active environment.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ”“ Active Copy</div><div class=\"state-detail\">In multi-environment mode, .env is automatically maintained as a copy of whichever environment is currently active.\n\nWhen you switch environments from the ğŸ” Secrets tab, the control plane saves this file back and copies the new environment into its place.\n\nYou donâ€™t edit .env directly for switching â€” use the Activate button in the Secrets tab.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": ".env.development"
                            },
                            "content": "Development environment secrets â€” used for local development and testing.",
                            "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸš§ Development</div><div class=\"state-detail\">This file holds secrets for your development environment â€” typically local databases, test API keys, and debug configurations.\n\nIts contents are separate from production. When development is active, .env is a copy of this file.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": ".env.production"
                            },
                            "content": "Production environment secrets â€” used for released and deployed applications.",
                            "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸš€ Production</div><div class=\"state-detail\">This file holds secrets for your production environment â€” live database credentials, real API keys, and deployment-specific configurations.\n\nHandle with extra care. When production is active, .env is a copy of this file. We suggest locking the vault when you move away â€” each environment can have its own passphrase for independent protection.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "Encrypted"
                            },
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ”’ Encrypted</div><div class=\"state-detail\">Contents are safe on disk â€” this file can be committed to git without exposing secrets. To read or edit it, unlock through the ğŸ” Secrets tab.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "Plaintext"
                            },
                            "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">ğŸ”“ Plaintext</div><div class=\"state-detail\">Anyone with file access can read this fileâ€™s contents. Use the ğŸ” Secrets tab to lock it when youâ€™re done editing â€” plaintext .env files should never be committed to git.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "Missing"
                            },
                            "expanded": "<div class=\"assistant-state-card state-error\"><div class=\"state-label\">âŒ Missing</div><div class=\"state-detail\">This file is expected but not found on disk. It may have been deleted or hasnâ€™t been created yet. Use + Create in the vault section above, or the ğŸ” Secrets tab.</div></div>"
                        }
                    ]
                },
                "children": []
            }
        ]
    },
    {
        "context": "wizard/content",
        "title": "Content Folders",
        "icon": "ğŸ“",
        "content": "Choose which folders appear in the ğŸ“ Content tab â€” your workspace for browsing, previewing, encrypting, and archiving project files.\n\nBelow the folders, you'll see the infrastructure directories that the control plane manages automatically. These track your chat history, audit traces, backups, and optimized large files â€” they're created on demand as you use the system.",
        "children": [
            {
                "id": "content-list",
                "title": "Project Folders",
                "icon": "ğŸ“‚",
                "selector": "#wiz-content-list",
                "separator": true,
                "content": "Select the folders you want to manage through the Content tab. Each selected folder becomes browsable with preview, encryption, download, and archive capabilities.",
                "expanded": "This controls the default folder tabs in the Content view. You can always browse any project directory using ğŸ—‚ Explore All â€” this selection just sets the defaults.\n\nğŸ’¡ Folders marked 'suggested' match common content folder patterns (docs, media, assets, etc). You don't have to include all of them â€” pick the ones that matter to your workflow.",
                "dynamic": true,
                "childTemplate": {
                    "title": "{{name}}",
                    "nameSelector": "div > div:first-child",
                    "content": "A project directory.",
                    "selector": "#wiz-content-list > label",
                    "variants": [
                        {
                            "when": {
                                "textContains": "Active",
                                "hasSelector": "[style*='suggested']"
                            },
                            "content": "This folder is selected and was auto-suggested as a common content folder.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Active Â· suggested</div><div class=\"state-detail\">This folder is included in the ğŸ“ Content tab. It matched a common content folder pattern and was pre-suggested.\n\nYou'll get full management capabilities: browsing, preview, upload, encryption, backup archives, and large file optimization.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "Active"
                            },
                            "content": "This folder is selected for content management.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Active</div><div class=\"state-detail\">This folder will appear as a tab in the ğŸ“ Content view. You can browse, upload, encrypt, download, and archive files inside it.\n\nUncheck it if you don't need to manage these files through the Content tab directly.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "suggested"
                            },
                            "content": "This looks like a good candidate for content management â€” it matches a common content folder pattern.",
                            "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ’¡ Suggested</div><div class=\"state-detail\">This directory name matches a common content folder pattern. Check it to include it in the Content tab â€” you'll get browsing, preview, encryption, and archive capabilities.\n\nSuggested doesn't mean required. If this folder isn't relevant to your workflow, leave it unchecked.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "â€”"
                            },
                            "content": "A project directory. Check the box to include it in the Content tab.",
                            "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">Not selected</div><div class=\"state-detail\">This folder exists in your project but isn't currently managed through the Content tab.\n\nCheck it if you want to browse, upload, encrypt, or archive files in this directory. Leave it unchecked if it's source code or configuration that doesn't need content management.</div></div>"
                        }
                    ]
                },
                "children": []
            },
            {
                "id": "content-infra",
                "title": "Content Infrastructure",
                "icon": "ğŸ—ï¸",
                "selector": "#wiz-content-infra",
                "separator": true,
                "content": "These directories are created and maintained by the control plane. They're gitignored and never need manual management â€” the system handles creation, population, and cleanup.",
                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Think of them as internal storage layers:</div><div class=\"state-grid\"><span class=\"state-key\">.ledger</span><span>shares data via git branches (chat threads, traces, audits)</span><span class=\"state-key\">.state</span><span>local caches (preferences, scores, pending audits, run history)</span><span class=\"state-key\">.backup</span><span>compressed archive snapshots from the Content tab</span><span class=\"state-key\">.large</span><span>optimized oversized files, uploaded to release artifacts for sharing</span><span class=\"state-key\">.pages</span><span>generated site builds from the Pages pipeline</span></div><div class=\"state-text\">Each one is gitignored. The 'shared' badge on .ledger means it syncs with collaborators via git push/pull â€” everything else stays local to your machine.</div></div></div>",
                "dynamic": true,
                "childTemplate": {
                    "title": "{{name}}",
                    "nameSelector": "code",
                    "content": "An infrastructure directory managed by the control plane.",
                    "selector": "#wiz-content-infra-list > div",
                    "variants": [
                        {
                            "when": {
                                "textContains": ".ledger"
                            },
                            "content": "Git worktree for shared project data â€” chat threads, trace snapshots, and saved audit records.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ“’ Ledger</div><div class=\"state-detail\">The ledger is a separate git branch checked out as a worktree at your project root. It stores:\n\nâ€¢ Chat threads and messages (from the ğŸ’¬ Chat tab)\nâ€¢ Execution traces (from traced operations)\nâ€¢ Saved audit snapshots (promoted from pending results)\n\nBadge: 'shared' means this data syncs with your remote repository via git push/pull. Collaborators get the same history.\n\nYou never interact with .ledger directly â€” the control plane handles all reads and writes through the ledger service.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": ".state"
                            },
                            "content": "Local cache â€” preferences, audit scores, pending audits, run history, and trace recordings.",
                            "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ’¾ Local State</div><div class=\"state-detail\">Machine-local storage for ephemeral and cached data:\n\nâ€¢ devops_prefs.json â€” your dashboard preferences\nâ€¢ devops_cache.json â€” cached scan results\nâ€¢ audit_activity.json â€” audit execution log\nâ€¢ audit_scores.json â€” audit score history\nâ€¢ pending_audits.json â€” audits awaiting review\nâ€¢ runs.jsonl â€” execution run history\nâ€¢ traces/ â€” local trace recordings before sharing\n\nNone of this leaves your machine. This directory is almost certainly present by now â€” the control plane creates it the first time any feature needs local persistence.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": ".backup"
                            },
                            "content": "Backup archives created from the Content tab's Archive view.",
                            "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ—„ï¸ Backups</div><div class=\"state-detail\">Compressed archive snapshots of folders you choose to protect. Created through the Archive view in the ğŸ“ Content tab.\n\nBackup archives can exist at any level â€” the root .backup holds project-wide archives, while individual content folders can have their own .backup subdirectories.\n\nFor off-machine protection, you can upload archives to GitHub release artifacts.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": ".large"
                            },
                            "content": "Optimized large files â€” gitignored, virtual in parent, uploadable to release artifacts.",
                            "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“¦ Large Files</div><div class=\"state-detail\">When files over 2 MB are uploaded through the Content tab, they're automatically moved to a .large subdirectory. The original filename appears virtually in the parent folder â€” you browse and manage them normally.\n\n.large is gitignored, so large files don't bloat your repository. For sharing, they can be uploaded to GitHub release artifacts (â˜ï¸ icon in the Content tab).\n\nThis directory can appear at any folder level â€” not just inside configured content folders. The content browser's Explore All mode can work with .large directories anywhere in the project.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": ".pages"
                            },
                            "content": "Generated site output from the Pages pipeline.",
                            "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸŒ Pages Output</div><div class=\"state-detail\">Build output from the Pages pipeline â€” your generated Docusaurus site, static assets, and deployment artifacts.\n\nThis directory is rebuilt on each deploy. It's not something you edit directly â€” changes flow from your source content through the Pages build process.\n\nğŸ’¡ If you see this without having used Pages yet, it was likely created by a previous build or site generation run.</div></div>"
                        }
                    ]
                },
                "children": []
            }
        ]
    },
    {
        "context": "wizard/integrations",
        "title": "Integrations & DevOps",
        "icon": "ğŸ”Œ",
        "content": "This step detects your environment and lets you choose which integrations are active. {{toolsInstalled}} of {{toolsTotal}} tools are available, {{filesDetected}} project files detected, and {{integrationCount}} integration cards are ready to configure.\n\nEach integration you enable here becomes a card on the dashboard â€” giving you one-click access to its setup, status, and operations.",
        "children": [
            {
                "id": "scan-bar",
                "title": "Scan Status",
                "icon": "ğŸ”",
                "selector": "#wiz-int-scan-bar",
                "content": "The control plane scans your project root and system PATH to detect available tools, project files, and integration readiness.",
                "expanded": "Results are cached in-memory and in your browser's session storage so you don't wait on every step change. The age shown is how long ago the last scan completed.\n\nHit ğŸ”„ Re-scan to force a fresh detection â€” useful after installing a tool or adding a Dockerfile.",
                "variants": [
                    {
                        "when": {
                            "textContains": "rescan recommended"
                        },
                        "content": "Files on disk have changed since the last scan â€” the detection results may be stale.",
                        "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš¡ Stale</div><div class=\"state-detail\">The staleness watcher detected file changes in your project since the last scan. This means new or modified Dockerfiles, manifests, config files, or tool installations may not be reflected in the current detection.\n\nHit ğŸ”„ Re-scan to refresh. The scan is fast (< 2 seconds) and updates everything: tool availability, file detection, stack defaults, and integration status.</div></div>"
                    },
                    {
                        "when": {
                            "textContains": "fresh"
                        },
                        "content": "The scan is recent and up to date â€” detection results reflect the current state of your project.",
                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ“ Fresh</div><div class=\"state-detail\">Scan completed less than 30 seconds ago. All tool checks, file detection, and integration status reflect the current state of your project.\n\nYou can still force a re-scan anytime if you've made changes since landing on this step.</div></div>"
                    }
                ],
                "children": []
            },
            {
                "id": "system-tools",
                "title": "System Tools",
                "icon": "ğŸ”§",
                "selector": "#wiz-int-tools-section",
                "content": "{{toolsInstalled}} of {{toolsTotal}} development tools are available on your system. These are the CLI binaries the control plane calls to perform real work â€” building images, running tests, scanning for vulnerabilities, deploying to clusters.",
                "expanded": "Tools marked âœ— are missing from your PATH. You can install them directly from here â€” pip-based tools install into your current virtualenv, while system tools need sudo.\n\nEvery tool here maps to a specific pipeline in the control plane. Missing tools don't block setup, but they'll limit what the corresponding integration cards can do.",
                "dynamic": true,
                "childTemplate": {
                    "selector": "[id^='wiz-int-tool-']",
                    "nameSelector": "code",
                    "title": "{{name}}",
                    "content": "Development tool used by the control plane.",
                    "variants": [
                        {
                            "when": {
                                "textContains": "âœ“ git"
                            },
                            "title": "git âœ“",
                            "icon": "âœ…",
                            "content": "Version control â€” the foundation everything else depends on.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Installed</div><div class=\"state-detail\">Git is the bedrock of the control plane. Every integration below â€” GitHub, CI/CD, Docker, K8s â€” assumes a git repository exists.\n\nThe control plane uses git for: commit tracking, remote detection, branch awareness, .gitignore analysis, and the entire sync pipeline that pushes secrets and configs to GitHub.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "git"
                            },
                            "content": "Version control â€” the foundation everything else depends on.",
                            "expanded": "<div class=\"assistant-state-card state-error\"><div class=\"state-label\">âŒ Missing â€” Critical</div><div class=\"state-detail\">Git is not installed. This blocks nearly every integration â€” GitHub, CI/CD, Docker builds, and K8s deployments all assume a git repository.\n\nInstall it now. Without git, the control plane cannot detect your project structure or sync configurations.\n\nğŸ“¦ Installs via: sudo apt-get install git</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "âœ“ gh"
                            },
                            "title": "gh âœ“",
                            "icon": "âœ…",
                            "content": "GitHub CLI â€” manages PRs, secrets, Actions, and environments from the terminal.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Installed</div><div class=\"state-detail\">The GitHub CLI is how the control plane interacts with your GitHub repository without needing API tokens or REST calls.\n\nUsed for: pushing secrets (gh secret set), syncing variables (gh variable set), dispatching workflows, creating deployment environments, and managing pull requests â€” all from the dashboard.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "gh"
                            },
                            "content": "GitHub CLI â€” manages PRs, secrets, Actions, and environments from the terminal.",
                            "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš  Missing</div><div class=\"state-detail\">Without the GitHub CLI, you can't sync secrets to GitHub, dispatch workflows, or manage deployment environments from the control plane.\n\nThe control plane exclusively uses `gh` for all GitHub operations â€” no raw REST API calls. Install it to unlock the full GitHub integration.\n\nğŸ“¦ Installs via: sudo snap install gh</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "âœ“ docker-compose"
                            },
                            "title": "docker-compose âœ“",
                            "icon": "âœ…",
                            "content": "Multi-service orchestration â€” manages docker-compose.yml stacks.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Installed</div><div class=\"state-detail\">Docker Compose is available. The control plane uses it to parse your compose files, enumerate services, manage stack lifecycle (up/down/restart), and generate compose configurations with detected stack defaults.\n\nYour compose services will appear in the Docker integration card with per-service controls.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "docker-compose"
                            },
                            "content": "Multi-service orchestration â€” manages docker-compose.yml stacks.",
                            "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš  Missing</div><div class=\"state-detail\">Docker Compose orchestrates multi-container applications from a single YAML file. Without it, the control plane can't manage your compose stacks, start/stop services, or generate compose configurations.\n\nIf you only run single containers, this is optional. For multi-service setups (API + database + cache), it's essential.\n\nğŸ“¦ Installs via: sudo apt-get install docker-compose-v2</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "âœ“ docker"
                            },
                            "title": "docker âœ“",
                            "icon": "âœ…",
                            "content": "Container runtime â€” builds images, runs containers, talks to the Docker daemon.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Installed</div><div class=\"state-detail\">Docker is available. The control plane uses it for: building container images from your Dockerfile, running docker compose stacks, inspecting the daemon for running containers, and producing deployment artifacts.\n\nThe Docker integration card on the dashboard gives you image management, compose orchestration, and Dockerfile generation â€” all powered by this binary.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "docker"
                            },
                            "content": "Container runtime â€” builds images, runs containers, talks to the Docker daemon.",
                            "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš  Missing</div><div class=\"state-detail\">Docker is not installed. Without it, the control plane can't build container images, run compose stacks, or produce deployment artifacts.\n\nThe Docker integration card will still appear but will be limited to configuration â€” no builds or daemon interaction until Docker is available.\n\nğŸ“¦ Installs via: sudo apt-get install docker.io</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "âœ“ kubectl"
                            },
                            "title": "kubectl âœ“",
                            "icon": "âœ…",
                            "content": "Kubernetes CLI â€” talks to clusters, applies manifests, inspects workloads.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Installed</div><div class=\"state-detail\">kubectl is available and the control plane can interact with Kubernetes clusters. Used for: applying manifests, inspecting pods/services/deployments, checking cluster connectivity, and the K8s manifest wizard.\n\nThe Kubernetes integration card uses kubectl for all cluster operations. Make sure your kubeconfig points to the right cluster.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "kubectl"
                            },
                            "content": "Kubernetes CLI â€” talks to clusters, applies manifests, inspects workloads.",
                            "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš  Missing</div><div class=\"state-detail\">Without kubectl, the control plane can't communicate with Kubernetes clusters. The K8s integration card will be limited to manifest generation â€” no live cluster operations.\n\nIf you're not deploying to Kubernetes, this is safe to skip.\n\nğŸ“¦ Installs via: sudo snap install kubectl --classic</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "âœ“ terraform"
                            },
                            "title": "terraform âœ“",
                            "icon": "âœ…",
                            "content": "Infrastructure as Code â€” provisions cloud resources from declarative configs.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Installed</div><div class=\"state-detail\">Terraform is available. The control plane uses it for: scaffolding provider configurations, generating backend state configs, planning infrastructure changes, and integrating with the Terraform card on the dashboard.\n\nThe Terraform integration detects your providers, backend, and existing state to give you a clear picture of your infrastructure posture.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "terraform"
                            },
                            "content": "Infrastructure as Code â€” provisions cloud resources from declarative configs.",
                            "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš  Missing</div><div class=\"state-detail\">Without Terraform, the control plane can't scaffold IaC configs or inspect your infrastructure state. The Terraform card will be hidden by default unless you have a terraform/ directory.\n\nIf you manage infrastructure through other means (CloudFormation, Pulumi, manual), this is safe to skip.\n\nğŸ“¦ Installs via: sudo snap install terraform --classic</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "âœ“ helm"
                            },
                            "title": "helm âœ“",
                            "icon": "âœ…",
                            "content": "Kubernetes package manager â€” manages charts, releases, and values files.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Installed</div><div class=\"state-detail\">Helm is available. The control plane uses it alongside kubectl for: listing releases, inspecting chart values, and generating Helm-based deployment configurations in the K8s manifest wizard.\n\nHelm charts provide a higher-level abstraction over raw K8s manifests â€” especially useful for complex applications with many resources.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "helm"
                            },
                            "content": "Kubernetes package manager â€” manages charts, releases, and values files.",
                            "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš  Missing</div><div class=\"state-detail\">Without Helm, the control plane can still work with raw K8s manifests via kubectl. Helm adds chart management and release tracking on top.\n\nIf you deploy with raw YAML manifests, Helm is optional. If your project uses Helm charts, install it.\n\nğŸ“¦ Installs via: curl script (sudo required)</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "âœ“ node"
                            },
                            "title": "node âœ“",
                            "icon": "âœ…",
                            "content": "Node.js runtime â€” required for npm, npx, and JavaScript-based tooling.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Installed</div><div class=\"state-detail\">Node.js is available. The control plane uses it indirectly through npm/npx for: JavaScript linting (ESLint), formatting (Prettier), and the Pages pipeline (Docusaurus builds).\n\nIf your project includes JavaScript or TypeScript modules, Node.js enables their full toolchain integration.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "node"
                            },
                            "content": "Node.js runtime â€” required for npm, npx, and JavaScript-based tooling.",
                            "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš  Missing</div><div class=\"state-detail\">Without Node.js, JavaScript-based tools (ESLint, Prettier) and the Pages pipeline (Docusaurus) won't work. If your project is pure Python/Go/Rust, this is safe to skip.\n\nğŸ“¦ Installs via: sudo snap install node --classic</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "âœ“ npm"
                            },
                            "title": "npm âœ“",
                            "icon": "âœ…",
                            "content": "Node package manager â€” installs JS dependencies and runs scripts.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Installed</div><div class=\"state-detail\">npm is available. Used by the control plane for: installing global tools (ESLint, Prettier), managing package.json dependencies, and running build scripts in JS/TS modules.\n\nThe Packages integration card uses npm for dependency auditing in Node.js projects.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "npm"
                            },
                            "content": "Node package manager â€” installs JS dependencies and runs scripts.",
                            "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš  Missing</div><div class=\"state-detail\">Without npm, JavaScript tooling can't be installed and package.json projects can't be managed. Usually installed alongside Node.js.\n\nğŸ“¦ Installs via: sudo apt-get install npm</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "âœ“ ruff"
                            },
                            "title": "ruff âœ“",
                            "icon": "âœ…",
                            "content": "Python linter and formatter â€” fast, Rust-powered, replaces flake8 + isort + black.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Installed</div><div class=\"state-detail\">Ruff is available. The control plane uses it in the Quality pipeline and audit scoring â€” it checks Python code for style violations, import ordering, and common mistakes.\n\nRuff is an order of magnitude faster than traditional Python linters. Its results feed into the ğŸ”§ Code Quality card on the dashboard.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "ruff"
                            },
                            "content": "Python linter and formatter â€” fast, Rust-powered, replaces flake8 + isort + black.",
                            "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš  Missing</div><div class=\"state-detail\">Without Ruff, the Code Quality card can't run lint checks on Python code. The audit scoring system treats this as a gap in your quality posture.\n\nIt's a pip install â€” no sudo needed, installs into your current virtualenv.\n\nğŸ“¦ Installs via: pip install ruff</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "âœ“ mypy"
                            },
                            "title": "mypy âœ“",
                            "icon": "âœ…",
                            "content": "Python static type checker â€” catches type errors before runtime.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Installed</div><div class=\"state-detail\">mypy is available. The control plane uses it in the Quality pipeline to verify type annotations across your Python codebase.\n\nType checking results feed into audit scoring. Projects with strict typing enabled score higher on the quality dimension.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "mypy"
                            },
                            "content": "Python static type checker â€” catches type errors before runtime.",
                            "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš  Missing</div><div class=\"state-detail\">Without mypy, the Quality pipeline skips type checking. If your Python code uses type annotations, installing mypy will improve your audit quality score.\n\nğŸ“¦ Installs via: pip install mypy</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "âœ“ pytest"
                            },
                            "title": "pytest âœ“",
                            "icon": "âœ…",
                            "content": "Python test runner â€” discovers and executes test suites.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Installed</div><div class=\"state-detail\">pytest is available. The control plane uses it in the Testing pipeline â€” running your test suite, collecting coverage data, and feeding results into the ğŸ§ª Testing card.\n\nTest results are a core input to audit scoring. Projects with passing tests and good coverage score significantly higher.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "pytest"
                            },
                            "content": "Python test runner â€” discovers and executes test suites.",
                            "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš  Missing</div><div class=\"state-detail\">Without pytest, the Testing card can't run your test suite or collect coverage. The audit scoring system will flag the testing dimension as uncovered.\n\nğŸ“¦ Installs via: pip install pytest</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "âœ“ pip-audit"
                            },
                            "title": "pip-audit âœ“",
                            "icon": "âœ…",
                            "content": "Python vulnerability scanner â€” checks installed packages against the PyPI advisory database.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Installed</div><div class=\"state-detail\">pip-audit is available. The control plane uses it in the Security pipeline to scan your Python dependencies for known CVEs.\n\nResults feed into the ğŸ” Security Posture card. It cross-references your installed packages against the PyPI advisory database and OSV.dev.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "pip-audit"
                            },
                            "content": "Python vulnerability scanner â€” checks installed packages against the PyPI advisory database.",
                            "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš  Missing</div><div class=\"state-detail\">Without pip-audit, the Security card can't check your Python dependencies for known vulnerabilities. This is one of the three security scanners the control plane uses.\n\nğŸ“¦ Installs via: pip install pip-audit</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "âœ“ bandit"
                            },
                            "title": "bandit âœ“",
                            "icon": "âœ…",
                            "content": "Python security linter â€” scans source code AST for common vulnerability patterns.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Installed</div><div class=\"state-detail\">Bandit is available. The control plane uses it in the Security pipeline to perform static analysis on your Python source code â€” looking for hardcoded passwords, insecure function calls, SQL injection patterns, and similar issues.\n\nUnlike pip-audit (which checks dependencies), Bandit scans your own code.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "bandit"
                            },
                            "content": "Python security linter â€” scans source code AST for common vulnerability patterns.",
                            "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš  Missing</div><div class=\"state-detail\">Without Bandit, the Security card can't scan your Python source code for vulnerability patterns. It complements pip-audit (which checks dependencies) by inspecting your actual code.\n\nğŸ“¦ Installs via: pip install bandit</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "âœ“ safety"
                            },
                            "title": "safety âœ“",
                            "icon": "âœ…",
                            "content": "Python dependency checker â€” cross-references packages against a known vulnerability database.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Installed</div><div class=\"state-detail\">Safety is available. It provides a second opinion to pip-audit by checking your Python dependencies against its own vulnerability database.\n\nThe control plane runs both pip-audit and Safety for comprehensive coverage â€” they use different data sources and catch different issues.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "safety"
                            },
                            "content": "Python dependency checker â€” cross-references packages against a known vulnerability database.",
                            "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš  Missing</div><div class=\"state-detail\">Without Safety, you lose one of the two dependency vulnerability scanners. pip-audit and Safety complement each other â€” they use different databases and catch different CVEs.\n\nğŸ“¦ Installs via: pip install safety</div></div>"
                        }
                    ]
                },
                "children": []
            },
            {
                "id": "file-detection",
                "title": "File Detection",
                "icon": "ğŸ“‹",
                "selector": "#wiz-int-files-section",
                "content": "{{filesDetected}} of {{filesTotal}} project files detected. These are the files and directories the control plane looks for to determine which integrations are relevant to your project.",
                "expanded": "Each pill represents a specific file or directory. Found files (â—) activate their corresponding integration by default â€” for example, a Dockerfile enables the Docker card, and a k8s/ directory enables Kubernetes.\n\nMissing files (â—‹) don't block anything â€” you can still enable integrations manually and the control plane will generate the missing files for you during setup.",
                "dynamic": true,
                "childTemplate": {
                    "selector": "#wiz-int-files-section > span",
                    "title": "{{name}}",
                    "content": "Project file or directory used for integration detection.",
                    "variants": [
                        {
                            "when": {
                                "textContains": "â— git repo"
                            },
                            "title": "git repo â—",
                            "content": "A .git directory exists â€” this project is under version control.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">â— Found</div><div class=\"state-detail\">The .git directory confirms this is a git repository. This is the foundation for Git, GitHub, and CI/CD integrations.\n\nThe control plane reads your remotes, branches, and commit history from this directory.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "â—‹ git repo"
                            },
                            "title": "git repo â—‹",
                            "content": "No .git directory found â€” this project is not yet under version control.",
                            "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">â—‹ Not found</div><div class=\"state-detail\">No git repository detected. Run `git init` to initialize one. Without it, the Git, GitHub, and CI/CD integrations cannot function.\n\nThe control plane will still let you configure integrations, but they won't be operational until a repository exists.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "â— dockerfile"
                            },
                            "title": "dockerfile â—",
                            "content": "A Dockerfile exists at the project root â€” Docker image builds are possible.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">â— Found</div><div class=\"state-detail\">Your project has a Dockerfile. The Docker integration card can build images, inspect layers, and integrate with your CI/CD pipeline for automated builds.\n\nThe control plane parses your Dockerfile to detect base images, exposed ports, and build stages.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "â—‹ dockerfile"
                            },
                            "title": "dockerfile â—‹",
                            "content": "No Dockerfile at the project root.",
                            "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â—‹ Not found</div><div class=\"state-detail\">No Dockerfile detected. The Docker integration can generate one for you based on your detected stack â€” including the right base image, dependencies, and port exposure.\n\nUse the âš™ï¸ Setup button on the Docker card to scaffold a Dockerfile.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "â— docker compose"
                            },
                            "title": "docker compose â—",
                            "content": "A docker-compose.yml exists â€” multi-service orchestration is configured.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">â— Found</div><div class=\"state-detail\">Your project has a compose file. The Docker integration parses it to enumerate services, detect ports, and provide per-service management from the dashboard.\n\nServices from your compose file appear in the Docker card with start/stop/restart controls.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "â—‹ docker compose"
                            },
                            "title": "docker compose â—‹",
                            "content": "No docker-compose.yml or docker-compose.yaml found.",
                            "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â—‹ Not found</div><div class=\"state-detail\">No compose file detected. If your project needs multiple services (API + database + cache), the Docker setup wizard can generate a compose file with detected stack defaults.\n\nSingle-container projects often don't need compose at all.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "â— k8s manifests"
                            },
                            "title": "k8s manifests â—",
                            "content": "A k8s/ or kubernetes/ directory exists â€” Kubernetes manifests are present.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">â— Found</div><div class=\"state-detail\">Kubernetes manifests detected. The K8s integration card can apply these to your cluster, inspect their status, and generate additional manifests through the K8s wizard.\n\nThe manifest wizard supports Deployments, Services, ConfigMaps, Secrets, PVCs, Ingress, and more.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "â—‹ k8s manifests"
                            },
                            "title": "k8s manifests â—‹",
                            "content": "No k8s/ or kubernetes/ directory found.",
                            "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â—‹ Not found</div><div class=\"state-detail\">No Kubernetes manifest directory detected. If you plan to deploy to K8s, the manifest wizard can generate a complete set of manifests based on your project's stack and requirements.\n\nEnable the Kubernetes integration to get started.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "â— terraform dir"
                            },
                            "title": "terraform dir â—",
                            "content": "A terraform/ directory or main.tf exists â€” infrastructure as code is configured.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">â— Found</div><div class=\"state-detail\">Terraform configuration detected. The Terraform integration card can inspect your providers, backend configuration, and state to give you infrastructure visibility from the dashboard.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "â—‹ terraform dir"
                            },
                            "title": "terraform dir â—‹",
                            "content": "No terraform/ directory or main.tf found.",
                            "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â—‹ Not found</div><div class=\"state-detail\">No Terraform configuration detected. The Terraform integration can scaffold a complete IaC setup â€” provider config, backend state, and resource templates â€” tailored to your cloud provider.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "â— github actions"
                            },
                            "title": "github actions â—",
                            "content": "GitHub Actions workflows exist in .github/workflows/.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">â— Found</div><div class=\"state-detail\">GitHub Actions workflows detected. The CI/CD integration card can list, enable, disable, and dispatch these workflows. It also detects which secrets and variables each workflow needs.\n\nThe control plane can generate additional workflows (cron-based pipelines, deployment workflows) through the CI/CD setup.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "â—‹ github actions"
                            },
                            "title": "github actions â—‹",
                            "content": "No .github/workflows/ directory found.",
                            "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â—‹ Not found</div><div class=\"state-detail\">No GitHub Actions workflows detected. The CI/CD integration can generate a pipeline workflow that runs your project's tests, security scans, and builds on push and on a schedule.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "â— pyproject"
                            },
                            "title": "pyproject â—",
                            "content": "pyproject.toml found â€” Python project metadata and dependencies are defined.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">â— Found</div><div class=\"state-detail\">Your project has a pyproject.toml. The control plane reads this for: dependency lists (used by security scanners), version metadata, build configuration, and tool settings (ruff, mypy, pytest).\n\nThis is the modern standard for Python project configuration.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "â—‹ pyproject"
                            },
                            "title": "pyproject â—‹",
                            "content": "No pyproject.toml found.",
                            "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â—‹ Not found</div><div class=\"state-detail\">No pyproject.toml detected. If this is a Python project, the control plane uses it for dependency scanning, tool configuration, and build metadata. Without it, setup.py or requirements.txt are used as fallbacks.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "â— package json"
                            },
                            "title": "package json â—",
                            "content": "package.json found â€” Node.js project metadata and dependencies are defined.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">â— Found</div><div class=\"state-detail\">Your project has a package.json. The control plane reads this for: dependency lists (npm audit), scripts, version metadata, and detected stack classification.\n\nThe Packages card uses this for npm dependency management and vulnerability scanning.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "â—‹ package json"
                            },
                            "title": "package json â—‹",
                            "content": "No package.json found.",
                            "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â—‹ Not found</div><div class=\"state-detail\">No package.json detected. If this isn't a Node.js project, this is expected and safe to ignore.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "â— pages config"
                            },
                            "title": "pages config â—",
                            "content": "project.yml found â€” Pages pipeline configuration is available.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">â— Found</div><div class=\"state-detail\">project.yml is present. The Pages integration uses it for site generation settings â€” docs source directories, Docusaurus configuration, and deployment targets.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "â—‹ pages config"
                            },
                            "title": "pages config â—‹",
                            "content": "No project.yml found.",
                            "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â—‹ Not found</div><div class=\"state-detail\">No project.yml detected. This file is generated by the Setup Wizard when you finish â€” it contains all your project configuration including module definitions, environment settings, and integration preferences.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "â— dns dir"
                            },
                            "title": "dns dir â—",
                            "content": "A dns/ directory exists â€” DNS configuration files are present.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">â— Found</div><div class=\"state-detail\">DNS configuration directory detected. The DNS & CDN integration card reads zone files and record definitions from this directory for domain management.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "â—‹ dns dir"
                            },
                            "title": "dns dir â—‹",
                            "content": "No dns/ directory found.",
                            "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â—‹ Not found</div><div class=\"state-detail\">No DNS directory detected. The DNS integration can generate one with record templates for your domains when you set it up.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "â— cdn dir"
                            },
                            "title": "cdn dir â—",
                            "content": "A cdn/ directory exists â€” CDN configuration is present.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">â— Found</div><div class=\"state-detail\">CDN configuration directory detected. The DNS & CDN integration uses this for edge caching rules, origin settings, and CDN deployment configuration.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "â—‹ cdn dir"
                            },
                            "title": "cdn dir â—‹",
                            "content": "No cdn/ directory found.",
                            "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â—‹ Not found</div><div class=\"state-detail\">No CDN directory detected. If you need CDN configuration for your static sites or APIs, the DNS & CDN integration can scaffold one during setup.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "â— cname file"
                            },
                            "title": "cname file â—",
                            "content": "A CNAME file exists â€” custom domain for GitHub Pages is configured.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">â— Found</div><div class=\"state-detail\">A CNAME file is present, pointing your GitHub Pages site to a custom domain. The Pages integration uses this for deployment URL resolution and DNS record validation.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "â—‹ cname file"
                            },
                            "title": "cname file â—‹",
                            "content": "No CNAME file found.",
                            "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â—‹ Not found</div><div class=\"state-detail\">No CNAME file detected. Without it, GitHub Pages uses the default github.io subdomain. If you want a custom domain, the Pages setup can create this file for you.</div></div>"
                        }
                    ]
                },
                "children": []
            },
            {
                "id": "integrations-section",
                "title": "Integrations",
                "icon": "ğŸ”Œ",
                "selector": "#wiz-int-section-integrations",
                "separator": true,
                "content": "These three integrations form the project's collaboration backbone â€” version control, remote hosting, and static site deployment.",
                "expanded": "Git, GitHub, and Pages work as a chain: Git provides the repository, GitHub connects it to a remote with CI/CD and secrets management, and Pages deploys your documentation or static site through that remote.\n\nEach card shows its current status and readiness. Enable or disable cards with the checkbox â€” disabled cards won't appear on the dashboard but can be re-enabled anytime.\n\nClick âš™ï¸ Setup on any card for inline configuration, or ğŸš€ Full Setup for the complete setup wizard with guided steps.",
                "children": [
                    {
                        "id": "git-card",
                        "title": "Git",
                        "icon": "ğŸ”€",
                        "selector": "#wiz-int-wrap-int-git",
                        "content": "Version control is the foundation of the control plane. Every integration â€” GitHub, CI/CD, Docker, K8s, Pages â€” depends on an initialized git repository with at least one remote.",
                        "expanded": "Git underpins the entire pipeline. The control plane uses it for commit tracking, remote detection, branch management, .gitignore analysis, and the sync pipeline that pushes secrets and configs to GitHub.\n\nThe checkbox enables or hides the Git card from the dashboard. Even disabled, git is still required by other integrations â€” GitHub reads your remotes, CI/CD triggers on push events, Docker builds embed commit SHAs in image labels, and the vault system from Step 3 relies on .gitignore to protect plaintext .env files.\n\nClick âš™ï¸ Setup to configure remotes, .gitignore, hooks, and initial commit in one pass.",
                        "variants": [
                            {
                                "when": {
                                    "textContains": "âœ… ready"
                                },
                                "content": "Your repository is initialized and connected â€” the foundation is healthy. Every downstream integration (GitHub, CI/CD, Docker, Pages) builds on this.",
                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Fully Configured</div><div class=\"state-detail\">The control plane can read your remotes, track branches, analyse .gitignore coverage, and manage commit hooks. This is the baseline that unlocks everything else.\n\nYour .gitignore protects the vault secrets from Step 3 â€” encrypted .env files, plaintext credentials, and auto-generated keys are all excluded from version control. Pre-commit hooks, if installed, enforce the lint and format tools detected in System Tools above before each commit reaches the repository.\n\nOpen âš™ï¸ Setup to fine-tune: add or remove remotes, regenerate .gitignore with stack-aware patterns, or wire pre-commit hooks into your toolchain. Use ğŸš€ Full Setup for the guided wizard with validation.</div></div>"
                            },
                            {
                                "when": {
                                    "textContains": "not configured"
                                },
                                "content": "Git is installed but this directory isn't a repository yet. Downstream integrations (GitHub, CI/CD) are blocked until you initialize one.",
                                "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš  No Repository</div><div class=\"state-detail\">The git binary is available but there's no .git/ directory in your project root. Without git init, the control plane can't detect remotes, branches, or .gitignore â€” and the GitHub and CI/CD cards below are stuck in an unconfigured state too.\n\nThis is the most actionable state â€” one setup pass fixes the entire chain. Click âš™ï¸ Setup to initialize the repository, choose a default branch, generate a stack-aware .gitignore, and optionally create an initial commit.\n\nAfter applying, hit ğŸ”„ Re-scan in the scan bar above. The GitHub card will update to reflect the new repository, CI/CD workflow generation becomes available, and the File Detection pills will show the git repo as found.</div></div>"
                            },
                            {
                                "when": {
                                    "textContains": "not installed"
                                },
                                "content": "Git is not installed on this system. This is the single most critical blocker â€” every integration depends on it, directly or transitively.",
                                "expanded": "<div class=\"assistant-state-card state-error\"><div class=\"state-label\">âŒ Critical â€” Not Installed</div><div class=\"state-detail\">Without git, the control plane cannot initialize a repository, detect project structure, sync configurations, or interact with any remote service. Every integration card below â€” GitHub, CI/CD, Docker, K8s, Terraform, Pages, DNS â€” depends on git either directly or through the repository it manages.\n\nThe vault system from Step 3 also needs a repository so that .gitignore can protect plaintext .env files from accidental commits. The chat sync feature uses git push/pull for message replication.\n\nInstall git first, then hit ğŸ”„ Re-scan in the scan bar above. All other integrations will unblock once the binary is on your PATH.\n\nğŸ“¦ Install: sudo apt-get install git</div></div>"
                            }
                        ],
                        "children": [
                            {
                                "id": "git-setup",
                                "title": "Setup Panel",
                                "icon": "âš™ï¸",
                                "selector": "#wiz-int-setup-int-git",
                                "content": "The Git setup panel configures your repository in one pass â€” initialization, remotes, .gitignore, hooks, and initial commit. Hit âœ… Apply to execute all changes in sequence.",
                                "expanded": "The status strip at the top shows what's already in place (âœ“ green) and what's missing (â—‹ gray). Each section below targets one aspect of git configuration.\n\nChanges are applied when you click âœ… Apply â€” nothing runs until then. The panel re-detects after applying, so all cards and pills update to reflect the new state.\n\nThis is the inline version. For a more guided experience with step-by-step validation, use ğŸš€ Full Setup instead.",
                                "children": [
                                    {
                                        "id": "git-status-strip",
                                        "title": "Status Strip",
                                        "icon": "ğŸ“Š",
                                        "selector": "#wiz-git-status-strip",
                                        "content": "At-a-glance health check â€” each pill tracks one aspect of your git configuration. Green (âœ“) means configured, gray (â—‹) means missing or not yet set up.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“Š Configuration Overview</div><div class=\"state-detail\">The status strip provides a quick visual summary of your repository's setup state. Each pill corresponds to a section below where you can configure the missing piece.\n\nThe strip updates after every Apply or re-scan. It reads live detection data from the backend â€” not cached state â€” so it always reflects the current reality on disk.\n\nHover any individual pill for details about that specific check and what to do if it's showing a failure state.</div></div>",
                                        "children": [
                                            {
                                                "id": "git-pill-binary",
                                                "title": "Git Binary",
                                                "icon": "ğŸ’»",
                                                "selector": "#wiz-git-pill-binary",
                                                "content": "Whether the git binary is installed and available on your system PATH.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ’» Git Installation</div><div class=\"state-detail\">This pill checks if the git executable is reachable. The version number shown is the installed version.\n\nGit is the foundation â€” every other pill, section, and the entire GitHub integration depends on it. If this shows âœ—, nothing else in this panel works.</div></div>",
                                                "variants": [
                                                    {
                                                        "when": {
                                                            "textContains": "âœ“ git"
                                                        },
                                                        "content": "Git is installed and available. The version number is detected from git --version.",
                                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Git Available</div><div class=\"state-detail\">The git binary was found on PATH and responded to version check. All git operations are unblocked.\n\nThe version shown is informational â€” the control plane works with any modern git version (2.x+).</div></div>"
                                                    },
                                                    {
                                                        "when": {
                                                            "textContains": "âœ— git"
                                                        },
                                                        "content": "Git is not installed â€” this blocks every integration in this panel.",
                                                        "expanded": "<div class=\"assistant-state-card state-error\"><div class=\"state-label\">âŒ Git Missing</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">The git executable was not found on PATH. This blocks:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Repository initialization</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Remote management</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ .gitignore generation</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Hook installation</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Commit operations</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ The entire GitHub integration</div><div class=\"state-text\">Install git first, then re-scan to refresh this panel.</div></div></div>"
                                                    }
                                                ],
                                                "children": []
                                            },
                                            {
                                                "id": "git-pill-repo",
                                                "title": "Repository",
                                                "icon": "ğŸ“",
                                                "selector": "#wiz-git-pill-repo",
                                                "content": "Whether a .git/ directory exists â€” indicates the project is a git repository.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“ Repository Status</div><div class=\"state-detail\">This pill checks for a .git/ directory in your project root. The branch name after the dot shows your current HEAD branch.\n\nInitialization creates the .git/ directory, which stores all version control metadata â€” commits, branches, refs, hooks, and configuration.</div></div>",
                                                "variants": [
                                                    {
                                                        "when": {
                                                            "textContains": "âœ“ repo"
                                                        },
                                                        "content": "Repository is initialized â€” the branch name shown is your current HEAD.",
                                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Repository Initialized</div><div class=\"state-detail\">A .git/ directory exists. The branch name after 'repo Â·' is your current HEAD â€” this is the active branch that commits will target.\n\nWith a repository in place, all other operations are unblocked: adding remotes, generating .gitignore, installing hooks, and making commits.</div></div>"
                                                    },
                                                    {
                                                        "when": {
                                                            "textContains": "â—‹ no repo"
                                                        },
                                                        "content": "No repository â€” git init will be run when you Apply.",
                                                        "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš  Not Initialized</div><div class=\"state-detail\">No .git/ directory found. The project is not under version control yet.\n\nWhen you hit âœ… Apply, the control plane runs git init to create the repository. The default branch name is set from the Default Branch field below.\n\nUntil initialized: no commits, no branches, no remotes, no hooks.</div></div>"
                                                    }
                                                ],
                                                "children": []
                                            },
                                            {
                                                "id": "git-pill-remotes",
                                                "title": "Remotes Count",
                                                "icon": "ğŸŒ",
                                                "selector": "#wiz-git-pill-remotes",
                                                "content": "How many remotes are configured â€” at least one (origin) is needed for push/pull and GitHub features.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸŒ Remote Count</div><div class=\"state-detail\">This pill counts all configured remotes (git remote -v). The number includes both origin and any additional remotes like upstream or deploy.\n\nThe GitHub integration reads the origin remote to determine your repository â€” no remotes means no GitHub features.</div></div>",
                                                "variants": [
                                                    {
                                                        "when": {
                                                            "textContains": "remote(s)"
                                                        },
                                                        "content": "At least one remote is configured â€” push/pull and GitHub integration are available.",
                                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Remotes Configured</div><div class=\"state-detail\">Your repository has one or more remotes. The origin remote is used by the GitHub integration to determine your repository slug for secrets sync, PR management, workflow dispatch, and Pages deployment.\n\nYou can manage remotes in the Remotes section below â€” add new ones or remove existing ones.</div></div>"
                                                    },
                                                    {
                                                        "when": {
                                                            "textContains": "â—‹ no remotes"
                                                        },
                                                        "content": "No remotes â€” push/pull and all GitHub features are blocked.",
                                                        "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš  No Remotes</div><div class=\"state-detail\">Without remotes, your repository is local-only. The control plane can't push code, sync secrets, dispatch CI/CD workflows, or deploy Pages.\n\nOpen the Remotes section below to add origin. If the GitHub CLI is authenticated, the URL may be pre-filled.</div></div>"
                                                    }
                                                ],
                                                "children": []
                                            },
                                            {
                                                "id": "git-pill-gitignore",
                                                "title": "Gitignore Status",
                                                "icon": "ğŸ“„",
                                                "selector": "#wiz-git-pill-gitignore",
                                                "content": "Whether .gitignore exists and what percentage of recommended patterns it covers.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“„ Coverage Check</div><div class=\"state-detail\">This pill shows two things: whether a .gitignore file exists, and if so, what percentage of recommended patterns (for your detected stacks) are present.\n\n100% means every recommended pattern is covered. Lower percentages mean gaps exist â€” potential for secrets or build artifacts to leak into version control.\n\nOpen the .gitignore section below for details on what's missing and to regenerate.</div></div>",
                                                "variants": [
                                                    {
                                                        "when": {
                                                            "textContains": "âœ“ .gitignore"
                                                        },
                                                        "content": "File exists â€” the percentage shows recommended pattern coverage for your stacks.",
                                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… .gitignore Present</div><div class=\"state-detail\">A .gitignore file exists in your project root. The percentage reflects how many recommended patterns for your detected stacks are included.\n\n100% means complete coverage. Below 100% means some recommended patterns are missing â€” check the .gitignore section below to see which ones and regenerate if needed.</div></div>"
                                                    },
                                                    {
                                                        "when": {
                                                            "textContains": "â—‹ no .gitignore"
                                                        },
                                                        "content": "No .gitignore file â€” secrets and build artifacts could be committed.",
                                                        "expanded": "<div class=\"assistant-state-card state-error\"><div class=\"state-label\">âŒ No .gitignore</div><div class=\"state-detail\">No .gitignore file was found. This is a security risk â€” without it, git add . would stage everything including .env files with secrets, build artifacts, and dependency directories.\n\nOpen the .gitignore section below and check 'Create .gitignore' to generate one based on your detected stacks.</div></div>"
                                                    }
                                                ],
                                                "children": []
                                            },
                                            {
                                                "id": "git-pill-hooks",
                                                "title": "Hooks Count",
                                                "icon": "ğŸª",
                                                "selector": "#wiz-git-pill-hooks",
                                                "content": "How many git hooks are installed â€” hooks automate quality checks before commits and pushes.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸª Hook Count</div><div class=\"state-detail\">This pill counts executable files in .git/hooks/ (excluding samples). Hooks are local scripts that git runs automatically at specific lifecycle events.\n\nThe most common hook is pre-commit â€” it runs checks before each commit. If the checks fail, the commit is blocked.\n\nIf lint or format tools are detected in your stack and no hooks exist, the Pre-commit Hook section below offers to install one.</div></div>",
                                                "variants": [
                                                    {
                                                        "when": {
                                                            "textContains": "hook(s)"
                                                        },
                                                        "content": "Hooks are installed â€” quality checks run automatically at git lifecycle events.",
                                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Hooks Active</div><div class=\"state-detail\">One or more git hooks are installed in .git/hooks/. These run automatically â€” typically before commits â€” to enforce code quality and catch issues early.\n\nThe hooks were either installed by the control plane or manually. You can inspect them at .git/hooks/ in your project root.</div></div>"
                                                    },
                                                    {
                                                        "when": {
                                                            "textContains": "â—‹ no hooks"
                                                        },
                                                        "content": "No hooks installed â€” commits go through unchecked.",
                                                        "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš  No Hooks</div><div class=\"state-detail\">No git hooks are installed. Commits are accepted without any automated checks.\n\nIf your stack has lint or format capabilities detected (shown in System Tools), the Pre-commit Hook section below can install a hook that runs those checks before every commit.\n\nHooks are a local first line of defense â€” the CI/CD pipeline provides the team-wide enforcement layer.</div></div>"
                                                    }
                                                ],
                                                "children": []
                                            }
                                        ]
                                    },
                                    {
                                        "id": "git-remotes",
                                        "title": "Remotes",
                                        "icon": "ğŸŒ",
                                        "selector": "#wiz-git-section-remotes",
                                        "content": "Remotes connect your local repository to its hosted counterpart. Adding origin is the first step to enabling push, pull, and the entire GitHub integration chain.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸŒ Remote Configuration</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">The control plane reads your remotes to detect your GitHub repository, resolve the deployment target for Pages, and configure CI/CD workflow dispatch.</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">Naming conventions:</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;font-size:0.75rem\"><span class=\"state-key\">origin</span><span>your primary remote, usually your own GitHub repo</span><span class=\"state-key\">upstream</span><span>the parent repository if you're working from a fork</span></div><div class=\"state-text\">If the GitHub CLI is authenticated, the remote URL is pre-filled from your gh repo info. The format should be https://github.com/owner/repo.git or git@github.com:owner/repo.git for SSH.</div><div class=\"state-text\">The GitHub integration card below reads the origin remote to determine which repository to target for secrets sync, PR management, and Actions dispatch. No remote = no GitHub features.</div></div></div>",
                                        "variants": [
                                            {
                                                "when": {
                                                    "textContains": "no remotes"
                                                },
                                                "content": "No remotes configured â€” push, pull, and GitHub integration are blocked until you add at least origin.",
                                                "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš  No Remotes</div><div class=\"state-detail\">Without a remote, your repository is local-only. The control plane can't push code, sync secrets to GitHub, dispatch workflows, or deploy Pages.\n\nAdd origin first â€” it's the primary remote that all GitHub features target. Type the remote name and URL below, then hit ï¼‹ Add.\n\nIf the GitHub CLI detected your repository, the URL is pre-filled. Otherwise, use the format: https://github.com/your-org/your-repo.git</div></div>"
                                            }
                                        ],
                                        "children": [
                                            {
                                                "id": "git-remote-name",
                                                "title": "Remote Name",
                                                "icon": "ğŸ·ï¸",
                                                "selector": "#wiz-git-remote-name",
                                                "content": "The remote name is a local alias for the hosted repository URL. It's how git references where to push and pull.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ·ï¸ Naming Convention</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Standard names and what they mean:</div><div class=\"state-grid\"><span class=\"state-key\">origin</span><span>your primary repository. This is the default target for git push and git pull. The GitHub integration reads this remote to determine your repository slug.</span><span class=\"state-key\">upstream</span><span>the parent repository you forked from. Used for syncing changes from the original project.</span><span class=\"state-key\">deploy</span><span>some teams use a separate remote for deployment targets.</span></div><div class=\"state-text\">If this is your first remote, the placeholder suggests \"origin\" â€” that's almost always the right choice. The name is local to your machine and can be changed later with git remote rename.</div></div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "git-remote-url",
                                                "title": "Remote URL",
                                                "icon": "ğŸ”—",
                                                "selector": "#wiz-git-remote-url",
                                                "content": "The remote URL points to your hosted repository â€” this is where git push sends your code and where GitHub integration reads your project from.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ”— URL Format</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Two formats work:</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">â€” Works out of the box, authenticates via git credential manager or token.</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ HTTPS: https://github.com/owner/repo.git</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">â€” Requires SSH key setup. The control plane can detect SSH auth status and prompt for passphrase unlock when needed.</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ SSH: git@github.com:owner/repo.git</div><div class=\"state-text\">If the GitHub CLI (gh) is authenticated and detected your repository, this field is pre-filled with the HTTPS URL. You can switch to SSH if your workflow prefers it.</div><div class=\"state-text\">The URL you set here becomes the target for all GitHub operations â€” secrets sync, PR management, workflow dispatch, and Pages deployment.</div></div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "git-add-remote",
                                                "title": "Add Remote",
                                                "icon": "ï¼‹",
                                                "selector": "#wiz-git-add-remote-btn",
                                                "content": "Adds the remote immediately â€” this runs git remote add right now, not on Apply. The page re-detects after adding so all cards update.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ï¼‹ Instant Action</div><div class=\"state-detail\">Unlike other setup options that wait for âœ… Apply, adding a remote executes immediately via the /git/remote/add API endpoint. The reason: remotes affect detection results, so re-scanning after add gives accurate status for all other cards.\n\nAfter adding, the remote appears in the list above with a âœ— remove button. The GitHub card will update on the next re-scan to reflect the new remote.\n\nIf the name field is empty, it defaults to the placeholder value (\"origin\" for the first remote, \"upstream\" for additional ones).</div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "git-remotes-list",
                                                "title": "Configured Remotes",
                                                "icon": "ğŸ“‹",
                                                "selector": "#wiz-git-remotes-list",
                                                "content": "Your configured remotes â€” each row shows the name, URL, and a remove button. Removal is immediate and triggers re-detection.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“‹ Remote Registry</div><div class=\"state-detail\">Each row in this list is a configured git remote. The name (origin, upstream) is a local alias, the URL is the hosted repository endpoint.\n\nThe âœ— button removes a remote immediately (git remote remove) â€” this is irreversible. After removal, the page re-detects so all cards and pills update. If you remove origin, the GitHub integration will lose its target repository.\n\nRemotes are stored in .git/config and are local to your machine â€” they don't affect other developers working on the same repository.</div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "git-gh-hint",
                                                "title": "GitHub CLI Hint",
                                                "icon": "ğŸ™",
                                                "selector": "#wiz-git-gh-hint",
                                                "content": "The GitHub CLI detected your repository and pre-filled the remote URL. You can change it before adding.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ™ Auto-Detection</div><div class=\"state-detail\">The GitHub CLI (gh) command was found on your system and is authenticated. It identified a repository associated with this project directory.\n\nThe pre-filled URL uses the HTTPS format by default. You can change it to SSH (git@github.com:owner/repo.git) if your workflow uses SSH authentication.\n\nThis hint only appears when gh is installed, authenticated, and successfully resolved a repository slug for the current directory.</div></div>",
                                                "children": []
                                            }
                                        ]
                                    },
                                    {
                                        "id": "git-gitignore",
                                        "title": ".gitignore",
                                        "icon": "ğŸ“„",
                                        "selector": "#wiz-git-section-gitignore",
                                        "content": "The .gitignore controls what git tracks. Proper coverage prevents secrets, build artifacts, and environment files from being committed â€” this is the first line of defense for your vault.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“„ .gitignore Coverage</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">The control plane analyses your .gitignore against a catalog of expected patterns for your detected stacks. Coverage percentage reflects how many recommended patterns are present.</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">Critical patterns (always needed):</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;font-size:0.75rem\"><span class=\"state-key\">.env, .env.*</span><span>vault secrets from Step 3</span><span class=\"state-key\">.env.vault</span><span>encrypted vault files (extra protection layer)</span></div><div class=\"state-text\">Stack-specific patterns are added based on your detected modules â€” the generator reads your stack definitions to determine which build artifacts, dependency directories, and compiled output directories to exclude.</div><div class=\"state-text\">The generator produces a comprehensive .gitignore in one pass. It's safe to regenerate â€” the generated file includes all your existing custom patterns.</div></div></div>",
                                        "variants": [
                                            {
                                                "when": {
                                                    "textContains": "100%"
                                                },
                                                "content": "Your .gitignore covers all recommended patterns for your detected stacks. Secrets, build artifacts, and environment files are protected.",
                                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Full Coverage</div><div class=\"state-detail\">Every recommended pattern for your project's stacks is present in .gitignore. This means secrets from Step 3, build artifacts, and environment-specific files are all excluded from version control.\n\nYou can still open this section to regenerate if your stacks change â€” the generator always includes existing custom patterns alongside the recommended ones.</div></div>"
                                            },
                                            {
                                                "when": {
                                                    "textContains": "missing)"
                                                },
                                                "content": "No .gitignore file exists. Without it, secrets, build artifacts, and environment files could be committed to the repository.",
                                                "expanded": "<div class=\"assistant-state-card state-error\"><div class=\"state-label\">âŒ No .gitignore</div><div class=\"state-detail\">This is a security risk. Without .gitignore, git tracks everything â€” including plaintext .env files from Step 3, build artifacts, dependency directories, and IDE configuration.\n\nThe \"Create .gitignore\" checkbox generates a comprehensive file based on your detected stacks. It includes universal security patterns (blocking .env, credentials, keys) plus stack-specific patterns for build artifacts and dependency directories relevant to your stack.\n\nThis should be the first thing you fix â€” even before adding remotes. A .gitignore protects you from day one.</div></div>"
                                            },
                                            {
                                                "when": {
                                                    "textContains": "Missing"
                                                },
                                                "content": "Your .gitignore has gaps â€” some recommended patterns for your stacks are missing. Regenerating adds them without losing your custom entries.",
                                                "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš  Incomplete Coverage</div><div class=\"state-detail\">The analysis found patterns recommended for your detected stacks that aren't in your .gitignore. Missing patterns are shown as red pills â€” each represents a file type or directory that could leak into version control.\n\nCommon gaps include build output directories, dependency caches, compiled artifacts, IDE configs (.vscode/, .idea/), and OS files (.DS_Store).\n\nCheck the \"Regenerate .gitignore\" checkbox and hit âœ… Apply to fill the gaps. The generator preserves your existing custom patterns and adds the missing recommended ones on top.</div></div>"
                                            }
                                        ],
                                        "children": [
                                            {
                                                "id": "git-regen-gi",
                                                "title": "Regenerate .gitignore",
                                                "icon": "ğŸ”„",
                                                "selector": "#wiz-git-regen-gi",
                                                "content": "Regenerates your .gitignore with stack-aware patterns â€” fills gaps without removing your existing custom entries.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ”„ Stack-Aware Regeneration</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">The generator reads your detected stacks (from Step 2 modules) and the security catalog to produce a comprehensive .gitignore.</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">What it adds:</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;font-size:0.75rem\"><span class=\"state-key\">Universal security patterns</span><span>.env, .env.*, credentials, private keys</span><span class=\"state-key\">Stack-specific patterns</span><span>build artifacts, dependency directories, and compiled output relevant to your detected language and framework stacks</span><span class=\"state-key\">IDE and OS patterns</span><span>.vscode/, .idea/, .DS_Store, Thumbs.db</span></div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">What it preserves:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Any custom patterns you've added manually</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Comments and section headers in your existing file</div><div class=\"state-text\">This checkbox is pre-checked when the analysis detected gaps. Uncheck it if you want to manage .gitignore manually. The regeneration runs on âœ… Apply along with all other setup steps.</div></div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "git-create-gi",
                                                "title": "Create .gitignore",
                                                "icon": "ğŸ“",
                                                "selector": "#wiz-git-create-gi",
                                                "content": "Creates a new .gitignore from scratch â€” generated from your detected stacks with security-first defaults.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“ New File Generation</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">This creates a brand-new .gitignore file in your project root. The generated file includes:</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">1. Security patterns (always included):</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;font-size:0.75rem\"><span class=\"state-key\">.env, .env.*</span><span>blocks vault secrets from Step 3</span><span class=\"state-key\">*.pem, *.key</span><span>blocks private keys and certificates</span><span class=\"state-key\">.env.vault</span><span>blocks encrypted vault archives</span></div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">Build artifacts, dependency directories, and compiled output specific to your detected language and framework stacks.</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">â†’ Stack patterns (based on detected modules):</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">3. Common patterns:</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;font-size:0.75rem\"><span class=\"state-key\">.DS_Store, Thumbs.db</span><span>OS artifacts</span><span class=\"state-key\">.vscode/, .idea/</span><span>IDE configs</span></div><div class=\"state-text\">This is the single most important file to create before your first commit. Without it, git add . would stage everything â€” including secrets.</div></div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "git-missing-patterns",
                                                "title": "Missing Patterns",
                                                "icon": "âš ï¸",
                                                "selector": "#wiz-git-missing-patterns",
                                                "content": "Each red pill is a pattern recommended for your detected stacks that's missing from .gitignore. Check 'Regenerate' and Apply to add them all.",
                                                "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš ï¸ Gap Analysis</div><div class=\"state-detail\">The control plane compares your .gitignore against a catalog of recommended patterns for each detected stack. Each red pill represents a pattern that should be present but isn't.\n\nPatterns are matched by your stack's language family and framework â€” the catalog knows which build outputs, dependency directories, and compiled artifacts each stack produces.\n\nChecking 'Regenerate .gitignore' and hitting âœ… Apply adds all missing patterns in one pass without removing your existing custom entries. Up to 5 are shown here â€” if there are more, the count is displayed.</div></div>",
                                                "children": []
                                            }
                                        ]
                                    },
                                    {
                                        "id": "git-hooks",
                                        "title": "Pre-commit Hook",
                                        "icon": "ğŸª",
                                        "selector": "#wiz-git-section-hooks",
                                        "content": "Pre-commit hooks run your lint and format tools automatically before each commit â€” catching issues before they reach the repository and enforcing code quality at the gate.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸª Automated Quality Gate</div><div class=\"state-detail\">This section appears when lint or format tools are detected in your stack but no pre-commit hook is installed yet. The hook runs automatically before every git commit â€” if the checks fail, the commit is blocked.\n\nThe commands wired into the hook come from your stack's capabilities, detected from the System Tools section above. The green pills below show which commands were detected and will be included in the hook script.\n\nThe hook is a simple shell script installed at .git/hooks/pre-commit. It runs each command in sequence and aborts the commit on any failure. This is the lightest quality gate â€” no CI required, runs locally, instant feedback.\n\nCheck the box and hit âœ… Apply to install it.</div></div>",
                                        "children": [
                                            {
                                                "id": "git-setup-hooks-check",
                                                "title": "Install Hook",
                                                "icon": "â˜‘ï¸",
                                                "selector": "#wiz-git-setup-hooks",
                                                "content": "Check this to install a pre-commit hook that runs your lint and format commands before every commit.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â˜‘ï¸ Hook Installation</div><div class=\"state-detail\">When checked, âœ… Apply creates a shell script at .git/hooks/pre-commit with the commands detected from your stack capabilities:\n\nFor each capability found in System Tools above, the hook runs the corresponding check command. If any check fails (non-zero exit), the commit is aborted and you see the error output.\n\nThe hook file is a standard git hook â€” you can edit it manually after installation. It's not versioned (lives in .git/hooks/ which is gitignored by default), so each developer needs to install it locally.\n\nFor team-wide enforcement, the CI/CD pipeline runs the same checks â€” the hook is just a fast local pre-check to catch issues before pushing.</div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "git-hook-commands",
                                                "title": "Detected Commands",
                                                "icon": "ğŸ”§",
                                                "selector": "#wiz-git-hook-commands",
                                                "content": "These are the check commands detected from your stack's capabilities. They'll be wired into the pre-commit hook script.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ”§ Stack Capabilities</div><div class=\"state-detail\">Each green pill represents a command detected from your stack definition's capabilities section. These commands are what the pre-commit hook will run before each commit.\n\nThe commands are not hardcoded â€” they come from your stack's YAML definition (discovered in Step 2). If your stack defines lint, format, or test capabilities, those commands appear here.\n\nThe hook runs each command in sequence. If any exits non-zero, the commit is blocked and the error output is shown.</div></div>",
                                                "children": [
                                                    {
                                                        "id": "git-hook-lint",
                                                        "title": "Lint Check",
                                                        "icon": "ğŸ”",
                                                        "selector": "#wiz-git-hook-lint",
                                                        "content": "The lint command from your stack's capabilities â€” runs static analysis to catch code issues before commit.",
                                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ” Static Analysis</div><div class=\"state-detail\">This is the lint command detected from your stack definition. Linting performs static analysis on your source code â€” catching bugs, style violations, and suspicious patterns without running the code.\n\nIn the pre-commit hook, this command runs in check mode (read-only). If it finds issues, the commit is blocked and you see the lint errors in your terminal.\n\nThe specific command shown here comes from your stack's 'lint' capability in its YAML definition.</div></div>",
                                                        "children": []
                                                    },
                                                    {
                                                        "id": "git-hook-format",
                                                        "title": "Format Check",
                                                        "icon": "âœ¨",
                                                        "selector": "#wiz-git-hook-format",
                                                        "content": "The format command from your stack's capabilities â€” checks code formatting consistency before commit.",
                                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">âœ¨ Formatting Verification</div><div class=\"state-detail\">This is the format command detected from your stack definition. Format checking verifies that your code follows consistent style rules â€” indentation, spacing, line length, and other formatting conventions.\n\nIn the pre-commit hook, this runs in check/verify mode â€” it reports formatting issues without modifying files. If unformatted code is found, the commit is blocked.\n\nThe specific command shown here comes from your stack's 'format' capability in its YAML definition.</div></div>",
                                                        "children": []
                                                    }
                                                ]
                                            }
                                        ]
                                    },
                                    {
                                        "id": "git-initial-commit",
                                        "title": "Initial Commit",
                                        "icon": "ğŸ’¾",
                                        "selector": "#wiz-git-section-commit",
                                        "content": "An initial commit anchors the repository â€” it's the baseline that all future changes are measured against and the first entry in your project's history.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ’¾ First Commit</div><div class=\"state-detail\">This section appears when the repository has no commits yet â€” either freshly initialized or never committed to. The initial commit typically includes your project.yml, .gitignore, and any existing source files.\n\nThe commit message defaults to \"Initial commit\" but you can customize it. The commit runs git add . followed by git commit -m after all other setup steps (remotes, .gitignore, hooks) have been applied â€” so the first commit captures a clean, properly configured state.\n\nAfter this commit, git log will show history, branch operations will work, and push to origin becomes possible.</div></div>",
                                        "children": [
                                            {
                                                "id": "git-init-commit-check",
                                                "title": "Create Commit",
                                                "icon": "â˜‘ï¸",
                                                "selector": "#wiz-git-init-commit",
                                                "content": "Check this to create an initial commit after all other setup steps complete â€” this anchors the repository with a clean starting state.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â˜‘ï¸ Initial Commit Toggle</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">When checked, âœ… Apply runs git add . followed by git commit -m with your message after completing all other steps (.gitignore generation, hook installation, branch setup).</div><div class=\"state-text\">This ordering matters: the .gitignore is created BEFORE the commit, so the first commit already respects ignore rules. Secrets and build artifacts won't be staged.</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">The initial commit gives you:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ A baseline for git diff and git log</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ A branch HEAD that enables push to remote</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ A commit SHA that Docker builds can embed in image labels</div><div class=\"state-text\">Leave unchecked if you want to review staged files before committing manually.</div></div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "git-commit-msg",
                                                "title": "Commit Message",
                                                "icon": "ğŸ’¬",
                                                "selector": "#wiz-git-commit-msg",
                                                "content": "The message for your initial commit â€” defaults to 'Initial commit' but you can describe what the first snapshot contains.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ’¬ First Message</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">The commit message appears in git log and on GitHub's commit history. For initial commits, common patterns:</div><div class=\"state-grid\"><span class=\"state-key\">\"Initial commit\"</span><span>the classic default</span><span class=\"state-key\">\"Initial project setup with devops-control-plane\"</span><span>more descriptive</span><span class=\"state-key\">\"chore: bootstrap project structure\"</span><span>conventional commits format</span></div><div class=\"state-text\">This message is passed directly to git commit -m. It only applies if the \"Create initial commit\" checkbox above is checked.</div><div class=\"state-text\">After the initial commit, future commits should follow your team's commit message convention â€” conventional commits, gitmoji, or plain descriptive messages.</div></div></div>",
                                                "children": []
                                            }
                                        ]
                                    },
                                    {
                                        "id": "git-branch",
                                        "title": "Default Branch",
                                        "icon": "ğŸŒ¿",
                                        "selector": "#wiz-git-branch",
                                        "content": "The default branch is your main development line â€” it determines the target for pull requests, the base for CI/CD triggers, and the name git uses when initializing.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸŒ¿ Branch Configuration</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Most projects use \"main\" â€” GitHub has defaulted to this since 2020. Some older projects still use \"master\" and that works too.</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">The control plane uses this branch name in several places:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ CI/CD workflows trigger on push to this branch</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ GitHub PR targets default to this branch</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Pages deployments reference this as the source branch</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ The docker image tagging uses branch name as part of the version string</div><div class=\"state-text\">Changing this after the initial setup is possible but requires renaming the branch (git branch -m old new) and updating any CI/CD workflow YAML that references the old name.</div><div class=\"state-text\">If you're starting fresh, stick with \"main\". If you have an existing repo, the current branch name is pre-filled.</div></div></div>",
                                        "children": []
                                    },
                                    {
                                        "id": "git-apply",
                                        "title": "Apply",
                                        "icon": "âœ…",
                                        "selector": "#wiz-apply-int-git",
                                        "content": "Executes all checked setup steps in sequence â€” .gitignore generation, hook installation, branch configuration, then initial commit if checked.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">âœ… Execution Order</div><div class=\"state-detail\">When you click Apply, the control plane runs each checked step in a specific order:\n\n1. git init (if no repository exists)\n2. Branch rename (if different from current)\n3. .gitignore generation or regeneration\n4. Pre-commit hook installation\n5. git add . + git commit (if initial commit is checked)\n\nThis ordering is intentional â€” .gitignore is created before the commit, so the first snapshot already excludes secrets and build artifacts.\n\nAfter all steps complete, the panel re-detects and all status pills and cards update to reflect the new state. If any step fails, the error is shown and remaining steps are skipped.</div></div>",
                                        "children": []
                                    },
                                    {
                                        "id": "git-cancel",
                                        "title": "Cancel",
                                        "icon": "âœ–",
                                        "selector": "#wiz-cancel-int-git",
                                        "content": "Closes the setup panel without applying any changes. Nothing is modified on disk.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">âœ– Discard Changes</div><div class=\"state-detail\">Clicking Cancel collapses the setup panel and discards any unsaved field values. No git operations are performed â€” no files are created, modified, or deleted.\n\nYou can reopen the panel at any time by clicking âš™ï¸ Setup again. Field values will be re-populated from the current detection state, not from your previous unsaved edits.</div></div>",
                                        "children": []
                                    }
                                ]
                            }
                        ]
                    },
                    {
                        "id": "gh-card",
                        "title": "GitHub",
                        "icon": "ğŸ™",
                        "selector": "#wiz-int-wrap-int-github",
                        "content": "GitHub integration connects your local project to GitHub's API â€” environment management, secrets sync, CODEOWNERS automation, and Actions dispatch all flow through the gh CLI.",
                        "variants": [
                            {
                                "when": {
                                    "textContains": "âœ… ready"
                                },
                                "content": "Authenticated as {{ghUser}} and linked to {{ghRepo}}. {{ghEnvAligned}} of {{ghEnvTotal}} environments aligned, {{ghWorkflows}} workflow(s) active. Open âš™ï¸ Setup to check what's left.",
                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Fully Connected</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">The gh CLI is authenticated and linked to {{ghRepo}}. The control plane can manage deployment environments, push vault secrets from Step 3, write CODEOWNERS for automatic PR review, and query workflow status.</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">Your integration health:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ {{ghEnvAligned}} of {{ghEnvTotal}} environments from Step 1 are on GitHub</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ {{ghWorkflows}} Actions workflow(s) detected</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Repository is {{ghVis}}</div><div class=\"state-text\">Open âš™ï¸ Setup to drill into each dimension, or use ğŸš€ Full Setup for the guided wizard with repository creation and visibility management.</div></div></div>"
                            },
                            {
                                "when": {
                                    "textContains": "not configured"
                                },
                                "content": "The gh CLI is installed but not authenticated. Without a GitHub session, the control plane can't sync your {{envCount}} environments or push vault secrets.",
                                "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš  Not Authenticated</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">The GitHub CLI binary is on your system but hasn't been linked to a GitHub account. This blocks:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Creating your {{envCount}} environments on GitHub for CI/CD deployment gating</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Pushing vault secrets so Actions workflows can use them</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Writing CODEOWNERS for automatic PR review assignment</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Querying repository metadata and workflow status</div><div class=\"state-text\">Click âš™ï¸ Setup â†’ ğŸ”‘ Authenticate to run the OAuth flow. After authenticating, hit ğŸ”„ Re-scan â€” the card will update with your account, repository link, and full integration status.</div></div></div>"
                            },
                            {
                                "when": {
                                    "textContains": "not installed"
                                },
                                "content": "The gh CLI isn't installed. Without it, your {{envCount}} environments, vault secrets, and CODEOWNERS have to be managed manually on github.com.",
                                "expanded": "<div class=\"assistant-state-card state-error\"><div class=\"state-label\">âŒ CLI Not Available</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">The gh CLI is the bridge between your local project and GitHub's API. Without it, the control plane can't:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Create deployment environments for your CI/CD workflows</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Push the vault secrets you configured in Step 3</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Write CODEOWNERS for automatic review assignment</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Query repository status, visibility, or workflow health</div><div class=\"state-text\">You'd have to do all of this manually through github.com.</div><div class=\"state-text\">Click âš™ï¸ Setup â†’ ğŸ“¦ Install gh. After installation, authenticate and re-scan â€” everything else unlocks from there.</div><div class=\"state-text\">ğŸ“¦ Install: https://cli.github.com or brew install gh</div></div></div>"
                            }
                        ],
                        "children": [
                            {
                                "id": "gh-setup",
                                "title": "Setup Panel",
                                "icon": "âš™ï¸",
                                "selector": "#wiz-int-setup-int-github",
                                "content": "Your GitHub integration dashboard â€” authentication, repository link, environment alignment, CODEOWNERS, and secrets sync. What you see here depends on your gh CLI state.",
                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">âš™ï¸ GitHub Configuration</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">This panel adapts to your current state:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Not installed â†’ install prompt for the gh CLI binary</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Not authenticated â†’ OAuth login to link a GitHub account</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Authenticated â†’ full dashboard with {{ghEnvTotal}} environments, repository details, CODEOWNERS, and secrets sync</div><div class=\"state-text\">Environments come from Step 1's project config. Secrets come from Step 3's vault. CODEOWNERS controls who reviews PRs. Everything here feeds into your CI/CD pipeline.</div><div class=\"state-text\">For the full guided experience with repository creation and visibility management, use ğŸš€ Full Setup instead.</div></div></div>",
                                "children": [
                                    {
                                        "id": "gh-status-strip",
                                        "title": "Status Strip",
                                        "icon": "ğŸ“Š",
                                        "selector": "#wiz-gh-status-strip",
                                        "content": "Integration health at a glance â€” {{ghEnvAligned}} of {{ghEnvTotal}} environments aligned, {{ghWorkflows}} workflow(s), repo is {{ghVis}}. Green pills are working, gray ones need attention.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“Š Integration Health</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Each pill is one dimension of your GitHub integration:</div><div class=\"state-grid\"><span class=\"state-key\">Authentication</span><span>API access for all operations</span><span class=\"state-key\">Account</span><span>the identity ({{ghUser}}) operations run under</span><span class=\"state-key\">Repository</span><span>{{ghRepo}} is the target for CI/CD, Pages, and environments</span><span class=\"state-key\">Visibility</span><span>{{ghVis}} controls who sees code, logs, and deployments</span><span class=\"state-key\">Branch</span><span>{{ghBranch}} is the CI/CD trigger target and PR merge destination</span><span class=\"state-key\">Environments</span><span>{{ghEnvAligned}} of {{ghEnvTotal}} aligned with Step 1</span><span class=\"state-key\">CODEOWNERS</span><span>PR review automation status</span><span class=\"state-key\">Workflows</span><span>{{ghWorkflows}} Actions pipeline(s) detected</span></div><div class=\"state-text\">Gray pills aren't always blockers â€” missing CODEOWNERS means manual review, not broken CI/CD. But missing environments will stall workflows that use deployment gates.</div></div></div>",
                                        "children": [
                                            {
                                                "id": "gh-pill-auth",
                                                "title": "Authentication",
                                                "icon": "ğŸ”‘",
                                                "selector": "#wiz-gh-pill-auth",
                                                "content": "You're authenticated â€” the control plane has API access to manage {{ghRepo}} on your behalf.",
                                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ“ Authenticated</div><div class=\"state-detail\">Your gh CLI session is active. The control plane can make API calls to GitHub as {{ghUser}} â€” creating environments, pushing secrets, writing CODEOWNERS, querying repository metadata.\n\nThe session persists until you explicitly log out or the OAuth token expires. If you see auth errors later, re-authenticate through the setup panel.</div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "gh-pill-user",
                                                "title": "Account",
                                                "icon": "ğŸ‘¤",
                                                "selector": "#wiz-gh-pill-user",
                                                "content": "Operating as {{ghUser}} â€” environment creation, secrets push, and CODEOWNERS writes all happen under this identity's permissions.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ‘¤ {{ghUser}}</div><div class=\"state-detail\">All GitHub operations happen under {{ghUser}}'s permissions. If {{ghRepo}} is owned by an organization, this account needs the right access level â€” environment creation and secrets management typically require admin or maintain role.\n\nIf operations fail with permission errors, use the ğŸ”“ Logout button in the user card below to switch to an account with the necessary access.</div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "gh-pill-repo",
                                                "title": "Repository",
                                                "icon": "ğŸ“¦",
                                                "selector": "#wiz-gh-pill-repo",
                                                "content": "Linked to {{ghRepo}} â€” your CI/CD workflows, Pages deployments, and environment scoping all reference this repository.",
                                                "variants": [
                                                    {
                                                        "when": {
                                                            "textContains": "no repo"
                                                        },
                                                        "content": "No repository linked. You need a git remote pointing to GitHub â€” set one up in the Git card's remotes section, or create a new repo through ğŸš€ Full Setup.",
                                                        "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">â—‹ No Repository Linked</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">The gh CLI can't find a GitHub repository for this project. This means either:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ No git remote is configured (check the Git card above)</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ The remote points to a non-GitHub host (GitLab, Bitbucket, etc.)</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ The repository doesn't exist on GitHub yet</div><div class=\"state-text\">Without a linked repo, environments can't be created, secrets can't be pushed, and CODEOWNERS has nowhere to live.</div><div class=\"state-text\">Use ğŸš€ Full Setup to create a new repository â€” it handles git remote add, initial push, and visibility settings in one flow.</div></div></div>"
                                                    }
                                                ],
                                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ“¦ {{ghRepo}}</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">This is your project's home on GitHub. The slug is used by:</div><div class=\"state-grid\"><span class=\"state-key\">CI/CD</span><span>Actions workflows trigger on push to this repository</span><span class=\"state-key\">Pages</span><span>deployments publish to GitHub Pages under this repo</span><span class=\"state-key\">Environments</span><span>deployment environments are scoped per-repository</span><span class=\"state-key\">Secrets</span><span>vault keys pushed here are available in Actions</span></div><div class=\"state-text\">The ğŸ“¦ Repository section below has full details â€” visibility, default branch, description, and a direct link to GitHub.</div></div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "gh-pill-vis",
                                                "title": "Visibility",
                                                "icon": "ğŸ‘",
                                                "selector": "#wiz-gh-pill-vis",
                                                "content": "Your repo is {{ghVis}} â€” this affects who can see your code, Actions logs, and Pages deployments.",
                                                "variants": [
                                                    {
                                                        "when": {
                                                            "textContains": "private"
                                                        },
                                                        "content": "{{ghRepo}} is private â€” code, Actions logs, and Pages are restricted to collaborators only.",
                                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ”’ Private Repository</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Only collaborators with explicit access can see {{ghRepo}}:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Source code is not publicly visible</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ GitHub Actions logs are restricted to collaborators</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Pages deployments require authentication (Enterprise) or are disabled</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Fork PRs from outside collaborators are not possible</div><div class=\"state-text\">The vault system from Step 3 protects secrets from commits, but private visibility adds a second layer â€” even if something leaks into the repo, only collaborators see it.</div><div class=\"state-text\">Use ğŸš€ Full Setup to change visibility â€” going public is irreversible for code that's already been seen.</div></div></div>"
                                                    },
                                                    {
                                                        "when": {
                                                            "textContains": "public"
                                                        },
                                                        "content": "{{ghRepo}} is public â€” your code, Actions logs, and Pages deployments are visible to everyone on the internet.",
                                                        "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">ğŸŒ Public Repository</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Anyone on the internet can see {{ghRepo}}:</div><div class=\"state-grid\"><span class=\"state-key\">Source code is fully visible</span><span>no secrets should ever be committed</span><span class=\"state-key\">GitHub Actions logs are public</span><span>workflow outputs are readable by anyone</span><span style=\"grid-column:1/-1;color:var(--text-secondary)\">âœ“ Pages deployments are accessible without authentication</span><span style=\"grid-column:1/-1;color:var(--text-secondary)\">âœ“ Anyone can fork and submit PRs (but fork PRs have limited secrets access)</span></div><div class=\"state-text\">Double-check your .gitignore coverage in the Git card â€” the vault's encrypted .env files and plaintext credentials must be excluded. Step 3's vault system handles this, but verify the Git card's .gitignore pill shows good coverage.</div></div></div>"
                                                    }
                                                ],
                                                "expanded": "",
                                                "children": []
                                            },
                                            {
                                                "id": "gh-pill-branch",
                                                "title": "Default Branch",
                                                "icon": "ğŸŒ¿",
                                                "selector": "#wiz-gh-pill-branch",
                                                "content": "Default branch is {{ghBranch}} â€” PRs merge here, Actions trigger on push here, Pages deploy from here.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸŒ¿ {{ghBranch}}</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">{{ghBranch}} is where everything converges:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ PRs merge into {{ghBranch}}</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ CI/CD workflows trigger on push to {{ghBranch}}</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Pages deployments source from {{ghBranch}}</div><div class=\"state-text\">This should match the branch in your CI/CD card's workflow YAML. If your workflow triggers on 'master' but GitHub's default is 'main', pushes won't fire the pipeline.</div><div class=\"state-text\">Use ğŸš€ Full Setup to change the default branch on GitHub.</div></div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "gh-pill-envs",
                                                "title": "Environments",
                                                "icon": "ğŸŒ",
                                                "selector": "#wiz-gh-pill-envs",
                                                "content": "{{ghEnvAligned}} environment(s) exist on GitHub â€” CI/CD can target them for deployment gating and scoped secrets.",
                                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸŒ {{ghEnvAligned}} Deployment Environment(s)</div><div class=\"state-detail\">These GitHub deployment environments match your Step 1 project config. When a CI/CD workflow uses environment: in a job, GitHub gates the deployment â€” it can require approvals, set wait timers, and scope secrets.\n\nEnvironment-scoped secrets mean your production DB_PASSWORD is only visible to jobs targeting the production environment. Development jobs can't see it â€” that's the separation you built in Step 3.\n\nSee the âš™ï¸ Environments section below for the full alignment breakdown.</div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "gh-pill-envs-missing",
                                                "title": "Missing Environments",
                                                "icon": "âš ï¸",
                                                "selector": "#wiz-gh-pill-envs-missing",
                                                "content": "{{ghEnvMissing}} environment(s) from Step 1 don't exist on GitHub yet â€” CI/CD workflows targeting them will stall at the deployment gate.",
                                                "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš  {{ghEnvMissing}} Environment(s) Missing</div><div class=\"state-detail\">Your project defines {{ghEnvTotal}} environments in Step 1, but {{ghEnvMissing}} haven't been created on GitHub. If your CI/CD workflow uses environment: for those, GitHub can't deploy â€” the workflow stalls waiting for an environment that doesn't exist.\n\nScroll down to the âš™ï¸ Environments section â€” check the missing ones and click ğŸ†• Create. After creation, push scoped secrets through the ğŸ”’ Secrets section so each environment has its own credentials in Actions.</div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "gh-pill-codeowners",
                                                "title": "CODEOWNERS",
                                                "icon": "ğŸ“‹",
                                                "selector": "#wiz-gh-pill-codeowners",
                                                "content": "CODEOWNERS controls automatic PR review assignment â€” who gets notified when files in {{ghRepo}} are changed.",
                                                "variants": [
                                                    {
                                                        "when": {
                                                            "textContains": "CODEOWNERS âœ“"
                                                        },
                                                        "content": "CODEOWNERS is active on {{ghRepo}} â€” GitHub auto-assigns reviewers to PRs based on which files changed.",
                                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Review Automation Active</div><div class=\"state-detail\">Your CODEOWNERS file tells GitHub who should review changes to specific files in {{ghRepo}}. When a PR touches files matching a pattern, the listed owners are automatically added as reviewers.\n\nSee the ğŸ“‹ CODEOWNERS section below for the current rules. The most common pattern is * @owner which catches everything â€” add path-specific patterns for team members who own specific areas of the codebase.</div></div>"
                                                    },
                                                    {
                                                        "when": {
                                                            "textContains": "no CODEOWNERS"
                                                        },
                                                        "content": "No CODEOWNERS on {{ghRepo}} â€” every PR requires manual reviewer selection. Create one in the ğŸ“‹ section below.",
                                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â—‹ No Review Automation</div><div class=\"state-detail\">Without CODEOWNERS, every PR to {{ghRepo}} requires manual reviewer assignment. Works fine for solo projects, but as collaborators join, it's easy to miss adding the right reviewer for infrastructure, docs, or security-sensitive changes.\n\nScroll down to ğŸ“‹ CODEOWNERS to create one â€” the default template assigns {{ghUser}} to all files. Customize with path-specific rules for your team structure.</div></div>"
                                                    }
                                                ],
                                                "expanded": "",
                                                "children": []
                                            },
                                            {
                                                "id": "gh-pill-workflows",
                                                "title": "Workflows",
                                                "icon": "ğŸ”„",
                                                "selector": "#wiz-gh-pill-workflows",
                                                "content": "{{ghWorkflows}} Actions workflow(s) detected in {{ghRepo}} â€” these are your CI/CD pipelines, managed through the CI/CD card.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ”„ {{ghWorkflows}} Workflow(s)</div><div class=\"state-detail\">These are YAML workflow files in .github/workflows/ of {{ghRepo}}. Each one defines a CI/CD pipeline â€” what triggers it, what it builds, what it tests, where it deploys.\n\nWorkflows are configured through the CI/CD integration card. The GitHub card shows the count to confirm the connection is healthy â€” {{ghRepo}} has active pipelines and the gh CLI can query their status.\n\nIf the count seems wrong, hit ğŸ”„ Re-scan in the scan bar above.</div></div>",
                                                "children": []
                                            }
                                        ]
                                    },
                                    {
                                        "id": "gh-user-card",
                                        "title": "Account",
                                        "icon": "ğŸ‘¤",
                                        "selector": "#wiz-gh-user-card",
                                        "content": "Operating as {{ghUser}} â€” all GitHub API operations (environments, secrets, CODEOWNERS, visibility changes) happen under this identity.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ‘¤ {{ghUser}}</div><div class=\"state-detail\">All operations the control plane performs on {{ghRepo}} â€” creating deployment environments, pushing vault secrets, writing CODEOWNERS â€” happen under {{ghUser}}'s permissions.\n\nIf {{ghRepo}} belongs to an organization, {{ghUser}} needs admin or maintain role for environment creation and secrets management.\n\nThe ğŸ”“ Logout button disconnects this account. After logging out, re-scan to get a fresh login prompt. Use this to switch accounts if operations fail due to insufficient permissions.</div></div>",
                                        "children": []
                                    },
                                    {
                                        "id": "gh-repo",
                                        "title": "Repository",
                                        "icon": "ğŸ“¦",
                                        "selector": "#wiz-gh-section-repo",
                                        "content": "{{ghRepo}} is {{ghVis}}, default branch is {{ghBranch}}. This is the repository your CI/CD, Pages, and environment scoping all target.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“¦ {{ghRepo}}</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Your project's home on GitHub:</div><div class=\"state-grid\"><span class=\"state-key\">Visibility</span><span>{{ghVis}}. Controls who sees code, Actions logs, and Pages deployments.</span><span class=\"state-key\">Default branch</span><span>{{ghBranch}}. PRs merge here, Actions trigger here, Pages deploy from here.</span><span class=\"state-key\">Fork status</span><span>fork repos have limited secrets access for outside PRs.</span></div><div class=\"state-text\">The Open â†— link goes directly to {{ghRepo}} on GitHub. Use ğŸš€ Full Setup to change visibility or the default branch.</div></div></div>",
                                        "variants": [
                                            {
                                                "when": {
                                                    "textContains": "ğŸ”’ private"
                                                },
                                                "content": "{{ghRepo}} is private, default branch is {{ghBranch}}. Code, Actions logs, and Pages are restricted to collaborators.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ”’ {{ghRepo}} Â· private</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Only collaborators with explicit access can see {{ghRepo}}:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Source code is not publicly visible</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ GitHub Actions logs are restricted to collaborators</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Pages deployments require Enterprise auth or are disabled</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Fork PRs from outside collaborators are blocked</div><div class=\"state-text\">Default branch is {{ghBranch}} â€” PRs merge there, CI/CD triggers on push there.</div><div class=\"state-text\">The vault from Step 3 protects secrets from commits. Private visibility adds a second layer â€” even if something leaks into the repo, only collaborators see it.</div><div class=\"state-text\">Use ğŸš€ Full Setup to change visibility â€” going public is irreversible for code that's already been seen.</div></div></div>"
                                            },
                                            {
                                                "when": {
                                                    "textContains": "ğŸŒ public"
                                                },
                                                "content": "{{ghRepo}} is public, default branch is {{ghBranch}}. Code, Actions logs, and Pages are visible to everyone on the internet.",
                                                "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">ğŸŒ {{ghRepo}} Â· public</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Anyone on the internet can see {{ghRepo}}:</div><div class=\"state-grid\"><span class=\"state-key\">Source code is fully visible</span><span>no secrets should ever be committed</span><span class=\"state-key\">GitHub Actions logs are public</span><span>workflow outputs readable by anyone</span><span style=\"grid-column:1/-1;color:var(--text-secondary)\">âœ“ Pages deployments are accessible without authentication</span><span style=\"grid-column:1/-1;color:var(--text-secondary)\">âœ“ Anyone can fork and submit PRs (fork PRs have limited secrets access)</span></div><div class=\"state-text\">Default branch is {{ghBranch}} â€” PRs merge there, CI/CD triggers on push there.</div><div class=\"state-text\">Double-check .gitignore coverage in the Git card â€” the vault's encrypted .env files and plaintext credentials must be excluded. Step 3's vault handles this, but verify the Git card's .gitignore pill shows good coverage.</div></div></div>"
                                            }
                                        ],
                                        "children": []
                                    },
                                    {
                                        "id": "gh-envs",
                                        "title": "Environments",
                                        "icon": "âš™ï¸",
                                        "selector": "#wiz-gh-section-envs",
                                        "content": "All {{ghEnvTotal}} environments from Step 1 are on GitHub â€” CI/CD can target every one for deployment gating and scoped secrets.",
                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… {{ghEnvTotal}}/{{ghEnvTotal}} Aligned</div><div class=\"state-detail\">All {{ghEnvTotal}} environments you defined in Step 1 exist as deployment environments on {{ghRepo}}. CI/CD workflows can target every one of them.\n\nWhen a workflow uses environment: production in a job, GitHub gates the deployment â€” it can require approvals, set wait timers, and scope secrets so production credentials are only available to production jobs.\n\nEnvironment-scoped secrets from ğŸ”’ Secrets are properly separated â€” your production DB_PASSWORD is invisible to development jobs.\n\nâ­ marks your default environment from Step 1 â€” the one pre-selected when working with secrets and variables.</div></div>",
                                        "variants": [
                                            {
                                                "when": {
                                                    "textContains": "âœ— missing"
                                                },
                                                "content": "{{ghEnvAligned}} of {{ghEnvTotal}} aligned â€” {{ghEnvMissing}} environment(s) still need to be created on GitHub for CI/CD deployment gating.",
                                                "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš  {{ghEnvMissing}} of {{ghEnvTotal}} Missing</div><div class=\"state-detail\">{{ghEnvMissing}} of your {{ghEnvTotal}} environments from Step 1 don't exist on GitHub yet. CI/CD workflows that reference these with environment: will stall â€” GitHub can't deploy to an environment that doesn't exist.\n\nCheck the boxes next to the missing ones and click ğŸ†• Create. After creation, push scoped secrets through ğŸ”’ Secrets so each environment has its own credentials in Actions.\n\nThis takes seconds and is reversible â€” environments can be deleted from GitHub's repository settings.</div></div>"
                                            }
                                        ],
                                        "children": []
                                    },
                                    {
                                        "id": "gh-codeowners",
                                        "title": "CODEOWNERS",
                                        "icon": "ğŸ“‹",
                                        "selector": "#wiz-gh-section-codeowners",
                                        "content": "CODEOWNERS automates PR review assignment on {{ghRepo}} â€” GitHub reads this file to decide who reviews changes to which files.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“‹ Review Automation</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">The CODEOWNERS file lives at .github/CODEOWNERS in {{ghRepo}} and tells GitHub who to assign as reviewers when a PR changes specific files.</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">Pattern format:</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;font-size:0.75rem\"><span class=\"state-key\">* @owner</span><span>assigns the owner to ALL files (catch-all)</span><span class=\"state-key\">/src/infra/ @platform-team</span><span>scopes to infrastructure</span><span class=\"state-key\">*.md @docs-team</span><span>scopes to documentation</span><span class=\"state-key\">/src/security/ @security @lead</span><span>multiple reviewers</span></div><div class=\"state-text\">Patterns match top-to-bottom, last match wins. The catch-all should be first, with specific overrides below.</div><div class=\"state-text\">This file is committed to your repository â€” it's versioned and reviewable like any other code change.</div></div></div>",
                                        "variants": [
                                            {
                                                "when": {
                                                    "textContains": "(exists)"
                                                },
                                                "content": "CODEOWNERS is active on {{ghRepo}} â€” the preview below shows your current review assignment rules. Every PR gets automatic reviewer selection.",
                                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… CODEOWNERS Active</div><div class=\"state-detail\">The file is live in {{ghRepo}}. Every PR now gets automatic reviewer assignment based on the patterns defined. The preview below shows the current content.\n\nTo update rules, edit the file directly or use ğŸš€ Full Setup which provides an editor. Changes take effect on the next PR â€” existing open PRs don't retroactively get new reviewers.</div></div>"
                                            },
                                            {
                                                "when": {
                                                    "textContains": "(missing)"
                                                },
                                                "content": "No CODEOWNERS on {{ghRepo}} â€” every PR requires manual reviewer selection. Check the box below to create one with {{ghUser}} as the default owner.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“ Create CODEOWNERS</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Without CODEOWNERS, you manually select reviewers for every PR to {{ghRepo}}. The checkbox below generates a default file that assigns {{ghUser}} to all files.</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">Customize the template before applying:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ /docs/ @docs-team</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ /src/infra/ @platform-team</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ *.yml @devops-team</div><div class=\"state-text\">The file is written to .github/CODEOWNERS when you click âœ… Apply. It takes effect on the next PR created.</div></div></div>"
                                            }
                                        ],
                                        "children": []
                                    },
                                    {
                                        "id": "gh-secrets",
                                        "title": "Secrets",
                                        "icon": "ğŸ”’",
                                        "selector": "#wiz-gh-section-secrets",
                                        "content": "Your vault keys from Step 3 need to be on GitHub for Actions to use them. With {{envCount}} environments, each gets its own scoped secrets â€” production keys stay separate from development keys.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ”’ Vault â†’ GitHub Sync</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">The secrets you configured in Step 3's vault are local to your machine. GitHub Actions can't access them until they're pushed to {{ghRepo}}.</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">With {{envCount}} environments, scoping works like this:</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;font-size:0.75rem\"><span style=\"grid-column:1/-1;color:var(--text-secondary)\">âœ“ Each environment gets its own GitHub environment secrets</span><span style=\"grid-column:1/-1;color:var(--text-secondary)\">âœ“ A production DB_PASSWORD is only visible to jobs using environment: production</span><span class=\"state-key\">Development jobs see only development secrets</span><span>no cross-contamination</span></div><div class=\"state-text\">The 'Push now' checkbox triggers a sync of all vault keys when you âœ… Apply. For per-key control â€” choosing which to push, which to skip â€” use the ğŸ” Secrets tab on the dashboard or ğŸš€ Full Setup.</div><div class=\"state-text\">Secrets pushed to GitHub are encrypted at rest and auto-masked in Actions logs.</div></div></div>",
                                        "children": []
                                    },
                                    {
                                        "id": "gh-apply",
                                        "title": "Apply",
                                        "icon": "âœ…",
                                        "selector": "#wiz-apply-int-github",
                                        "content": "Runs all checked actions: create {{ghEnvMissing}} missing environment(s), push vault secrets, write CODEOWNERS â€” in that order.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">âœ… Execution Order</div><div class=\"state-detail\">When you click Apply, the control plane runs each checked action against {{ghRepo}}:\n\n1. Create checked environments on GitHub (so deployment gates work)\n2. Push vault secrets (scoped per-environment if multi-env)\n3. Write CODEOWNERS (so PR review is automated)\n\nThis ordering matters â€” environments are created first so environment-scoped secrets land in the right targets.\n\nAfter all steps complete, re-detection runs and all status pills update. If any step fails, the error shows in a toast.\n\nFor repository creation, visibility changes, and branch management, use ğŸš€ Full Setup instead.</div></div>",
                                        "children": []
                                    },
                                    {
                                        "id": "gh-cancel",
                                        "title": "Cancel",
                                        "icon": "âœ–",
                                        "selector": "#wiz-cancel-int-github",
                                        "content": "Closes the setup panel without applying. No API calls to {{ghRepo}} â€” nothing changes on GitHub.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">âœ– Discard Changes</div><div class=\"state-detail\">Cancel collapses the panel and discards unsaved selections â€” environment checkboxes, CODEOWNERS content, secrets push toggle. No API calls are made to {{ghRepo}}.\n\nReopen anytime with âš™ï¸ Setup â€” checkbox states repopulate from the current detection state, not your previous unsaved selections.</div></div>",
                                        "children": []
                                    }
                                ]
                            }
                        ]
                    },
                    {
                        "id": "pages-card",
                        "title": "Pages",
                        "icon": "ğŸ“„",
                        "selector": "#wiz-int-wrap-int-pages",
                        "content": "Pages is your static site builder â€” documentation sites, landing pages, and content-driven sections built from your project's content folders and deployed through GitHub Pages or other targets.",
                        "variants": [
                            {
                                "when": {
                                    "textContains": "âœ… ready"
                                },
                                "content": "{{pagesSegments}} segment(s) configured and building. Deploy branch is {{pagesBranch}}, {{pagesBuildersAvail}} of {{pagesBuildersTotal}} builders available. Your static sites are operational.",
                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Pages Ready</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Your static site pipeline is healthy:</div><div class=\"state-grid\"><span class=\"state-key\">{{pagesSegments}} segment(s) configured</span><span>each one is a buildable site section</span><span class=\"state-key\">Deploy branch is {{pagesBranch}}</span><span>built output lands there for GitHub Pages</span><span style=\"grid-column:1/-1;color:var(--text-secondary)\">âœ“ {{pagesBuildersAvail}} of {{pagesBuildersTotal}} builders available</span></div><div class=\"state-text\">Segments pull content from source directories, build through their assigned builder (Docusaurus, MkDocs, Hugo, plain HTML), and output to the deploy path.</div><div class=\"state-text\">Full segment management â€” adding, editing, building, deploying â€” is in the Pages tab on the dashboard. This card gives you the overview and quick auto-init for new content folders.</div></div></div>"
                            },
                            {
                                "when": {
                                    "textContains": "âš ï¸ partial"
                                },
                                "content": "Pages is partially configured â€” {{pagesSegments}} segment(s) exist but the pipeline isn't fully operational. Check the sections below for what's missing.",
                                "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš  Partially Configured</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">You have {{pagesSegments}} segment(s) defined but the Pages pipeline isn't fully ready. Common causes:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ A builder required by a segment isn't installed (check ğŸ”¨ Builders below)</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Content source directory is empty or missing</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Deploy branch isn't set for GitHub Pages</div><div class=\"state-text\">Open the sections below to see what needs attention. The Pages tab has full management â€” build logs, preview, and deploy controls.</div></div></div>"
                            },
                            {
                                "when": {
                                    "textContains": "not configured"
                                },
                                "content": "No Pages segments configured yet. If your project has content folders (docs/, content/), the auto-init below can create segments automatically.",
                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â—‹ Not Configured</div><div class=\"state-detail\">Pages isn't set up yet. This means no static sites are being built from your project.\n\nIf you have content folders â€” docs/, content/, site/ â€” they'll appear in the ğŸ“‚ Content Folders section with an auto-init option. The control plane detects the best builder for each folder (Docusaurus for docs with docusaurus.config.js, MkDocs for mkdocs.yml, etc.).\n\nYou can also create segments manually from the Pages tab, choosing any source directory and builder combination.\n\nPages deployment typically goes through GitHub Pages on branch {{pagesBranch}} â€” which links back to your GitHub card's repository configuration.</div></div>"
                            }
                        ],
                        "children": [
                            {
                                "id": "pages-setup",
                                "title": "Setup Panel",
                                "icon": "âš™ï¸",
                                "selector": "#wiz-int-setup-int-pages",
                                "content": "Your Pages dashboard â€” segments, content folders, available builders, and deployment configuration. What you see depends on what the detection scan found in your project.",
                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">âš™ï¸ Pages Configuration</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">The Pages system works in segments â€” each one is an independent static site section:</div><div class=\"state-grid\"><span style=\"grid-column:1/-1;color:var(--text-secondary)\">âœ“ A segment has a source (content directory), a builder (Docusaurus, MkDocs, Hugo, plain), and an output path</span><span class=\"state-key\">Multiple segments combine into one deployed site</span><span>docs + blog + landing page all coexist</span><span style=\"grid-column:1/-1;color:var(--text-secondary)\">âœ“ Each builder is auto-detected from your source structure (docusaurus.config.js â†’ Docusaurus, mkdocs.yml â†’ MkDocs)</span></div><div class=\"state-text\">The setup panel here shows what the detection scan found. For full management â€” adding segments, building, previewing, deploying â€” use the Pages tab on the dashboard.</div></div></div>",
                                "children": [
                                    {
                                        "id": "pages-status-strip",
                                        "title": "Status Strip",
                                        "icon": "ğŸ“Š",
                                        "selector": "#wiz-pages-status-strip",
                                        "content": "Pages health at a glance â€” {{pagesSegments}} segment(s), deploy branch {{pagesBranch}}, {{pagesBuildersAvail}} builders available.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“Š Pages Health</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Each pill is one dimension of your Pages setup:</div><div class=\"state-grid\"><span class=\"state-key\">Status</span><span>overall pipeline health (ready, partial, not configured)</span><span class=\"state-key\">Segments</span><span>{{pagesSegments}} buildable site section(s) defined</span><span class=\"state-key\">.pages/</span><span>the configuration directory exists in your project root</span><span class=\"state-key\">Deploy branch</span><span>{{pagesBranch}} is where built output goes for GitHub Pages</span><span class=\"state-key\">Content folders</span><span>detected directories that could become segments</span></div><div class=\"state-text\">Green status means all segments have valid sources, working builders, and a deploy target. Partial means something's incomplete â€” a missing builder or empty source.</div></div></div>",
                                        "children": [
                                            {
                                                "id": "pages-pill-status",
                                                "title": "Status",
                                                "icon": "ğŸ“‹",
                                                "selector": "#wiz-pages-pill-status",
                                                "content": "Overall Pages pipeline status â€” whether segments are configured and builders are operational.",
                                                "variants": [
                                                    {
                                                        "when": {
                                                            "textContains": "âœ… ready"
                                                        },
                                                        "content": "All {{pagesSegments}} segment(s) are healthy â€” sources exist, builders are available, output paths are configured.",
                                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Pipeline Ready</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Every configured segment has:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ A valid source directory with content</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ An available builder installed on your system</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ An output path for the built site</div><div class=\"state-text\">You can build and preview segments from the Pages tab. Deployment pushes built output to {{pagesBranch}} for GitHub Pages.</div></div></div>"
                                                    },
                                                    {
                                                        "when": {
                                                            "textContains": "âš ï¸ partial"
                                                        },
                                                        "content": "Some segments have issues â€” a builder might be missing or a source directory is empty. Check the sections below.",
                                                        "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš  Partially Ready</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">At least one segment has a problem. Common issues:</div><div class=\"state-grid\"><span class=\"state-key\">Builder not installed</span><span>check ğŸ”¨ Builders section</span><span style=\"grid-column:1/-1;color:var(--text-secondary)\">âœ“ Source directory empty or deleted since last scan</span><span style=\"grid-column:1/-1;color:var(--text-secondary)\">âœ“ Output path conflicts between segments</span></div><div class=\"state-text\">Hit ğŸ”„ Re-scan to refresh detection. The Pages tab shows per-segment build status with detailed error messages.</div></div></div>"
                                                    },
                                                    {
                                                        "when": {
                                                            "textContains": "not configured"
                                                        },
                                                        "content": "No segments exist yet. Content folders below can be auto-initialized, or create segments manually in the Pages tab.",
                                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â—‹ No Segments</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Pages has no configured segments. A segment is required before anything can be built or deployed.</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">Two paths to create one:</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;font-size:0.75rem\"><span style=\"grid-column:1/-1;color:var(--text-secondary)\">âœ“ Auto-init from detected content folders (ğŸ“‚ section below)</span><span class=\"state-key\">Manual creation in the Pages tab</span><span>choose any directory + builder</span></div><div class=\"state-text\">The auto-init option examines each content folder's structure and picks the best builder automatically.</div></div></div>"
                                                    }
                                                ],
                                                "expanded": "",
                                                "children": []
                                            },
                                            {
                                                "id": "pages-pill-segments",
                                                "title": "Segments",
                                                "icon": "ğŸ“‘",
                                                "selector": "#wiz-pages-pill-segments",
                                                "content": "{{pagesSegments}} segment(s) â€” each one is an independent buildable site section with its own source directory and builder.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“‘ {{pagesSegments}} Segment(s)</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Each segment is a self-contained build unit:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Has its own source directory (e.g., docs/, content/blog/)</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Uses a specific builder (Docusaurus, MkDocs, Hugo, plain HTML)</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Outputs to a path within the deployed site</div><div class=\"state-text\">Multiple segments combine into one site â€” you can have docs at /docs, a blog at /blog, and a landing page at / all building independently.</div><div class=\"state-text\">See the ğŸ“‘ Segments section below for the full list with source â†’ output mappings and preview links.</div></div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "pages-pill-pagesdir",
                                                "title": ".pages/ Directory",
                                                "icon": "ğŸ“",
                                                "selector": "#wiz-pages-pill-pagesdir",
                                                "content": "The .pages/ directory holds Pages configuration â€” segment definitions, builder settings, and deploy metadata.",
                                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ“ .pages/ Exists</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Your project has a .pages/ directory at the root. This is where the Pages system stores:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Segment definitions (which directories build into which site sections)</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Builder configuration and overrides</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Deploy metadata (branch, base URL, custom domain)</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Theme and plugin settings per builder</div><div class=\"state-text\">This directory is committed to your repository â€” your Pages configuration is versioned and reproducible across environments.</div></div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "pages-pill-branch",
                                                "title": "Deploy Branch",
                                                "icon": "ğŸŒ¿",
                                                "selector": "#wiz-pages-pill-branch",
                                                "content": "Built site output goes to {{pagesBranch}} â€” GitHub Pages serves from this branch automatically when configured on your repository.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸŒ¿ {{pagesBranch}}</div><div class=\"state-detail\">The deploy branch is where built static site output is committed. GitHub Pages reads from this branch to serve your site.\n\nThe flow:\n1. Build segments locally (or in CI/CD)\n2. Built output is committed to {{pagesBranch}}\n3. GitHub Pages picks it up and serves at your.domain.com or username.github.io/repo\n\nThis links back to your GitHub card â€” {{ghRepo}} needs GitHub Pages enabled in repository settings, pointing at {{pagesBranch}} as the source.\n\nThe CI/CD card's workflow can automate this: build on push to {{ghBranch}}, deploy output to {{pagesBranch}}.</div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "pages-pill-folders",
                                                "title": "Content Folders",
                                                "icon": "ğŸ“‚",
                                                "selector": "#wiz-pages-pill-folders",
                                                "content": "{{pagesFolders}} content folder(s) detected that could become segments â€” auto-init available if you want to build them into your site.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“‚ {{pagesFolders}} Content Folder(s)</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">The detection scan found {{pagesFolders}} directories in your project that contain buildable content (markdown, HTML, RST) but don't have segments yet.</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">Each folder is matched with the best builder:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Has docusaurus.config.js â†’ Docusaurus</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Has mkdocs.yml â†’ MkDocs</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Contains .md files â†’ plain markdown (fallback)</div><div class=\"state-text\">Check the ğŸ“‚ Content Folders section below to auto-initialize segments from these. Apply creates the segment definitions â€” you can preview and build from the Pages tab afterward.</div></div></div>",
                                                "children": []
                                            }
                                        ]
                                    },
                                    {
                                        "id": "pages-segments",
                                        "title": "Segments",
                                        "icon": "ğŸ“‘",
                                        "selector": "#wiz-pages-section-segments",
                                        "content": "{{pagesSegments}} configured segment(s) â€” each row shows the segment name, builder, source â†’ output mapping, and a local preview link.",
                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ“‘ {{pagesSegments}} Active Segment(s)</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">These segments are configured and buildable. Each row shows:</div><div class=\"state-grid\"><span class=\"state-key\">Name</span><span>the segment identifier used in commands and the Pages tab</span><span class=\"state-key\">Builder</span><span>which build tool processes the content (Docusaurus, MkDocs, etc.)</span><span class=\"state-key\">Source â†’ Path</span><span>the content directory and where it appears in the deployed site</span><span class=\"state-key\">ğŸ”—</span><span>opens a local preview of the built segment</span></div><div class=\"state-text\">Segments build independently â€” changing docs doesn't rebuild blog. The Pages tab has build controls, logs, and full preview for each segment.</div><div class=\"state-text\">Deployment pushes all segment outputs to {{pagesBranch}} as a combined site.</div></div></div>",
                                        "children": []
                                    },
                                    {
                                        "id": "pages-folders",
                                        "title": "Content Folders",
                                        "icon": "ğŸ“‚",
                                        "selector": "#wiz-pages-section-folders",
                                        "content": "Detected content directories that can become segments. âœ… means a segment already exists, â¬œ means auto-init is available.",
                                        "variants": [
                                            {
                                                "when": {
                                                    "textContains": "no segment"
                                                },
                                                "content": "{{pagesUninit}} content folder(s) don't have segments yet â€” check the auto-init box and Apply to create them automatically with the best matching builder.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“‚ {{pagesUninit}} Uninitialized</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">{{pagesUninit}} content folder(s) were detected but don't have segments yet. Each one shows:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ The folder name and file count</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ The best-matching builder (detected from config files and content type)</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ A ğŸ’¡ suggestion if the detection has a specific recommendation</div><div class=\"state-text\">The auto-init checkbox at the bottom creates segments for all uninitialized folders using their detected builders. After init, you can build and preview from the Pages tab.</div><div class=\"state-text\">This is the fastest way to get your content building â€” one click creates properly configured segments.</div></div></div>"
                                            }
                                        ],
                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ“‚ All Folders Linked</div><div class=\"state-detail\">Every detected content folder has a corresponding segment. Your project's content directories are fully integrated into the Pages pipeline.\n\nEach folder's content is being built through its assigned builder whenever you trigger a build from the Pages tab or CI/CD workflow.</div></div>",
                                        "children": []
                                    },
                                    {
                                        "id": "pages-builders",
                                        "title": "Builders",
                                        "icon": "ğŸ”¨",
                                        "selector": "#wiz-pages-section-builders",
                                        "content": "{{pagesBuildersAvail}} of {{pagesBuildersTotal}} builders available on your system â€” these are the tools that compile content into static HTML.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ”¨ {{pagesBuildersAvail}}/{{pagesBuildersTotal}} Builders</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Builders are the engines that transform your content into static HTML. Each one handles a different source format:</div><div class=\"state-grid\"><span class=\"state-key\">Docusaurus</span><span>React-based, MDX support, versioned docs, blog</span><span class=\"state-key\">MkDocs</span><span>Python-based, Material theme, simpler configuration</span><span class=\"state-key\">Hugo</span><span>Go-based, extremely fast builds, shortcodes</span><span class=\"state-key\">Plain</span><span>copies HTML/CSS/JS directly, no compilation</span></div><div class=\"state-text\">âœ… means the builder's CLI is installed and ready. â—‹ means it's known but not installed â€” segments using that builder can't build until you install it.</div><div class=\"state-text\">The system tools section at the top of this step shows CLI availability. Missing builders can be installed from there.</div></div></div>",
                                        "children": [
                                            {
                                                "id": "pages-builder-docusaurus",
                                                "title": "Docusaurus",
                                                "icon": "ğŸ¦–",
                                                "selector": "#wiz-pages-builder-docusaurus",
                                                "content": "Docusaurus â€” React-based documentation framework with MDX support. The most feature-rich builder for documentation sites.",
                                                "variants": [
                                                    {
                                                        "when": {
                                                            "textContains": "âœ…"
                                                        },
                                                        "content": "Docusaurus is installed and ready â€” Node.js and npx detected. The most powerful builder for documentation-heavy projects.",
                                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ¦– Docusaurus Â· ready</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Docusaurus is available and can build segments assigned to it.</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">What it gives you:</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;font-size:0.75rem\"><span class=\"state-key\">MDX</span><span>write React components directly in markdown</span><span class=\"state-key\">Versioned docs</span><span>maintain docs across software versions</span><span class=\"state-key\">Blog engine</span><span>built-in blog with RSS and pagination</span><span class=\"state-key\">Search</span><span>Algolia-powered search out of the box</span><span class=\"state-key\">i18n</span><span>built-in internationalization support</span><span class=\"state-key\">Theme system</span><span>fully customizable React-based themes</span></div><div class=\"state-text\">Best for: documentation sites, knowledge bases, multi-version API docs, developer portals.</div><div class=\"state-text\">Requires: Node.js 18+ (detected via npx). Builds are slower than Hugo but the output is a full React SPA with client-side navigation.</div><div class=\"state-text\">This is the default builder when a content folder contains markdown and Node.js is available.</div></div></div>"
                                                    },
                                                    {
                                                        "when": {
                                                            "textContains": "â—‹"
                                                        },
                                                        "content": "Docusaurus requires Node.js 18+ (npx). Install Node.js to use this builder for MDX-enabled documentation sites.",
                                                        "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">ğŸ¦– Docusaurus Â· not available</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Docusaurus can't build because Node.js is missing.</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">To install:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Node.js 18+ from https://nodejs.org</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Or via nvm: nvm install 18</div><div class=\"state-text\">Once Node.js is installed, npx handles Docusaurus initialization and builds automatically â€” no global install needed.</div><div class=\"state-text\">Alternative: MkDocs uses Python instead of Node.js and is simpler to set up, though it has fewer features (no MDX, no React components).</div></div></div>"
                                                    }
                                                ],
                                                "expanded": "",
                                                "children": []
                                            },
                                            {
                                                "id": "pages-builder-mkdocs",
                                                "title": "MkDocs",
                                                "icon": "ğŸ“˜",
                                                "selector": "#wiz-pages-builder-mkdocs",
                                                "content": "MkDocs â€” Python-based documentation generator with Material theme support. Simpler than Docusaurus but very polished.",
                                                "variants": [
                                                    {
                                                        "when": {
                                                            "textContains": "âœ…"
                                                        },
                                                        "content": "MkDocs is installed and ready â€” Python and mkdocs CLI detected. Great for clean, Material-themed documentation.",
                                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ“˜ MkDocs Â· ready</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">MkDocs is available and can build segments assigned to it.</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">What it gives you:</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;font-size:0.75rem\"><span class=\"state-key\">Material theme</span><span>polished, responsive design out of the box</span><span class=\"state-key\">Navigation</span><span>automatic sidebar from directory structure</span><span class=\"state-key\">Search</span><span>built-in lunr.js search, no external service needed</span><span class=\"state-key\">Plugins</span><span>rich ecosystem (mermaid diagrams, code annotations, admonitions)</span><span class=\"state-key\">Fast</span><span>Python-based but builds are quick for typical doc sizes</span></div><div class=\"state-text\">Best for: project documentation, internal wikis, API reference sites, README-style docs.</div><div class=\"state-text\">Requires: Python 3 with pip. Configuration lives in mkdocs.yml.</div><div class=\"state-text\">MkDocs is the fallback when Node.js isn't available but Python is â€” it produces excellent results with less configuration than Docusaurus.</div></div></div>"
                                                    },
                                                    {
                                                        "when": {
                                                            "textContains": "â—‹"
                                                        },
                                                        "content": "MkDocs requires Python 3 and the mkdocs package. Install with: pip install mkdocs mkdocs-material",
                                                        "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">ğŸ“˜ MkDocs Â· not available</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">MkDocs isn't installed. Python is likely available but the mkdocs package is missing.</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">To install:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ pip install mkdocs mkdocs-material</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Or in a venv: python -m pip install mkdocs mkdocs-material</div><div class=\"state-text\">The Material theme is strongly recommended â€” it provides the polished look and responsive layout. Without it, MkDocs uses a basic theme.</div><div class=\"state-text\">Alternative: Docusaurus requires Node.js but is more feature-rich (MDX, versioned docs, React components).</div></div></div>"
                                                    }
                                                ],
                                                "expanded": "",
                                                "children": []
                                            },
                                            {
                                                "id": "pages-builder-hugo",
                                                "title": "Hugo",
                                                "icon": "âš¡",
                                                "selector": "#wiz-pages-builder-hugo",
                                                "content": "Hugo â€” Go-based static site generator. Single binary, no runtime dependencies, extremely fast builds.",
                                                "variants": [
                                                    {
                                                        "when": {
                                                            "textContains": "âœ…"
                                                        },
                                                        "content": "Hugo is installed and ready â€” the hugo binary is available. Fastest builder for large content sites.",
                                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âš¡ Hugo Â· ready</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Hugo is available and can build segments assigned to it.</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">What it gives you:</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;font-size:0.75rem\"><span class=\"state-key\">Speed</span><span>builds thousands of pages in milliseconds (Go compiled binary)</span><span class=\"state-key\">Shortcodes</span><span>reusable content snippets without a framework</span><span class=\"state-key\">Taxonomies</span><span>categories, tags, series out of the box</span><span class=\"state-key\">Multilingual</span><span>built-in i18n with per-language content trees</span><span class=\"state-key\">Themes</span><span>300+ themes available, single-file configuration</span></div><div class=\"state-text\">Best for: blogs, large content sites, multi-language sites, sites where build speed matters.</div><div class=\"state-text\">Requires: hugo binary (no runtime dependencies). Single binary â€” no package manager, no node_modules, no virtual environments.</div><div class=\"state-text\">Hugo is the fastest builder by far but has less flexibility than Docusaurus for custom interactive components.</div></div></div>"
                                                    },
                                                    {
                                                        "when": {
                                                            "textContains": "â—‹"
                                                        },
                                                        "content": "Hugo requires the hugo binary. The control plane can download it to ~/.local/bin/ automatically.",
                                                        "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš¡ Hugo Â· not available</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">The hugo binary isn't installed.</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">To install:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ The control plane can download it automatically (ğŸ”§ Install in the system tools section)</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Or manually: https://gohugo.io/installation/</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Homebrew: brew install hugo</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Snap: snap install hugo</div><div class=\"state-text\">Hugo is a single binary â€” no runtime dependencies. It downloads and runs immediately. No python, no node, no package manager needed.</div><div class=\"state-text\">Alternative: Docusaurus or MkDocs if you already have Node.js or Python installed.</div></div></div>"
                                                    }
                                                ],
                                                "expanded": "",
                                                "children": []
                                            },
                                            {
                                                "id": "pages-builder-sphinx",
                                                "title": "Sphinx",
                                                "icon": "ğŸ“œ",
                                                "selector": "#wiz-pages-builder-sphinx",
                                                "content": "Sphinx â€” Python documentation generator. The standard for Python project docs, supports RST and Markdown via MyST.",
                                                "variants": [
                                                    {
                                                        "when": {
                                                            "textContains": "âœ…"
                                                        },
                                                        "content": "Sphinx is installed and ready â€” Python and sphinx-build detected. The standard choice for Python project documentation.",
                                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ“œ Sphinx Â· ready</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Sphinx is available and can build segments assigned to it.</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">What it gives you:</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;font-size:0.75rem\"><span class=\"state-key\">RST</span><span>reStructuredText, the most expressive plain-text markup</span><span class=\"state-key\">Cross-referencing</span><span>automatic links between docs, API references, glossary terms</span><span class=\"state-key\">API autodoc</span><span>generate docs directly from Python docstrings</span><span class=\"state-key\">Extensions</span><span>hundreds of extensions (intersphinx, napoleon, todo, coverage)</span><span class=\"state-key\">MyST</span><span>Markdown support via myst-parser (write markdown instead of RST)</span></div><div class=\"state-text\">Best for: Python projects, API documentation, academic/technical writing, projects needing cross-references.</div><div class=\"state-text\">Requires: Python 3 with sphinx. Configuration lives in conf.py.</div><div class=\"state-text\">Sphinx is the gold standard for Python projects â€” if your project is Python-heavy with docstrings, autodoc will save you hours of manual documentation.</div></div></div>"
                                                    },
                                                    {
                                                        "when": {
                                                            "textContains": "â—‹"
                                                        },
                                                        "content": "Sphinx requires Python 3 and the sphinx package. Install with: pip install sphinx myst-parser",
                                                        "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">ğŸ“œ Sphinx Â· not available</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Sphinx isn't installed.</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">To install:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ pip install sphinx myst-parser</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ myst-parser enables Markdown alongside RST</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ For the RTD theme: pip install sphinx-rtd-theme</div><div class=\"state-text\">Sphinx is most useful for Python projects with docstrings that need API reference generation. For pure markdown documentation, MkDocs or Docusaurus are simpler.</div><div class=\"state-text\">Alternative: MkDocs for simpler markdown docs, Docusaurus for MDX and React.</div></div></div>"
                                                    }
                                                ],
                                                "expanded": "",
                                                "children": []
                                            },
                                            {
                                                "id": "pages-builder-raw",
                                                "title": "Static Files",
                                                "icon": "ğŸ“‹",
                                                "selector": "#wiz-pages-builder-raw",
                                                "content": "Static Files â€” copies HTML, CSS, and JS directly to the output. No build step, no dependencies. Always available.",
                                                "variants": [
                                                    {
                                                        "when": {
                                                            "textContains": "âœ…"
                                                        },
                                                        "content": "Static Files is always available â€” no build tools needed. Copies your files directly to the deployed site.",
                                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ“‹ Static Files Â· always available</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">The raw/static builder is always ready â€” it requires no external tools.</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">What it does:</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;font-size:0.75rem\"><span style=\"grid-column:1/-1;color:var(--text-secondary)\">âœ“ Copies files as-is from source to output directory</span><span style=\"grid-column:1/-1;color:var(--text-secondary)\">âœ“ No compilation, no transformation, no dependencies</span><span class=\"state-key\">HTML, CSS, JS, images</span><span>anything goes</span></div><div class=\"state-text\">Best for: pre-built sites, hand-crafted HTML, legacy content, assets that don't need processing.</div><div class=\"state-text\">This is the fallback builder when no specialized tool is available or when your content is already built HTML. It's also useful for embedding pre-existing sites as segments alongside Docusaurus or MkDocs segments.</div></div></div>"
                                                    }
                                                ],
                                                "expanded": "",
                                                "children": []
                                            },
                                            {
                                                "id": "pages-builder-custom",
                                                "title": "Custom Build",
                                                "icon": "ğŸ”§",
                                                "selector": "#wiz-pages-builder-custom",
                                                "content": "Custom Build â€” run any shell command as the build step. Full flexibility for non-standard toolchains. Always available.",
                                                "variants": [
                                                    {
                                                        "when": {
                                                            "textContains": "âœ…"
                                                        },
                                                        "content": "Custom Build is always available â€” define any build command for segments that don't fit standard builders.",
                                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ”§ Custom Build Â· always available</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">The custom builder lets you define any shell command as your build step.</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">Use cases:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Gatsby, Astro, Next.js, Eleventy, or any other SSG</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Custom scripts that generate HTML from templates</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Compile-to-HTML workflows (Pandoc, LaTeX â†’ HTML)</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Chained builds that combine multiple tools</div><div class=\"state-text\">Configuration: set the build command, source directory, and output path in the segment config. The command runs from the project root.</div><div class=\"state-text\">This builder exists because the Pages system shouldn't limit you to the built-in options. If your tool can produce HTML output, it works as a custom builder.</div></div></div>"
                                                    }
                                                ],
                                                "expanded": "",
                                                "children": []
                                            }
                                        ]
                                    },
                                    {
                                        "id": "pages-deploy-info",
                                        "title": "Deploy Info",
                                        "icon": "ğŸš€",
                                        "selector": "#wiz-pages-deploy-info",
                                        "content": "Deploy branch is {{pagesBranch}} â€” built output goes here. GitHub Pages on {{ghRepo}} should be configured to serve from this branch.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸš€ Deployment Target</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Your Pages deployment configuration:</div><div class=\"state-grid\"><span class=\"state-key\">Deploy branch</span><span>{{pagesBranch}}. Built segment output is committed here.</span><span class=\"state-key\">GitHub Pages</span><span>{{ghRepo}} needs Pages enabled in repository settings, source set to {{pagesBranch}}.</span></div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">The deployment flow:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">â†’ Build all segments (locally or in CI/CD)</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">â†’ Commit built output to {{pagesBranch}}</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">â†’ GitHub Pages serves the combined site</div><div class=\"state-text\">Base URL matters if your repo is at github.io/repo-name â€” internal links need the prefix. The Pages tab has base URL configuration per segment.</div></div></div>",
                                        "children": []
                                    },
                                    {
                                        "id": "pages-apply",
                                        "title": "Apply",
                                        "icon": "âœ…",
                                        "selector": "#wiz-apply-int-pages",
                                        "content": "Auto-initializes {{pagesUninit}} segment(s) from uninitialized content folders using their best-matching builders.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">âœ… Auto-Initialize Segments</div><div class=\"state-detail\">Apply creates segment definitions for each checked content folder:\n\n1. Reads the content folder's structure and detected builder\n2. Creates a segment in .pages/ with the right configuration\n3. Sets the output path within the deployed site\n\nAfter initialization, segments are ready to build and preview from the Pages tab. No content is modified â€” only .pages/ segment definitions are created.\n\nThis is reversible â€” delete any segment from the Pages tab if the auto-detected configuration isn't right.</div></div>",
                                        "children": []
                                    },
                                    {
                                        "id": "pages-cancel",
                                        "title": "Cancel",
                                        "icon": "âœ–",
                                        "selector": "#wiz-cancel-int-pages",
                                        "content": "Closes the setup panel without creating any segments. No files are modified.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">âœ– Discard</div><div class=\"state-detail\">Cancel collapses the panel without creating segments or modifying any files. The auto-init checkbox state is discarded.\n\nReopen anytime with âš™ï¸ Setup â€” detection results repopulate from the current project state.</div></div>",
                                        "children": []
                                    }
                                ]
                            }
                        ]
                    },
                    {
                        "id": "docker-card",
                        "title": "Docker",
                        "icon": "ğŸ³",
                        "selector": "#wiz-int-wrap-int-docker",
                        "content": "Docker containerization â€” your project's build, run, and deploy pipeline for containers.",
                        "variants": [
                            {
                                "when": {
                                    "textContains": "âœ“ running"
                                },
                                "content": "Docker daemon is running ({{dockerVersion}}) â€” {{dockerDockerfiles}} Dockerfile(s), {{dockerServices}} compose service(s). Your container pipeline is operational.",
                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ³ Docker Â· operational</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Your Docker environment is fully operational:</div><div class=\"state-grid\"><span class=\"state-key\">Daemon</span><span>running (v{{dockerVersion}})</span><span class=\"state-key\">Compose CLI</span><span>{{dockerComposeCli}}</span><span class=\"state-key\">Dockerfiles</span><span>{{dockerDockerfiles}} detected</span><span class=\"state-key\">Compose services</span><span>{{dockerServices}}</span><span class=\"state-key\">.dockerignore</span><span>{{dockerIgnoreRules}} rules</span></div><div class=\"state-text\">Docker turns your project into portable, reproducible containers. Each Dockerfile defines how your code is packaged, and docker-compose orchestrates multi-service stacks (app + database + cache, etc.).</div><div class=\"state-text\">With the daemon running, you have full access to build, run, and manage containers directly from this panel.</div><div class=\"state-text\">Stack detection identified {{dockerStack}} for your project â€” base images, install commands, and entry points are pre-filled accordingly.</div></div></div>"
                            },
                            {
                                "when": {
                                    "textContains": "âš  daemon offline"
                                },
                                "content": "Docker is installed but the daemon isn't running. Start Docker Desktop or the dockerd service to enable container operations.",
                                "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">ğŸ³ Docker Â· daemon offline</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Docker CLI is installed but the daemon process isn't running. Without the daemon:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ âœ— Cannot build images</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ âœ— Cannot start/stop containers</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ âœ— Cannot list running containers or images</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ âœ“ Can still generate Dockerfiles and compose files</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ âœ“ Can still analyze existing Docker configuration</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">To fix:</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;font-size:0.75rem\"><span class=\"state-key\">Docker Desktop</span><span>open the application, it starts the daemon automatically</span><span class=\"state-key\">Linux service</span><span>sudo systemctl start docker</span><span class=\"state-key\">Manual</span><span>sudo dockerd (foreground)</span></div><div class=\"state-text\">Once the daemon is running, refresh this page to unlock the full operations panel (Start, Stop, Build, Logs, etc.).</div></div></div>"
                            },
                            {
                                "when": {
                                    "textContains": "Docker containerization"
                                },
                                "content": "Docker CLI is not installed. Install Docker to enable container-based builds and deployments for your project.",
                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ³ Docker Â· not installed</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Docker is not detected on this system. Without Docker:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Cannot build container images</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Cannot run services locally in containers</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Cannot use docker-compose for multi-service stacks</div><div class=\"state-text\">The control plane can still generate Dockerfiles and compose files â€” they'll be ready when Docker is installed.</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">To install:</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;font-size:0.75rem\"><span class=\"state-key\">Docker Desktop</span><span>https://docs.docker.com/desktop/ (Mac/Windows/Linux)</span><span class=\"state-key\">Docker Engine</span><span>https://docs.docker.com/engine/install/ (Linux servers)</span><span class=\"state-key\">Package manager</span><span>apt install docker.io or brew install docker</span></div><div class=\"state-text\">Docker is optional for development but essential for CI/CD pipelines and production deployments. If your project uses GitHub Actions, the CI/CD integration can build containers without a local Docker install.</div></div></div>"
                            }
                        ],
                        "expanded": "",
                        "children": [
                            {
                                "id": "docker-setup",
                                "title": "Docker Setup",
                                "icon": "âš™ï¸",
                                "selector": "#wiz-int-setup-int-docker",
                                "content": "Docker integration panel â€” daemon status, Dockerfile analysis, compose services, live operations, and config generation.",
                                "expanded": "",
                                "children": [
                                    {
                                        "id": "docker-status-strip",
                                        "title": "Status Strip",
                                        "icon": "ğŸ“Š",
                                        "selector": "#wiz-docker-status-strip",
                                        "content": "Quick glance at your Docker environment: daemon {{dockerDaemon}}, compose CLI {{dockerComposeCli}}, {{dockerDockerfiles}} Dockerfile(s), {{dockerServices}} service(s), {{dockerIgnoreRules}} ignore rules.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“Š Docker Status Overview</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Each pill shows the state of a Docker component. Green (âœ“) means present and operational. Grey (â—‹ or âœ—) means missing or unavailable.</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">The five components:</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;font-size:0.75rem\"><span class=\"state-key\">Daemon</span><span>Docker engine process (required for all operations)</span><span class=\"state-key\">Compose CLI</span><span>docker compose subcommand (required for multi-service orchestration)</span><span class=\"state-key\">Dockerfiles</span><span>build recipes for your container images</span><span class=\"state-key\">Compose file</span><span>service definitions, networks, volumes</span><span class=\"state-key\">.dockerignore</span><span>build context exclusion rules (like .gitignore for Docker)</span></div><div class=\"state-text\">Hover each pill for detailed explanations. All five green means your container pipeline is fully operational.</div></div></div>",
                                        "children": [
                                            {
                                                "id": "docker-pill-daemon",
                                                "title": "Daemon",
                                                "icon": "ğŸŸ¢",
                                                "selector": "#wiz-docker-pill-daemon",
                                                "content": "Docker daemon â€” the background process that builds images and runs containers.",
                                                "variants": [
                                                    {
                                                        "when": {
                                                            "textContains": "âœ“"
                                                        },
                                                        "content": "Docker daemon is running (v{{dockerVersion}}) â€” all container operations are available.",
                                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸŸ¢ Daemon Â· running</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">The Docker daemon (dockerd) is active and responding. Version: {{dockerVersion}}.</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">This means you can:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Build images from Dockerfiles</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Start/stop containers</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Pull/push images from registries</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ View running containers and resource usage</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Stream container logs</div><div class=\"state-text\">The daemon communicates via the Docker socket (/var/run/docker.sock). All buttons in the Operations section call the daemon through the Docker CLI.</div><div class=\"state-text\">If you're running Docker Desktop, the daemon lifecycle is managed by the application. On Linux, it's typically a systemd service.</div></div></div>"
                                                    },
                                                    {
                                                        "when": {
                                                            "textContains": "âœ—"
                                                        },
                                                        "content": "Docker daemon is not running â€” start Docker Desktop or the dockerd service to enable container operations.",
                                                        "expanded": "<div class=\"assistant-state-card state-error\"><div class=\"state-label\">ğŸ”´ Daemon Â· offline</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">The Docker daemon is not responding. Without it, no container operations work.</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">To start the daemon:</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;font-size:0.75rem\"><span class=\"state-key\">Docker Desktop</span><span>open the application</span><span class=\"state-key\">Linux</span><span>sudo systemctl start docker</span><span class=\"state-key\">Manual</span><span>sudo dockerd</span></div><div class=\"state-text\">Note: You can still generate Dockerfiles and compose files while the daemon is offline. They'll work as soon as the daemon starts.</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">If Docker is installed but the daemon fails to start, check:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Disk space (Docker needs space for images/layers)</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Permissions (your user must be in the 'docker' group on Linux)</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Conflicting services (only one daemon can bind the socket)</div></div></div>"
                                                    }
                                                ],
                                                "expanded": "",
                                                "children": []
                                            },
                                            {
                                                "id": "docker-pill-compose-cli",
                                                "title": "Compose CLI",
                                                "icon": "ğŸ“‹",
                                                "selector": "#wiz-docker-pill-compose-cli",
                                                "content": "Docker Compose CLI â€” the orchestration tool for multi-container applications.",
                                                "variants": [
                                                    {
                                                        "when": {
                                                            "textContains": "âœ“"
                                                        },
                                                        "content": "Compose CLI is available â€” you can orchestrate multi-service stacks with docker compose up/down/build.",
                                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ“‹ Compose CLI Â· available</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">docker compose (v2) is available as a Docker CLI plugin.</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">This enables:</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;font-size:0.75rem\"><span class=\"state-key\">docker compose up</span><span>start all services defined in compose file</span><span class=\"state-key\">docker compose down</span><span>stop and remove containers</span><span class=\"state-key\">docker compose build</span><span>build images for services with 'build:' config</span><span class=\"state-key\">docker compose logs</span><span>aggregate logs from all services</span><span class=\"state-key\">docker compose ps</span><span>show running service status</span></div><div class=\"state-text\">Compose v2 is the modern replacement for the standalone docker-compose binary. It's built into Docker Desktop and available as a CLI plugin on Linux.</div><div class=\"state-text\">The Operations section below uses compose commands for Start/Stop/Build/Logs. Without compose, only individual container operations are available.</div></div></div>"
                                                    },
                                                    {
                                                        "when": {
                                                            "textContains": "â—‹"
                                                        },
                                                        "content": "Compose CLI is not available â€” install it to unlock multi-service orchestration (Start/Stop/Build controls).",
                                                        "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">ğŸ“‹ Compose CLI Â· missing</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">The docker compose plugin is not installed. Without it:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ âœ— Cannot use Start/Stop/Build/Logs buttons in Operations</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ âœ— Cannot orchestrate multi-service stacks</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ âœ“ Can still build individual images with docker build</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ âœ“ Can still generate compose files (ready when compose is installed)</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">To install:</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;font-size:0.75rem\"><span class=\"state-key\">Docker Desktop</span><span>includes compose automatically</span><span class=\"state-key\">Linux plugin</span><span>sudo apt install docker-compose-plugin</span><span class=\"state-key\">Manual</span><span>https://docs.docker.com/compose/install/</span></div><div class=\"state-text\">Compose is essential for projects with multiple services (app + database + cache). For single-service projects, you can use docker build and docker run directly.</div></div></div>"
                                                    }
                                                ],
                                                "expanded": "",
                                                "children": []
                                            },
                                            {
                                                "id": "docker-pill-dockerfile",
                                                "title": "Dockerfiles",
                                                "icon": "ğŸ“„",
                                                "selector": "#wiz-docker-pill-dockerfile",
                                                "content": "Dockerfiles â€” build recipes that define how your code is packaged into container images.",
                                                "variants": [
                                                    {
                                                        "when": {
                                                            "textContains": "âœ“"
                                                        },
                                                        "content": "{{dockerDockerfiles}} Dockerfile(s) detected â€” your project has container build recipes. See the Dockerfiles section below for analysis.",
                                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ“„ {{dockerDockerfiles}} Dockerfile(s) detected</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Your project has {{dockerDockerfiles}} Dockerfile(s). Each one defines how to build a container image:</div><div class=\"state-grid\"><span class=\"state-key\">FROM</span><span>base image (OS + runtime)</span><span class=\"state-key\">COPY/ADD</span><span>bring your source code in</span><span class=\"state-key\">RUN</span><span>install dependencies, compile</span><span class=\"state-key\">EXPOSE</span><span>declare network ports</span><span class=\"state-key\">CMD/ENTRYPOINT</span><span>what runs when the container starts</span></div><div class=\"state-text\">The Dockerfiles section below shows a breakdown of each file: base images, multi-stage builds, exposed ports, and any warnings.</div><div class=\"state-text\">If you have multiple Dockerfiles, each typically builds a different service or uses a different strategy (e.g., Dockerfile for production, Dockerfile.dev for development).</div><div class=\"state-text\">The 'ğŸ“ Regenerate Basic Config' section can overwrite these with stack-aware templates, or use 'ğŸš€ Full Docker Setup' for per-module Dockerfiles.</div></div></div>"
                                                    },
                                                    {
                                                        "when": {
                                                            "textContains": "â—‹"
                                                        },
                                                        "content": "No Dockerfile found â€” use 'ğŸ“ Generate Basic Config' below to create one from your detected stack ({{dockerStack}}).",
                                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“„ No Dockerfile</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">No Dockerfile was found in your project root or subdirectories.</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">A Dockerfile is required to build container images. Without it:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ docker build won't work</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ CI/CD pipelines can't build container images</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Container registries have nothing to receive</div><div class=\"state-text\">Two options to create one:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">â†’ 'ğŸ“ Generate Basic Config' â€” creates a single-template Dockerfile based on your detected stack ({{dockerStack}}). Pre-filled with the right base image, install command, and entry point.</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">â†’ 'ğŸš€ Full Docker Setup' â€” opens a multi-step wizard for per-module Dockerfiles, infrastructure services, vault-aware env vars, and health checks.</div><div class=\"state-text\">For most single-service projects, Basic Config is sufficient. Use Full Setup if you have multiple modules or need infrastructure services (databases, caches).</div></div></div>"
                                                    }
                                                ],
                                                "expanded": "",
                                                "children": []
                                            },
                                            {
                                                "id": "docker-pill-composefile",
                                                "title": "Compose File",
                                                "icon": "ğŸ“¦",
                                                "selector": "#wiz-docker-pill-composefile",
                                                "content": "Compose file â€” defines multi-service stacks with networking, volumes, and dependencies.",
                                                "variants": [
                                                    {
                                                        "when": {
                                                            "textContains": "âœ“"
                                                        },
                                                        "content": "Compose file detected with {{dockerServices}} service(s) â€” see the Compose Services section below for the full service map.",
                                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ“¦ Compose Â· {{dockerServices}} service(s)</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Your compose file defines {{dockerServices}} service(s). Each service is a container with its own image, ports, volumes, and environment.</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">The compose file orchestrates:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Service dependencies (web depends on database)</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Network isolation (services talk through named networks)</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Volume mounts (persistent data, live code reload)</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Environment variables (config per service)</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Health checks (readiness probes)</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Resource limits (CPU, memory)</div><div class=\"state-text\">The Compose Services section below shows each service's image, ports, volumes, and dependencies.</div><div class=\"state-text\">With the daemon running and compose CLI available, the Operations section gives you Start/Stop/Build/Logs controls for the entire stack.</div></div></div>"
                                                    },
                                                    {
                                                        "when": {
                                                            "textContains": "â—‹"
                                                        },
                                                        "content": "No compose file â€” generate one alongside your Dockerfile to enable multi-service orchestration.",
                                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“¦ No compose file</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">No docker-compose.yml or compose.yml was found.</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">Without a compose file:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ âœ— Start/Stop/Build/Logs buttons are unavailable</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ âœ— No multi-service orchestration</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ âœ“ Can still build and run individual containers manually</div><div class=\"state-text\">A compose file is worth creating even for single-service projects â€” it documents your runtime configuration (ports, env vars, volumes) in a reproducible file.</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">To create one:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Check 'â˜ Also generate docker-compose.yml' in the Basic Config section, or</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Use 'ğŸš€ Full Docker Setup' for per-module services with infrastructure</div><div class=\"state-text\">The generated compose file will include your service with the right ports, volumes, and restart policy based on your stack.</div></div></div>"
                                                    }
                                                ],
                                                "expanded": "",
                                                "children": []
                                            },
                                            {
                                                "id": "docker-pill-dockerignore",
                                                "title": ".dockerignore",
                                                "icon": "ğŸš«",
                                                "selector": "#wiz-docker-pill-dockerignore",
                                                "content": ".dockerignore â€” controls which files are excluded from the Docker build context.",
                                                "variants": [
                                                    {
                                                        "when": {
                                                            "textContains": "âœ“"
                                                        },
                                                        "content": ".dockerignore is present with {{dockerIgnoreRules}} rules â€” build context is filtered to avoid sending unnecessary files to the daemon.",
                                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸš« .dockerignore Â· {{dockerIgnoreRules}} rules</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Your .dockerignore file filters the build context â€” {{dockerIgnoreRules}} rules prevent unnecessary files from being sent to the Docker daemon during builds.</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">Why this matters:</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;font-size:0.75rem\"><span class=\"state-key\">Build speed</span><span>smaller context = faster COPY operations</span><span class=\"state-key\">Image size</span><span>prevents bloating images with dev files, node_modules, .git, etc.</span><span class=\"state-key\">Security</span><span>keeps secrets, env files, and credentials out of images</span></div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">Common patterns to include:</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;font-size:0.75rem\"><span class=\"state-key\">.git/</span><span>version history (not needed in images)</span><span class=\"state-key\">node_modules/</span><span>reinstalled during build</span><span class=\"state-key\">__pycache__/</span><span>Python bytecode</span><span class=\"state-key\">.env</span><span>local environment secrets</span><span class=\"state-key\">*.log</span><span>runtime logs</span></div><div class=\"state-text\">The .dockerignore file works like .gitignore â€” patterns match files relative to the build context root.</div><div class=\"state-text\">'ğŸš€ Full Docker Setup' can generate a comprehensive .dockerignore tailored to your stack.</div></div></div>"
                                                    },
                                                    {
                                                        "when": {
                                                            "textContains": "â—‹"
                                                        },
                                                        "content": "No .dockerignore â€” all project files are sent to the daemon during builds. This slows builds and may leak secrets into images.",
                                                        "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">ğŸš« No .dockerignore</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Without a .dockerignore file, docker build sends your entire project directory to the daemon as build context. This causes:</div><div class=\"state-grid\"><span class=\"state-key\">Slow builds</span><span>large directories (node_modules, .git, media) are transferred every build</span><span class=\"state-key\">Bloated images</span><span>COPY . . brings in everything, increasing image size</span><span class=\"state-key\">Security risk</span><span>.env files, secrets, or credentials may end up in image layers</span></div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">To create one:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ 'ğŸš€ Full Docker Setup' generates a .dockerignore tailored to your stack</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Or create one manually with at minimum: .git, node_modules, __pycache__, .env, *.log</div><div class=\"state-text\">A good .dockerignore can reduce build context from hundreds of MB to just your source code â€” making builds 10-100x faster for large projects.</div></div></div>"
                                                    }
                                                ],
                                                "expanded": "",
                                                "children": []
                                            }
                                        ]
                                    },
                                    {
                                        "id": "docker-section-dockerfiles",
                                        "title": "Dockerfiles",
                                        "icon": "ğŸ“„",
                                        "selector": "#wiz-docker-section-dockerfiles",
                                        "content": "Dockerfile analysis â€” {{dockerDockerfiles}} Dockerfile(s) found. Each is broken down by runtime, version, variant, stages, and exposed ports.",
                                        "expanded": "<div class=\"assistant-state-card state-info\" style=\"margin-bottom:0.5rem\"><div class=\"state-label\">ğŸ“„ Dockerfile Analysis Â· {{dockerDockerfiles}} file(s)</div><div class=\"state-detail\" class=\"state-wrap\">Hover each Dockerfile below for per-file breakdown. General guidance:</div></div><div class=\"assistant-state-card state-info\" style=\"margin-top:0.6rem;margin-bottom:0.4rem\"><div class=\"state-label\">ğŸ§© Image Components</div><div class=\"state-detail\" class=\"state-wrap\"><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;margin-top:0.3rem;font-size:0.75rem\"><span style=\"font-weight:600;color:var(--accent)\">ğŸ”§ Runtime</span><span>Language or service â€” Python, Node.js, Go, Redisâ€¦</span><span class=\"state-key\">ğŸ“Œ Version</span><span>Pinned release tag â€” 3.12, 20, 1.22, 16â€¦</span><span style=\"font-weight:600;color:hsla(140,60%,55%,1)\">ğŸ“¦ Variant</span><span>OS/flavor suffix â€” controls image size and compatibility</span></div></div></div><div class=\"assistant-state-card state-info\" style=\"margin-bottom:0.4rem\"><div class=\"state-label\">ğŸ“¦ Variant Guide</div><div class=\"state-detail\" class=\"state-wrap\"><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.25rem 0.4rem;margin-top:0.3rem;font-size:0.73rem\"><code style=\"font-size:0.7rem;padding:0.05rem 0.3rem;border-radius:3px;background:hsla(140,60%,40%,0.1);color:hsla(140,60%,55%,1)\">slim</code><span>~150MB Â· Debian minimal Â· all native extensions work Â· <strong>recommended default</strong></span><code style=\"font-size:0.7rem;padding:0.05rem 0.3rem;border-radius:3px;background:hsla(210,60%,50%,0.1);color:hsla(210,60%,60%,1)\">alpine</code><span>~50MB Â· smallest Â· uses musl libc Â· some C extensions may fail</span><code style=\"font-size:0.7rem;padding:0.05rem 0.3rem;border-radius:3px;background:hsla(40,80%,50%,0.1);color:hsla(40,80%,55%,1)\">bookworm</code><span>~400MB+ Â· full Debian 12 Â· every system library Â· use as fallback</span><code style=\"font-size:0.7rem;padding:0.05rem 0.3rem;border-radius:3px;background:hsla(40,80%,50%,0.1);color:hsla(40,80%,55%,1)\">bullseye</code><span>~400MB+ Â· full Debian 11 Â· older stable Â· consider upgrading</span></div></div></div><div class=\"assistant-state-card state-success\" style=\"margin-bottom:0.4rem\"><div class=\"state-label\">âš¡ Multi-Stage Builds</div><div class=\"state-detail\" style=\"white-space:normal;font-size:0.73rem\"><div style=\"display:flex;gap:0.3rem;align-items:center;margin:0.3rem 0\"><span style=\"padding:0.15rem 0.35rem;border-radius:4px;background:hsla(210,60%,50%,0.1);color:hsla(210,60%,60%,1);font-size:0.7rem;font-weight:600\">Stage 1 Â· builder</span><span style=\"color:var(--text-muted)\">â†’</span><span style=\"padding:0.15rem 0.35rem;border-radius:4px;background:hsla(140,60%,40%,0.1);color:hsla(140,60%,55%,1);font-size:0.7rem;font-weight:600\">Stage 2 Â· runtime</span></div>Builder stage has full toolchain (compilers, dev headers). Runtime stage copies only built artifacts into a minimal base. Final images can be <strong>10-100x smaller</strong>.</div></div><div class=\"assistant-state-card state-info\"><div class=\"state-label\">âœ… Best Practices</div><div class=\"state-detail\" style=\"white-space:normal;font-size:0.73rem\"><div style=\"margin-top:0.2rem\"><div style=\"margin-bottom:0.15rem\"><span style=\"color:hsla(140,60%,55%,1);font-weight:600\">âœ“</span> Pin versions â€” <code style=\"font-size:0.68rem\">python:3.12-slim</code> not <code style=\"font-size:0.68rem;text-decoration:line-through;opacity:0.6\">python:latest</code></div><div style=\"margin-bottom:0.15rem\"><span style=\"color:hsla(140,60%,55%,1);font-weight:600\">âœ“</span> Match your local dev environment version</div><div><span style=\"color:hsla(140,60%,55%,1);font-weight:600\">âœ“</span> Prefer <strong>slim â†’ alpine â†’ full</strong> (in order of compatibility risk)</div></div></div></div>",
                                        "dynamic": true,
                                        "childTemplate": {
                                            "title": "ğŸ“„ {{name}}",
                                            "content": "Dockerfile at {{name}} â€” defines how this module is containerized. Hover to see its base images, build stages, and exposed ports.",
                                            "selector": "[id^=\"wiz-docker-df-\"]",
                                            "nameSelector": "code"
                                        },
                                        "children": []
                                    },
                                    {
                                        "id": "docker-section-compose-svcs",
                                        "title": "Compose Services",
                                        "icon": "ğŸ“‹",
                                        "selector": "#wiz-docker-section-compose-svcs",
                                        "content": "Compose service map â€” {{dockerServices}} service(s) with parsed image breakdown, ports, volumes, and topology classification.",
                                        "expanded": "<div class=\"assistant-state-card state-info\" style=\"margin-bottom:0.5rem\"><div class=\"state-label\">ğŸ“‹ Compose Services Â· {{dockerServices}} service(s)</div><div class=\"state-detail\" class=\"state-wrap\">Hover each service below for per-service breakdown. General guidance:</div></div><div class=\"assistant-state-card state-info\" style=\"margin-top:0.6rem;margin-bottom:0.4rem\"><div class=\"state-label\">ğŸ· Service Roles</div><div class=\"state-detail\" class=\"state-wrap\"><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.25rem 0.4rem;margin-top:0.3rem;font-size:0.73rem\"><span style=\"padding:0.1rem 0.3rem;border-radius:4px;background:hsla(140,60%,40%,0.1);color:hsla(140,60%,55%,1);font-size:0.68rem;font-weight:600\">ğŸš€ Application</span><span>Builds from Dockerfile â€” your actual code</span><span style=\"padding:0.1rem 0.3rem;border-radius:4px;background:hsla(210,60%,50%,0.1);color:hsla(210,60%,60%,1);font-size:0.68rem;font-weight:600\">ğŸ—„ Database</span><span>PostgreSQL, MySQL, MongoDB â€” persistent storage</span><span style=\"padding:0.1rem 0.3rem;border-radius:4px;background:hsla(210,60%,50%,0.1);color:hsla(210,60%,60%,1);font-size:0.68rem;font-weight:600\">âš¡ Cache</span><span>Redis, Memcached â€” fast key-value stores</span><span style=\"padding:0.1rem 0.3rem;border-radius:4px;background:hsla(210,60%,50%,0.1);color:hsla(210,60%,60%,1);font-size:0.68rem;font-weight:600\">ğŸŒ Proxy</span><span>Nginx, Apache â€” reverse proxy / static files</span><span style=\"padding:0.1rem 0.3rem;border-radius:4px;background:hsla(210,60%,50%,0.1);color:hsla(210,60%,60%,1);font-size:0.68rem;font-weight:600\">ğŸ“¨ Queue</span><span>RabbitMQ, Kafka â€” async message processing</span></div></div></div><div class=\"assistant-state-card state-info\" style=\"margin-bottom:0.4rem\"><div class=\"state-label\">ğŸ§© Image Breakdown</div><div class=\"state-detail\" style=\"white-space:normal;font-size:0.73rem\"><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;margin-top:0.3rem\"><span style=\"font-weight:600;color:var(--accent)\">ğŸ”§ Runtime</span><span>What the service IS â€” PostgreSQL, Redis, Nginx</span><span class=\"state-key\">ğŸ“Œ Version</span><span>Which release â€” 16, 7.2, 1.25</span><span style=\"font-weight:600;color:hsla(140,60%,55%,1)\">ğŸ“¦ Variant</span><span>OS base â€” alpine = small, bookworm = full Debian</span></div><div style=\"margin-top:0.35rem;padding:0.25rem 0.4rem;border-radius:4px;background:hsla(210,60%,50%,0.06);font-size:0.7rem;color:var(--text-muted)\">Services using <strong>(build)</strong> compile from a local Dockerfile â€” see Dockerfile Analysis above.</div></div></div><div class=\"assistant-state-card state-info\" style=\"margin-bottom:0.4rem\"><div class=\"state-label\">ğŸ”Œ Port Mappings</div><div class=\"state-detail\" style=\"white-space:normal;font-size:0.73rem\"><div style=\"margin-top:0.2rem\"><span style=\"font-family:monospace;padding:0.1rem 0.3rem;border-radius:3px;background:var(--bg-primary);font-size:0.7rem\">host:container</span> â€” e.g. <span style=\"font-family:monospace;font-size:0.7rem\">5432:5432</span> means database at <span style=\"font-family:monospace;font-size:0.7rem\">localhost:5432</span></div><div style=\"margin-top:0.2rem;color:hsla(40,80%,55%,1);font-size:0.7rem\">âš  If two services map the same host port â†’ port conflict on start</div></div></div><div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ”— Dependencies</div><div class=\"state-detail\" style=\"white-space:normal;font-size:0.73rem\"><div style=\"margin-top:0.2rem\"><code style=\"font-size:0.7rem\">depends_on</code> controls startup order. Docker starts dependencies first but <strong>doesn't wait for readiness</strong> â€” only 'started'.</div><div style=\"margin-top:0.15rem;color:hsla(140,60%,55%,1);font-size:0.7rem\">âœ“ Use healthchecks for true readiness gating</div></div></div>",
                                        "dynamic": true,
                                        "childTemplate": {
                                            "title": "ğŸ“‹ {{name}}",
                                            "content": "Compose service {{name}} â€” hover for image breakdown, role classification, ports, volumes, and dependencies.",
                                            "selector": "[id^=\"wiz-docker-svc-\"]",
                                            "nameSelector": "strong"
                                        },
                                        "children": []
                                    },
                                    {
                                        "id": "docker-live-panel",
                                        "title": "Live Panel",
                                        "icon": "ğŸ”",
                                        "selector": "#wiz-docker-live",
                                        "content": "Live Docker inspection â€” view running containers, cached images, and compose status in real time.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ” Live Docker Panel</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">This panel queries the Docker daemon in real time. Click a button to fetch and display current state:</div><div class=\"state-grid\"><span class=\"state-key\">Containers</span><span>all running and stopped containers with their status, ports, and names</span><span class=\"state-key\">Images</span><span>locally cached images with tags, sizes, and creation dates</span><span class=\"state-key\">Compose</span><span>docker compose ps output showing service status for the current project</span></div><div class=\"state-text\">The data is fetched fresh each time you click â€” it reflects the actual state of Docker on your machine, not cached detection data.</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">Useful for:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Checking if your services are actually running after Start</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Finding leftover containers from previous sessions</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Seeing which images are cached (avoids re-pulling)</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Debugging port conflicts (another container using the same port)</div></div></div>",
                                        "children": [
                                            {
                                                "id": "docker-btn-containers",
                                                "title": "Containers",
                                                "icon": "ğŸ“¦",
                                                "selector": "#wiz-docker-btn-containers",
                                                "content": "List all Docker containers â€” running and stopped â€” with their status, ports, and names.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“¦ List Containers</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Runs docker ps -a and displays all containers on this machine.</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">Each row shows:</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;font-size:0.75rem\"><span class=\"state-key\">Container ID</span><span>short hash identifier</span><span class=\"state-key\">Image</span><span>what image the container was created from</span><span class=\"state-key\">Status</span><span>Up (running), Exited (stopped), Created (never started)</span><span class=\"state-key\">Ports</span><span>mapped host:container ports</span><span class=\"state-key\">Names</span><span>container name (auto-generated or from compose)</span></div><div class=\"state-text\">Containers from your compose file will have names prefixed with the project directory name.</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">Common situations:</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;font-size:0.75rem\"><span class=\"state-key\">'Exited (0)'</span><span>stopped cleanly</span><span class=\"state-key\">'Exited (1)'</span><span>crashed, check logs</span><span class=\"state-key\">'Up X minutes'</span><span>running normally</span><span class=\"state-key\">Multiple containers on same port</span><span>port conflict, stop one first</span></div></div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "docker-btn-images",
                                                "title": "Images",
                                                "icon": "ğŸ–¼",
                                                "selector": "#wiz-docker-btn-images",
                                                "content": "List locally cached Docker images with their tags, sizes, and ages.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ–¼ List Images</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Runs docker images and shows all locally cached images.</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">Each row shows:</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;font-size:0.75rem\"><span class=\"state-key\">Repository</span><span>image name (e.g., python, postgres, your-project)</span><span class=\"state-key\">Tag</span><span>version tag (e.g., 3.12-slim, 16-alpine, latest)</span><span class=\"state-key\">Size</span><span>compressed size on disk</span><span class=\"state-key\">Created</span><span>when the image was built or pulled</span></div><div class=\"state-text\">Images are cached layers â€” pulling the same image twice is instant. Building with docker compose build creates images tagged with your service names.</div><div class=\"state-text\">Dangling images (\\u003cnone\\u003e:\\u003cnone\\u003e) are leftover layers from rebuilds. Use ğŸ§¹ Prune in Operations to clean them up and reclaim disk space.</div></div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "docker-btn-compose-live",
                                                "title": "Compose Status",
                                                "icon": "ğŸ“‹",
                                                "selector": "#wiz-docker-btn-compose-live",
                                                "content": "Show docker compose ps â€” the status of all services defined in your compose file.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“‹ Compose Status</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Runs docker compose ps for the current project and shows which services are running.</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">Each row shows:</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;font-size:0.75rem\"><span class=\"state-key\">Service name</span><span>matches the key in your compose file</span><span class=\"state-key\">State</span><span>running, exited, restarting, or created</span><span class=\"state-key\">Ports</span><span>mapped ports for that service</span></div><div class=\"state-text\">This only shows containers managed by compose for this project â€” not containers from other projects or manually started ones.</div><div class=\"state-text\">If a service shows 'restarting', it's likely crash-looping. Check ğŸ“œ Logs to see the error.</div><div class=\"state-text\">If no services appear, the compose stack hasn't been started yet â€” use â–¶ Start in Operations.</div></div></div>",
                                                "children": []
                                            }
                                        ]
                                    },
                                    {
                                        "id": "docker-section-ops",
                                        "title": "Operations",
                                        "icon": "âš¡",
                                        "selector": "#wiz-docker-section-ops",
                                        "content": "Docker compose operations â€” start, stop, build, and manage your container stack directly from the control plane.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">âš¡ Docker Operations</div><div class=\"state-detail\">These buttons run docker compose commands against your project's compose file. Each operation targets all services defined in the compose file.\n\nWorkflow:\n1. â–¶ Start â€” bring up the stack (builds if needed)\n2. Check status with ğŸ“‹ Compose in the live panel\n3. ğŸ“œ Logs â€” stream output to debug issues\n4. ğŸ”„ Restart â€” apply config changes without full rebuild\n5. ğŸ”¨ Build â€” rebuild images after code changes\n6. â¹ Stop â€” tear down when done\n\nAll commands run in the project directory. Output appears in the panel below the buttons.\n\nRequires: Docker daemon running + compose CLI available + compose file present. If any are missing, this section won't appear â€” check the status strip pills above.</div></div>",
                                        "children": [
                                            {
                                                "id": "docker-btn-start",
                                                "title": "Start",
                                                "icon": "â–¶",
                                                "selector": "#wiz-docker-btn-start",
                                                "content": "docker compose up -d â€” start all services in detached mode. Builds images if they don't exist yet.",
                                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">â–¶ Start Stack</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Runs docker compose up -d (detached mode).</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">This will:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Pull any missing base images</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Build images for services with 'build:' config</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Create networks and volumes</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Start all containers</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Return immediately (containers run in background)</div><div class=\"state-text\">After starting, use ğŸ“‹ Compose in the live panel to verify all services are running, and ğŸ“œ Logs to check for startup errors.</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">If a service fails to start, common causes:</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;font-size:0.75rem\"><span class=\"state-key\">Port already in use</span><span>another process or container on the same port</span><span class=\"state-key\">Missing env vars</span><span>check your .env file</span><span class=\"state-key\">Build failure</span><span>syntax error in Dockerfile</span><span class=\"state-key\">Dependency not ready</span><span>database not accepting connections yet (add healthcheck)</span></div></div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "docker-btn-stop",
                                                "title": "Stop",
                                                "icon": "â¹",
                                                "selector": "#wiz-docker-btn-stop",
                                                "content": "docker compose down â€” stop and remove all containers, networks. Volumes are preserved.",
                                                "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">â¹ Stop Stack</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Runs docker compose down.</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">This will:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Stop all running containers gracefully (SIGTERM, then SIGKILL after timeout)</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Remove stopped containers</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Remove project networks</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Preserve named volumes (database data survives)</div><div class=\"state-text\">Volumes are NOT deleted â€” your database data, uploads, and other persistent state remain intact. To also delete volumes, you'd need docker compose down -v (not available here â€” protects against data loss).</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">Use Stop when:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Done developing for the day</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Need to free ports for another project</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Before rebuilding with major changes</div></div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "docker-btn-restart",
                                                "title": "Restart",
                                                "icon": "ğŸ”„",
                                                "selector": "#wiz-docker-btn-restart",
                                                "content": "docker compose restart â€” restart all containers without rebuilding. Useful for picking up config changes.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ”„ Restart Stack</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Runs docker compose restart.</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">This will:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Stop each container gracefully</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Start each container again with the same image</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Preserve all container state</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">Restart does NOT rebuild images â€” it uses the existing images. If you changed code or Dockerfile:</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;font-size:0.75rem\"><span class=\"state-key\">Code changes with volume mounts</span><span>restart picks them up</span><span class=\"state-key\">Dockerfile changes</span><span>use ğŸ”¨ Build instead</span><span class=\"state-key\">Config changes (env vars, ports)</span><span>use Stop then Start</span></div><div class=\"state-text\">Restart is the fastest way to apply changes when using volume-mounted source code for development.</div></div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "docker-btn-build",
                                                "title": "Build",
                                                "icon": "ğŸ”¨",
                                                "selector": "#wiz-docker-btn-build",
                                                "content": "docker compose build â€” rebuild images using cached layers. Fast when only source code changed.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ”¨ Build Images</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Runs docker compose build.</div><div class=\"state-text\">Rebuilds images for all services that have 'build:' in their compose config. Uses Docker's layer cache â€” unchanged layers are reused.</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">Layer caching means:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Only changed steps are re-executed</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ If only source code changed, only COPY and later steps rebuild</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Base image and dependency install layers are cached</div><div class=\"state-text\">After building, use â–¶ Start or ğŸ”„ Restart to run the new images.</div><div class=\"state-text\">Build is fast for iterative development. Use Build (no-cache) when caching causes stale results (e.g., after changing dependency files that Docker doesn't detect as changed).</div></div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "docker-btn-build-nc",
                                                "title": "Build (no-cache)",
                                                "icon": "ğŸ”¨",
                                                "selector": "#wiz-docker-btn-build-nc",
                                                "content": "docker compose build --no-cache â€” rebuild from scratch, ignoring all cached layers. Use after base image or dependency changes.",
                                                "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">ğŸ”¨ Build (no-cache)</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Runs docker compose build --no-cache.</div><div class=\"state-text\">This forces a complete rebuild of every layer â€” nothing is reused from cache. Slower than regular build but guarantees a clean state.</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">Use no-cache when:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Updated base image tag (e.g., python:3.12-slim got a security patch)</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Changed dependency files but Docker didn't detect it (pip install with uncached requirements)</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Debugging build issues that might be cache-related</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Reproducing CI/CD builds locally (CI usually builds without cache)</div><div class=\"state-text\">No-cache builds can take significantly longer â€” a 30-second cached build might take 5-10 minutes without cache due to re-downloading and re-installing all dependencies.</div><div class=\"state-text\">For regular development, prefer the cached ğŸ”¨ Build and only use no-cache when you suspect stale layers.</div></div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "docker-btn-prune",
                                                "title": "Prune",
                                                "icon": "ğŸ§¹",
                                                "selector": "#wiz-docker-btn-prune",
                                                "content": "docker system prune â€” remove unused containers, networks, and dangling images to reclaim disk space.",
                                                "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">ğŸ§¹ Prune System</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Runs docker system prune to clean up unused Docker resources.</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">This removes:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Stopped containers (not currently running)</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Unused networks (not attached to any container)</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Dangling images (untagged layers from rebuilds)</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Build cache (intermediate layers)</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">This does NOT remove:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Running containers</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Tagged images (your named images are safe)</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Named volumes (database data is preserved)</div><div class=\"state-text\">Prune is safe for development â€” it only removes resources that aren't actively in use. After a few days of building and rebuilding, pruning can reclaim several GB of disk space.</div><div class=\"state-text\">If images tab shows many \\u003cnone\\u003e:\\u003cnone\\u003e entries, pruning will clean those up.</div></div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "docker-btn-logs",
                                                "title": "Logs",
                                                "icon": "ğŸ“œ",
                                                "selector": "#wiz-docker-btn-logs",
                                                "content": "docker compose logs --tail 50 â€” show recent log output from all services for debugging.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“œ Service Logs</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Runs docker compose logs --tail 50 to show recent output from all compose services.</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">Logs are aggregated across all services with service name prefixes. Useful for:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Checking startup errors after â–¶ Start</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Debugging request failures</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Monitoring database connections</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Verifying health check passes</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">The output shows the most recent 50 lines from each service. For full logs or live streaming, use the terminal:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ docker compose logs -f (follow/stream)</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ docker compose logs web (single service)</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ docker compose logs --since 5m (last 5 minutes)</div><div class=\"state-text\">If a service is crash-looping (restarting repeatedly), logs will show the error causing the crash â€” usually a missing env var, port conflict, or failed database connection.</div></div></div>",
                                                "children": []
                                            }
                                        ]
                                    },
                                    {
                                        "id": "docker-ops-hint",
                                        "title": "Operations Hint",
                                        "icon": "â„¹",
                                        "selector": "#wiz-docker-ops-hint",
                                        "content": "Operations require a compose file â€” generate one with the Basic Config form below to unlock Start/Stop/Build controls.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â„¹ Operations Locked</div><div class=\"state-detail\">The Start/Stop/Build/Logs buttons require a docker-compose.yml file to be present. Without it, Docker doesn't know which services to manage.\n\nTo unlock operations:\n1. Open 'ğŸ“ Generate Basic Config' below\n2. Check 'â˜ Also generate docker-compose.yml'\n3. Click âœ… Apply\n\nOr use 'ğŸš€ Full Docker Setup' for a comprehensive compose file with infrastructure services.\n\nOnce a compose file exists, this hint will be replaced by the full Operations panel.</div></div>",
                                        "children": []
                                    },
                                    {
                                        "id": "docker-section-genconfig",
                                        "title": "Generate Config",
                                        "icon": "ğŸ“",
                                        "selector": "#wiz-docker-section-genconfig",
                                        "content": "Generate or regenerate a basic Dockerfile and optional compose file from your detected stack ({{dockerStack}}).",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“ Basic Config Generator</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">This form creates a single-service Dockerfile (and optionally docker-compose.yml) based on your project's detected stack.</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">The fields are pre-filled from stack detection:</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;font-size:0.75rem\"><span class=\"state-key\">Base Image</span><span>the right runtime for your detected stack</span><span class=\"state-key\">Working Directory</span><span>standard /app convention</span><span class=\"state-key\">Install Command</span><span>your language's dependency installer</span><span class=\"state-key\">Expose Port</span><span>default port for your stack type</span><span class=\"state-key\">Entry Command</span><span>how to start your application</span></div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">The generated Dockerfile follows best practices:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Uses appropriate base image tags</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Sets WORKDIR before COPY</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Installs dependencies before copying source (layer caching)</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Exposes the correct port</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Sets a proper CMD</div><div class=\"state-text\">For projects with multiple modules, infrastructure services, or vault-managed env vars, use 'ğŸš€ Full Docker Setup' instead â€” Basic Config only handles single-service setups.</div></div></div>",
                                        "children": [
                                            {
                                                "id": "docker-field-base",
                                                "title": "Base Image",
                                                "icon": "ğŸ—",
                                                "selector": "#wiz-docker-base",
                                                "content": "Base image: {{dockerBaseRuntime}} {{dockerBaseVersion}} ({{dockerBaseVariant}}) â€” {{dockerBaseVariantExplain}}",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ— Base Image Breakdown</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Your current base image parsed into components:</div><div class=\"state-text\">{{dockerBaseBreakdown}}</div><div class=\"state-text\">â”€â”€ What Each Part Means â”€â”€</div><div class=\"state-text\">ğŸ”§ Runtime: {{dockerBaseRuntime}}\nThe language or service runtime. This determines what's pre-installed in your container â€” the interpreter, compiler, or server binary. Detected from your project stack ({{dockerStack}}).</div><div class=\"state-text\">ğŸ“Œ Version: {{dockerBaseVersion}}\nThe pinned release. Always pin a specific version for reproducible builds. Using ':latest' means your build could break when the upstream image updates. Your version should match your local development environment.</div><div class=\"state-text\">ğŸ“¦ Variant: {{dockerBaseVariant}}\n{{dockerBaseVariantExplain}}</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">â”€â”€ Variant Trade-offs â”€â”€</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;font-size:0.75rem\"><span style=\"grid-column:1/-1;color:var(--text-secondary)\">âœ“ slim: ~150MB, Debian-based, works with everything, good default</span><span class=\"state-key\">alpine: ~50MB, smallest, but uses musl libc</span><span>some native extensions may fail</span><span style=\"grid-column:1/-1;color:var(--text-secondary)\">âœ“ full (bookworm/bullseye): ~400MB+, all system libraries, use when slim/alpine builds fail</span><span class=\"state-key\">No variant: depends on the image</span><span>some default to full Debian, others to slim</span></div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">â”€â”€ Recommendations â”€â”€</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ For Python: slim is the best default (C extensions work, moderate size)</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ For Node.js: alpine works for most apps, use slim if native modules fail</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ For Go: alpine for multi-stage builds (final image is just your binary)</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ For Java: jdk-alpine for smallest, jdk for full compatibility</div><div class=\"state-text\">Pre-filled from detected stack: {{dockerStack}}</div></div></div>",
                                                "children": [
                                                    {
                                                        "id": "docker-base-runtime",
                                                        "title": "Runtime",
                                                        "icon": "ğŸ”§",
                                                        "selector": "#wiz-docker-base",
                                                        "content": "Runtime: {{dockerBaseRuntime}} â€” the language or service pre-installed in this image.",
                                                        "variants": [
                                                            {
                                                                "when": {
                                                                    "resolver": "dockerBaseRuntime",
                                                                    "contains": "Python"
                                                                },
                                                                "icon": "ğŸ",
                                                                "content": "âœ“ Python runtime â€” CPython interpreter with pip. Fully supported, auto-detected from your stack.",
                                                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ Runtime Â· Python</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">âœ“ Known and supported runtime</div><div class=\"state-text\">Python runtime detected from your project stack ({{dockerStack}}).</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">What's included in the Python image:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ CPython interpreter</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ pip package manager</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Standard library</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ OS-level packages (varies by variant)</div><div class=\"state-text\">Your install command, entry command, and port are all pre-configured for Python. The base image version ({{dockerBaseVersion}}) should match your local Python version.</div></div></div>"
                                                            },
                                                            {
                                                                "when": {
                                                                    "resolver": "dockerBaseRuntime",
                                                                    "contains": "Go"
                                                                },
                                                                "icon": "ğŸ”µ",
                                                                "content": "âœ“ Go runtime â€” Go compiler with module tooling. Ideal for multi-stage builds.",
                                                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ”µ Runtime Â· Go</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">âœ“ Known and supported runtime</div><div class=\"state-text\">Go runtime detected from your project stack ({{dockerStack}}).</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">Go images are ideal for multi-stage builds:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Stage 1: golang image compiles your binary</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Stage 2: scratch or alpine image runs the binary</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Result: final image can be under 20MB</div><div class=\"state-text\">Includes: Go compiler, go mod tooling, CGO support (if using glibc variant).</div></div></div>"
                                                            },
                                                            {
                                                                "when": {
                                                                    "resolver": "dockerBaseRuntime",
                                                                    "contains": "Node"
                                                                },
                                                                "icon": "ğŸŸ¢",
                                                                "content": "âœ“ Node.js runtime â€” V8 engine with npm/yarn. Auto-detected from your stack.",
                                                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸŸ¢ Runtime Â· Node.js</div><div class=\"state-detail\">âœ“ Known and supported runtime\n\nNode.js runtime detected from your project stack ({{dockerStack}}).\n\nIncludes: V8 JavaScript engine, npm, npx. Yarn available via corepack.\n\nFor production builds, use 'npm ci --only=production' instead of 'npm install' to ensure reproducible installs from package-lock.json.</div></div>"
                                                            },
                                                            {
                                                                "when": {
                                                                    "resolver": "dockerBaseRuntime",
                                                                    "contains": "Java"
                                                                },
                                                                "icon": "â˜•",
                                                                "content": "âœ“ Java runtime (Eclipse Temurin) â€” JDK with HotSpot JVM.",
                                                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">â˜• Runtime Â· Java (Temurin)</div><div class=\"state-detail\">âœ“ Known and supported runtime\n\nEclipse Temurin provides a production-quality OpenJDK distribution.\n\nFor runtime-only deployments, consider switching to JRE variant (jre-alpine) instead of JDK â€” smaller image since the compiler isn't needed at runtime.</div></div>"
                                                            },
                                                            {
                                                                "when": {
                                                                    "resolver": "dockerBaseRuntime",
                                                                    "contains": "Rust"
                                                                },
                                                                "icon": "ğŸ¦€",
                                                                "content": "âœ“ Rust runtime â€” rustc compiler with cargo. Ideal for multi-stage builds.",
                                                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ¦€ Runtime Â· Rust</div><div class=\"state-detail\">âœ“ Known and supported runtime\n\nRust images include rustc, cargo, and the standard library.\n\nLike Go, Rust compiles to native binaries â€” multi-stage builds let you copy just the binary to a minimal final image (scratch, alpine, or distroless).</div></div>"
                                                            },
                                                            {
                                                                "when": {
                                                                    "resolver": "dockerBaseRuntime",
                                                                    "equals": ""
                                                                },
                                                                "icon": "â“",
                                                                "content": "âš  No runtime detected â€” base image field may be empty or unparseable.",
                                                                "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">â“ Runtime Â· Unknown</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">âš  Could not detect a known runtime from the base image field.</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">This means either:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ The base image field is empty</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ The image uses a repository name not in the supported list</div><div class=\"state-text\">Supported runtimes: Python, Go, Node.js, Rust, Java, .NET, Ruby, Elixir, PHP, GCC, Swift, Nginx, PostgreSQL, MySQL, MongoDB, Redis.</div><div class=\"state-text\">If your runtime is correct but not recognized, the image will still work â€” the assistant just can't provide stack-specific guidance.</div></div></div>"
                                                            }
                                                        ],
                                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ”§ Runtime Â· {{dockerBaseRuntime}}</div><div class=\"state-detail\">âœ“ Runtime detected: {{dockerBaseRuntime}}\n\nAuto-detected from your project stack ({{dockerStack}}). The runtime determines what's pre-installed â€” interpreter, compiler, or server binary.\n\nIf you change the runtime, update your install and entry commands to match.</div></div>",
                                                        "children": []
                                                    },
                                                    {
                                                        "id": "docker-base-version",
                                                        "title": "Version",
                                                        "icon": "ğŸ“Œ",
                                                        "selector": "#wiz-docker-base",
                                                        "content": "Version: {{dockerBaseVersion}} â€” the pinned release tag for reproducible builds.",
                                                        "variants": [
                                                            {
                                                                "when": {
                                                                    "resolver": "dockerBaseVersion",
                                                                    "equals": "latest"
                                                                },
                                                                "icon": "âš ï¸",
                                                                "content": "âš  Version 'latest' â€” not pinned. Builds are not reproducible and may break without warning.",
                                                                "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš ï¸ Version Â· latest (not pinned)</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">âš  Using ':latest' is not recommended for production.</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">Problems with :latest:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Your build today and tomorrow may use different versions</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ CI/CD and local environments may diverge silently</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ A breaking upstream change can fail your builds without any code change</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">Fix: Replace 'latest' with a specific version tag:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Python: 3.12, 3.11</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Node.js: 20, 22</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Go: 1.22, 1.23</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Java: 21, 17</div><div class=\"state-text\">Your local {{dockerBaseRuntime}} version should match what you pin here.</div></div></div>"
                                                            },
                                                            {
                                                                "when": {
                                                                    "resolver": "dockerBaseVersion",
                                                                    "equals": ""
                                                                },
                                                                "icon": "âš ï¸",
                                                                "content": "âš  No version detected â€” image may default to 'latest'.",
                                                                "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš ï¸ Version Â· missing</div><div class=\"state-detail\">âš  No version tag detected in the base image.\n\nWhen no tag is specified, Docker defaults to ':latest' which is not reproducible. Always pin a specific version.</div></div>"
                                                            }
                                                        ],
                                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ“Œ Version Â· {{dockerBaseVersion}} (pinned)</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">âœ“ Version is pinned â€” builds are reproducible.</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">Pinned to {{dockerBaseVersion}} for {{dockerBaseRuntime}}:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Guarantees the same base on every build</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Security patches arrive as point releases within this version line</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Match this to your local development version</div><div class=\"state-text\">docker pull will fetch the latest build of {{dockerBaseRuntime}} {{dockerBaseVersion}}-{{dockerBaseVariant}}</div></div></div>",
                                                        "children": []
                                                    },
                                                    {
                                                        "id": "docker-base-variant",
                                                        "title": "Variant",
                                                        "icon": "ğŸ“¦",
                                                        "selector": "#wiz-docker-base",
                                                        "content": "Variant: {{dockerBaseVariant}} â€” {{dockerBaseVariantExplain}}",
                                                        "variants": [
                                                            {
                                                                "when": {
                                                                    "resolver": "dockerBaseVariant",
                                                                    "contains": "slim"
                                                                },
                                                                "icon": "âœ…",
                                                                "content": "âœ“ slim variant â€” good balance of size (~150MB) and compatibility. Recommended default.",
                                                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Variant Â· slim (optimized)</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">âœ“ Excellent choice for {{dockerBaseRuntime}}.</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">slim is the recommended default for most projects:</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;font-size:0.75rem\"><span class=\"state-key\">~150MB</span><span>significantly smaller than full Debian</span><span class=\"state-key\">Debian-based</span><span>all native extensions and C libraries work</span><span class=\"state-key\">Compatible with everything</span><span>no musl/glibc issues</span><span style=\"grid-column:1/-1;color:var(--text-secondary)\">âœ“ Missing only: man pages, docs, dev headers (rarely needed at runtime)</span></div><div class=\"state-text\">This is the sweet spot between image size and compatibility. You're unlikely to hit missing-library issues that alpine can cause.</div></div></div>"
                                                            },
                                                            {
                                                                "when": {
                                                                    "resolver": "dockerBaseVariant",
                                                                    "contains": "alpine"
                                                                },
                                                                "icon": "ğŸ”",
                                                                "content": "âœ“ alpine variant â€” smallest image (~50MB) but uses musl libc. Watch for C extension compatibility.",
                                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ” Variant Â· alpine (smallest)</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Alpine Linux â€” smallest possible image for {{dockerBaseRuntime}}.</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">Benefits:</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;font-size:0.75rem\"><span class=\"state-key\">~50MB</span><span>dramatically smaller than slim (~150MB) or full (~400MB)</span><span style=\"grid-column:1/-1;color:var(--text-secondary)\">âœ“ Fastest pull times and smallest registry storage</span><span style=\"grid-column:1/-1;color:var(--text-secondary)\">âœ“ Minimal attack surface for security</span></div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">Risks:</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;font-size:0.75rem\"><span class=\"state-key\">Uses musl libc instead of glibc</span><span>some C extensions may fail to compile</span><span style=\"grid-column:1/-1;color:var(--text-secondary)\">âœ“ Python: numpy, pandas, cryptography may need extra build dependencies</span><span style=\"grid-column:1/-1;color:var(--text-secondary)\">âœ“ Node.js: native addons may need rebuilding</span></div><div class=\"state-text\">If builds fail with missing library errors, switch to 'slim' â€” it's the safe fallback.</div><div class=\"state-text\">Best for: Go (multi-stage final image), Redis, Nginx, and apps without native dependencies.</div></div></div>"
                                                            },
                                                            {
                                                                "when": {
                                                                    "resolver": "dockerBaseVariant",
                                                                    "contains": "bookworm"
                                                                },
                                                                "icon": "ğŸ“€",
                                                                "content": "âš  bookworm variant â€” full Debian 12 (~400MB+). Consider slim for smaller images unless you need all system libraries.",
                                                                "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">ğŸ“€ Variant Â· bookworm (full Debian)</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">âš  Full Debian Bookworm â€” largest variant for {{dockerBaseRuntime}}.</div><div class=\"state-text\">~400MB+ image with every system library. This works for everything but is larger than necessary for most projects.</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">When full Debian is justified:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Complex native dependencies that fail on slim/alpine</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ System tools needed at runtime (curl, wget, etc.)</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Legacy packages only available in full Debian repos</div><div class=\"state-text\">Otherwise, consider switching to 'slim' â€” same compatibility, ~60% smaller.</div></div></div>"
                                                            },
                                                            {
                                                                "when": {
                                                                    "resolver": "dockerBaseVariant",
                                                                    "contains": "bullseye"
                                                                },
                                                                "icon": "ğŸ“€",
                                                                "content": "âš  bullseye variant â€” full Debian 11 (older). Consider bookworm (Debian 12) or slim for a smaller, newer image.",
                                                                "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">ğŸ“€ Variant Â· bullseye (older Debian)</div><div class=\"state-detail\">âš  Debian 11 Bullseye â€” older stable release.\n\nThis still receives security updates but newer packages and fixes are in bookworm (Debian 12). Consider upgrading to bookworm or switching to slim for a smaller image.</div></div>"
                                                            },
                                                            {
                                                                "when": {
                                                                    "resolver": "dockerBaseVariant",
                                                                    "contains": "cli"
                                                                },
                                                                "icon": "ğŸ’»",
                                                                "content": "âœ“ cli variant â€” PHP CLI mode, no web server. Appropriate for CLI tools, workers, and scripts.",
                                                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ’» Variant Â· cli (PHP CLI)</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">âœ“ PHP CLI mode â€” no built-in web server.</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">Appropriate for:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ CLI tools and scripts</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Queue workers and cron jobs</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Artisan commands (Laravel)</div><div class=\"state-text\">For web apps, consider 'fpm' (with nginx) or 'apache' (self-contained).</div></div></div>"
                                                            },
                                                            {
                                                                "when": {
                                                                    "resolver": "dockerBaseVariant",
                                                                    "contains": "fpm"
                                                                },
                                                                "icon": "âš¡",
                                                                "content": "âœ“ fpm variant â€” PHP FastCGI Process Manager. Pair with nginx for production web serving.",
                                                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âš¡ Variant Â· fpm (PHP-FPM)</div><div class=\"state-detail\">âœ“ PHP-FPM â€” production-grade PHP process management.\n\nRequires a separate web server (typically nginx) to proxy requests. This is the recommended setup for production PHP applications â€” better performance and control than mod_php or the built-in server.</div></div>"
                                                            },
                                                            {
                                                                "when": {
                                                                    "resolver": "dockerBaseVariant",
                                                                    "contains": "jdk"
                                                                },
                                                                "icon": "â˜•",
                                                                "content": "âœ“ JDK variant â€” full Java Development Kit. Use JRE variant for smaller runtime-only images.",
                                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â˜• Variant Â· JDK</div><div class=\"state-detail\">Full JDK includes the Java compiler (javac) and development tools.\n\nFor production runtime-only images, consider 'jre-alpine' â€” it includes only the JVM, making the image significantly smaller. Use JDK in build stages, JRE in the final stage.</div></div>"
                                                            },
                                                            {
                                                                "when": {
                                                                    "resolver": "dockerBaseVariant",
                                                                    "equals": ""
                                                                },
                                                                "icon": "âš ï¸",
                                                                "content": "âš  No variant â€” using default image. May be unnecessarily large. Consider adding '-slim' or '-alpine'.",
                                                                "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš ï¸ Variant Â· none (default)</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">âš  No variant suffix detected â€” the image defaults to its base variant.</div><div class=\"state-text\">For most runtimes, the default is a full Debian image (~400MB+). This is bigger than necessary.</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">Recommendation: Add a variant suffix to optimize image size:</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;font-size:0.75rem\"><span class=\"state-key\">'-slim'</span><span>safe default (~150MB), works with everything</span><span class=\"state-key\">'-alpine'</span><span>smallest (~50MB), watch for C extension issues</span></div><div class=\"state-text\">Edit the base image field to add the variant after the version: e.g., {{dockerBaseRuntime}}:{{dockerBaseVersion}}-slim</div></div></div>"
                                                            }
                                                        ],
                                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“¦ Variant Â· {{dockerBaseVariant}}</div><div class=\"state-detail\">{{dockerBaseVariantExplain}}\n\nThe variant controls the OS base and image size. Edit the base image field to change it â€” the variant is everything after the first dash in the tag.</div></div>",
                                                        "children": []
                                                    }
                                                ]
                                            },
                                            {
                                                "id": "docker-field-workdir",
                                                "title": "Working Directory",
                                                "icon": "ğŸ“",
                                                "selector": "#wiz-docker-workdir",
                                                "content": "WORKDIR in the Dockerfile â€” the directory inside the container where your code lives. Usually /app.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“ Working Directory</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Sets the WORKDIR instruction in the Dockerfile. All subsequent COPY, RUN, and CMD instructions execute relative to this directory.</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">Conventions:</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;font-size:0.75rem\"><span class=\"state-key\">/app</span><span>most common, universally understood</span><span class=\"state-key\">/usr/src/app</span><span>Node.js convention</span><span class=\"state-key\">/go/src/app</span><span>Go convention (though /app is fine too)</span></div><div class=\"state-text\">The WORKDIR instruction also creates the directory if it doesn't exist. It's equivalent to mkdir -p /app && cd /app.</div><div class=\"state-text\">Leave as /app unless your framework expects a specific path.</div></div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "docker-field-install",
                                                "title": "Install Command",
                                                "icon": "ğŸ“¥",
                                                "selector": "#wiz-docker-install",
                                                "content": "The RUN command that installs dependencies â€” e.g., pip install, npm install, go mod download.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“¥ Install Command</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">This becomes a RUN instruction in the Dockerfile that installs your project's dependencies during the build.</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">Common values:</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;font-size:0.75rem\"><span class=\"state-key\">Python</span><span>pip install --no-cache-dir -r requirements.txt</span><span class=\"state-key\">Node.js</span><span>npm ci --only=production</span><span class=\"state-key\">Go</span><span>go mod download</span><span class=\"state-key\">Ruby</span><span>bundle install</span></div><div class=\"state-text\">The generated Dockerfile copies dependency files (requirements.txt, package.json) BEFORE copying source code. This means dependency installation is cached â€” it only re-runs when dependency files change, not on every code change.</div><div class=\"state-text\">This is a critical Docker optimization: changing a Python source file won't trigger a full pip install, saving minutes on every build.</div><div class=\"state-text\">Pre-filled from your stack detection.</div></div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "docker-field-port",
                                                "title": "Expose Port",
                                                "icon": "ğŸ”Œ",
                                                "selector": "#wiz-docker-port",
                                                "content": "The EXPOSE port â€” which network port your application listens on inside the container.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ”Œ Expose Port</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Sets the EXPOSE instruction and the port mapping in docker-compose.yml.</div><div class=\"state-text\">EXPOSE is documentation â€” it tells users and tools which port the app listens on. The actual port binding happens in compose (ports: - '8080:8080').</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">Common ports:</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;font-size:0.75rem\"><span class=\"state-key\">8080</span><span>generic web service</span><span class=\"state-key\">3000</span><span>Node.js/React dev server</span><span class=\"state-key\">8000</span><span>Python (Django, FastAPI, Flask)</span><span class=\"state-key\">5000</span><span>Flask default</span><span class=\"state-key\">4000</span><span>Phoenix/Elixir</span></div><div class=\"state-text\">The generated compose file maps this port 1:1 (host:container). If you need a different host port (e.g., host 9090 â†’ container 8080), edit the compose file after generation.</div><div class=\"state-text\">Hidden for library-type projects that don't expose network services.</div></div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "docker-field-cmd",
                                                "title": "Entry Command",
                                                "icon": "ğŸš€",
                                                "selector": "#wiz-docker-cmd",
                                                "content": "CMD instruction â€” the command that runs when the container starts.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸš€ Entry Command</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Sets the CMD instruction â€” what runs when the container starts. This is the 'main process' of your container.</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">Common values:</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;font-size:0.75rem\"><span class=\"state-key\">Python</span><span>python -m uvicorn app:app --host 0.0.0.0 --port 8080</span><span class=\"state-key\">Node.js</span><span>node server.js or npm start</span><span class=\"state-key\">Go</span><span>./app (compiled binary)</span><span class=\"state-key\">Ruby</span><span>bundle exec rails server</span></div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">Important:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Always bind to 0.0.0.0, not 127.0.0.1 (container networking requires it)</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ The CMD process should run in the foreground (not daemonize)</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ When this process exits, the container stops</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">CMD vs ENTRYPOINT:</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;font-size:0.75rem\"><span class=\"state-key\">CMD</span><span>default command, can be overridden with docker run args</span><span class=\"state-key\">ENTRYPOINT</span><span>always runs, CMD args are appended</span></div><div class=\"state-text\">For development, you can override CMD in compose with 'command:' per service.</div><div class=\"state-text\">Hidden for library-type projects that don't have a runtime entry point.</div></div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "docker-genconfig-warning",
                                                "title": "Multi-Module Warning",
                                                "icon": "âš ï¸",
                                                "selector": "#wiz-docker-genconfig-warning",
                                                "content": "Your project has multiple modules â€” Basic Config creates only a single-service Dockerfile. Use Full Docker Setup for per-module configuration.",
                                                "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš ï¸ Basic Config Limitation</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Your project has multiple modules or compose services. Basic Config generates a single-template Dockerfile for one service only.</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">What Basic Config handles:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ One Dockerfile with one service</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ One optional docker-compose.yml entry</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Stack-detected base image and commands</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">What it does NOT handle:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Per-module Dockerfiles (each module needs its own)</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Infrastructure services (databases, caches, queues)</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Vault-managed environment variables</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Custom port/volume mappings per service</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Health checks and resource limits</div><div class=\"state-text\">For multi-module projects, use 'ğŸš€ Full Docker Setup' below â€” it creates per-module Dockerfiles, adds infrastructure services, maps vault secrets to env vars, and generates a comprehensive docker-compose.yml.</div></div></div>",
                                                "children": []
                                            }
                                        ]
                                    },
                                    {
                                        "id": "docker-section-fullsetup",
                                        "title": "Full Docker Setup",
                                        "icon": "ğŸš€",
                                        "selector": "#wiz-docker-section-fullsetup",
                                        "content": "Open the comprehensive Docker wizard â€” per-module Dockerfiles, infrastructure services, vault integration, and live preview.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸš€ Full Docker Setup</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">The Full Docker Setup wizard goes beyond basic config generation. It opens a multi-step wizard that handles:</div><div class=\"state-grid\"><span class=\"state-key\">Per-module Dockerfiles</span><span>each detected module gets its own Dockerfile tailored to its stack</span><span class=\"state-key\">Infrastructure services</span><span>add databases (postgres, mysql, mongo), caches (redis, memcached), queues (rabbitmq, kafka)</span><span class=\"state-key\">Environment variables</span><span>map vault secrets to container env vars per service</span><span class=\"state-key\">Port and volume mappings</span><span>configure host:container bindings with conflict detection</span><span class=\"state-key\">Health checks</span><span>readiness probes for each service</span><span class=\"state-key\">.dockerignore</span><span>comprehensive exclusion rules tailored to your stack</span><span class=\"state-key\">Live preview</span><span>see the generated Dockerfile and compose file before writing to disk</span></div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">The readiness pills below show what the wizard has to work with:</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;font-size:0.75rem\"><span class=\"state-key\">Modules</span><span>detected code modules in your project</span><span class=\"state-key\">Dockerfile</span><span>whether one already exists (will offer merge or overwrite)</span><span class=\"state-key\">Compose</span><span>whether a compose file exists</span><span class=\"state-key\">.dockerignore</span><span>whether build context filtering is configured</span></div><div class=\"state-text\">Use this when Basic Config isn't sufficient â€” typically for projects with 2+ services or any infrastructure dependencies.</div></div></div>",
                                        "children": [
                                            {
                                                "id": "docker-fullsetup-pill-modules",
                                                "title": "Modules",
                                                "icon": "ğŸ“¦",
                                                "selector": "#wiz-docker-fullsetup-pill-modules",
                                                "content": "{{dockerModules}} module(s) detected â€” each will get its own Dockerfile in the full setup wizard.",
                                                "expanded": "",
                                                "children": []
                                            },
                                            {
                                                "id": "docker-fullsetup-pill-dockerfile",
                                                "title": "Dockerfile Status",
                                                "icon": "ğŸ“„",
                                                "selector": "#wiz-docker-fullsetup-pill-dockerfile",
                                                "content": "Shows whether a Dockerfile already exists. The wizard will offer to merge with or replace existing files.",
                                                "expanded": "",
                                                "children": []
                                            },
                                            {
                                                "id": "docker-fullsetup-pill-compose",
                                                "title": "Compose Status",
                                                "icon": "ğŸ“‹",
                                                "selector": "#wiz-docker-fullsetup-pill-compose",
                                                "content": "Shows whether a compose file exists. The wizard will merge new services into existing or create from scratch.",
                                                "expanded": "",
                                                "children": []
                                            },
                                            {
                                                "id": "docker-fullsetup-pill-dockerignore",
                                                "title": ".dockerignore Status",
                                                "icon": "ğŸš«",
                                                "selector": "#wiz-docker-fullsetup-pill-dockerignore",
                                                "content": "Shows whether .dockerignore exists. The wizard generates comprehensive patterns tailored to your stack.",
                                                "expanded": "",
                                                "children": []
                                            }
                                        ]
                                    },
                                    {
                                        "id": "docker-section-delete",
                                        "title": "Delete Config",
                                        "icon": "ğŸ—‘",
                                        "selector": "#wiz-docker-section-delete",
                                        "content": "Remove generated Docker configuration files (Dockerfile, compose file) from your project.",
                                        "expanded": "<div class=\"assistant-state-card state-error\"><div class=\"state-label\">ğŸ—‘ Delete Docker Config</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Removes Docker configuration files that were generated by the control plane.</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">This will delete:</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;font-size:0.75rem\"><span class=\"state-key\">Dockerfile</span><span>your container build recipe</span><span class=\"state-key\">docker-compose.yml</span><span>your service orchestration config</span></div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">This will NOT delete:</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;font-size:0.75rem\"><span class=\"state-key\">.dockerignore</span><span>kept for safety</span><span style=\"grid-column:1/-1;color:var(--text-secondary)\">âœ“ Any running containers or images (use â¹ Stop and ğŸ§¹ Prune for those)</span><span style=\"grid-column:1/-1;color:var(--text-secondary)\">âœ“ Any manually created Docker files outside the project root</span></div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">After deletion:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Operations buttons will disappear (no compose file)</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Status pills will show â—‹ for Dockerfile and compose</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ You can regenerate at any time with Basic Config or Full Setup</div><div class=\"state-text\">Use this when you want to start fresh with a different Docker configuration.</div></div></div>",
                                        "children": []
                                    },
                                    {
                                        "id": "docker-apply",
                                        "title": "Apply",
                                        "icon": "âœ…",
                                        "selector": "#wiz-apply-int-docker",
                                        "content": "Generate the Docker configuration files with the settings from the Basic Config form above.",
                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Apply Docker Config</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Clicking Apply generates Docker configuration files based on the form values above:</div><div class=\"state-grid\"><span class=\"state-key\">Dockerfile</span><span>created in your project root with the specified base image, install command, port, and entry command</span><span class=\"state-key\">docker-compose.yml</span><span>created if the checkbox is checked, with your service mapped to the specified port</span></div><div class=\"state-text\">If 'Overwrite existing Dockerfile' is unchecked and a Dockerfile already exists, the generation will skip it.</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">After applying:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Status pills will update to show âœ“ for Dockerfile (and compose if generated)</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Operations section will appear (if compose was generated and daemon is running)</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ You can immediately use â–¶ Start to run your containers</div><div class=\"state-text\">The generated files are standard Docker files â€” you can edit them manually at any time.</div></div></div>",
                                        "children": []
                                    },
                                    {
                                        "id": "docker-cancel",
                                        "title": "Cancel",
                                        "icon": "âœ–",
                                        "selector": "#wiz-cancel-int-docker",
                                        "content": "Close the Docker setup panel without generating any files. No changes are made.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">âœ– Discard</div><div class=\"state-detail\">Cancel collapses the Docker setup panel without generating any files or modifying any existing configuration.\n\nReopen anytime with âš™ï¸ Setup â€” all form fields repopulate from the current project state and stack detection.</div></div>",
                                        "children": []
                                    }
                                ]
                            }
                        ]
                    },
                    {
                        "id": "k8s-card",
                        "title": "Kubernetes",
                        "icon": "â˜¸ï¸",
                        "selector": "#wiz-int-wrap-k8s",
                        "content": "Kubernetes orchestration â€” deploy, scale, and manage containerized workloads across clusters.",
                        "variants": [
                            {
                                "when": {
                                    "textContains": "âœ“ cluster"
                                },
                                "content": "kubectl connected to a live cluster â€” {{k8sResources}} resource(s) across {{k8sManifests}} manifest file(s). Your K8s pipeline is operational.",
                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">â˜¸ï¸ Kubernetes Â· cluster connected</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Your Kubernetes environment is fully operational:</div><div class=\"state-grid\"><span class=\"state-key\">kubectl</span><span>connected and authenticated</span><span class=\"state-key\">Manifests</span><span>{{k8sManifests}} file(s), {{k8sResources}} resource(s)</span><span class=\"state-key\">Cluster</span><span>reachable â€” live operations available (Pods, Services, Deployments, Validate)</span></div><div class=\"state-text\">With a connected cluster, you can apply manifests directly, inspect running workloads, and validate configurations before deployment.</div><div class=\"state-text\">Kubernetes turns your containers (built via Docker) into production workloads with scaling, self-healing, service discovery, and rolling updates.</div></div></div>"
                            },
                            {
                                "when": {
                                    "textContains": "â—‹ no cluster"
                                },
                                "content": "kubectl is available but no cluster is connected. Manifest generation and analysis work â€” live cluster operations are blocked.",
                                "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">â˜¸ï¸ Kubernetes Â· no cluster</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">kubectl is installed but can't reach a cluster. Without a cluster:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ— Cannot apply manifests</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ— Cannot inspect running pods/services/deployments</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ— Cannot validate live cluster state</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Can still generate and analyze manifest files</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Can still set up Helm charts and Kustomize overlays</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">To connect a cluster:</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;font-size:0.75rem\"><span class=\"state-key\">Local</span><span>minikube start, kind create cluster, or Docker Desktop K8s</span><span class=\"state-key\">Cloud</span><span>aws eks update-kubeconfig, gcloud container clusters get-credentials, az aks get-credentials</span><span class=\"state-key\">Custom</span><span>set KUBECONFIG or merge into ~/.kube/config</span></div></div></div>"
                            },
                            {
                                "when": {
                                    "textContains": "âœ— no kubectl"
                                },
                                "content": "kubectl is not installed. Install it to enable Kubernetes manifest management and cluster operations.",
                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â˜¸ï¸ Kubernetes Â· kubectl missing</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">kubectl is not detected on this system. Without it:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ— Cannot communicate with Kubernetes clusters</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ— Cannot apply, inspect, or validate manifests on a cluster</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Can still generate manifest YAML files</div><div class=\"state-text\">The control plane can generate manifests without kubectl â€” they'll be ready when kubectl is installed.</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">To install:</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;font-size:0.75rem\"><span class=\"state-key\">Snap</span><span>sudo snap install kubectl --classic</span><span class=\"state-key\">Homebrew</span><span>brew install kubectl</span><span class=\"state-key\">Binary</span><span>https://kubernetes.io/docs/tasks/tools/</span></div></div></div>"
                            }
                        ],
                        "expanded": "",
                        "children": [
                            {
                                "id": "k8s-setup",
                                "title": "K8s Setup Panel",
                                "icon": "âš™ï¸",
                                "selector": "#wiz-int-setup-k8s",
                                "content": "Kubernetes integration setup â€” manifest analysis, cluster connectivity, and deployment tooling.",
                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â˜¸ï¸ Kubernetes Setup</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">This panel manages your project's Kubernetes configuration. It covers:</div><div class=\"state-grid\"><span class=\"state-key\">Manifests</span><span>YAML files defining Deployments, Services, ConfigMaps, etc.</span><span class=\"state-key\">Helm</span><span>package manager for K8s â€” charts bundle related manifests with configurable values</span><span class=\"state-key\">Kustomize</span><span>overlay system â€” one base + per-environment patches (dev/staging/prod)</span><span class=\"state-key\">Live Cluster</span><span>real-time pod/service/deployment inspection and validation</span></div><div class=\"state-text\">Unlike Docker (which builds images), Kubernetes deploys those images as workloads â€” scheduling them across nodes, managing networking, and handling scaling and self-healing.</div></div></div>",
                                "children": [
                                    {
                                        "id": "k8s-section-status",
                                        "title": "Status Strip",
                                        "icon": "ğŸ“Š",
                                        "selector": "#wiz-k8s-section-status",
                                        "content": "Seven status pills showing kubectl, resource count, Helm charts, Kustomize, deployment strategy, readiness, and cluster connectivity.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“Š K8s Status Strip</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-grid\"><span class=\"state-key\">kubectl</span><span>whether the CLI is available and its version</span><span class=\"state-key\">resources</span><span>total K8s resources found across all manifest files</span><span class=\"state-key\">Helm</span><span>number of Helm charts detected in the project</span><span class=\"state-key\">Kustomize</span><span>whether kustomization.yaml exists and overlay count</span><span class=\"state-key\">strategy</span><span>deployment strategy: raw manifests, Helm, Kustomize, or mixed</span><span class=\"state-key\">readiness</span><span>overall deployment readiness: ready, needs_config, needs_tools</span><span class=\"state-key\">cluster</span><span>whether kubectl can reach a live cluster</span></div></div></div>",
                                        "children": [
                                            {
                                                "id": "k8s-pill-kubectl",
                                                "title": "kubectl",
                                                "icon": "â˜¸ï¸",
                                                "selector": "#wiz-k8s-pill-kubectl",
                                                "content": "Kubernetes CLI â€” the primary tool for managing clusters, applying manifests, and inspecting workloads.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â˜¸ï¸ kubectl</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">kubectl is the command-line interface for Kubernetes. It communicates with the cluster's API server to manage all resources.</div><div class=\"state-grid\"><span class=\"state-key\">Apply</span><span>kubectl apply -f manifest.yaml</span><span class=\"state-key\">Get</span><span>kubectl get pods, deployments, services</span><span class=\"state-key\">Logs</span><span>kubectl logs pod-name -f</span><span class=\"state-key\">Exec</span><span>kubectl exec -it pod-name -- /bin/sh</span></div></div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "k8s-pill-resources",
                                                "title": "Resources",
                                                "icon": "ğŸ“¦",
                                                "selector": "#wiz-k8s-pill-resources",
                                                "content": "Total K8s resource definitions found across all manifest files â€” Deployments, Services, ConfigMaps, etc.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“¦ Resource Count</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Each resource is a declared K8s object â€” the cluster creates and manages it. Multiple resources can be defined in a single YAML file using --- separators.</div><div class=\"state-text\">A minimal deployment needs at least 1 Deployment + 1 Service = 2 resources. Production setups typically have 5-15+ resources per microservice (ConfigMaps, Secrets, HPA, PDB, Ingress, etc.).</div></div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "k8s-pill-helm",
                                                "title": "Helm",
                                                "icon": "âˆ",
                                                "selector": "#wiz-k8s-pill-helm",
                                                "content": "Helm chart detection â€” charts package K8s manifests into version-controlled, configurable bundles.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">âˆ Helm Charts</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Helm is the package manager for Kubernetes. A chart bundles templates, default values, and dependencies into a release.</div><div class=\"state-text\">When present, Helm provides:<br>â€¢ Templated manifests with configurable values<br>â€¢ Release versioning and rollback capabilities<br>â€¢ Dependency management (e.g. PostgreSQL as a subchart)<br>â€¢ Per-environment values files (values-dev.yaml, values-prod.yaml)</div></div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "k8s-pill-kustomize",
                                                "title": "Kustomize",
                                                "icon": "ğŸ—‚",
                                                "selector": "#wiz-k8s-pill-kustomize",
                                                "content": "Kustomize detection â€” overlay system that patches base manifests per environment without templating.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ—‚ Kustomize</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Kustomize is built into kubectl â€” no extra installation needed. It works by patching plain YAML manifests:</div><div class=\"state-text\">â€¢ Base manifests define the common resources<br>â€¢ Overlays apply strategic merge patches per environment<br>â€¢ No template language â€” just YAML manipulation<br>â€¢ Apply with: kubectl apply -k overlays/prod/</div></div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "k8s-pill-strategy",
                                                "title": "Strategy",
                                                "icon": "âš¡",
                                                "selector": "#wiz-k8s-pill-strategy",
                                                "content": "Deployment strategy â€” raw manifests, Helm charts, Kustomize overlays, or a mix of approaches.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">âš¡ Deployment Strategy</div><div class=\"state-detail\" class=\"state-wrap\"><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.25rem 0.4rem;margin-top:0.3rem;font-size:0.73rem\"><span class=\"state-key\">raw_kubectl</span><span>plain YAML manifests applied directly with kubectl apply -f</span><span class=\"state-key\">helm</span><span>charts with values â€” uses helm install/upgrade</span><span class=\"state-key\">kustomize</span><span>base + overlays â€” uses kubectl apply -k</span><span class=\"state-key\">mixed</span><span>multiple strategies detected â€” some manifests are raw, others use Helm or Kustomize</span></div></div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "k8s-pill-readiness",
                                                "title": "Readiness",
                                                "icon": "âœ…",
                                                "selector": "#wiz-k8s-pill-readiness",
                                                "content": "Overall K8s deployment readiness â€” whether all tools are installed and manifests are properly configured.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">âœ… Deployment Readiness</div><div class=\"state-detail\" class=\"state-wrap\"><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.25rem 0.4rem;margin-top:0.3rem;font-size:0.73rem\"><span style=\"font-weight:600;color:var(--success)\">âœ“ ready</span><span>all tools installed, manifests valid, can deploy immediately</span><span style=\"font-weight:600;color:var(--warning)\">âš  needs config</span><span>tools available but manifests need configuration â€” use the form below</span><span style=\"font-weight:600;color:var(--warning)\">âš  needs tools</span><span>missing required tools â€” install them from the System Tools section</span><span style=\"font-weight:600;color:var(--text-muted)\">â—‹ not configured</span><span>no K8s manifests detected â€” generate them with the config form or Full Setup</span></div></div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "k8s-pill-cluster",
                                                "title": "Cluster",
                                                "icon": "ğŸŒ",
                                                "selector": "#wiz-k8s-pill-cluster",
                                                "content": "Live cluster connectivity â€” whether kubectl can reach a Kubernetes API server.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸŒ Cluster Connectivity</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">A connected cluster enables live operations â€” applying manifests, inspecting pods, reading logs. Without a cluster, the control plane can still generate and analyze manifest files.</div><div class=\"state-grid\"><span class=\"state-key\">Local</span><span>minikube, kind, Docker Desktop K8s, k3s</span><span class=\"state-key\">Cloud</span><span>EKS (AWS), GKE (Google), AKS (Azure)</span><span class=\"state-key\">Config</span><span>~/.kube/config or KUBECONFIG env var</span></div></div></div>",
                                                "children": []
                                            }
                                        ]
                                    },
                                    {
                                        "id": "k8s-section-manifests",
                                        "title": "Manifests",
                                        "icon": "ğŸ“„",
                                        "selector": "#wiz-k8s-section-manifests",
                                        "content": "Manifest analysis â€” {{k8sManifests}} file(s) containing {{k8sResources}} K8s resource(s). Each manifest is parsed for resource kinds, counts, and structure.",
                                        "expanded": "<div class=\"assistant-state-card state-info\" style=\"margin-bottom:0.5rem\"><div class=\"state-label\">ğŸ“„ Manifest Analysis Â· {{k8sManifests}} file(s)</div><div class=\"state-detail\" class=\"state-wrap\">Hover each manifest below for per-file breakdown. General guidance:</div></div><div class=\"assistant-state-card state-info\" style=\"margin-top:0.6rem;margin-bottom:0.4rem\"><div class=\"state-label\">ğŸ§© Resource Kinds</div><div class=\"state-detail\" class=\"state-wrap\"><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.25rem 0.4rem;margin-top:0.3rem;font-size:0.73rem\"><span style=\"padding:0.1rem 0.3rem;border-radius:4px;background:hsla(210,60%,50%,0.1);color:hsla(210,60%,60%,1);font-size:0.68rem;font-weight:600\">ğŸš€ Deployment</span><span>manages replicated pods â€” rolling updates, rollbacks, scaling</span><span style=\"padding:0.1rem 0.3rem;border-radius:4px;background:hsla(140,60%,40%,0.1);color:hsla(140,60%,55%,1);font-size:0.68rem;font-weight:600\">ğŸŒ Service</span><span>stable network endpoint â€” ClusterIP, NodePort, or LoadBalancer</span><span style=\"padding:0.1rem 0.3rem;border-radius:4px;background:hsla(40,80%,50%,0.1);color:hsla(40,80%,55%,1);font-size:0.68rem;font-weight:600\">ğŸ”§ ConfigMap</span><span>key-value config injected as env vars or mounted files</span><span style=\"padding:0.1rem 0.3rem;border-radius:4px;background:hsla(0,70%,55%,0.1);color:hsla(0,70%,60%,1);font-size:0.68rem;font-weight:600\">ğŸ”’ Secret</span><span>base64-encoded sensitive data â€” passwords, tokens, certs</span><span style=\"padding:0.1rem 0.3rem;border-radius:4px;background:hsla(280,60%,55%,0.1);color:hsla(280,60%,60%,1);font-size:0.68rem;font-weight:600\">ğŸ“€ PVC</span><span>PersistentVolumeClaim â€” requests durable storage for pods</span><span style=\"padding:0.1rem 0.3rem;border-radius:4px;background:hsla(170,60%,45%,0.1);color:hsla(170,60%,50%,1);font-size:0.68rem;font-weight:600\">ğŸŒ Ingress</span><span>HTTP routing â€” hostname + path rules that expose services externally</span><span style=\"padding:0.1rem 0.3rem;border-radius:4px;background:hsla(30,70%,55%,0.1);color:hsla(30,70%,60%,1);font-size:0.68rem;font-weight:600\">â° CronJob</span><span>scheduled pod execution â€” backups, cleanups, reports</span><span style=\"padding:0.1rem 0.3rem;border-radius:4px;background:hsla(320,50%,55%,0.1);color:hsla(320,50%,60%,1);font-size:0.68rem;font-weight:600\">ğŸ“ˆ HPA</span><span>HorizontalPodAutoscaler â€” scales replicas based on CPU/memory/custom metrics</span></div></div></div><div class=\"assistant-state-card state-info\" style=\"margin-bottom:0.4rem\"><div class=\"state-label\">ğŸ“ Manifest Structure</div><div class=\"state-detail\" style=\"white-space:normal;font-size:0.73rem\"><div style=\"margin-top:0.2rem\">K8s manifests are YAML files with <code style=\"font-size:0.68rem\">apiVersion</code>, <code style=\"font-size:0.68rem\">kind</code>, <code style=\"font-size:0.68rem\">metadata</code>, and <code style=\"font-size:0.68rem\">spec</code>. Multiple resources can live in one file separated by <code style=\"font-size:0.68rem\">---</code>.</div><div style=\"margin-top:0.15rem\"><span style=\"color:hsla(140,60%,55%,1);font-weight:600\">âœ“</span> Group related resources (Deployment + Service) in one file for clarity</div><div style=\"margin-top:0.15rem\"><span style=\"color:hsla(140,60%,55%,1);font-weight:600\">âœ“</span> Use namespaces to isolate environments</div></div></div>",
                                        "dynamic": true,
                                        "childTemplate": {
                                            "title": "ğŸ“„ {{name}}",
                                            "content": "Manifest file {{name}} â€” hover for resource kind breakdown and structure analysis.",
                                            "selector": "#wiz-k8s-section-manifests [style*=\"border-bottom\"]",
                                            "nameSelector": "code"
                                        },
                                        "children": []
                                    },
                                    {
                                        "id": "k8s-section-helm",
                                        "title": "Helm Charts",
                                        "icon": "âˆ",
                                        "selector": "#wiz-k8s-section-helm",
                                        "content": "Helm chart analysis â€” charts package K8s resources into reusable, configurable bundles with values overrides per environment.",
                                        "expanded": "<div class=\"assistant-state-card state-info\" style=\"margin-bottom:0.5rem\"><div class=\"state-label\">âˆ Helm Chart Analysis</div><div class=\"state-detail\" class=\"state-wrap\">Hover each chart below for per-chart breakdown. General guidance:</div></div><div class=\"assistant-state-card state-info\" style=\"margin-top:0.6rem;margin-bottom:0.4rem\"><div class=\"state-label\">ğŸ“¦ Chart Structure</div><div class=\"state-detail\" class=\"state-wrap\"><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.25rem 0.4rem;margin-top:0.3rem;font-size:0.73rem\"><span class=\"state-key\">Chart.yaml</span><span>chart metadata â€” name, version, dependencies, type (application vs library)</span><span class=\"state-key\">values.yaml</span><span>default configuration â€” image tags, replica counts, resource limits, feature flags</span><span class=\"state-key\">templates/</span><span>Go-templated K8s manifests â€” rendered with values to produce final YAML</span><span class=\"state-key\">charts/</span><span>subcharts â€” bundled dependencies (e.g. PostgreSQL, Redis as subcharts)</span></div></div></div><div class=\"assistant-state-card state-info\" style=\"margin-bottom:0.4rem\"><div class=\"state-label\">ğŸŒ± Environment Values</div><div class=\"state-detail\" style=\"white-space:normal;font-size:0.73rem\"><div style=\"margin-top:0.2rem\">Per-environment values files (values-dev.yaml, values-prod.yaml) override defaults for each target. Install with:</div><div style=\"margin-top:0.15rem;font-family:monospace;font-size:0.7rem;padding:0.2rem 0.4rem;border-radius:3px;background:var(--bg-primary)\">helm install myapp ./chart -f values-prod.yaml</div></div></div>",
                                        "dynamic": true,
                                        "childTemplate": {
                                            "title": "âˆ {{name}}",
                                            "content": "Helm chart {{name}} â€” hover for chart metadata, values files, templates, and subchart analysis.",
                                            "selector": "#wiz-k8s-section-helm [style*=\"border-bottom\"]",
                                            "nameSelector": "strong"
                                        },
                                        "children": []
                                    },
                                    {
                                        "id": "k8s-section-kustomize",
                                        "title": "Kustomize",
                                        "icon": "ğŸ—‚",
                                        "selector": "#wiz-k8s-section-kustomize",
                                        "content": "Kustomize overlay analysis â€” a base set of manifests with per-environment patches. No templating â€” pure YAML patching.",
                                        "expanded": "<div class=\"assistant-state-card state-info\" style=\"margin-bottom:0.5rem\"><div class=\"state-label\">ğŸ—‚ Kustomize Analysis</div><div class=\"state-detail\" class=\"state-wrap\">Kustomize lets you maintain one set of base manifests and apply patches per environment â€” no template engine, just strategic merge patches on plain YAML.</div></div><div class=\"assistant-state-card state-info\" style=\"margin-top:0.6rem;margin-bottom:0.4rem\"><div class=\"state-label\">ğŸ“ Structure</div><div class=\"state-detail\" class=\"state-wrap\"><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.25rem 0.4rem;margin-top:0.3rem;font-size:0.73rem\"><span class=\"state-key\">base/</span><span>common manifests shared across all environments</span><span class=\"state-key\">overlays/</span><span>per-environment customizations (dev, staging, prod)</span><span class=\"state-key\">patches</span><span>strategic merge patches that modify specific fields</span><span class=\"state-key\">configMapGenerator</span><span>generates ConfigMaps from files or literals</span><span class=\"state-key\">images</span><span>image tag overrides without editing manifests</span></div></div></div><div class=\"assistant-state-card state-info\" style=\"margin-bottom:0.4rem\"><div class=\"state-label\">ğŸ”§ Usage</div><div class=\"state-detail\" style=\"white-space:normal;font-size:0.73rem\"><div style=\"margin-top:0.2rem\">Apply with: <code style=\"font-size:0.68rem\">kubectl apply -k overlays/prod/</code></div><div style=\"margin-top:0.15rem\">Preview output: <code style=\"font-size:0.68rem\">kubectl kustomize overlays/prod/</code></div><div style=\"margin-top:0.15rem\">Kustomize is built into kubectl â€” no extra tools needed.</div></div></div>",
                                        "dynamic": true,
                                        "childTemplate": {
                                            "title": "ğŸ“ {{name}}",
                                            "content": "Kustomize overlay {{name}} â€” environment-specific patches applied on top of the base manifests.",
                                            "selector": "#wiz-k8s-section-kustomize [style*=\"padding:0.1rem\"]",
                                            "nameSelector": "code"
                                        },
                                        "children": []
                                    },
                                    {
                                        "id": "k8s-section-envs",
                                        "title": "Environments",
                                        "icon": "ğŸŒ±",
                                        "selector": "#wiz-k8s-section-envs",
                                        "content": "Detected environments from Kustomize overlays and Helm values files â€” each targets a different deployment stage.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸŒ± Detected Environments</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Each pill represents a detected environment target. Sources:</div><div class=\"state-grid\"><span class=\"state-key\">Kustomize overlay</span><span>a directory under overlays/ with its own kustomization.yaml</span><span class=\"state-key\">Helm values file</span><span>values-&lt;env&gt;.yaml with environment-specific overrides</span></div><div class=\"state-text\">Environments let you deploy the same application with different configuration â€” smaller replicas in dev, more resources and strict policies in prod.</div></div></div>",
                                        "children": []
                                    },
                                    {
                                        "id": "k8s-section-infra",
                                        "title": "Infra Dependencies",
                                        "icon": "ğŸ—",
                                        "selector": "#wiz-k8s-section-infra",
                                        "content": "Infrastructure services detected in your K8s manifests â€” databases, caches, and other backing services your application depends on.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ— Infrastructure Dependencies</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">These are backing services detected in your manifests â€” each appears as a Deployment, StatefulSet, or Service with a recognizable image.</div><div class=\"state-text\">In production K8s, consider:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Managed services (RDS, Cloud SQL) instead of in-cluster databases</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Operators for stateful workloads (PostgreSQL Operator, Redis Operator)</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ PersistentVolumeClaims for any data that must survive pod restarts</div></div></div>",
                                        "children": []
                                    },
                                    {
                                        "id": "k8s-section-live",
                                        "title": "Live Cluster",
                                        "icon": "ğŸ–¥",
                                        "selector": "#wiz-k8s-section-live",
                                        "content": "Live cluster inspection â€” query running pods, services, deployments, and validate manifest readiness against the connected cluster.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ–¥ Live Cluster Panel</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">This panel queries your connected K8s cluster in real time. Click a button to fetch current state:</div><div class=\"state-grid\"><span class=\"state-key\">ğŸ“¦ Pods</span><span>running containers â€” status, restarts, age, node placement</span><span class=\"state-key\">ğŸŒ Services</span><span>network endpoints â€” type, cluster IP, external IP, ports</span><span class=\"state-key\">ğŸš€ Deployments</span><span>desired vs ready replicas, rollout status, revision history</span><span class=\"state-key\">âœ… Validate</span><span>dry-run apply of your manifests â€” catches errors before real deployment</span><span class=\"state-key\">ğŸ–¥ Cluster</span><span>node count, Kubernetes version, resource capacity</span></div><div class=\"state-text\">Data is fetched fresh each time â€” reflects actual cluster state, not cached detection.</div></div></div>",
                                        "children": []
                                    },
                                    {
                                        "id": "k8s-section-genconfig",
                                        "title": "Generate Manifests",
                                        "icon": "ğŸ“",
                                        "selector": "#wiz-k8s-section-genconfig",
                                        "content": "Basic manifest generation â€” creates a Deployment + Service YAML from the fields below. For complex setups, use Full K8s Setup.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“ Basic Manifest Generation</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">This form generates a minimal Deployment + Service pair. Fill in the fields and hit Apply.</div><div class=\"state-grid\"><span class=\"state-key\">App Name</span><span>used for metadata.name, labels, and selectors across both resources</span><span class=\"state-key\">Container Image</span><span>the Docker image to deploy â€” must be pullable from the cluster</span><span class=\"state-key\">Container Port</span><span>the port your app listens on inside the container</span><span class=\"state-key\">Replicas</span><span>number of pod instances â€” more replicas = higher availability</span><span class=\"state-key\">Namespace</span><span>K8s namespace to deploy into â€” 'default' if unset</span><span class=\"state-key\">Service Type</span><span>ClusterIP (internal), NodePort (node access), LoadBalancer (external)</span></div><div class=\"state-text\">If your project uses Helm charts, Kustomize overlays, or has multiple modules, use ğŸš€ Full K8s Setup below for comprehensive per-service configuration.</div></div></div>",
                                        "children": [
                                            {
                                                "id": "k8s-field-name",
                                                "title": "App Name",
                                                "icon": "ğŸ·ï¸",
                                                "selector": "#wiz-k8s-name",
                                                "content": "The application name â€” used in metadata.name for the Deployment, Service, and all label selectors. Keep it lowercase with hyphens.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ·ï¸ App Name</div><div class=\"state-detail\">This value becomes metadata.name in your K8s resources and is used in label selectors (app: your-name) that tie Deployments to Services.<br><br>Conventions: lowercase, hyphens not underscores, max 63 characters. Example: my-api, payment-service, frontend.</div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "k8s-field-image",
                                                "title": "Container Image",
                                                "icon": "ğŸ³",
                                                "selector": "#wiz-k8s-image",
                                                "content": "The Docker image to deploy. Must be pullable from the cluster â€” either a public registry or one your cluster has credentials for.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ³ Container Image</div><div class=\"state-detail\">The image reference goes into spec.containers[].image. Format: registry/name:tag<br><br>Examples:<br>â€¢ myapp:latest (local/default registry)<br>â€¢ ghcr.io/org/myapp:v1.2.3 (GitHub Container Registry)<br>â€¢ 123456789.dkr.ecr.us-east-1.amazonaws.com/myapp:latest (AWS ECR)<br><br>Use a specific tag (not 'latest') in production for reproducible deployments.</div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "k8s-field-port",
                                                "title": "Container Port",
                                                "icon": "ğŸ”Œ",
                                                "selector": "#wiz-k8s-port",
                                                "content": "The port your application listens on inside the container. Must match the EXPOSE directive in your Dockerfile.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ”Œ Container Port</div><div class=\"state-detail\">This port is used in both the Deployment's containerPort and the Service's targetPort.<br><br>Common ports by stack:<br>â€¢ 5000/8000 â€” Python (Flask/FastAPI/Django)<br>â€¢ 3000 â€” Node.js (Express/Next.js)<br>â€¢ 8080 â€” Go / Java / generic<br>â€¢ 4000 â€” Elixir Phoenix<br><br>The Service routes traffic from its port to this containerPort.</div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "k8s-field-replicas",
                                                "title": "Replicas",
                                                "icon": "ğŸ“Š",
                                                "selector": "#wiz-k8s-replicas",
                                                "content": "How many pod instances to run. More replicas = higher availability but more resource consumption.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“Š Replica Count</div><div class=\"state-detail\">spec.replicas in the Deployment. Kubernetes maintains exactly this many pods running at all times.<br><br>Guidelines:<br>â€¢ 1 â€” development/testing<br>â€¢ 2-3 â€” staging and small production workloads<br>â€¢ 3+ â€” production with high availability requirements<br><br>For auto-scaling, use HPA (HorizontalPodAutoscaler) instead of a fixed count â€” it adjusts replicas based on CPU/memory metrics.</div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "k8s-field-namespace",
                                                "title": "Namespace",
                                                "icon": "ğŸ“‚",
                                                "selector": "#wiz-k8s-namespace",
                                                "content": "The K8s namespace to deploy into. Namespaces isolate resources â€” use different ones for dev, staging, and production.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“‚ Namespace</div><div class=\"state-detail\">metadata.namespace in all generated resources. Namespaces are virtual clusters within a physical cluster.<br><br>Conventions:<br>â€¢ 'default' â€” fine for learning and single-app clusters<br>â€¢ project-name â€” isolate by project<br>â€¢ dev / staging / prod â€” isolate by environment<br><br>Resources in different namespaces are isolated â€” a Service in namespace A can't reach pods in namespace B without the full DNS name (svc.namespace.svc.cluster.local).</div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "k8s-field-service-type",
                                                "title": "Service Type",
                                                "icon": "ğŸŒ",
                                                "selector": "#wiz-k8s-service-type",
                                                "content": "How the Service is exposed. ClusterIP (internal only), NodePort (via node IP), or LoadBalancer (external IP from cloud provider).",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸŒ Service Type</div><div class=\"state-detail\" class=\"state-wrap\"><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.25rem 0.4rem;margin-top:0.3rem;font-size:0.73rem\"><span class=\"state-key\">ClusterIP</span><span>internal only â€” reachable from inside the cluster. Use with Ingress for external HTTP traffic. <strong>Default and recommended.</strong></span><span class=\"state-key\">NodePort</span><span>exposes on every node at a static port (30000-32767). Useful for development and on-prem clusters without a load balancer.</span><span class=\"state-key\">LoadBalancer</span><span>provisions a cloud load balancer (AWS ALB/NLB, GCP LB, Azure LB). Each costs money. Use sparingly â€” prefer Ingress to multiplex many services behind one LB.</span></div></div></div>",
                                                "children": []
                                            }
                                        ]
                                    },
                                    {
                                        "id": "k8s-section-fullsetup",
                                        "title": "Full K8s Setup",
                                        "icon": "ğŸš€",
                                        "selector": "#wiz-k8s-section-fullsetup",
                                        "content": "Full multi-step K8s wizard â€” per-service Deployments, Helm chart generation, Skaffold configuration, HPA autoscaling, and live preview.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸš€ Full K8s Setup</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">The full setup wizard provides comprehensive K8s configuration beyond the basic Deployment + Service pair. It covers:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Per-module Deployments with resource limits and health probes</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Environment variables from vault (secrets integration)</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Helm chart scaffolding with values templates</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Skaffold configuration for local dev/deploy workflows</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Volume and PVC management</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ HPA autoscaling configuration</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Live preview and editing of generated YAML</div><div class=\"state-text\">Use this when your project has multiple services, needs Helm charts, or requires production-grade configurations with probes and resource limits.</div></div></div>",
                                        "children": [
                                            {
                                                "id": "k8s-fullsetup-pill-resources",
                                                "title": "Resources Detected",
                                                "icon": "ğŸ“¦",
                                                "selector": "#wiz-k8s-fullsetup-pill-resources",
                                                "content": "Existing K8s resources detected in the project â€” the full setup will extend or replace these.",
                                                "children": []
                                            },
                                            {
                                                "id": "k8s-fullsetup-pill-kubectl",
                                                "title": "kubectl",
                                                "icon": "â˜¸ï¸",
                                                "selector": "#wiz-k8s-fullsetup-pill-kubectl",
                                                "content": "kubectl availability â€” required for applying generated manifests to a cluster.",
                                                "children": []
                                            },
                                            {
                                                "id": "k8s-fullsetup-pill-helm",
                                                "title": "Helm Charts",
                                                "icon": "âˆ",
                                                "selector": "#wiz-k8s-fullsetup-pill-helm",
                                                "content": "Existing Helm charts â€” the full setup can generate new charts or extend existing ones.",
                                                "children": []
                                            },
                                            {
                                                "id": "k8s-fullsetup-pill-kustomize",
                                                "title": "Kustomize",
                                                "icon": "ğŸ—‚",
                                                "selector": "#wiz-k8s-fullsetup-pill-kustomize",
                                                "content": "Kustomize detection â€” the full setup can generate base manifests with overlay structure.",
                                                "children": []
                                            },
                                            {
                                                "id": "k8s-fullsetup-pill-docker",
                                                "title": "Docker Ready",
                                                "icon": "ğŸ³",
                                                "selector": "#wiz-k8s-fullsetup-pill-docker",
                                                "content": "Docker availability â€” needed to build container images that K8s will deploy.",
                                                "children": []
                                            }
                                        ]
                                    },
                                    {
                                        "id": "k8s-section-delete",
                                        "title": "Delete Manifests",
                                        "icon": "ğŸ—‘",
                                        "selector": "#wiz-k8s-section-delete",
                                        "content": "Remove generated K8s manifest files from your project. Does not affect running cluster resources.",
                                        "expanded": "<div class=\"assistant-state-card state-error\"><div class=\"state-label\">ğŸ—‘ Delete K8s Manifests</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Removes K8s manifest files that were generated by the control plane.</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">This will delete:</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;font-size:0.75rem\"><span class=\"state-key\">k8s/ directory</span><span>all generated YAML manifests</span></div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">This will NOT:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Delete any resources running on your cluster</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Touch Helm charts or Kustomize overlays you created manually</div><div class=\"state-text\">After deletion, you can regenerate manifests at any time with the config form or Full Setup.</div></div></div>",
                                        "children": []
                                    },
                                    {
                                        "id": "k8s-apply",
                                        "title": "Apply",
                                        "icon": "âœ…",
                                        "selector": "#wiz-apply-k8s",
                                        "content": "Generate K8s manifest files with the settings from the config form above.",
                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Apply K8s Config</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Clicking Apply generates Kubernetes manifest files based on the form values:</div><div class=\"state-grid\"><span class=\"state-key\">deployment.yaml</span><span>Deployment with the specified image, port, replicas, and namespace</span><span class=\"state-key\">service.yaml</span><span>Service with the specified type routing to the container port</span></div><div class=\"state-text\">Files are created in the k8s/ directory. The generated YAML is standard Kubernetes â€” you can edit it manually at any time.</div></div></div>",
                                        "children": []
                                    },
                                    {
                                        "id": "k8s-cancel",
                                        "title": "Cancel",
                                        "icon": "âœ–",
                                        "selector": "#wiz-cancel-k8s",
                                        "content": "Close the K8s setup panel without generating any files. No changes are made.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">âœ– Discard</div><div class=\"state-detail\">Cancel collapses the K8s setup panel without generating any files or modifying any existing configuration.<br><br>Reopen anytime with âš™ï¸ Setup â€” all form fields repopulate from the current project state and stack detection.</div></div>",
                                        "children": []
                                    }
                                ]
                            }
                        ]
                    },
                    {
                        "id": "terraform-card",
                        "title": "Terraform",
                        "icon": "ğŸ—ï¸",
                        "selector": "#wiz-int-wrap-terraform",
                        "content": "Infrastructure as Code â€” provision and manage cloud resources from declarative HCL configurations.",
                        "variants": [
                            {
                                "when": {
                                    "textContains": "âœ“ initialized"
                                },
                                "content": "Terraform is initialized with {{tfResources}} resource(s) across {{tfProviders}} provider(s). State is tracked and infrastructure operations are available.",
                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ—ï¸ Terraform Â· initialized</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Your Terraform environment is fully operational:</div><div class=\"state-grid\"><span class=\"state-key\">CLI</span><span>terraform available and working</span><span class=\"state-key\">State</span><span>initialized â€” terraform plan/apply ready</span><span class=\"state-key\">Resources</span><span>{{tfResources}} declared resource(s)</span><span class=\"state-key\">Providers</span><span>{{tfProviders}} configured provider(s)</span></div><div class=\"state-text\">With an initialized state, you can run terraform plan to preview changes and terraform apply to provision infrastructure. The Live panel buttons above run these operations directly.</div></div></div>"
                            },
                            {
                                "when": {
                                    "textContains": "â—‹ no resources"
                                },
                                "content": "Terraform CLI is available but no resources are declared. Use the config form or Full Setup to scaffold your infrastructure.",
                                "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">ğŸ—ï¸ Terraform Â· no resources</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Terraform is installed but no infrastructure resources are defined yet. Without resources:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ— Nothing to plan or apply</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ— No state to track</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Can scaffold new configurations</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Can import existing infrastructure</div><div class=\"state-text\">Use <strong>ğŸ“ Generate Config</strong> for a quick starter, or <strong>ğŸš€ Full Setup</strong> for comprehensive multi-provider IaC scaffolding.</div></div></div>"
                            },
                            {
                                "when": {
                                    "textContains": "âœ— no terraform"
                                },
                                "content": "Terraform CLI is not installed. Install it to enable infrastructure-as-code management.",
                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ—ï¸ Terraform Â· CLI missing</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Terraform is not detected on this system. Without it:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ— Cannot plan or apply infrastructure changes</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ— Cannot inspect state or workspaces</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Can still generate HCL configuration files</div><div class=\"state-text\">The control plane can generate .tf files without the CLI â€” they'll be ready when Terraform is installed.</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">To install:</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;font-size:0.75rem\"><span class=\"state-key\">Snap</span><span>sudo snap install terraform --classic</span><span class=\"state-key\">Homebrew</span><span>brew install hashicorp/tap/terraform</span><span class=\"state-key\">Binary</span><span>https://developer.hashicorp.com/terraform/install</span></div></div></div>"
                            }
                        ],
                        "expanded": "",
                        "children": [
                            {
                                "id": "tf-setup",
                                "title": "Terraform Setup Panel",
                                "icon": "âš™ï¸",
                                "selector": "#wiz-int-setup-terraform",
                                "content": "Terraform integration setup â€” provider configuration, state backend, resource analysis, and live infrastructure operations.",
                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ—ï¸ Terraform Setup</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">This panel manages your project's Terraform configuration. It covers:</div><div class=\"state-grid\"><span class=\"state-key\">Files</span><span>.tf files â€” main.tf, variables.tf, outputs.tf, providers.tf, backend.tf</span><span class=\"state-key\">Providers</span><span>cloud platforms â€” AWS, GCP, Azure, DigitalOcean, and 3000+ others</span><span class=\"state-key\">Modules</span><span>reusable infrastructure blocks â€” from the Terraform Registry or local paths</span><span class=\"state-key\">State</span><span>tracks what's deployed â€” local file or remote backend (S3, GCS, Azure Blob)</span><span class=\"state-key\">Live Ops</span><span>state inspection, workspace management, validation, and output viewing</span></div><div class=\"state-text\">Unlike K8s (which schedules containers), Terraform provisions the underlying infrastructure â€” VPCs, load balancers, databases, DNS records, and the clusters themselves.</div></div></div>",
                                "children": [
                                    {
                                        "id": "tf-section-status",
                                        "title": "Status Strip",
                                        "icon": "ğŸ“Š",
                                        "selector": "#wiz-tf-section-status",
                                        "content": "Seven status pills showing Terraform CLI, resource count, providers, modules, backend, initialization state, and config detection.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“Š Terraform Status Strip</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-grid\"><span class=\"state-key\">terraform</span><span>whether the Terraform CLI is available and its version</span><span class=\"state-key\">resources</span><span>total declared resources across all .tf files</span><span class=\"state-key\">providers</span><span>configured cloud providers (aws, google, azurerm, etc.)</span><span class=\"state-key\">modules</span><span>reusable infrastructure modules (registry or local)</span><span class=\"state-key\">backend</span><span>where terraform state is stored (local, s3, gcs, azurerm)</span><span class=\"state-key\">initialized</span><span>whether terraform init has been run successfully</span><span class=\"state-key\">config</span><span>whether any .tf configuration files exist in the project</span></div></div></div>",
                                        "children": [
                                            {
                                                "id": "tf-pill-cli",
                                                "title": "Terraform CLI",
                                                "icon": "ğŸ—ï¸",
                                                "selector": "#wiz-tf-pill-cli",
                                                "content": "Terraform CLI â€” the core tool for planning and applying infrastructure changes.",
                                                "variants": [
                                                    {
                                                        "when": {
                                                            "textContains": "âœ“ terraform"
                                                        },
                                                        "content": "Terraform CLI is installed and available. All commands (init, plan, apply, destroy) are operational.",
                                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ—ï¸ Terraform CLI Â· installed</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Terraform is ready. You can run all lifecycle commands:</div><div class=\"state-grid\"><span style=\"font-weight:600;color:var(--success)\">init</span><span>download providers and configure backend</span><span style=\"font-weight:600;color:var(--success)\">plan</span><span>preview infrastructure changes</span><span style=\"font-weight:600;color:var(--success)\">apply</span><span>create/update/delete real infrastructure</span><span style=\"font-weight:600;color:var(--success)\">destroy</span><span>tear down all managed resources</span></div></div></div>"
                                                    },
                                                    {
                                                        "when": {
                                                            "textContains": "âœ— no terraform"
                                                        },
                                                        "content": "Terraform CLI is not installed. Install it to manage infrastructure as code.",
                                                        "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">ğŸ—ï¸ Terraform CLI Â· missing</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Terraform is not found on this system. Without it, you cannot init, plan, or apply infrastructure.</div><div class=\"state-text\"><strong>Install:</strong></div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;margin:0.3rem 0;font-size:0.73rem\"><span class=\"state-key\">macOS</span><span>brew install terraform</span><span class=\"state-key\">Linux</span><span>apt install terraform (or download from releases.hashicorp.com)</span><span class=\"state-key\">Manual</span><span>releases.hashicorp.com/terraform â€” single binary, add to PATH</span></div></div></div>"
                                                    }
                                                ],
                                                "children": []
                                            },
                                            {
                                                "id": "tf-pill-resources",
                                                "title": "Resources",
                                                "icon": "ğŸ“¦",
                                                "selector": "#wiz-tf-pill-resources",
                                                "content": "Total declared Terraform resources â€” each maps to a real cloud object.",
                                                "variants": [
                                                    {
                                                        "when": {
                                                            "textContains": "âœ“"
                                                        },
                                                        "content": "Resources detected in your .tf files â€” each one maps to a real cloud infrastructure object managed by Terraform.",
                                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ“¦ Resources Â· detected</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Your Terraform config declares resources. Each <code>resource</code> block maps 1:1 to a real infrastructure object (VM, bucket, database, etc.).</div><div class=\"state-text\">Run <code>terraform plan</code> to preview what will be created, modified, or destroyed. Run <code>terraform apply</code> to execute.</div></div></div>"
                                                    },
                                                    {
                                                        "when": {
                                                            "textContains": "â—‹ no resources"
                                                        },
                                                        "content": "No resources declared yet. Add resource blocks to your .tf files to define infrastructure.",
                                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“¦ Resources Â· none</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">No resource blocks found in your .tf files. Resources are how you declare infrastructure:</div><div style=\"margin:0.3rem 0;font-size:0.73rem\"><code>resource \"aws_instance\" \"web\" {<br>&nbsp;&nbsp;ami = \"ami-0c55b159\"<br>&nbsp;&nbsp;instance_type = \"t2.micro\"<br>}</code></div><div class=\"state-text\">Use the config generator below or the Full Setup wizard to scaffold resources for your chosen provider.</div></div></div>"
                                                    }
                                                ],
                                                "children": []
                                            },
                                            {
                                                "id": "tf-pill-providers",
                                                "title": "Providers",
                                                "icon": "â˜",
                                                "selector": "#wiz-tf-pill-providers",
                                                "content": "Configured cloud providers â€” each provider plugin enables Terraform to manage resources on that platform.",
                                                "variants": [
                                                    {
                                                        "when": {
                                                            "textContains": "âœ“"
                                                        },
                                                        "content": "Cloud providers are configured â€” Terraform can connect to these platforms and manage their resources.",
                                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">â˜ Providers Â· configured</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Provider plugins are declared in your .tf files. After <code>terraform init</code>, they're downloaded to <code>.terraform/providers/</code>.</div><div class=\"state-text\">Expand the â˜ Providers section below to see which platforms are configured and hover each for details.</div></div></div>"
                                                    },
                                                    {
                                                        "when": {
                                                            "textContains": "â—‹ no providers"
                                                        },
                                                        "content": "No providers configured. Add a provider block to connect Terraform to a cloud platform.",
                                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â˜ Providers Â· none</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">No provider blocks found. A provider tells Terraform which cloud to manage:</div><div style=\"margin:0.3rem 0;font-size:0.73rem\"><code>provider \"aws\" {<br>&nbsp;&nbsp;region = \"us-east-1\"<br>}</code></div><div class=\"state-text\">Use the config generator below to scaffold a provider for AWS, GCP, Azure, or DigitalOcean.</div></div></div>"
                                                    }
                                                ],
                                                "children": []
                                            },
                                            {
                                                "id": "tf-pill-modules",
                                                "title": "Modules",
                                                "icon": "ğŸ“¦",
                                                "selector": "#wiz-tf-pill-modules",
                                                "content": "Terraform modules â€” reusable infrastructure blocks.",
                                                "variants": [
                                                    {
                                                        "when": {
                                                            "textContains": "âœ“"
                                                        },
                                                        "content": "Modules detected â€” your config uses reusable infrastructure packages. Expand the ğŸ“¦ Modules section for per-module analysis.",
                                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ“¦ Modules Â· in use</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Your Terraform config references modules. These are reusable packages that encapsulate resources with configurable inputs.</div><div class=\"state-text\">Expand the ğŸ“¦ Modules section below and hover each module for source type analysis (registry, git, or local).</div></div></div>"
                                                    },
                                                    {
                                                        "when": {
                                                            "textContains": "â—‹ no modules"
                                                        },
                                                        "content": "No modules in use. Modules are optional but recommended for organizing complex infrastructure.",
                                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“¦ Modules Â· none</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">No module blocks found. Modules are optional â€” simple projects work fine without them.</div><div class=\"state-text\">Consider modules when:<br>â€¢ You repeat similar resource patterns<br>â€¢ You need the same infra in multiple environments<br>â€¢ You want to use community-maintained best practices from registry.terraform.io</div></div></div>"
                                                    }
                                                ],
                                                "children": []
                                            },
                                            {
                                                "id": "tf-pill-backend",
                                                "title": "Backend",
                                                "icon": "ğŸ’¾",
                                                "selector": "#wiz-tf-pill-backend",
                                                "content": "State backend â€” where Terraform state is stored.",
                                                "variants": [
                                                    {
                                                        "when": {
                                                            "textContains": "âœ“"
                                                        },
                                                        "content": "A state backend is configured â€” Terraform knows where to store and lock its state file.",
                                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ’¾ Backend Â· configured</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">A backend is configured for state storage. Terraform state tracks the mapping between your .tf declarations and real infrastructure.</div><div class=\"state-text\">Remote backends (s3, gcs, azurerm) enable team collaboration with state locking â€” preventing concurrent applies that could corrupt state.</div></div></div>"
                                                    },
                                                    {
                                                        "when": {
                                                            "textContains": "â—‹ no backend"
                                                        },
                                                        "content": "No backend configured â€” state defaults to a local terraform.tfstate file.",
                                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ’¾ Backend Â· default (local)</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">No explicit backend is configured. Terraform defaults to storing state in a local <code>terraform.tfstate</code> file.</div><div class=\"state-text\">This is fine for solo development. For teams, configure a remote backend:</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;margin:0.3rem 0;font-size:0.73rem\"><span class=\"state-key\">s3</span><span>AWS S3 + DynamoDB locking</span><span class=\"state-key\">gcs</span><span>Google Cloud Storage</span><span class=\"state-key\">azurerm</span><span>Azure Blob Storage</span></div><div class=\"state-text\">âš  Never commit terraform.tfstate to Git â€” it may contain secrets.</div></div></div>"
                                                    }
                                                ],
                                                "children": []
                                            },
                                            {
                                                "id": "tf-pill-initialized",
                                                "title": "Initialized",
                                                "icon": "ğŸ”„",
                                                "selector": "#wiz-tf-pill-initialized",
                                                "content": "Initialization state â€” whether terraform init has been run.",
                                                "variants": [
                                                    {
                                                        "when": {
                                                            "textContains": "âœ“ initialized"
                                                        },
                                                        "content": "Project is initialized â€” providers are downloaded, backend is configured, and you can run plan/apply.",
                                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ”„ Initialized Â· ready</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">terraform init has completed successfully. The .terraform/ directory contains:</div><div class=\"state-text\">â€¢ Provider plugins (downloaded binaries)<br>â€¢ Module sources (if any)<br>â€¢ Backend configuration</div><div class=\"state-text\">You can now run <code>terraform plan</code> and <code>terraform apply</code>. Re-run init when adding providers, modules, or changing backends.</div></div></div>"
                                                    },
                                                    {
                                                        "when": {
                                                            "textContains": "â—‹ not initialized"
                                                        },
                                                        "content": "Project is not initialized â€” run terraform init before plan or apply.",
                                                        "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">ğŸ”„ Not Initialized</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">terraform init has not been run yet. This is required before any other command.</div><div class=\"state-text\">terraform init will:<br>â€¢ Download provider plugins to .terraform/<br>â€¢ Configure the state backend<br>â€¢ Download referenced modules<br>â€¢ Create .terraform.lock.hcl</div><div class=\"state-text\">Run: <code>cd terraform/ && terraform init</code></div></div></div>"
                                                    }
                                                ],
                                                "children": []
                                            },
                                            {
                                                "id": "tf-pill-config",
                                                "title": "Config",
                                                "icon": "ğŸ“„",
                                                "selector": "#wiz-tf-pill-config",
                                                "content": "Config detection â€” whether .tf files exist.",
                                                "variants": [
                                                    {
                                                        "when": {
                                                            "textContains": "âœ“ config found"
                                                        },
                                                        "content": "Terraform configuration files detected in your project. Expand the ğŸ“„ Files section for per-file analysis.",
                                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ“„ Config Â· found</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">.tf files are present in your project. Terraform will process all .tf files in the working directory.</div><div class=\"state-text\">Expand the ğŸ“„ Files section to see each file categorized by type (resource, variable, output, provider, etc.) with hover-level analysis.</div></div></div>"
                                                    },
                                                    {
                                                        "when": {
                                                            "textContains": "â—‹ no config"
                                                        },
                                                        "content": "No .tf files found. Use the config generator below to scaffold a starter Terraform project.",
                                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“„ Config Â· none</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">No .tf files found in the project. You need at least one .tf file to use Terraform.</div><div class=\"state-text\">Use the ğŸ“ Generate Config form below to create a starter project, or the ğŸš€ Full Setup for comprehensive scaffolding.</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.25rem 0.4rem;margin-top:0.3rem;font-size:0.73rem\"><span class=\"state-key\">main.tf</span><span>primary resource definitions</span><span class=\"state-key\">variables.tf</span><span>input variable declarations</span><span class=\"state-key\">outputs.tf</span><span>values exported after apply</span></div></div></div>"
                                                    }
                                                ],
                                                "children": []
                                            }
                                        ]
                                    },
                                    {
                                        "id": "tf-section-files",
                                        "title": "Files",
                                        "icon": "ğŸ“„",
                                        "selector": "#wiz-tf-section-files",
                                        "content": ".tf file analysis â€” each file is categorized by type (resource, variable, output, provider, data, module, backend).",
                                        "expanded": "<div class=\"assistant-state-card state-info\" style=\"margin-bottom:0.5rem\"><div class=\"state-label\">ğŸ“„ Terraform Files</div><div class=\"state-detail\" class=\"state-wrap\">Each .tf file is parsed and categorized. Hover individual files for per-file analysis.</div></div><div class=\"assistant-state-card state-info\" style=\"margin-top:0.6rem;margin-bottom:0.4rem\"><div class=\"state-label\">ğŸ“‚ File Types</div><div class=\"state-detail\" class=\"state-wrap\"><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.25rem 0.4rem;margin-top:0.3rem;font-size:0.73rem\"><span class=\"state-key\">resource</span><span>declares infrastructure objects (aws_instance, google_compute_network, etc.)</span><span class=\"state-key\">variable</span><span>input parameters â€” make configs reusable across environments</span><span class=\"state-key\">output</span><span>exports values after apply â€” IP addresses, URLs, ARNs</span><span class=\"state-key\">provider</span><span>configures cloud API connections â€” credentials, region, features</span><span class=\"state-key\">data</span><span>reads existing infrastructure â€” lookup AMIs, VPCs, DNS zones</span><span class=\"state-key\">module</span><span>imports reusable infrastructure packages</span><span class=\"state-key\">backend</span><span>configures where state is stored</span></div></div></div>",
                                        "dynamic": true,
                                        "childTemplate": {
                                            "title": "ğŸ“„ {{name}}",
                                            "content": "Terraform file {{name}} â€” hover for file type and contents analysis.",
                                            "selector": "#wiz-tf-section-files [style*=\"border-bottom\"]",
                                            "nameSelector": "code"
                                        },
                                        "children": []
                                    },
                                    {
                                        "id": "tf-section-providers",
                                        "title": "Providers",
                                        "icon": "â˜",
                                        "selector": "#wiz-tf-section-providers",
                                        "content": "Configured cloud providers â€” each plugin enables Terraform to manage resources on that platform.",
                                        "expanded": "<div class=\"assistant-state-card state-info\" style=\"margin-bottom:0.5rem\"><div class=\"state-label\">â˜ Provider Analysis</div><div class=\"state-detail\" class=\"state-wrap\">Each provider connects Terraform to a cloud API. Hover individual providers for platform-specific guidance.</div></div><div class=\"assistant-state-card state-info\" style=\"margin-top:0.6rem;margin-bottom:0.4rem\"><div class=\"state-label\">ğŸ”‘ Authentication</div><div class=\"state-detail\" class=\"state-wrap\"><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.25rem 0.4rem;margin-top:0.3rem;font-size:0.73rem\"><span class=\"state-key\">AWS</span><span>AWS_ACCESS_KEY_ID + AWS_SECRET_ACCESS_KEY or IAM role</span><span class=\"state-key\">GCP</span><span>GOOGLE_APPLICATION_CREDENTIALS or gcloud auth application-default login</span><span class=\"state-key\">Azure</span><span>az login or service principal (ARM_CLIENT_ID, ARM_CLIENT_SECRET)</span></div><div style=\"margin-top:0.3rem;font-size:0.73rem\">Never hardcode credentials in .tf files â€” use environment variables or provider-specific auth chains.</div></div></div>",
                                        "dynamic": true,
                                        "childTemplate": {
                                            "title": "â˜ {{name}}",
                                            "content": "Terraform provider {{name}} â€” hover for provider capabilities and resource types.",
                                            "selector": "#wiz-tf-section-providers [style*=\"border-bottom\"]",
                                            "nameSelector": "code"
                                        },
                                        "children": []
                                    },
                                    {
                                        "id": "tf-section-modules",
                                        "title": "Modules",
                                        "icon": "ğŸ“¦",
                                        "selector": "#wiz-tf-section-modules",
                                        "content": "Terraform modules â€” reusable infrastructure packages with configurable inputs.",
                                        "expanded": "<div class=\"assistant-state-card state-info\" style=\"margin-bottom:0.5rem\"><div class=\"state-label\">ğŸ“¦ Module Analysis</div><div class=\"state-detail\" class=\"state-wrap\">Modules package related resources into reusable units. Hover individual modules for source and structure analysis.</div></div><div class=\"assistant-state-card state-info\" style=\"margin-top:0.6rem;margin-bottom:0.4rem\"><div class=\"state-label\">ğŸ“ Module Structure</div><div class=\"state-detail\" class=\"state-wrap\"><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.25rem 0.4rem;margin-top:0.3rem;font-size:0.73rem\"><span class=\"state-key\">source</span><span>where the module code lives (registry, git, local path)</span><span class=\"state-key\">version</span><span>pinned version constraint (e.g. \"~&gt; 3.0\")</span><span class=\"state-key\">inputs</span><span>variables passed into the module</span><span class=\"state-key\">outputs</span><span>values exported by the module for use elsewhere</span></div></div></div>",
                                        "dynamic": true,
                                        "childTemplate": {
                                            "title": "ğŸ“¦ {{name}}",
                                            "content": "Module {{name}} â€” hover for source analysis and input/output details.",
                                            "selector": "#wiz-tf-section-modules [style*=\"border-bottom\"]",
                                            "nameSelector": "strong"
                                        },
                                        "children": []
                                    },
                                    {
                                        "id": "tf-section-resources",
                                        "title": "Resources",
                                        "icon": "ğŸ“¦",
                                        "selector": "#wiz-tf-section-resources",
                                        "content": "Declared resources grouped by type â€” each maps to a real cloud infrastructure object.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“¦ Resource Summary</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Resources are grouped by their Terraform type (e.g. aws_instance, google_compute_network). Each chip shows the type and count.</div><div class=\"state-text\">The type name follows the pattern: <code style=\"font-size:0.68rem\">provider_service_object</code>. For example:<br>â€¢ <strong>aws_s3_bucket</strong> = AWS â†’ S3 â†’ Bucket<br>â€¢ <strong>google_compute_instance</strong> = GCP â†’ Compute â†’ Instance<br>â€¢ <strong>azurerm_virtual_network</strong> = Azure â†’ Virtual Network</div><div class=\"state-text\">Review the distribution to understand your infrastructure footprint â€” heavy concentration in one type may indicate refactoring opportunities via modules.</div></div></div>",
                                        "children": []
                                    },
                                    {
                                        "id": "tf-section-backend",
                                        "title": "State Backend",
                                        "icon": "ğŸ’¾",
                                        "selector": "#wiz-tf-section-backend",
                                        "content": "Where Terraform state is stored â€” tracks the mapping between your .tf declarations and real infrastructure.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ’¾ State Backend</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Terraform state is critical â€” it's the source of truth for what infrastructure exists. Without state, Terraform can't know what to update or destroy.</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.25rem 0.4rem;margin-top:0.3rem;font-size:0.73rem\"><span class=\"state-key\">local</span><span>terraform.tfstate on disk â€” simple but not collaborative</span><span class=\"state-key\">s3</span><span>S3 bucket + DynamoDB for locking â€” team-safe on AWS</span><span class=\"state-key\">gcs</span><span>Google Cloud Storage â€” team-safe on GCP</span><span class=\"state-key\">azurerm</span><span>Azure Blob Storage â€” team-safe on Azure</span></div><div class=\"state-text\">âš  Never commit terraform.tfstate to Git â€” it may contain secrets. Use a remote backend for teams.</div></div></div>",
                                        "children": []
                                    },
                                    {
                                        "id": "tf-section-live",
                                        "title": "Live Operations",
                                        "icon": "ğŸ”§",
                                        "selector": "#wiz-tf-section-live",
                                        "content": "Live Terraform operations â€” state inspection, workspace management, config validation, and output viewing.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ”§ Live Operations</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-grid\"><span class=\"state-key\">ğŸ“‹ State</span><span>terraform state list â€” shows all managed resources and their addresses</span><span class=\"state-key\">ğŸ—ƒï¸ Workspaces</span><span>terraform workspace list â€” isolated state environments (dev/staging/prod)</span><span class=\"state-key\">âœ… Validate</span><span>terraform validate â€” checks HCL syntax and configuration consistency</span><span class=\"state-key\">ğŸ“§ Outputs</span><span>terraform output â€” shows exported values (IPs, URLs, connection strings)</span></div><div class=\"state-text\">These buttons run the corresponding Terraform commands against your project and display results in the panel below. Requires both terraform CLI and an initialized project.</div></div></div>",
                                        "children": []
                                    },
                                    {
                                        "id": "tf-section-genconfig",
                                        "title": "Generate Config",
                                        "icon": "ğŸ“",
                                        "selector": "#wiz-tf-section-genconfig",
                                        "content": "Quick config scaffolding â€” generates starter main.tf, variables.tf, and outputs.tf with your chosen provider and backend.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“ Config Generation</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">This form generates a minimal but complete Terraform starter:</div><div class=\"state-grid\"><span class=\"state-key\">main.tf</span><span>provider block + starter resource for the chosen platform</span><span class=\"state-key\">variables.tf</span><span>input variables for region, project name, and common settings</span><span class=\"state-key\">outputs.tf</span><span>placeholder output values</span></div><div class=\"state-text\">For projects with modules, multiple providers, or complex environments, use <strong>ğŸš€ Full Terraform Setup</strong> instead â€” it handles multi-environment configs, module scaffolding, and environment-specific variable files.</div></div></div>",
                                        "children": [
                                            {
                                                "id": "tf-field-provider",
                                                "title": "Provider",
                                                "icon": "â˜",
                                                "selector": "#wiz-tf-provider",
                                                "content": "Select a cloud provider for the generated config.",
                                                "variants": [
                                                    {
                                                        "when": {
                                                            "resolver": "tfProviderValue",
                                                            "equals": "aws"
                                                        },
                                                        "content": "AWS selected â€” generates provider block for Amazon Web Services.",
                                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸŸ§ Amazon Web Services</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">1000+ resource types. The most widely used Terraform provider.</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;margin:0.3rem 0;font-size:0.73rem\"><span class=\"state-key\">Auth</span><span>AWS_ACCESS_KEY_ID + AWS_SECRET_ACCESS_KEY or IAM role</span><span class=\"state-key\">Regions</span><span>us-east-1, eu-west-1, ap-southeast-1, etc.</span><span class=\"state-key\">Key resources</span><span>aws_instance, aws_s3_bucket, aws_lambda_function, aws_ecs_service</span></div></div></div>"
                                                    },
                                                    {
                                                        "when": {
                                                            "resolver": "tfProviderValue",
                                                            "equals": "google"
                                                        },
                                                        "content": "GCP selected â€” generates provider block for Google Cloud Platform.",
                                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ”µ Google Cloud Platform</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Strong in data, AI/ML, and managed Kubernetes (GKE).</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;margin:0.3rem 0;font-size:0.73rem\"><span class=\"state-key\">Auth</span><span>GOOGLE_APPLICATION_CREDENTIALS or gcloud auth application-default login</span><span class=\"state-key\">Regions</span><span>us-central1, europe-west1, asia-east1, etc.</span><span class=\"state-key\">Key resources</span><span>google_compute_instance, google_container_cluster, google_sql_database_instance</span></div></div></div>"
                                                    },
                                                    {
                                                        "when": {
                                                            "resolver": "tfProviderValue",
                                                            "equals": "azurerm"
                                                        },
                                                        "content": "Azure selected â€” generates provider block for Microsoft Azure.",
                                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ”· Microsoft Azure</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Enterprise-focused with strong Active Directory integration.</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;margin:0.3rem 0;font-size:0.73rem\"><span class=\"state-key\">Auth</span><span>az login or service principal (ARM_CLIENT_ID, ARM_CLIENT_SECRET)</span><span class=\"state-key\">Regions</span><span>eastus, westeurope, southeastasia, etc.</span><span class=\"state-key\">Key resources</span><span>azurerm_resource_group, azurerm_virtual_machine, azurerm_kubernetes_cluster</span></div></div></div>"
                                                    },
                                                    {
                                                        "when": {
                                                            "resolver": "tfProviderValue",
                                                            "equals": "digitalocean"
                                                        },
                                                        "content": "DigitalOcean selected â€” generates provider block for DigitalOcean.",
                                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ”µ DigitalOcean</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Developer-friendly cloud with simpler API and pricing.</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;margin:0.3rem 0;font-size:0.73rem\"><span class=\"state-key\">Auth</span><span>DIGITALOCEAN_TOKEN â€” API token from cloud.digitalocean.com</span><span class=\"state-key\">Regions</span><span>nyc1, sfo3, lon1, ams3, sgp1, etc.</span><span class=\"state-key\">Key resources</span><span>digitalocean_droplet, digitalocean_kubernetes_cluster, digitalocean_database_cluster</span></div></div></div>"
                                                    }
                                                ],
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â˜ Provider Selection</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Select the cloud platform for your generated Terraform config. Each provider determines the available resource types and authentication method.</div></div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "tf-field-region",
                                                "title": "Region",
                                                "icon": "ğŸŒ",
                                                "selector": "#wiz-tf-region",
                                                "content": "The cloud region â€” where infrastructure will be physically located.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸŒ Region</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">The region sets the physical datacenter location for your resources. Choose based on:</div><div class=\"state-text\">â€¢ <strong>Latency</strong> â€” closest to your users<br>â€¢ <strong>Compliance</strong> â€” data residency requirements (GDPR, etc.)<br>â€¢ <strong>Cost</strong> â€” some regions are cheaper<br>â€¢ <strong>Services</strong> â€” not all services available in all regions</div><div class=\"state-text\">Common: us-east-1 (AWS Virginia), us-central1 (GCP Iowa), eastus (Azure).</div></div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "tf-field-project",
                                                "title": "Project Name",
                                                "icon": "ğŸ·ï¸",
                                                "selector": "#wiz-tf-project",
                                                "content": "The project name â€” used in resource naming, tagging, and state file identification.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ·ï¸ Project Name</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Used as a prefix or tag for generated resources. Helps identify which project owns which infrastructure in shared accounts.</div><div class=\"state-text\">Conventions: lowercase, hyphens, max 20 characters. Example: my-api, payment-svc, infra-core.</div></div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "tf-field-backend",
                                                "title": "State Backend",
                                                "icon": "ğŸ’¾",
                                                "selector": "#wiz-tf-backend",
                                                "content": "Where Terraform state will be stored.",
                                                "variants": [
                                                    {
                                                        "when": {
                                                            "resolver": "tfBackendValue",
                                                            "equals": "local"
                                                        },
                                                        "content": "Local backend selected â€” state stored in terraform.tfstate on disk.",
                                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ’¾ Local Backend</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">State is stored in a local terraform.tfstate file. Simple and zero-setup.</div><div class=\"state-text\">âš  Not suitable for teams â€” no locking, no remote access, risk of state loss.</div><div class=\"state-text\">Never commit terraform.tfstate to Git â€” it may contain secrets.</div></div></div>"
                                                    },
                                                    {
                                                        "when": {
                                                            "resolver": "tfBackendValue",
                                                            "equals": "s3"
                                                        },
                                                        "content": "S3 backend selected â€” state stored in AWS S3 with DynamoDB locking.",
                                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ’¾ S3 Backend (AWS)</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">State stored in an S3 bucket with optional DynamoDB table for state locking.</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;margin:0.3rem 0;font-size:0.73rem\"><span class=\"state-key\">Bucket</span><span>S3 bucket with versioning enabled</span><span class=\"state-key\">Locking</span><span>DynamoDB table for state locking (prevents concurrent applies)</span><span class=\"state-key\">Encryption</span><span>Enable server-side encryption (SSE-S3 or SSE-KMS)</span></div></div></div>"
                                                    },
                                                    {
                                                        "when": {
                                                            "resolver": "tfBackendValue",
                                                            "equals": "gcs"
                                                        },
                                                        "content": "GCS backend selected â€” state stored in Google Cloud Storage.",
                                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ’¾ GCS Backend (GCP)</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">State stored in a Google Cloud Storage bucket with built-in locking.</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;margin:0.3rem 0;font-size:0.73rem\"><span class=\"state-key\">Bucket</span><span>GCS bucket with versioning enabled</span><span class=\"state-key\">Locking</span><span>Built-in â€” GCS provides native state locking</span><span class=\"state-key\">Auth</span><span>GOOGLE_APPLICATION_CREDENTIALS or gcloud auth</span></div></div></div>"
                                                    },
                                                    {
                                                        "when": {
                                                            "resolver": "tfBackendValue",
                                                            "equals": "azurerm"
                                                        },
                                                        "content": "Azure backend selected â€” state stored in Azure Blob Storage.",
                                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ’¾ Azure Backend</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">State stored in Azure Blob Storage with built-in locking via blob lease.</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;margin:0.3rem 0;font-size:0.73rem\"><span class=\"state-key\">Account</span><span>Azure Storage Account</span><span class=\"state-key\">Container</span><span>Blob container for state files</span><span class=\"state-key\">Auth</span><span>ARM_ACCESS_KEY or az login</span></div></div></div>"
                                                    }
                                                ],
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ’¾ State Backend</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Select where Terraform state will be stored. Each backend type determines how state is persisted and shared.</div></div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "tf-field-overwrite",
                                                "title": "Overwrite",
                                                "icon": "âš ",
                                                "selector": "#wiz-tf-overwrite",
                                                "content": "Whether to overwrite existing .tf files â€” only shown when config already exists.",
                                                "children": []
                                            }
                                        ]
                                    },
                                    {
                                        "id": "tf-section-fullsetup",
                                        "title": "Full Terraform Setup",
                                        "icon": "ğŸš€",
                                        "selector": "#wiz-tf-section-fullsetup",
                                        "content": "Full multi-step Terraform wizard â€” provider selection, backend configuration, resource definitions, environment management, and HCL editing.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸš€ Full Terraform Setup</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">The full setup wizard provides comprehensive IaC configuration beyond the basic starter. It covers:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Multi-provider configuration with version constraints</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Remote backend setup with locking</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Resource scaffolding with best-practice defaults</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Module integration from the Terraform Registry</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Environment-specific variable files (dev.tfvars, prod.tfvars)</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Workspace configuration for state isolation</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Live HCL preview and editing</div><div class=\"state-text\">Use this when your project has multiple providers, needs environment separation, or requires production-grade configurations with modules and remote state.</div></div></div>",
                                        "children": [
                                            {
                                                "id": "tf-fullsetup-pill-cli",
                                                "title": "Terraform CLI",
                                                "icon": "ğŸ—ï¸",
                                                "selector": "#wiz-tf-fullsetup-pill-cli",
                                                "content": "Terraform CLI availability.",
                                                "variants": [
                                                    {
                                                        "when": {
                                                            "textContains": "âœ“ terraform"
                                                        },
                                                        "content": "Terraform is installed â€” the full setup wizard can use all CLI features.",
                                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ—ï¸ CLI Â· ready</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Terraform CLI is available. The full setup can run init, validate, and preview generated configs.</div></div></div>"
                                                    },
                                                    {
                                                        "when": {
                                                            "textContains": "â—‹ no terraform"
                                                        },
                                                        "content": "Terraform CLI is missing â€” the full setup will generate files but can't validate or init them.",
                                                        "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">ğŸ—ï¸ CLI Â· missing</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Terraform CLI is not installed. The full setup can still generate .tf files, but you'll need to install terraform before you can init, plan, or apply.</div></div></div>"
                                                    }
                                                ],
                                                "children": []
                                            },
                                            {
                                                "id": "tf-fullsetup-pill-resources",
                                                "title": "Resources",
                                                "icon": "ğŸ“¦",
                                                "selector": "#wiz-tf-fullsetup-pill-resources",
                                                "content": "Existing resources.",
                                                "variants": [
                                                    {
                                                        "when": {
                                                            "textContains": "âœ“"
                                                        },
                                                        "content": "Resources already exist â€” the full setup will extend or restructure your existing infrastructure declarations.",
                                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ“¦ Resources Â· existing</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Your project already has resource declarations. The full setup will work alongside them â€” adding new resources, reorganizing into modules, or extending with environment-specific configs.</div></div></div>"
                                                    },
                                                    {
                                                        "when": {
                                                            "textContains": "â—‹ will create"
                                                        },
                                                        "content": "No resources yet â€” the full setup will scaffold resource definitions from scratch.",
                                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“¦ Resources Â· will create</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">No resources exist yet. The full setup wizard will generate resource scaffolding based on your chosen provider, including best-practice defaults for common infrastructure patterns.</div></div></div>"
                                                    }
                                                ],
                                                "children": []
                                            },
                                            {
                                                "id": "tf-fullsetup-pill-providers",
                                                "title": "Providers",
                                                "icon": "â˜",
                                                "selector": "#wiz-tf-fullsetup-pill-providers",
                                                "content": "Provider configuration.",
                                                "variants": [
                                                    {
                                                        "when": {
                                                            "textContains": "âœ“"
                                                        },
                                                        "content": "Providers already configured â€” the full setup can add new ones or reconfigure existing providers.",
                                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">â˜ Providers Â· configured</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Your project has provider blocks. The full setup can add additional providers (multi-cloud) or update version constraints on existing ones.</div></div></div>"
                                                    },
                                                    {
                                                        "when": {
                                                            "textContains": "â—‹ no providers"
                                                        },
                                                        "content": "No providers configured yet â€” the full setup will create provider blocks for your chosen platform.",
                                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â˜ Providers Â· will configure</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">No provider blocks exist. The full setup will generate provider configuration with version constraints and authentication setup for your chosen cloud platform.</div></div></div>"
                                                    }
                                                ],
                                                "children": []
                                            },
                                            {
                                                "id": "tf-fullsetup-pill-initialized",
                                                "title": "Initialized",
                                                "icon": "ğŸ”„",
                                                "selector": "#wiz-tf-fullsetup-pill-initialized",
                                                "content": "Initialization state.",
                                                "variants": [
                                                    {
                                                        "when": {
                                                            "textContains": "âœ“ initialized"
                                                        },
                                                        "content": "Already initialized â€” providers and backend are configured. The full setup may require re-running init after changes.",
                                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ”„ Initialized Â· ready</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">terraform init has been run. After the full setup generates new configs, you may need to re-run <code>terraform init</code> to download any new providers or modules.</div></div></div>"
                                                    },
                                                    {
                                                        "when": {
                                                            "textContains": "â—‹ not initialized"
                                                        },
                                                        "content": "Not initialized â€” after the full setup generates configs, you'll need to run terraform init.",
                                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ”„ Not Initialized</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">terraform init has not been run. After the full setup wizard generates your configs, run <code>terraform init</code> to download providers and configure the backend.</div></div></div>"
                                                    }
                                                ],
                                                "children": []
                                            },
                                            {
                                                "id": "tf-fullsetup-pill-backend",
                                                "title": "Backend",
                                                "icon": "ğŸ’¾",
                                                "selector": "#wiz-tf-fullsetup-pill-backend",
                                                "content": "State backend.",
                                                "variants": [
                                                    {
                                                        "when": {
                                                            "textContains": "âœ“"
                                                        },
                                                        "content": "Backend is configured â€” state storage and locking are set up.",
                                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ’¾ Backend Â· configured</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">A state backend is already configured. The full setup can migrate to a different backend type if needed (terraform init -migrate-state).</div></div></div>"
                                                    },
                                                    {
                                                        "when": {
                                                            "textContains": "â—‹ no backend"
                                                        },
                                                        "content": "No backend configured â€” the full setup will help you choose between local and remote state storage.",
                                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ’¾ Backend Â· will configure</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">No backend configured. The full setup wizard will help you choose a state backend (local, S3, GCS, or Azure Blob) and generate the backend configuration block.</div></div></div>"
                                                    }
                                                ],
                                                "children": []
                                            }
                                        ]
                                    },
                                    {
                                        "id": "tf-section-delete",
                                        "title": "Delete Config",
                                        "icon": "ğŸ—‘",
                                        "selector": "#wiz-tf-section-delete",
                                        "content": "Remove generated Terraform configuration files from your project. Does not affect deployed infrastructure.",
                                        "expanded": "<div class=\"assistant-state-card state-error\"><div class=\"state-label\">ğŸ—‘ Delete Terraform Config</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Removes .tf files that were generated by the control plane.</div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">This will delete:</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;font-size:0.75rem\"><span class=\"state-key\">terraform/ or *.tf</span><span>generated HCL configuration files</span></div><div style=\"margin-bottom:0.3rem;font-size:0.75rem\">This will NOT:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Destroy any deployed infrastructure</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Delete terraform.tfstate (state file)</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Touch .terraform/ directory (provider cache)</div><div class=\"state-text\">After deletion, you can regenerate configs at any time. Deployed infrastructure continues running until explicitly destroyed with terraform destroy.</div></div></div>",
                                        "children": []
                                    },
                                    {
                                        "id": "tf-apply",
                                        "title": "Apply",
                                        "icon": "âœ…",
                                        "selector": "#wiz-apply-terraform",
                                        "content": "Generate Terraform configuration files with the settings from the config form above.",
                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Apply Terraform Config</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Clicking Apply generates Terraform configuration files based on the form values:</div><div class=\"state-grid\"><span class=\"state-key\">main.tf</span><span>provider configuration + starter resource for the chosen platform</span><span class=\"state-key\">variables.tf</span><span>input variables for region, project name, and common settings</span><span class=\"state-key\">outputs.tf</span><span>placeholder output values ready to be populated</span></div><div class=\"state-text\">Files are created in the terraform/ directory. After generation, run terraform init to download providers, then terraform plan to preview.</div></div></div>",
                                        "children": []
                                    },
                                    {
                                        "id": "tf-cancel",
                                        "title": "Cancel",
                                        "icon": "âœ–",
                                        "selector": "#wiz-cancel-terraform",
                                        "content": "Close the Terraform setup panel without generating any files. No changes are made.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">âœ– Discard</div><div class=\"state-detail\">Cancel collapses the Terraform setup panel without generating any files or modifying any existing configuration.<br><br>Reopen anytime with âš™ï¸ Setup â€” all form fields repopulate from the current project state and detection.</div></div>",
                                        "children": []
                                    }
                                ]
                            }
                        ]
                    },
                    {
                        "id": "dns-cdn-card",
                        "title": "DNS & CDN",
                        "icon": "ğŸŒ",
                        "selector": "#wiz-int-wrap-dns",
                        "content": "Domain name system and content delivery network configuration â€” domains, DNS records, CDN providers, and SSL certificates.",
                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸŒ DNS & CDN Setup</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">This panel manages your project's DNS and CDN configuration. It covers:</div><div class=\"state-grid\"><span class=\"state-key\">DNS</span><span>zone files, A/AAAA/CNAME/MX/TXT records for your domains</span><span class=\"state-key\">CDN</span><span>content delivery providers â€” Cloudflare, AWS CloudFront, Fastly, etc.</span><span class=\"state-key\">SSL</span><span>TLS certificates â€” auto-detected from project files</span><span class=\"state-key\">Mail</span><span>SPF, DKIM, DMARC records for email deliverability</span><span class=\"state-key\">Live Tools</span><span>DNS lookup and SSL check directly from the panel</span></div></div></div>",
                        "children": [
                            {
                                "id": "dns-section-status",
                                "title": "Status",
                                "icon": "ğŸ“Š",
                                "selector": "#wiz-dns-section-status",
                                "content": "DNS & CDN status overview â€” quick summary of your current configuration state.",
                                "children": [
                                    {
                                        "id": "dns-pill-dns",
                                        "title": "DNS Status",
                                        "icon": "ğŸŒ",
                                        "selector": "#wiz-dns-pill-dns",
                                        "content": "DNS configuration status.",
                                        "variants": [
                                            {
                                                "when": {
                                                    "textContains": "âœ“ DNS configured"
                                                },
                                                "content": "DNS configuration is present â€” zone files and records are defined.",
                                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸŒ DNS Â· configured</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">DNS configuration detected. Your project has zone files with record definitions. Use the DNS Lookup tool below to verify records resolve correctly.</div><div class=\"state-text\">To modify records, regenerate the config or edit the zone files directly in your dns/ directory.</div></div></div>"
                                            },
                                            {
                                                "when": {
                                                    "textContains": "â—‹ no DNS"
                                                },
                                                "content": "No DNS configuration found â€” generate one with the form below.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸŒ DNS Â· not configured</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">No DNS configuration detected. Use the Generate DNS Config form below to create zone files and record definitions for your domain.</div><div class=\"state-text\">The generator creates A, CNAME, MX, TXT (SPF/DMARC) records based on your domain and mail provider selection.</div></div></div>"
                                            }
                                        ],
                                        "children": []
                                    },
                                    {
                                        "id": "dns-pill-cdn",
                                        "title": "CDN Status",
                                        "icon": "âš¡",
                                        "selector": "#wiz-dns-pill-cdn",
                                        "content": "CDN provider detection status.",
                                        "variants": [
                                            {
                                                "when": {
                                                    "textContains": "âœ“ CDN"
                                                },
                                                "content": "CDN provider detected â€” content delivery is configured for your project.",
                                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âš¡ CDN Â· detected</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">A CDN provider configuration was found. CDN accelerates content delivery by caching static assets at edge locations worldwide.</div><div class=\"state-text\">The Full Setup wizard can configure advanced CDN settings including cache rules, origin configuration, and WAF integration.</div></div></div>"
                                            },
                                            {
                                                "when": {
                                                    "textContains": "â—‹ no CDN"
                                                },
                                                "content": "No CDN detected â€” optional, configure via Full Setup for edge caching.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">âš¡ CDN Â· not detected</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">No CDN configuration found. A CDN is optional but recommended for production sites.</div><div class=\"state-text\">Benefits: faster page loads, DDoS protection, SSL termination, global edge caching. Use the Full Setup wizard to configure one.</div></div></div>"
                                            }
                                        ],
                                        "children": []
                                    },
                                    {
                                        "id": "dns-pill-domains",
                                        "title": "Domains",
                                        "icon": "ğŸ”—",
                                        "selector": "#wiz-dns-pill-domains",
                                        "content": "Domain detection status.",
                                        "variants": [
                                            {
                                                "when": {
                                                    "textContains": "âœ“"
                                                },
                                                "content": "Domain(s) detected in your project configuration.",
                                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ”— Domains Â· found</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">One or more domains are referenced in your project. These are used for DNS record generation, SSL certificate configuration, and CDN origin setup.</div></div></div>"
                                            },
                                            {
                                                "when": {
                                                    "textContains": "â—‹ no domains"
                                                },
                                                "content": "No domains detected â€” enter your domain in the config form below.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ”— Domains Â· none</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">No domains detected in project files. Enter your primary domain (e.g., example.com) in the Generate Config form to create DNS records.</div></div></div>"
                                            }
                                        ],
                                        "children": []
                                    },
                                    {
                                        "id": "dns-pill-files",
                                        "title": "DNS Files",
                                        "icon": "ğŸ“„",
                                        "selector": "#wiz-dns-pill-files",
                                        "content": "DNS file detection status.",
                                        "variants": [
                                            {
                                                "when": {
                                                    "textContains": "âœ“"
                                                },
                                                "content": "DNS configuration files found in your project.",
                                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ“„ Files Â· found</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">DNS configuration files detected. These contain zone definitions and record entries. Expand the DNS Files section below to see individual files.</div></div></div>"
                                            },
                                            {
                                                "when": {
                                                    "textContains": "â—‹ no files"
                                                },
                                                "content": "No DNS files found â€” generate them with the config form.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“„ Files Â· none</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">No DNS configuration files found. Use Generate DNS Config to create zone files with A, CNAME, MX, and TXT records for your domain.</div></div></div>"
                                            }
                                        ],
                                        "children": []
                                    },
                                    {
                                        "id": "dns-pill-certs",
                                        "title": "SSL Certificates",
                                        "icon": "ğŸ”’",
                                        "selector": "#wiz-dns-pill-certs",
                                        "content": "SSL certificate detection status.",
                                        "variants": [
                                            {
                                                "when": {
                                                    "textContains": "âœ“"
                                                },
                                                "content": "SSL certificates detected in your project.",
                                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ”’ SSL Â· found</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">SSL/TLS certificates detected. These are used for HTTPS encryption. Use the SSL Check tool below to verify certificate validity and expiration.</div><div class=\"state-text\">âš  Never commit private keys to git. Ensure .gitignore covers *.key and *.pem files.</div></div></div>"
                                            },
                                            {
                                                "when": {
                                                    "textContains": "â—‹ no certs"
                                                },
                                                "content": "No SSL certificates found â€” most modern setups use auto-provisioned certs (Let's Encrypt, ACM).",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ”’ SSL Â· none</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">No SSL certificates found in the project. This is normal â€” most production setups use auto-provisioned certificates:</div><div class=\"state-text\">â€¢ <strong>Let's Encrypt</strong> â€” free, auto-renewed via certbot or ACME clients<br>â€¢ <strong>AWS ACM</strong> â€” free certs for CloudFront and ALB<br>â€¢ <strong>Cloudflare</strong> â€” automatic SSL for proxied domains</div></div></div>"
                                            }
                                        ],
                                        "children": []
                                    },
                                    {
                                        "id": "dns-pill-config",
                                        "title": "Config Status",
                                        "icon": "âš™",
                                        "selector": "#wiz-dns-pill-config",
                                        "content": "Overall DNS config detection.",
                                        "variants": [
                                            {
                                                "when": {
                                                    "textContains": "âœ“ config found"
                                                },
                                                "content": "DNS configuration exists â€” you can regenerate or modify it.",
                                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âš™ Config Â· found</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">A generated DNS configuration exists. You can regenerate it with different settings (enable Overwrite) or edit the files directly.</div></div></div>"
                                            },
                                            {
                                                "when": {
                                                    "textContains": "â—‹ no config"
                                                },
                                                "content": "No generated config â€” use the form below to create one.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">âš™ Config Â· none</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">No generated DNS configuration found. Fill in the form below with your domain and mail provider, then click Apply to generate DNS record files.</div></div></div>"
                                            }
                                        ],
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "id": "dns-section-live",
                                "title": "Live Tools",
                                "icon": "ğŸ”§",
                                "selector": "#wiz-dns-section-live",
                                "content": "Live DNS and SSL diagnostic tools â€” query DNS records and check certificate status in real-time.",
                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ”§ Live DNS Tools</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Interactive diagnostic tools that query live infrastructure. Results appear in the panel below the buttons.</div><div class=\"state-text\">These tools require <strong>dig</strong> (DNS lookup) and <strong>openssl</strong> (SSL check) to be installed on the server. If they're missing, the Missing Tools banner above will indicate which ones.</div></div></div>",
                                "children": [
                                    {
                                        "id": "dns-btn-lookup",
                                        "title": "DNS Lookup",
                                        "icon": "ğŸ”",
                                        "selector": "#wiz-dns-btn-lookup",
                                        "content": "Query live DNS records for your domain â€” A, AAAA, CNAME, MX, TXT, NS records.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ” DNS Lookup</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Runs <code>dig</code> against public DNS servers to resolve records for your domain. Shows:</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;margin:0.3rem 0;font-size:0.73rem\"><span class=\"state-key\">A / AAAA</span><span>IPv4 and IPv6 addresses the domain points to</span><span class=\"state-key\">CNAME</span><span>alias records (e.g., www â†’ apex)</span><span class=\"state-key\">MX</span><span>mail server routing with priorities</span><span class=\"state-key\">TXT</span><span>SPF, DMARC, domain verification entries</span><span class=\"state-key\">NS</span><span>authoritative nameservers for the zone</span></div><div class=\"state-text\">Use this to verify your DNS configuration is live and propagated after making changes at your registrar.</div></div></div>",
                                        "children": []
                                    },
                                    {
                                        "id": "dns-btn-ssl",
                                        "title": "SSL Check",
                                        "icon": "ğŸ”’",
                                        "selector": "#wiz-dns-btn-ssl",
                                        "content": "Check SSL/TLS certificate validity, expiration, and chain for your domain.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ”’ SSL Certificate Check</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Connects to your domain via <code>openssl s_client</code> and inspects the TLS certificate. Reports:</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;margin:0.3rem 0;font-size:0.73rem\"><span class=\"state-key\">Issuer</span><span>who issued the cert (Let's Encrypt, DigiCert, Cloudflare, etc.)</span><span class=\"state-key\">Validity</span><span>not-before and not-after dates</span><span class=\"state-key\">Subject</span><span>domain(s) the cert covers (CN + SANs)</span><span class=\"state-key\">Chain</span><span>intermediate and root CA verification</span></div><div class=\"state-text\">Useful for verifying HTTPS is working, checking expiration dates, and confirming the correct certificate is served.</div></div></div>",
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "id": "dns-section-config",
                                "title": "Generate DNS Config",
                                "icon": "ğŸ“",
                                "content": "Generate DNS zone files and record definitions for your domain.",
                                "children": [
                                    {
                                        "id": "dns-field-domain",
                                        "title": "Domain",
                                        "icon": "ğŸŒ",
                                        "selector": "#wiz-dns-domain",
                                        "content": "Your primary domain name for DNS record generation.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸŒ Domain</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">The root domain for all generated DNS records. Enter the apex domain (e.g., example.com), not a subdomain.</div><div class=\"state-text\">Generated records will include:<br>â€¢ <strong>A record</strong> â€” points domain to your server IP<br>â€¢ <strong>CNAME</strong> â€” www subdomain alias<br>â€¢ <strong>MX</strong> â€” mail routing (if mail provider selected)<br>â€¢ <strong>TXT</strong> â€” SPF, DMARC verification records</div></div></div>",
                                        "children": []
                                    },
                                    {
                                        "id": "dns-field-mail",
                                        "title": "Mail Provider",
                                        "icon": "ğŸ“§",
                                        "selector": "#wiz-dns-mail",
                                        "content": "Mail provider for MX record generation.",
                                        "variants": [
                                            {
                                                "when": {
                                                    "resolver": "dnsMailValue",
                                                    "equals": "none"
                                                },
                                                "content": "No mail provider â€” MX records will not be generated.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“§ No Mail Provider</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">No mail provider selected. No MX records will be generated. Select a provider if you need email on this domain.</div></div></div>"
                                            },
                                            {
                                                "when": {
                                                    "resolver": "dnsMailValue",
                                                    "equals": "google"
                                                },
                                                "content": "Google Workspace selected â€” generates MX records for Gmail.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“§ Google Workspace</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Generates MX records pointing to Google's mail servers (ASPMX.L.GOOGLE.COM and alternates).</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;margin:0.3rem 0;font-size:0.73rem\"><span class=\"state-key\">Priority 1</span><span>ASPMX.L.GOOGLE.COM</span><span class=\"state-key\">Priority 5</span><span>ALT1.ASPMX.L.GOOGLE.COM, ALT2.ASPMX.L.GOOGLE.COM</span></div></div></div>"
                                            },
                                            {
                                                "when": {
                                                    "resolver": "dnsMailValue",
                                                    "equals": "protonmail"
                                                },
                                                "content": "ProtonMail selected â€” generates MX records for Proton Mail.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“§ ProtonMail</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Generates MX records pointing to Proton Mail servers. ProtonMail provides end-to-end encrypted email.</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;margin:0.3rem 0;font-size:0.73rem\"><span class=\"state-key\">Priority 10</span><span>mail.protonmail.ch</span><span class=\"state-key\">Priority 20</span><span>mailsec.protonmail.ch</span></div></div></div>"
                                            },
                                            {
                                                "when": {
                                                    "resolver": "dnsMailValue",
                                                    "equals": "fastmail"
                                                },
                                                "content": "Fastmail selected â€” generates MX records for Fastmail.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“§ Fastmail</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Generates MX records pointing to Fastmail servers. Known for privacy, standards compliance, and calendar/contacts support.</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;margin:0.3rem 0;font-size:0.73rem\"><span class=\"state-key\">Priority 10</span><span>in1-smtp.messagingengine.com</span><span class=\"state-key\">Priority 20</span><span>in2-smtp.messagingengine.com</span></div></div></div>"
                                            },
                                            {
                                                "when": {
                                                    "resolver": "dnsMailValue",
                                                    "equals": "zoho"
                                                },
                                                "content": "Zoho Mail selected â€” generates MX records for Zoho.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“§ Zoho Mail</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Generates MX records pointing to Zoho's mail servers. Zoho offers a free tier for up to 5 users.</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;margin:0.3rem 0;font-size:0.73rem\"><span class=\"state-key\">Priority 10</span><span>mx.zoho.com</span><span class=\"state-key\">Priority 20</span><span>mx2.zoho.com</span></div></div></div>"
                                            }
                                        ],
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“§ Mail Provider</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Select the email provider for this domain to generate the correct MX records. Choose 'none' if you don't need email on this domain.</div></div></div>",
                                        "children": []
                                    },
                                    {
                                        "id": "dns-field-spf",
                                        "title": "SPF Record",
                                        "icon": "ğŸ›¡",
                                        "selector": "#wiz-dns-spf",
                                        "content": "Include an SPF TXT record â€” prevents email spoofing by declaring authorized senders.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ›¡ SPF Record</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Sender Policy Framework â€” a DNS TXT record that lists which mail servers are authorized to send email for your domain.</div><div class=\"state-text\">Without SPF, your domain is vulnerable to email spoofing. Most mail providers require SPF for deliverability.</div><div style=\"margin:0.3rem 0;font-size:0.73rem\">Example: <code>v=spf1 include:_spf.google.com ~all</code></div></div></div>",
                                        "children": []
                                    },
                                    {
                                        "id": "dns-field-dmarc",
                                        "title": "DMARC Record",
                                        "icon": "ğŸ›¡",
                                        "selector": "#wiz-dns-dmarc",
                                        "content": "Include a DMARC TXT record â€” tells receivers how to handle unauthenticated email.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ›¡ DMARC Record</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Domain-based Message Authentication â€” builds on SPF and DKIM to tell receiving servers what to do with emails that fail authentication checks.</div><div class=\"state-text\">Policies: <strong>none</strong> (monitor only), <strong>quarantine</strong> (flag as spam), <strong>reject</strong> (block entirely).</div><div style=\"margin:0.3rem 0;font-size:0.73rem\">Example: <code>v=DMARC1; p=quarantine; rua=mailto:dmarc@example.com</code></div></div></div>",
                                        "children": []
                                    },
                                    {
                                        "id": "dns-field-overwrite",
                                        "title": "Overwrite",
                                        "icon": "âš ",
                                        "selector": "#wiz-dns-overwrite",
                                        "content": "Whether to overwrite existing DNS config files â€” only shown when config already exists.",
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "id": "dns-section-fullsetup",
                                "title": "Full DNS & CDN Setup",
                                "icon": "ğŸš€",
                                "selector": "#wiz-dns-section-fullsetup",
                                "content": "Full multi-step DNS & CDN wizard â€” domain management, CDN provider selection, SSL certificates, traffic routing, and Terraform DNS resources.",
                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸš€ Full DNS & CDN Setup</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">The full setup wizard provides comprehensive DNS and CDN configuration beyond basic record generation:</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Multi-domain management</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ CDN provider selection and configuration</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ SSL certificate management</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Traffic routing and proxy configuration</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ K8s ingress integration</div><div style=\"margin:0.15rem 0;font-size:0.75rem;color:var(--text-secondary)\">âœ“ Terraform DNS resource generation</div></div></div>",
                                "children": [
                                    {
                                        "id": "dns-fullsetup-pill-dns",
                                        "title": "DNS",
                                        "icon": "ğŸŒ",
                                        "selector": "#wiz-dns-fullsetup-pill-dns",
                                        "content": "DNS configuration readiness for full setup.",
                                        "variants": [
                                            {
                                                "when": {
                                                    "textContains": "âœ“ DNS configured"
                                                },
                                                "content": "DNS is already configured â€” the full setup can extend or modify existing records.",
                                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸŒ DNS Â· ready</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">DNS configuration exists. The full setup wizard will build on top of your existing records, adding CDN, SSL, and advanced routing configuration.</div></div></div>"
                                            },
                                            {
                                                "when": {
                                                    "textContains": "â—‹ will create"
                                                },
                                                "content": "No DNS config yet â€” the full setup will create one from scratch.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸŒ DNS Â· will create</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">No existing DNS configuration. The full setup wizard will create a complete DNS setup including zones, records, and optional CDN/SSL integration.</div></div></div>"
                                            }
                                        ],
                                        "children": []
                                    },
                                    {
                                        "id": "dns-fullsetup-pill-cdn",
                                        "title": "CDN",
                                        "icon": "âš¡",
                                        "selector": "#wiz-dns-fullsetup-pill-cdn",
                                        "content": "CDN provider readiness for full setup.",
                                        "variants": [
                                            {
                                                "when": {
                                                    "textContains": "âœ“ CDN"
                                                },
                                                "content": "CDN provider detected â€” the full setup can configure advanced CDN settings.",
                                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âš¡ CDN Â· detected</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">CDN provider found. The full setup wizard can configure cache policies, origin settings, SSL termination, and WAF rules for your provider.</div></div></div>"
                                            },
                                            {
                                                "when": {
                                                    "textContains": "â—‹ no CDN"
                                                },
                                                "content": "No CDN detected â€” the full setup can help you choose and configure one.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">âš¡ CDN Â· will configure</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">No CDN provider detected. The full setup wizard will help you choose a CDN provider (Cloudflare, CloudFront, Fastly, etc.) and generate the configuration.</div></div></div>"
                                            }
                                        ],
                                        "children": []
                                    },
                                    {
                                        "id": "dns-fullsetup-pill-domains",
                                        "title": "Domains",
                                        "icon": "ğŸ”—",
                                        "selector": "#wiz-dns-fullsetup-pill-domains",
                                        "content": "Domain readiness for full setup.",
                                        "variants": [
                                            {
                                                "when": {
                                                    "textContains": "âœ“"
                                                },
                                                "content": "Domains detected â€” the full setup will use these as starting points.",
                                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ”— Domains Â· found</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Domains are already known. The full setup wizard will pre-populate domain fields and allow you to add more domains for multi-domain configurations.</div></div></div>"
                                            },
                                            {
                                                "when": {
                                                    "textContains": "â—‹ no domains"
                                                },
                                                "content": "No domains detected â€” you'll enter domains during full setup.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ”— Domains Â· none</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">No domains detected. The full setup wizard will prompt you to enter your domains and configure records for each one.</div></div></div>"
                                            }
                                        ],
                                        "children": []
                                    },
                                    {
                                        "id": "dns-fullsetup-pill-certs",
                                        "title": "SSL Certs",
                                        "icon": "ğŸ”’",
                                        "selector": "#wiz-dns-fullsetup-pill-certs",
                                        "content": "SSL certificate readiness for full setup.",
                                        "variants": [
                                            {
                                                "when": {
                                                    "textContains": "âœ“ SSL certs"
                                                },
                                                "content": "SSL certificates found â€” the full setup can integrate them with CDN and ingress.",
                                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ”’ SSL Â· found</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">SSL certificates detected. The full setup wizard can configure these for CDN SSL termination, K8s ingress TLS, and reverse proxy HTTPS.</div></div></div>"
                                            },
                                            {
                                                "when": {
                                                    "textContains": "â—‹ no certs"
                                                },
                                                "content": "No SSL certs â€” the full setup can configure auto-provisioning (Let's Encrypt, ACM).",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ”’ SSL Â· will configure</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">No SSL certificates found. The full setup wizard can configure automatic certificate provisioning via Let's Encrypt, AWS ACM, or your CDN provider's built-in SSL.</div></div></div>"
                                            }
                                        ],
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "id": "dns-apply",
                                "title": "Apply",
                                "icon": "âœ…",
                                "selector": "#wiz-apply-dns",
                                "content": "Generate DNS configuration files with the settings from the config form above.",
                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Apply DNS Config</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Clicking Apply generates DNS zone files and record definitions based on the form values:</div><div class=\"state-grid\"><span class=\"state-key\">Zone file</span><span>BIND-format zone with SOA, NS, A, CNAME records</span><span class=\"state-key\">MX records</span><span>Mail routing for your selected provider</span><span class=\"state-key\">TXT records</span><span>SPF and DMARC entries for email authentication</span></div><div class=\"state-text\">Files are created in the dns/ directory. After generation, configure these records with your domain registrar or DNS provider.</div></div></div>",
                                "children": []
                            },
                            {
                                "id": "dns-cancel",
                                "title": "Cancel",
                                "icon": "âœ–",
                                "selector": "#wiz-cancel-dns",
                                "content": "Close the DNS setup panel without generating any files. No changes are made.",
                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">âœ– Discard</div><div class=\"state-detail\">Cancel collapses the DNS setup panel without generating any files or modifying any existing configuration.<br><br>Reopen anytime with âš™ï¸ Setup â€” all form fields repopulate from the current project state and detection.</div></div>",
                                "children": []
                            }
                        ]
                    },
                    {
                        "id": "cicd-card",
                        "title": "CI/CD",
                        "icon": "ğŸ”„",
                        "selector": "#wiz-int-wrap-ci",
                        "content": "Continuous integration and delivery â€” GitHub Actions workflow generation, pipeline composition, and cross-integration orchestration.",
                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ”„ CI/CD Pipeline</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">This panel manages CI/CD workflow generation for your project. It detects your stack, integrations, and environment configuration to produce GitHub Actions workflows.</div><div class=\"state-grid\"><span class=\"state-key\">Basic</span><span>single workflow â€” test + lint for your detected stack</span><span class=\"state-key\">Compose</span><span>full pipeline â€” Docker build, K8s deploy, Terraform, multi-env</span><span class=\"state-key\">Connections</span><span>integration surface â€” what your CI pipeline can orchestrate</span></div></div></div>",
                        "children": [
                            {
                                "id": "ci-section-status",
                                "title": "Status Strip",
                                "icon": "ğŸ“Š",
                                "selector": "#wiz-ci-section-status",
                                "content": "CI/CD status overview â€” workflows, GitHub authentication, and repository info.",
                                "children": [
                                    {
                                        "id": "ci-pill-workflows",
                                        "title": "Workflows",
                                        "icon": "ğŸ“‹",
                                        "selector": "#wiz-ci-pill-workflows",
                                        "content": "CI workflow detection status.",
                                        "variants": [
                                            {
                                                "when": {
                                                    "textContains": "âœ“"
                                                },
                                                "content": "CI workflows detected â€” your project has GitHub Actions workflow files.",
                                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ“‹ Workflows Â· found</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Existing CI/CD workflow files detected in <code>.github/workflows/</code>. Use Regenerate Basic Workflow (with Overwrite) to replace them, or Compose Full Pipeline to generate a more comprehensive setup.</div></div></div>"
                                            },
                                            {
                                                "when": {
                                                    "textContains": "â—‹ no workflows"
                                                },
                                                "content": "No CI workflows found â€” generate one with the form below.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“‹ Workflows Â· none</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">No CI/CD workflows found. Use Generate Basic Workflow for a simple test + lint pipeline, or Compose Full Pipeline to build a complete CI/CD setup from your detected integrations.</div></div></div>"
                                            }
                                        ],
                                        "children": []
                                    },
                                    {
                                        "id": "ci-pill-ghauth",
                                        "title": "GitHub Auth",
                                        "icon": "ğŸ™",
                                        "selector": "#wiz-ci-pill-ghauth",
                                        "content": "GitHub CLI authentication status.",
                                        "variants": [
                                            {
                                                "when": {
                                                    "textContains": "âœ“ gh auth"
                                                },
                                                "content": "GitHub CLI is authenticated â€” secrets, environments, and repo operations are available.",
                                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ™ GitHub Â· authenticated</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">GitHub CLI (<code>gh</code>) is authenticated. This enables:<br>â€¢ Repository secret management<br>â€¢ Environment creation and configuration<br>â€¢ Workflow dispatch and status checks<br>â€¢ Pull request and issue automation</div></div></div>"
                                            },
                                            {
                                                "when": {
                                                    "textContains": "âš  gh not auth"
                                                },
                                                "content": "GitHub CLI not authenticated â€” run 'gh auth login' to enable repository operations.",
                                                "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">ğŸ™ GitHub Â· not authenticated</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">GitHub CLI is not authenticated. Some features require authentication:<br>â€¢ Secret management requires <code>gh auth login</code><br>â€¢ Environment creation needs repo access<br><br>Workflow file generation still works without auth â€” files are created locally.</div></div></div>"
                                            }
                                        ],
                                        "children": []
                                    },
                                    {
                                        "id": "ci-pill-repo",
                                        "title": "Repository",
                                        "icon": "ğŸ“¦",
                                        "selector": "#wiz-ci-pill-repo",
                                        "content": "GitHub repository slug â€” identifies your repo for workflow configuration.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“¦ Repository</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">The GitHub repository slug (org/repo) detected from your git remote. This is used for container registry paths (ghcr.io/org/repo), workflow badge URLs, and environment references.</div></div></div>",
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "id": "ci-section-connections",
                                "title": "Pipeline Connections",
                                "icon": "ğŸ”Œ",
                                "content": "Integration surface dashboard â€” shows which integrations your CI pipeline can orchestrate.",
                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ”Œ Pipeline Connections</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Each row shows an integration that can be wired into your CI/CD pipeline. Green pills mean the integration is detected and can generate pipeline steps. Grey pills mean the integration is not present â€” those steps will be skipped.</div><div class=\"state-text\">The Compose Full Pipeline wizard reads all connections to build a coordinated multi-job workflow.</div></div></div>",
                                "children": [
                                    {
                                        "id": "ci-conn-git",
                                        "title": "Git",
                                        "icon": "ğŸ”€",
                                        "selector": "#wiz-ci-conn-git",
                                        "content": "Git repository connection â€” provides trigger events and branch filtering for CI workflows.",
                                        "variants": [
                                            {
                                                "when": {
                                                    "textContains": "âœ“ repo"
                                                },
                                                "content": "Git repo detected â€” workflows will trigger on push/PR to configured branches.",
                                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ”€ Git Â· connected</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Git repository detected. Workflows trigger on:<br>â€¢ <strong>push</strong> to configured branches (main, master, etc.)<br>â€¢ <strong>pull_request</strong> targeting those branches<br>â€¢ Branch filter is configurable in the Basic Workflow form.</div></div></div>"
                                            },
                                            {
                                                "when": {
                                                    "textContains": "â—‹ no git"
                                                },
                                                "content": "No Git repo â€” workflows can still be generated but won't have trigger context.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ”€ Git Â· not connected</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">No Git repository detected. Workflow files can still be generated, but they won't have automatic push/PR trigger context until the project is initialized as a Git repo.</div></div></div>"
                                            }
                                        ],
                                        "children": []
                                    },
                                    {
                                        "id": "ci-conn-github",
                                        "title": "GitHub",
                                        "icon": "ğŸ™",
                                        "selector": "#wiz-ci-conn-github",
                                        "content": "GitHub platform connection â€” Actions runner, secrets, environments, and repo visibility.",
                                        "variants": [
                                            {
                                                "when": {
                                                    "textContains": "âœ“ auth"
                                                },
                                                "content": "GitHub authenticated â€” full access to Actions, secrets, and environment management.",
                                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ™ GitHub Â· connected</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">GitHub CLI authenticated. Your pipeline can leverage:<br>â€¢ <strong>GitHub Actions</strong> â€” cloud CI runners<br>â€¢ <strong>Secrets</strong> â€” secure variable injection<br>â€¢ <strong>Environments</strong> â€” deployment targets with protection rules<br>â€¢ <strong>GHCR</strong> â€” GitHub Container Registry for Docker images</div></div></div>"
                                            },
                                            {
                                                "when": {
                                                    "textContains": "â—‹ no auth"
                                                },
                                                "content": "GitHub not authenticated â€” workflow files generated locally, but secret/env management unavailable.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ™ GitHub Â· not connected</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">GitHub CLI not authenticated. Workflow files will still be generated locally, but you won't be able to manage secrets or environments through the wizard. Run <code>gh auth login</code> to connect.</div></div></div>"
                                            }
                                        ],
                                        "children": []
                                    },
                                    {
                                        "id": "ci-conn-stacks",
                                        "title": "Stacks",
                                        "icon": "ğŸ“¦",
                                        "selector": "#wiz-ci-conn-stacks",
                                        "content": "Detected language stacks â€” determines test, lint, and build commands for the pipeline.",
                                        "variants": [
                                            {
                                                "when": {
                                                    "textContains": "â—‹ none"
                                                },
                                                "content": "No language stacks detected â€” test/lint commands will need manual configuration.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“¦ Stacks Â· none</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">No language stacks detected. The Basic Workflow form fields will be empty â€” you'll need to manually specify the language version, install command, and test command.</div></div></div>"
                                            }
                                        ],
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“¦ Detected Stacks</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Your project's language stacks were auto-detected. Each stack provides default commands for:<br>â€¢ <strong>Install</strong> â€” dependency installation (pip install, npm install, etc.)<br>â€¢ <strong>Test</strong> â€” test suite runner (pytest, npm test, etc.)<br>â€¢ <strong>Lint</strong> â€” code quality checks (flake8, eslint, etc.)<br>These defaults pre-populate the workflow form fields.</div></div></div>",
                                        "children": []
                                    },
                                    {
                                        "id": "ci-conn-docker",
                                        "title": "Docker",
                                        "icon": "ğŸ³",
                                        "selector": "#wiz-ci-conn-docker",
                                        "content": "Docker integration â€” enables container image build and registry push steps in the pipeline.",
                                        "variants": [
                                            {
                                                "when": {
                                                    "textContains": "âœ“ detected"
                                                },
                                                "content": "Docker detected â€” pipeline can include image build + registry push steps.",
                                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ³ Docker Â· connected</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Docker configuration detected. The Compose Full Pipeline can include:<br>â€¢ <strong>Build</strong> â€” docker build from your Dockerfile<br>â€¢ <strong>Push</strong> â€” push to configured registry (GHCR, DockerHub, etc.)<br>â€¢ <strong>Scan</strong> â€” optional vulnerability scanning<br>â€¢ Image tags auto-generated from branch/tag/SHA.</div></div></div>"
                                            },
                                            {
                                                "when": {
                                                    "textContains": "â—‹ not found"
                                                },
                                                "content": "No Docker config â€” Docker build/push steps will be omitted from composed pipelines.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ³ Docker Â· not connected</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">No Dockerfile or Docker configuration detected. Docker build and push steps will not be included in composed pipelines. Set up Docker integration first if you need containerized deployments.</div></div></div>"
                                            }
                                        ],
                                        "children": []
                                    },
                                    {
                                        "id": "ci-conn-k8s",
                                        "title": "Kubernetes",
                                        "icon": "â˜¸ï¸",
                                        "selector": "#wiz-ci-conn-k8s",
                                        "content": "Kubernetes integration â€” enables deployment steps in the pipeline.",
                                        "variants": [
                                            {
                                                "when": {
                                                    "textContains": "âœ“ detected"
                                                },
                                                "content": "Kubernetes detected â€” pipeline can include deploy steps via kubectl, helm, or skaffold.",
                                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">â˜¸ï¸ Kubernetes Â· connected</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Kubernetes manifests detected. The Compose Full Pipeline can include:<br>â€¢ <strong>kubectl apply</strong> â€” direct manifest deployment<br>â€¢ <strong>helm upgrade</strong> â€” Helm chart release<br>â€¢ <strong>skaffold</strong> â€” dev-loop and deployment<br>Deploy method is selectable in the compose form.</div></div></div>"
                                            },
                                            {
                                                "when": {
                                                    "textContains": "â—‹ not found"
                                                },
                                                "content": "No Kubernetes manifests â€” K8s deploy steps will be omitted from composed pipelines.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â˜¸ï¸ Kubernetes Â· not connected</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">No Kubernetes manifests or configuration detected. K8s deployment steps will not be included in composed pipelines. Set up the K8s integration first if you need cluster deployments.</div></div></div>"
                                            }
                                        ],
                                        "children": []
                                    },
                                    {
                                        "id": "ci-conn-terraform",
                                        "title": "Terraform",
                                        "icon": "ğŸ—ï¸",
                                        "selector": "#wiz-ci-conn-terraform",
                                        "content": "Terraform integration â€” enables infrastructure provisioning steps in the pipeline.",
                                        "variants": [
                                            {
                                                "when": {
                                                    "textContains": "âœ“ detected"
                                                },
                                                "content": "Terraform detected â€” pipeline can include plan + apply infrastructure steps.",
                                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ—ï¸ Terraform Â· connected</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Terraform configuration detected. The Compose Full Pipeline can include:<br>â€¢ <strong>terraform plan</strong> â€” preview infrastructure changes<br>â€¢ <strong>terraform apply</strong> â€” provision infrastructure<br>â€¢ Runs before deployment steps to ensure infra is ready.</div></div></div>"
                                            },
                                            {
                                                "when": {
                                                    "textContains": "â—‹ not found"
                                                },
                                                "content": "No Terraform config â€” infrastructure provisioning steps will be omitted.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ—ï¸ Terraform Â· not connected</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">No Terraform configuration detected. Infrastructure provisioning steps will not be included in composed pipelines. Set up Terraform integration first if you need IaC in your CI/CD.</div></div></div>"
                                            }
                                        ],
                                        "children": []
                                    },
                                    {
                                        "id": "ci-conn-envs",
                                        "title": "Environments",
                                        "icon": "âš™ï¸",
                                        "selector": "#wiz-ci-conn-envs",
                                        "content": "Environment configuration â€” multi-environment deployments with approval gates and secrets.",
                                        "variants": [
                                            {
                                                "when": {
                                                    "textContains": "âœ“"
                                                },
                                                "content": "Multiple environments detected â€” pipeline can generate per-environment deployment jobs.",
                                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âš™ï¸ Environments Â· configured</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Multiple environments detected. The Compose Full Pipeline can generate:<br>â€¢ Per-environment deployment jobs with matrix strategy<br>â€¢ GitHub environment protection rules<br>â€¢ Environment-scoped secrets (e.g., staging vs production credentials)<br>â€¢ Sequential deployment with approval gates</div></div></div>"
                                            },
                                            {
                                                "when": {
                                                    "textContains": "â—‹ single"
                                                },
                                                "content": "Single environment â€” pipeline deploys to one target without environment matrix.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">âš™ï¸ Environments Â· single</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">No multi-environment configuration detected. Pipeline will deploy to a single target. To enable staged deployments (dev â†’ staging â†’ production), configure environments in the wizard.</div></div></div>"
                                            }
                                        ],
                                        "children": []
                                    },
                                    {
                                        "id": "ci-conn-pages",
                                        "title": "Pages",
                                        "icon": "ğŸ“„",
                                        "selector": "#wiz-ci-conn-pages",
                                        "content": "Pages integration â€” site build and deploy steps for documentation or static sites.",
                                        "variants": [
                                            {
                                                "when": {
                                                    "textContains": "âœ“ detected"
                                                },
                                                "content": "Pages detected â€” pipeline can include site build + deploy steps.",
                                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ“„ Pages Â· connected</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Pages/documentation site detected. The Compose Full Pipeline can include a site build and deployment step (e.g., GitHub Pages deploy action).</div></div></div>"
                                            },
                                            {
                                                "when": {
                                                    "textContains": "â—‹ not found"
                                                },
                                                "content": "No Pages site â€” site build/deploy steps will be omitted.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“„ Pages Â· not connected</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">No documentation or static site configuration detected. Pages deploy steps will not be included in composed pipelines.</div></div></div>"
                                            }
                                        ],
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "id": "ci-section-basic",
                                "title": "Generate Basic Workflow",
                                "icon": "ğŸ“",
                                "content": "Generate a single GitHub Actions workflow with test + lint jobs for your detected stack.",
                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“ Basic Workflow</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Generates a single <code>.github/workflows/ci.yml</code> file with test and optional lint jobs. Stack-aware defaults auto-populate the form based on your detected language.</div><div class=\"state-text\">âš  If your project has Docker, K8s, or other integrations, use <strong>Compose Full Pipeline</strong> instead â€” the basic workflow only covers test + lint.</div></div></div>",
                                "children": [
                                    {
                                        "id": "ci-field-branches",
                                        "title": "Trigger Branches",
                                        "icon": "ğŸ”€",
                                        "selector": "#wiz-ci-branches",
                                        "content": "Comma-separated list of branches that trigger the CI workflow on push and pull_request.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ”€ Trigger Branches</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Defines which branches trigger the workflow. Common patterns:<br>â€¢ <strong>main, master</strong> â€” production branches only<br>â€¢ <strong>main, develop</strong> â€” production + integration branch<br>â€¢ <strong>main, release/*</strong> â€” with glob patterns for release branches<br><br>Both <code>push</code> and <code>pull_request</code> events use this filter.</div></div></div>",
                                        "children": []
                                    },
                                    {
                                        "id": "ci-field-langver",
                                        "title": "Language Version",
                                        "icon": "ğŸ“¦",
                                        "selector": "#wiz-ci-langver",
                                        "content": "Language/runtime version for the CI matrix â€” auto-filled from stack detection.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“¦ Language Version</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">The version string used in the CI matrix for <code>setup-*</code> actions (e.g., setup-python, setup-node). Auto-detected from your project files (pyproject.toml, package.json, etc.).<br><br>You can specify multiple versions for matrix testing: <code>3.11, 3.12</code></div></div></div>",
                                        "children": []
                                    },
                                    {
                                        "id": "ci-field-install",
                                        "title": "Install Command",
                                        "icon": "ğŸ“¥",
                                        "selector": "#wiz-ci-install",
                                        "content": "Command to install project dependencies â€” runs before test and lint steps.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“¥ Install Command</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Runs in the CI environment before test/lint steps. Examples:<br>â€¢ <code>pip install -e .[dev]</code> â€” Python editable install with dev deps<br>â€¢ <code>npm ci</code> â€” Node.js clean install from lockfile<br>â€¢ <code>go mod download</code> â€” Go module fetch</div></div></div>",
                                        "children": []
                                    },
                                    {
                                        "id": "ci-field-test",
                                        "title": "Test Command",
                                        "icon": "ğŸ§ª",
                                        "selector": "#wiz-ci-test",
                                        "content": "Command to run the test suite â€” the primary CI verification step.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ§ª Test Command</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">The main test runner. This runs after install and determines the CI pass/fail status. Examples:<br>â€¢ <code>pytest</code> â€” Python test runner<br>â€¢ <code>npm test</code> â€” Node.js test script<br>â€¢ <code>go test ./...</code> â€” Go recursive test</div></div></div>",
                                        "children": []
                                    },
                                    {
                                        "id": "ci-field-lint",
                                        "title": "Also Run Linting",
                                        "icon": "âœ¨",
                                        "selector": "#wiz-ci-lint",
                                        "content": "Enable a separate lint step in the workflow â€” runs code quality checks.",
                                        "children": []
                                    },
                                    {
                                        "id": "ci-field-lint-cmd",
                                        "title": "Lint Command",
                                        "icon": "âœ¨",
                                        "selector": "#wiz-ci-lint-cmd",
                                        "content": "Command for code linting â€” only used if linting is enabled.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">âœ¨ Lint Command</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Runs as a separate job or step for code quality. Examples:<br>â€¢ <code>flake8 .</code> â€” Python PEP8 linting<br>â€¢ <code>npm run lint</code> â€” Node.js ESLint<br>â€¢ <code>golangci-lint run</code> â€” Go multi-linter</div></div></div>",
                                        "children": []
                                    },
                                    {
                                        "id": "ci-field-overwrite",
                                        "title": "Overwrite",
                                        "icon": "âš ",
                                        "selector": "#wiz-ci-overwrite",
                                        "content": "Overwrite existing workflow files â€” only shown when workflows already exist.",
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "id": "ci-section-compose",
                                "title": "Compose Full Pipeline",
                                "icon": "ğŸš€",
                                "content": "Generate a complete CI/CD pipeline from all detected integrations â€” Docker, K8s, Terraform, environments, Pages.",
                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸš€ Compose Full Pipeline</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Builds a coordinated GitHub Actions workflow that combines <strong>all</strong> your detected integrations into a single (or split) pipeline:</div><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;margin:0.3rem 0;font-size:0.73rem\"><span class=\"state-key\">Test + Lint</span><span>from detected stack (always included)</span><span class=\"state-key\">Docker Build</span><span>if Dockerfile detected â€” build + push to registry</span><span class=\"state-key\">K8s Deploy</span><span>if manifests detected â€” kubectl/helm/skaffold</span><span class=\"state-key\">Terraform</span><span>if .tf files detected â€” plan + apply</span><span class=\"state-key\">Multi-env</span><span>if environments configured â€” staged rollout</span><span class=\"state-key\">Pages</span><span>if site detected â€” build + deploy docs</span></div></div></div>",
                                "children": [
                                    {
                                        "id": "ci-job-test",
                                        "title": "Test Job",
                                        "icon": "ğŸ§ª",
                                        "selector": "#wiz-ci-job-test",
                                        "content": "Test step in the composed pipeline.",
                                        "variants": [
                                            {
                                                "when": {
                                                    "textContains": "âœ“ Test"
                                                },
                                                "content": "Test job included â€” runs your detected stack's test command.",
                                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ§ª Test Â· included</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Test job will be generated using your stack's detected test command. This is the first step in the pipeline â€” all other steps depend on tests passing.</div></div></div>"
                                            },
                                            {
                                                "when": {
                                                    "textContains": "â—‹ Test"
                                                },
                                                "content": "No test command detected â€” test job will be empty or skipped.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ§ª Test Â· no stack</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">No language stack detected, so no test command is available. Configure your stack or use the Basic Workflow form to manually specify test commands.</div></div></div>"
                                            }
                                        ],
                                        "children": []
                                    },
                                    {
                                        "id": "ci-job-lint",
                                        "title": "Lint Job",
                                        "icon": "âœ¨",
                                        "selector": "#wiz-ci-job-lint",
                                        "content": "Lint step in the composed pipeline.",
                                        "variants": [
                                            {
                                                "when": {
                                                    "textContains": "âœ“ Lint"
                                                },
                                                "content": "Lint job included â€” runs code quality checks for your detected stack.",
                                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ¨ Lint Â· included</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Lint job will run your stack's detected linter. Runs in parallel with the test job to minimize pipeline duration.</div></div></div>"
                                            },
                                            {
                                                "when": {
                                                    "textContains": "â—‹ Lint"
                                                },
                                                "content": "No lint command detected â€” lint job will be skipped.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">âœ¨ Lint Â· no stack</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">No language stack detected for linting. Configure your stack or manually specify a lint command in the Basic Workflow form.</div></div></div>"
                                            }
                                        ],
                                        "children": []
                                    },
                                    {
                                        "id": "ci-job-docker",
                                        "title": "Docker Build",
                                        "icon": "ğŸ³",
                                        "selector": "#wiz-ci-job-docker",
                                        "content": "Docker image build + push step in the composed pipeline.",
                                        "variants": [
                                            {
                                                "when": {
                                                    "textContains": "âœ“ Docker Build"
                                                },
                                                "content": "Docker build included â€” builds container image and pushes to configured registry.",
                                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ³ Docker Build Â· included</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Docker build + push step will be generated. Runs after test/lint pass. Uses buildx for multi-platform support. Image tagged with branch, tag, and commit SHA.</div></div></div>"
                                            },
                                            {
                                                "when": {
                                                    "textContains": "â—‹ Docker Build"
                                                },
                                                "content": "No Docker config â€” build step will be omitted.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ³ Docker Build Â· skipped</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">No Dockerfile detected. Docker build and push steps will not be included. Set up the Docker integration first if you need containerized deployments.</div></div></div>"
                                            }
                                        ],
                                        "children": []
                                    },
                                    {
                                        "id": "ci-job-k8s",
                                        "title": "K8s Deploy",
                                        "icon": "â˜¸ï¸",
                                        "selector": "#wiz-ci-job-k8s",
                                        "content": "Kubernetes deployment step in the composed pipeline.",
                                        "variants": [
                                            {
                                                "when": {
                                                    "textContains": "âœ“ K8s Deploy"
                                                },
                                                "content": "K8s deploy included â€” deploys to cluster after build steps complete.",
                                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">â˜¸ï¸ K8s Deploy Â· included</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Kubernetes deployment step will be generated. Deploy method (kubectl, helm, skaffold) is configurable below. Runs after Docker build when Docker is also connected.</div></div></div>"
                                            },
                                            {
                                                "when": {
                                                    "textContains": "â—‹ K8s Deploy"
                                                },
                                                "content": "No K8s manifests â€” deploy step will be omitted.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â˜¸ï¸ K8s Deploy Â· skipped</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">No Kubernetes manifests detected. K8s deployment steps will not be included. Set up the K8s integration first.</div></div></div>"
                                            }
                                        ],
                                        "children": []
                                    },
                                    {
                                        "id": "ci-job-terraform",
                                        "title": "Terraform",
                                        "icon": "ğŸ—ï¸",
                                        "selector": "#wiz-ci-job-terraform",
                                        "content": "Terraform infrastructure provisioning step in the composed pipeline.",
                                        "variants": [
                                            {
                                                "when": {
                                                    "textContains": "âœ“ Terraform"
                                                },
                                                "content": "Terraform included â€” runs plan + apply before deployment steps.",
                                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ—ï¸ Terraform Â· included</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Terraform plan and apply steps will be generated. Infrastructure provisioning runs before deployment to ensure resources exist.</div></div></div>"
                                            },
                                            {
                                                "when": {
                                                    "textContains": "â—‹ Terraform"
                                                },
                                                "content": "No Terraform config â€” infra provisioning step will be omitted.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ—ï¸ Terraform Â· skipped</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">No Terraform configuration detected. Infrastructure provisioning steps will not be included.</div></div></div>"
                                            }
                                        ],
                                        "children": []
                                    },
                                    {
                                        "id": "ci-job-envs",
                                        "title": "Multi-env",
                                        "icon": "âš™ï¸",
                                        "selector": "#wiz-ci-job-envs",
                                        "content": "Multi-environment deployment in the composed pipeline.",
                                        "variants": [
                                            {
                                                "when": {
                                                    "textContains": "âœ“ Multi-env"
                                                },
                                                "content": "Multi-env included â€” generates per-environment deployment jobs with staging â†’ production flow.",
                                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âš™ï¸ Multi-env Â· included</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Multiple environments detected. Pipeline will generate per-environment deployment jobs with GitHub environment protection rules and sequential deployment gates.</div></div></div>"
                                            },
                                            {
                                                "when": {
                                                    "textContains": "â—‹ Single env"
                                                },
                                                "content": "Single environment â€” deploys to one target without environment matrix.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">âš™ï¸ Single env</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Only one environment detected. Pipeline deploys directly without environment matrix or staged rollout. Configure environments in the wizard for multi-stage deployments.</div></div></div>"
                                            }
                                        ],
                                        "children": []
                                    },
                                    {
                                        "id": "ci-job-pages",
                                        "title": "Pages Deploy",
                                        "icon": "ğŸ“„",
                                        "selector": "#wiz-ci-job-pages",
                                        "content": "Pages/documentation site deploy step in the composed pipeline.",
                                        "variants": [
                                            {
                                                "when": {
                                                    "textContains": "âœ“ Pages Deploy"
                                                },
                                                "content": "Pages deploy included â€” builds and deploys documentation site.",
                                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ“„ Pages Â· included</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Pages/documentation site detected. A build + deploy step will be added to the pipeline for GitHub Pages deployment.</div></div></div>"
                                            },
                                            {
                                                "when": {
                                                    "textContains": "â—‹ Pages"
                                                },
                                                "content": "No Pages site â€” site deploy step will be omitted.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“„ Pages Â· skipped</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">No documentation or static site configuration detected. Pages deploy steps will not be included.</div></div></div>"
                                            }
                                        ],
                                        "children": []
                                    },
                                    {
                                        "id": "ci-field-strategy",
                                        "title": "Workflow Strategy",
                                        "icon": "ğŸ“",
                                        "selector": "#wiz-ci-compose-strategy",
                                        "content": "How the pipeline is organized â€” single file or split across multiple workflow files.",
                                        "variants": [
                                            {
                                                "when": {
                                                    "resolver": "ciStrategyValue",
                                                    "equals": "unified"
                                                },
                                                "content": "Unified strategy â€” all jobs in a single ci-cd.yml file.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“ Unified Strategy</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">All pipeline jobs (test, build, deploy) are defined in a single <code>ci-cd.yml</code> file. Jobs use <code>needs:</code> to define dependencies.</div><div class=\"state-text\"><strong>Pros:</strong> simpler to manage, single trigger, jobs share context<br><strong>Cons:</strong> a single file can become complex for large pipelines</div></div></div>"
                                            },
                                            {
                                                "when": {
                                                    "resolver": "ciStrategyValue",
                                                    "equals": "split"
                                                },
                                                "content": "Split strategy â€” separate workflow files linked with workflow_run triggers.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“ Split Strategy</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Pipeline is split across multiple files (e.g., <code>ci.yml</code>, <code>build.yml</code>, <code>deploy.yml</code>). Files are linked using <code>workflow_run</code> triggers.</div><div class=\"state-text\"><strong>Pros:</strong> modular, easier to maintain individually, reusable across repos<br><strong>Cons:</strong> more files, slightly harder to debug dependencies</div></div></div>"
                                            }
                                        ],
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“ Workflow Strategy</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Choose how the pipeline is organized:<br>â€¢ <strong>Unified</strong> â€” single ci-cd.yml with all jobs<br>â€¢ <strong>Split</strong> â€” separate files linked by workflow_run</div></div></div>",
                                        "children": []
                                    },
                                    {
                                        "id": "ci-field-deploy",
                                        "title": "Deploy Method",
                                        "icon": "â˜¸ï¸",
                                        "selector": "#wiz-ci-compose-deploy",
                                        "content": "How to deploy to Kubernetes â€” only shown when K8s manifests are detected.",
                                        "variants": [
                                            {
                                                "when": {
                                                    "resolver": "ciDeployValue",
                                                    "equals": "kubectl"
                                                },
                                                "content": "kubectl apply â€” direct manifest deployment using kubectl.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â˜¸ï¸ kubectl</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Uses <code>kubectl apply -f</code> to deploy manifests directly. Simple and transparent â€” what you see in the YAML is what gets deployed.</div><div class=\"state-text\">Best for: simple deployments, small teams, when you want full control over manifests.</div></div></div>"
                                            },
                                            {
                                                "when": {
                                                    "resolver": "ciDeployValue",
                                                    "equals": "helm"
                                                },
                                                "content": "Helm upgrade â€” deploy via Helm chart releases with templated values.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â˜¸ï¸ Helm</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Uses <code>helm upgrade --install</code> to manage releases. Helm provides templating, versioning, and rollback capabilities for Kubernetes deployments.</div><div class=\"state-text\">Best for: complex deployments, multiple environments with different values, rollback needs.</div></div></div>"
                                            },
                                            {
                                                "when": {
                                                    "resolver": "ciDeployValue",
                                                    "equals": "skaffold"
                                                },
                                                "content": "Skaffold â€” build + deploy with Skaffold's pipeline orchestration.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â˜¸ï¸ Skaffold</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Uses <code>skaffold run</code> to handle the full build â†’ tag â†’ deploy lifecycle. Skaffold manages Docker builds and K8s deployment together with profiles for different environments.</div><div class=\"state-text\">Best for: dev-loop parity, teams that want CI to mirror their local workflow.</div></div></div>"
                                            }
                                        ],
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â˜¸ï¸ Deploy Method</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Select the Kubernetes deployment strategy:<br>â€¢ <strong>kubectl</strong> â€” direct manifest apply<br>â€¢ <strong>helm</strong> â€” chart-based releases<br>â€¢ <strong>skaffold</strong> â€” full build + deploy pipeline</div></div></div>",
                                        "children": []
                                    },
                                    {
                                        "id": "ci-field-registry",
                                        "title": "Docker Registry",
                                        "icon": "ğŸ³",
                                        "selector": "#wiz-ci-compose-registry",
                                        "content": "Docker registry for pushing built images â€” only shown when Docker is detected.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ³ Docker Registry</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">The container registry where built images are pushed. Common options:<br>â€¢ <strong>ghcr.io</strong> â€” GitHub Container Registry (free for public repos)<br>â€¢ <strong>docker.io</strong> â€” Docker Hub<br>â€¢ <strong>*.dkr.ecr.*.amazonaws.com</strong> â€” AWS ECR<br>â€¢ <strong>gcr.io</strong> â€” Google Container Registry<br><br>Format: <code>registry/org</code> â€” the image name and tag are appended automatically.</div></div></div>",
                                        "children": []
                                    },
                                    {
                                        "id": "ci-btn-compose",
                                        "title": "Generate Pipeline",
                                        "icon": "ğŸš€",
                                        "selector": "#wiz-ci-btn-compose",
                                        "content": "Generate the complete CI/CD pipeline based on all detected connections and compose settings.",
                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸš€ Generate Pipeline</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Generates workflow file(s) combining all connected integrations. The output preview will appear below, showing the generated YAML before it's written to <code>.github/workflows/</code>.</div></div></div>",
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "id": "ci-apply",
                                "title": "Apply",
                                "icon": "âœ…",
                                "selector": "#wiz-apply-int-ci",
                                "content": "Generate the basic CI workflow file with the settings from the form above.",
                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Apply Basic Workflow</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Generates a single <code>.github/workflows/ci.yml</code> file with test + lint jobs based on the form values. The file is created in your project directory.</div></div></div>",
                                "children": []
                            },
                            {
                                "id": "ci-cancel",
                                "title": "Cancel",
                                "icon": "âœ–",
                                "selector": "#wiz-cancel-int-ci",
                                "content": "Close the CI/CD setup panel without generating any files. No changes are made.",
                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">âœ– Discard</div><div class=\"state-detail\">Cancel collapses the CI/CD setup panel without generating any files or modifying existing workflows.<br><br>Reopen anytime with âš™ï¸ Setup â€” all form fields repopulate from the current project state.</div></div>",
                                "children": []
                            },
                            {
                                "id": "ci-btn-delete",
                                "title": "Delete Workflow",
                                "icon": "ğŸ—‘",
                                "selector": "#wiz-ci-btn-delete",
                                "content": "Delete the generated CI workflow files â€” removes .github/workflows files created by the wizard.",
                                "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">ğŸ—‘ Delete Workflow</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Removes CI workflow files generated by the wizard. This only deletes wizard-generated files â€” manually created workflows are preserved.<br><br>âš  This action cannot be undone. The files are deleted from disk immediately.</div></div></div>",
                                "children": []
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "context": "setup/git",
        "title": "Git Setup",
        "icon": "ğŸ”€",
        "content": "Git is the foundation of the control plane â€” remotes, .gitignore, hooks, and CI/CD all build on top of it.\n\n{{gitStepIntro}}",
        "children": [
            {
                "id": "detect-banner",
                "title": "Read-only Scan",
                "icon": "ğŸ”",
                "selector": "#git-detect-banner",
                "content": "This step only reads â€” no files are created, no settings are changed. It shows what's already configured so you can decide what to do in Configure.",
                "children": []
            },
            {
                "id": "detect-section",
                "title": "Git Repository",
                "icon": "ğŸ“",
                "selector": "#git-detect-section",
                "separator": true,
                "content": "The scan results for your project's Git configuration. Each row below is a check â€” green means ready, yellow means partial, red means missing.",
                "children": [
                    {
                        "id": "detect-grid",
                        "title": "Detection Results",
                        "icon": "ğŸ“Š",
                        "selector": "#git-detect-grid",
                        "content": "All Git checks at a glance. The status rows below tell you what's installed, what's configured, and what's missing.",
                        "children": [
                            {
                                "id": "detect-cli",
                                "title": "Git CLI",
                                "icon": "âš™ï¸",
                                "selector": "#git-detect-cli",
                                "content": "Git is the foundation â€” every check below depends on it being present.",
                                "variants": [
                                    {
                                        "when": {
                                            "textContains": "Installed"
                                        },
                                        "content": "Git is installed and available.",
                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Installed</div><div class=\"state-detail\">Git is the foundation â€” remotes, .gitignore, hooks, and the entire CI/CD pipeline all depend on it. Version doesn't matter much as long as it's reasonably recent.\n\nEverything below this row assumes git is installed. If this check fails, nothing else in the wizard can work.</div></div>"
                                    },
                                    {
                                        "when": {
                                            "textContains": "Not found"
                                        },
                                        "content": "Git is not installed â€” nothing else in this wizard can work without it.",
                                        "expanded": "<div class=\"assistant-state-card state-error\"><div class=\"state-label\">âŒ Not Found</div><div class=\"state-detail\">Without Git, no repository can be initialized, no remotes can be added, and no .gitignore can be managed. Every integration downstream â€” GitHub, CI/CD, Docker â€” assumes a git repository exists.\n\nInstall git first, then re-open this wizard.\n\nğŸ“¦ sudo apt-get install git</div></div>"
                                    }
                                ],
                                "children": []
                            },
                            {
                                "id": "detect-repo",
                                "title": "Repository",
                                "icon": "ğŸ“",
                                "selector": "#git-detect-repo",
                                "content": "Whether a .git directory exists and your current branch.",
                                "variants": [
                                    {
                                        "when": {
                                            "textContains": "Initialized"
                                        },
                                        "content": "Your repository is live and tracking changes.",
                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Initialized</div><div class=\"state-detail\">Your repository is live. The branch shown here is what you'll push from â€” you can rename it in the Configure step if needed.\n\nThe control plane reads your commit history, branch state, and remote configuration from the .git directory.</div></div>"
                                    },
                                    {
                                        "when": {
                                            "textContains": "Not initialized"
                                        },
                                        "content": "No repository yet â€” the Configure step will create one.",
                                        "expanded": "<div class=\"assistant-state-card state-error\"><div class=\"state-label\">ğŸ“­ Not Initialized</div><div class=\"state-detail\">No .git directory found. The Configure step will run git init for you and set your default branch.\n\nUntil a repository is initialized, remotes can't be added and commits can't be made. This is the first thing the wizard will fix.</div></div>"
                                    }
                                ],
                                "children": []
                            },
                            {
                                "id": "detect-remotes",
                                "title": "Remotes",
                                "icon": "ğŸŒ",
                                "content": "Remote connections link your local repository to GitHub, GitLab, or other hosts â€” they're where git push sends your code.",
                                "dynamic": true,
                                "childTemplate": {
                                    "title": "{{name}}",
                                    "nameSelector": ".wiz-status-label",
                                    "content": "A configured git remote.",
                                    "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸŒ Connected</div><div class=\"state-detail\">This is where git push sends your code. If the URL needs to change (e.g., SSH â†” HTTPS, or a repo move), update it in the Configure step.\n\nThe GitHub Setup wizard (next) uses your remote URL to connect environments, secrets, and CI/CD to this repository.</div></div>",
                                    "selector": "[id^='git-detect-remote-']:not(#git-detect-remote-none)"
                                },
                                "children": [
                                    {
                                        "id": "detect-remote-none",
                                        "title": "No Remote",
                                        "icon": "âš ï¸",
                                        "selector": "#git-detect-remote-none",
                                        "content": "No remotes configured â€” your work stays local.",
                                        "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš ï¸ No Remote</div><div class=\"state-detail\">Without a remote, you can't push, pull, or sync your code. Your commits stay on this machine only.\n\nAdd a remote in the Configure step â€” if the GitHub CLI is authenticated, the URL can be pre-filled automatically.</div></div>",
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "id": "detect-gitignore",
                                "title": ".gitignore",
                                "icon": "ğŸ“„",
                                "selector": "#git-detect-gitignore",
                                "content": "Controls which files git tracks â€” protects your repo from committing secrets, build artifacts, and OS clutter.",
                                "variants": [
                                    {
                                        "when": {
                                            "textContains": "100%"
                                        },
                                        "content": "Your .gitignore covers all recommended patterns.",
                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Complete Coverage</div><div class=\"state-detail\">Your .gitignore covers all recommended patterns for your detected stacks. No action needed â€” the Configure step will skip this section.\n\nThe control plane checks coverage against your project's detected stacks (Python, Node, Docker, etc.) and common sensitive patterns (.env, credentials, IDE files).</div></div>"
                                    },
                                    {
                                        "when": {
                                            "textContains": "Present"
                                        },
                                        "content": "Your .gitignore exists but has coverage gaps.",
                                        "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš ï¸ Partial Coverage</div><div class=\"state-detail\">Some recommended patterns are missing â€” these gaps could leak build artifacts or sensitive files into your repository.\n\nThe Configure step shows exactly which patterns are missing and can replace your .gitignore with a complete, stack-aware version. You'll see a preview before anything changes.</div></div>"
                                    },
                                    {
                                        "when": {
                                            "textContains": "Missing"
                                        },
                                        "content": "No .gitignore â€” everything gets committed.",
                                        "expanded": "<div class=\"assistant-state-card state-error\"><div class=\"state-label\">âŒ Missing</div><div class=\"state-detail\">Without a .gitignore, everything in your project directory gets committed â€” secrets, build output, OS metadata, IDE files, node_modules, __pycache__, all of it.\n\nThe Configure step will generate one tuned to your detected stacks. It analyzes your project's languages and frameworks to produce the right patterns.\n\nâš ï¸ If you've already pushed without a .gitignore, those files are in your git history. Adding one now prevents future leaks but doesn't clean the past.</div></div>"
                                    }
                                ],
                                "children": []
                            },
                            {
                                "id": "detect-hooks",
                                "title": "Hooks",
                                "icon": "ğŸª",
                                "selector": "#git-detect-hooks",
                                "content": "Git hooks run scripts automatically at specific points â€” before commits, before pushes, after merges.",
                                "variants": [
                                    {
                                        "when": {
                                            "textContains": "active"
                                        },
                                        "content": "You've got quality gates that run before code leaves your machine.",
                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸª Active</div><div class=\"state-detail\">These hooks run automatically â€” they're your first line of defense against committing broken or non-compliant code.\n\nThe wizard will preserve existing hooks during setup. If you want to modify them, you can do that through the Configure step or directly in .git/hooks/.</div></div>"
                                    },
                                    {
                                        "when": {
                                            "textContains": "None"
                                        },
                                        "content": "No automated checks before commits.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â– None Configured</div><div class=\"state-detail\">No hooks means no automated checks before commits or pushes. Code goes straight to the repository without validation.\n\nIf lint tools are detected in your project (ruff, eslint, mypy, etc.), the Configure step can set up a pre-commit hook that runs them automatically before each commit.\n\nğŸ’¡ Pre-commit hooks are lightweight â€” they typically add 1â€“3 seconds to each commit.</div></div>"
                                    }
                                ],
                                "children": []
                            },
                            {
                                "id": "detect-ghcli",
                                "title": "GitHub CLI",
                                "icon": "ğŸ™",
                                "selector": "#git-detect-ghcli",
                                "content": "The gh CLI enables deeper GitHub integration â€” not required for Git setup, but unlocks secrets sync and CI/CD management.",
                                "variants": [
                                    {
                                        "when": {
                                            "textContains": "Authenticated"
                                        },
                                        "content": "GitHub CLI is linked â€” Configure can pre-fill your remote URL.",
                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Authenticated</div><div class=\"state-detail\">The GitHub CLI is logged in and linked to a repository. This means:\n\nâ€¢ The Configure step can pre-fill your remote URL from the linked repo\nâ€¢ The GitHub Setup wizard (next after Git) will use this for environments, secrets sync, and CI/CD\nâ€¢ You can manage pull requests, dispatch workflows, and create deployment environments from the dashboard\n\nğŸ’¡ The gh CLI is how the control plane interacts with GitHub â€” no raw API tokens needed.</div></div>"
                                    },
                                    {
                                        "when": {
                                            "textContains": "not authenticated"
                                        },
                                        "content": "gh is installed but not logged in.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">âš ï¸ Not Authenticated</div><div class=\"state-detail\">The GitHub CLI is installed but not logged in. You can still complete Git setup without it â€” remotes, .gitignore, and hooks don't need GitHub authentication.\n\nTo unlock the full GitHub integration later, run:\n\ngh auth login\n\nThis enables secrets sync, environment management, and CI/CD dispatch from the dashboard.</div></div>"
                                    },
                                    {
                                        "when": {
                                            "textContains": "Not installed"
                                        },
                                        "content": "gh CLI is not installed â€” not a problem for Git setup.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â– Not Installed</div><div class=\"state-detail\">The GitHub CLI is optional for Git setup â€” remotes, .gitignore, and hooks work without it.\n\nBut if you plan to use the GitHub Setup wizard next (for environments, secrets sync, and CI/CD), installing gh unlocks the full experience.\n\nğŸ“¦ sudo snap install gh</div></div>"
                                    }
                                ],
                                "children": []
                            }
                        ]
                    }
                ]
            },
            {
                "id": "detect-hints",
                "title": "Recommendations",
                "icon": "ğŸ’¡",
                "selector": "#git-detect-hints",
                "separator": true,
                "content": "These are opportunities detected in your project â€” each one maps to a configuration section in the next step.",
                "expanded": "The hints below summarize what the Configure step can act on. They're generated from your scan results: detected stacks determine .gitignore patterns, missing patterns trigger replacement suggestions, and detected lint tools enable pre-commit hook setup.\n\nğŸ’¡ If no hints appear, your Git setup is already solid.",
                "children": []
            },
            {
                "id": "cfg-remotes",
                "title": "Remotes",
                "icon": "ğŸŒ",
                "selector": "#git-cfg-remotes",
                "separator": true,
                "content": "This is where you wire your local repo to a host. Changes in this section are immediate â€” edits and removals hit the API the moment you click, not at Review.",
                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">âš¡ Live Actions</div><div class=\"state-detail\">Unlike branch, .gitignore, and hooks (which queue up for the Review step), remote operations execute immediately:\n\nâ€¢ <strong>âœï¸ URL</strong> â€” runs <code>git remote set-url</code> right now\nâ€¢ <strong>ğŸ—‘ Remove</strong> â€” runs <code>git remote remove</code> (asks \"Sure?\" first)\nâ€¢ <strong>ï¼‹ Add</strong> â€” runs <code>git remote add</code> immediately\n\nThe remote URL you configure here feeds directly into the GitHub Setup wizard â€” it uses it to connect environments, secrets, and CI/CD to this repository.</div></div>",
                "children": [
                    {
                        "id": "cfg-remotes-table",
                        "title": "Current Remotes",
                        "icon": "ğŸ“‹",
                        "selector": "#git-cfg-remotes-table",
                        "content": "Your existing remote connections. Each row has live action buttons â€” changes apply instantly.",
                        "dynamic": true,
                        "childTemplate": {
                            "title": "{{name}}",
                            "nameSelector": "code",
                            "content": "A configured git remote â€” click âœï¸ to change its URL or ğŸ—‘ to remove it.",
                            "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ”— Remote Connection</div><div class=\"state-detail\">This remote is where <code>git push</code> sends your code and <code>git pull</code> fetches updates from.\n\n<strong>âœï¸ URL</strong> changes the fetch/push endpoint. Common reason: switching between HTTPS and SSH, or moving to a different repository.\n\n<strong>ğŸ—‘ Remove</strong> disconnects this remote. Your local branches and history are unaffected â€” only the link to the remote host is removed.</div></div>",
                            "selector": "[id^='remote-row-']",
                            "variants": [
                                {
                                    "when": {
                                        "textContains": "git@"
                                    },
                                    "content": "This remote uses SSH â€” requires an SSH key configured on the host.",
                                    "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ” SSH Protocol</div><div class=\"state-detail\">SSH remotes authenticate with your SSH key, not a password or token. This is generally more secure and convenient for development â€” you won't be prompted for credentials on every push.\n\nIf pushes fail with \"Permission denied (publickey)\", your SSH key may not be added to the host. Check with <code>ssh -T git@github.com</code>.\n\nTo switch to HTTPS, click âœï¸ URL and use the <code>https://</code> version of the repository URL.</div></div>"
                                },
                                {
                                    "when": {
                                        "textContains": "https://"
                                    },
                                    "content": "This remote uses HTTPS â€” authenticates with tokens or credential helpers.",
                                    "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸŒ HTTPS Protocol</div><div class=\"state-detail\">HTTPS remotes authenticate via Personal Access Tokens, credential managers, or the GitHub CLI's credential helper.\n\nIf you're using the GitHub CLI (<code>gh</code>), it automatically handles HTTPS credentials. Otherwise, you may be prompted for a username/token on push.\n\nTo switch to SSH (avoids token management), click âœï¸ URL and use the <code>git@host:user/repo.git</code> format.</div></div>"
                                }
                            ]
                        },
                        "children": []
                    },
                    {
                        "id": "cfg-no-remotes",
                        "title": "No Remotes",
                        "icon": "âš ï¸",
                        "selector": "#git-cfg-no-remotes",
                        "content": "Without a remote, your commits stay on this machine only â€” no push, no pull, no collaboration.",
                        "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš ï¸ Local Only</div><div class=\"state-detail\">A remote is the link between your local repository and a host like GitHub, GitLab, or Bitbucket. Without one:\n\nâ€¢ <code>git push</code> has nowhere to send code\nâ€¢ CI/CD pipelines can't trigger\nâ€¢ No backup exists outside this machine\n\nUse the Add Remote form below. If the GitHub CLI is authenticated, the URL will be pre-filled for you.\n\nConvention: your first remote should be named <code>origin</code>.</div></div>",
                        "children": []
                    },
                    {
                        "id": "cfg-add-remote",
                        "title": "Add Remote",
                        "icon": "ï¼‹",
                        "selector": "#git-cfg-add-remote",
                        "content": "Add a new remote connection. This executes immediately â€” the remote is added the moment you click ï¼‹ Add.",
                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“ Fields</div><div class=\"state-detail\"><strong>Name</strong> â€” conventionally <code>origin</code> for your primary remote, <code>upstream</code> for the original repo in a fork workflow.\n\n<strong>URL</strong> â€” the repository endpoint. Two formats:\nâ€¢ SSH: <code>git@github.com:user/repo.git</code>\nâ€¢ HTTPS: <code>https://github.com/user/repo.git</code>\n\nIf the GitHub CLI is authenticated and you have no remotes, the URL is pre-filled from your linked repository.</div></div>",
                        "children": [
                            {
                                "id": "cfg-add-remote-name",
                                "title": "Remote Name",
                                "icon": "ğŸ·ï¸",
                                "selector": "#mf-add-remote-name",
                                "content": "The name identifies this remote locally. Convention: origin for your primary, upstream for the source repo in a fork workflow.",
                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ·ï¸ Naming Conventions</div><div class=\"state-detail\"><strong><code>origin</code></strong> â€” your primary remote. This is where <code>git push</code> sends code by default. Use this if you own the repo or it's your fork.\n\n<strong><code>upstream</code></strong> â€” the original repository you forked from. Used in fork workflows to pull updates from the original while pushing to your fork.\n\nOther names are allowed but rare. CI/CD tools, deploy scripts, and documentation typically assume <code>origin</code> exists â€” deviating from this convention can cause subtle issues.\n\nIf you leave this blank, the placeholder value is used.</div></div>",
                                "variants": [
                                    {
                                        "when": {
                                            "hasSelector": "#git-cfg-remotes-table"
                                        },
                                        "content": "You already have remotes â€” this would typically be upstream (the original repo in a fork) or a secondary deployment target.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ”€ Additional Remote</div><div class=\"state-detail\">Since you already have an <code>origin</code>, common names for a second remote:\n\nâ€¢ <strong><code>upstream</code></strong> â€” the repo you forked from. Pull updates with <code>git pull upstream main</code>.\nâ€¢ <strong><code>deploy</code></strong> â€” a deploy target (e.g., Heroku, a staging server).\nâ€¢ <strong><code>backup</code></strong> â€” a mirror on a different host.\n\nAvoid adding a second remote pointing to the same repository â€” there's rarely a reason, and it creates confusion about which to push to.</div></div>"
                                    }
                                ],
                                "children": []
                            },
                            {
                                "id": "cfg-add-remote-url",
                                "title": "Remote URL",
                                "icon": "ğŸ”—",
                                "selector": "#mf-add-remote-url",
                                "content": "The repository endpoint â€” where Git sends and fetches code. Supports SSH and HTTPS formats.",
                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ”— URL Formats</div><div class=\"state-detail\">Two formats, same destination:\n\n<strong>SSH</strong>: <code>git@github.com:user/repo.git</code>\nâ€¢ Authenticates with your SSH key\nâ€¢ No password prompts after key setup\nâ€¢ Requires SSH key added to the host\n\n<strong>HTTPS</strong>: <code>https://github.com/user/repo.git</code>\nâ€¢ Works immediately, no SSH setup\nâ€¢ Authenticates via PAT, credential manager, or <code>gh</code> CLI\nâ€¢ Some orgs require HTTPS for audit/firewall reasons\n\nBoth support push and pull. Choose based on your auth setup â€” you can always switch later with âœï¸ URL.</div></div>",
                                "variants": [
                                    {
                                        "when": {
                                            "textContains": "github.com"
                                        },
                                        "content": "Pre-filled from your GitHub CLI authentication â€” this points to your linked repository.",
                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ™ GitHub CLI Pre-fill</div><div class=\"state-detail\">The URL was automatically populated from your <code>gh</code> CLI authentication. This is the repository linked to your current GitHub session.\n\nYou can modify this URL before clicking ï¼‹ Add if needed â€” for example, to use the SSH format (<code>git@github.com:...</code>) instead of HTTPS.\n\nThis pre-fill only appears when the GitHub CLI is authenticated and you have no remotes yet.</div></div>"
                                    }
                                ],
                                "children": []
                            },
                            {
                                "id": "cfg-add-remote-btn",
                                "title": "Add Button",
                                "icon": "ï¼‹",
                                "selector": "#git-add-remote-btn",
                                "content": "Adds the remote immediately â€” runs git remote add right now, not at Review.",
                                "children": []
                            }
                        ]
                    }
                ]
            },
            {
                "id": "cfg-branch",
                "title": "Default Branch",
                "icon": "ğŸŒ¿",
                "selector": "#git-cfg-branch",
                "separator": true,
                "content": "The branch name set here becomes your repository's default. This is applied during the Review step, not immediately.",
                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸŒ¿ Branch Naming</div><div class=\"state-detail\"><code>main</code> is the modern standard â€” GitHub, GitLab, and most tools default to it since 2020.\n\nIf you already have commits on a branch with a different name, changing this value will rename the branch using <code>git branch -M</code>. Your history is preserved â€” only the pointer name changes.\n\nâš ï¸ If a CI/CD pipeline or branch protection rule targets the old name, you'll need to update those references after renaming.</div></div>",
                "children": [
                    {
                        "id": "cfg-branch-input",
                        "title": "Branch Name",
                        "icon": "âœï¸",
                        "selector": "#mf-git-branch",
                        "content": "The name for your default branch. Most teams use main â€” the value here is applied at Review.",
                        "variants": [
                            {
                                "when": {
                                    "textContains": "Current:"
                                },
                                "content": "You already have a branch â€” changing the name here will rename it, not create a new one.",
                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ”„ Rename</div><div class=\"state-detail\">Since you already have a branch, changing this value runs <code>git branch -M &lt;new-name&gt;</code> during the Review step. This is a rename, not a new branch â€” all existing commits stay on the renamed branch.\n\nLeave this unchanged if you're happy with your current branch name.</div></div>"
                            },
                            {
                                "when": {
                                    "textContains": "Will be set on init"
                                },
                                "content": "No branch exists yet â€” this name will be used when the repository is initialized.",
                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ†• New Repository</div><div class=\"state-detail\">Since the repository isn't initialized yet, no branch exists. The value here sets the name of the branch created by <code>git init</code>.\n\nStick with <code>main</code> unless your team uses a different convention. This can always be renamed later.</div></div>"
                            }
                        ],
                        "children": []
                    }
                ]
            },
            {
                "id": "cfg-gitignore",
                "title": ".gitignore",
                "icon": "ğŸ“„",
                "selector": "#git-cfg-gitignore",
                "separator": true,
                "content": "The .gitignore file controls which files Git tracks. Patterns here are generated from your detected stacks â€” Python, Node, Docker, etc.",
                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“„ Stack-Aware Generation</div><div class=\"state-detail\">The control plane scans your project for technology stacks and generates a .gitignore that covers:\n\nâ€¢ <strong>Build artifacts</strong> â€” dist/, build/, __pycache__/\nâ€¢ <strong>Dependencies</strong> â€” node_modules/, .venv/\nâ€¢ <strong>Secrets</strong> â€” .env, *.pem, credentials files\nâ€¢ <strong>IDE/OS clutter</strong> â€” .vscode/, .idea/, .DS_Store\n\nPatterns are stack-specific: a Python project gets <code>*.pyc</code>, a Node project gets <code>node_modules/</code>, and so on. Coverage percentage reflects how many recommended patterns are already present.</div></div>",
                "children": [
                    {
                        "id": "cfg-gitignore-ok",
                        "title": "Complete",
                        "icon": "âœ…",
                        "selector": "#git-cfg-gitignore-ok",
                        "content": "Your .gitignore already covers all recommended patterns â€” nothing to configure here.",
                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Full Coverage</div><div class=\"state-detail\">Every pattern recommended for your detected stacks is already present. The wizard won't modify your .gitignore.\n\nIf you add new stacks later (e.g., add Docker to a Python project), re-running this wizard will detect the gap and offer to update.</div></div>",
                        "children": []
                    },
                    {
                        "id": "cfg-gitignore-missing",
                        "title": "Missing Patterns",
                        "icon": "âš ï¸",
                        "selector": "#git-cfg-gitignore-missing",
                        "content": "These patterns are recommended for your stacks but aren't in your .gitignore yet. Each one is a potential leak.",
                        "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš ï¸ Coverage Gaps</div><div class=\"state-detail\">Missing patterns mean files that <em>should</em> be ignored are being tracked (or could be committed accidentally).\n\nCommon consequences of missing patterns:\nâ€¢ <strong>Secrets committed</strong> â€” .env files with API keys end up in history\nâ€¢ <strong>Bloated diffs</strong> â€” build artifacts create noise in pull requests\nâ€¢ <strong>Platform conflicts</strong> â€” .DS_Store or Thumbs.db files from other OSes\n\nThe \"Replace\" checkbox below replaces your entire .gitignore with the generated version. If you've added custom patterns, review the preview to make sure they're preserved.</div></div>",
                        "children": []
                    },
                    {
                        "id": "cfg-gitignore-replace",
                        "title": "Replace .gitignore",
                        "icon": "ğŸ”„",
                        "selector": "#mf-gitignore-replace",
                        "content": "Replaces your existing .gitignore entirely with the generated version. This is a full replacement, not a merge.",
                        "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">ğŸ”„ Full Replacement</div><div class=\"state-detail\">This replaces the <em>entire</em> file content, not just the missing patterns. Your existing custom patterns will be lost unless they also appear in the generated version.\n\n<strong>Before checking this:</strong> review the preview below. If you have custom patterns you want to keep, click âœï¸ Edit and add them to the generated content.\n\nThe actual replacement happens at the Review step â€” nothing is written yet.</div></div>",
                        "children": []
                    },
                    {
                        "id": "cfg-gitignore-create",
                        "title": "Create .gitignore",
                        "icon": "ğŸ“",
                        "selector": "#mf-gitignore-create",
                        "content": "Creates a new .gitignore file with all recommended patterns for your detected stacks.",
                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“ New File</div><div class=\"state-detail\">Your project currently has no .gitignore at all â€” every file in the directory is eligible for commits, including secrets, build artifacts, and IDE files.\n\nThe generated file covers all detected stacks. Review the preview below and click âœï¸ Edit if you want to add custom patterns.\n\nCreation happens at the Review step â€” nothing is written yet.</div></div>",
                        "children": []
                    },
                    {
                        "id": "cfg-gitignore-preview",
                        "title": "Preview",
                        "icon": "ğŸ“‹",
                        "selector": "#git-cfg-gitignore-preview",
                        "content": "What will be written to .gitignore. Click âœï¸ Edit to modify before applying.",
                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“‹ Preview â‰  Applied</div><div class=\"state-detail\">This is a read-only preview of the generated content. The file won't be written until the Review step.\n\nClick <strong>âœï¸ Edit</strong> to open an editable textarea â€” any changes you make there will be used instead of the generated version.\n\nPatterns use standard gitignore glob syntax:\nâ€¢ <code>*.pyc</code> â€” match files by extension\nâ€¢ <code>dist/</code> â€” match directories\nâ€¢ <code>!important.log</code> â€” negate (force-track a file)\nâ€¢ <code>#</code> â€” comments (ignored by Git)</div></div>",
                        "children": []
                    }
                ]
            },
            {
                "id": "cfg-hooks",
                "title": "Pre-commit Hook",
                "icon": "ğŸª",
                "selector": "#git-cfg-hooks",
                "separator": true,
                "content": "Runs your detected lint tools automatically before each commit â€” catches issues before they reach the repository.",
                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸª How It Works</div><div class=\"state-detail\">A pre-commit hook is a shell script at <code>.git/hooks/pre-commit</code> that Git runs before allowing a commit. If the script exits non-zero, the commit is aborted.\n\nThe wizard detected lint tools in your project and can wire them into this hook. Typical execution time is 1â€“3 seconds.\n\nThis is a local hook â€” it only runs on your machine. It doesn't affect collaborators unless they also set up pre-commit (or you use a tool like Husky to share hooks via the repo).</div></div>",
                "children": [
                    {
                        "id": "cfg-hooks-checkbox",
                        "title": "Setup Checkbox",
                        "icon": "â˜‘ï¸",
                        "selector": "#mf-setup-hooks",
                        "content": "Check this to create the hook script during Review. The tools listed below are the ones that will run.",
                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ›¡ï¸ Safety Net</div><div class=\"state-detail\">When enabled, every <code>git commit</code> will first run your lint tools. If any tool finds issues, the commit is blocked until you fix them.\n\nYou can always skip the hook with <code>git commit --no-verify</code> for emergency commits, but use that sparingly.\n\nThe hook script is created at the Review step. If you later add more lint tools, re-run this wizard to update the hook.</div></div>",
                        "children": []
                    }
                ]
            },
            {
                "id": "cfg-commit",
                "title": "Initial Commit",
                "icon": "ğŸ’¾",
                "selector": "#git-cfg-commit",
                "separator": true,
                "content": "Creates a first commit with your current project files. Only appears when the repository has no commits yet.",
                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ’¾ First Commit</div><div class=\"state-detail\">An initial commit establishes the starting point of your repository's history. Without at least one commit:\n\nâ€¢ <code>git log</code> shows nothing\nâ€¢ Branches can't be created\nâ€¢ Remotes can't be pushed to\n\nThe commit will include all files in the working directory (respecting .gitignore). If you enabled .gitignore creation above, it will be written first so the initial commit already excludes the right files.</div></div>",
                "children": [
                    {
                        "id": "cfg-commit-checkbox",
                        "title": "Create Commit",
                        "icon": "â˜‘ï¸",
                        "selector": "#mf-initial-commit",
                        "content": "Check this to create the initial commit during Review. Includes all files respecting .gitignore.",
                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“¦ What Gets Committed</div><div class=\"state-detail\">The initial commit runs <code>git add .</code> followed by <code>git commit -m \"...\"</code>. This stages every file in the project directory except those excluded by .gitignore.\n\nIf you also enabled .gitignore creation or replacement above, the wizard applies that first â€” so your initial commit won't include build artifacts, secrets, or other ignored files.\n\nOrder of operations at Review: init â†’ branch â†’ .gitignore â†’ hooks â†’ commit.</div></div>",
                        "children": []
                    },
                    {
                        "id": "cfg-commit-msg",
                        "title": "Commit Message",
                        "icon": "âœï¸",
                        "selector": "#mf-commit-msg",
                        "content": "The message for the first commit. Mostly symbolic â€” \"Initial commit\" is the universal convention.",
                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ’¬ Convention</div><div class=\"state-detail\">\"Initial commit\" is used by virtually every project. It signals the starting snapshot.\n\nSome teams prefer descriptive first messages like \"Bootstrap project with Flask + Docker\" â€” that's fine too, but the message matters less here than in regular development commits.\n\nIf your project enforces conventional commit format (<code>feat:</code>, <code>chore:</code>), you might use <code>chore: initial project setup</code>.</div></div>",
                        "children": []
                    }
                ]
            }
        ]
    },
    {
        "context": "setup/github",
        "title": "GitHub Setup",
        "icon": "ğŸ™",
        "content": "GitHub connects your repository to platform features â€” environments, secrets, CODEOWNERS, and visibility.\n\n{{ghStepIntro}}",
        "children": [
            {
                "id": "detect-banner",
                "title": "Read-only Scan",
                "icon": "ğŸ”",
                "selector": "#gh-detect-banner",
                "content": "This step queries your gh CLI and GitHub's API to inventory the current state. Nothing is modified â€” all changes happen in Configure.",
                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ” What's Being Scanned</div><div class=\"state-detail\">The detect step checks five things:\n\nâ€¢ <strong>gh CLI</strong> â€” is it installed and authenticated?\nâ€¢ <strong>Repository</strong> â€” is a GitHub repo linked via git remote?\nâ€¢ <strong>Infrastructure</strong> â€” .github/ dir, CODEOWNERS, workflows\nâ€¢ <strong>Environments</strong> â€” do local envs match GitHub deployment environments?\nâ€¢ <strong>Secrets</strong> â€” what's currently stored on GitHub?\n\nAll of this feeds into the Configure step, where you can act on what's found.</div></div>",
                "children": []
            },
            {
                "id": "detect-cli-section",
                "title": "GitHub CLI",
                "icon": "ğŸ”§",
                "selector": "#gh-detect-cli",
                "separator": true,
                "content": "The gh CLI is how the control plane talks to GitHub's API. Authentication and account identity flow through it â€” everything below depends on this section being green.",
                "children": [
                    {
                        "id": "detect-cli-grid",
                        "title": "CLI Status",
                        "icon": "ğŸ“Š",
                        "selector": "#gh-detect-cli-grid",
                        "content": "Tool availability and authentication â€” the two prerequisites for any GitHub API operation.",
                        "children": [
                            {
                                "id": "detect-cli-row",
                                "title": "gh CLI",
                                "icon": "ğŸ”§",
                                "selector": "#gh-detect-cli-row",
                                "content": "The gh CLI is how the control plane talks to GitHub â€” secret pushes, environment creation, visibility changes, and repo queries all go through it.",
                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ”§ Foundation Tool</div><div class=\"state-detail\">This is the same <code>gh</code> that powers the remote URL pre-fill in Git Setup. Without it, the control plane has no way to reach GitHub's API.\n\nIt handles:\nâ€¢ Repository queries (visibility, branches, description)\nâ€¢ Environment management (create, list)\nâ€¢ Secret and variable sync (push from vault)\nâ€¢ Authentication (OAuth token management)\n\nInstalled via your system package manager. Requires <code>sudo</code> on most systems.</div></div>",
                                "variants": [
                                    {
                                        "when": {
                                            "textContains": "Not installed"
                                        },
                                        "content": "Without gh, the control plane can't reach GitHub. Environments, secrets, visibility controls, and CI/CD management are all unavailable until it's installed.",
                                        "expanded": "<div class=\"assistant-state-card state-error\"><div class=\"state-label\">âŒ Blocker</div><div class=\"state-detail\">The gh CLI is not installed. This blocks <em>everything</em> in this wizard:\n\nâ€¢ Can't check if a repository is linked\nâ€¢ Can't query environments or secrets\nâ€¢ Can't manage visibility or CODEOWNERS\nâ€¢ Can't push vault secrets to GitHub\n\nUse the install button below, or install manually:\n<code>sudo apt install gh</code> (Debian/Ubuntu)\n<code>brew install gh</code> (macOS)\n\nAfter installing, click <strong>Re-scan</strong> to continue.</div></div>"
                                    },
                                    {
                                        "when": {
                                            "textContains": "Installed"
                                        },
                                        "content": "The gh CLI is present â€” the control plane can reach GitHub's API for environments, secrets, and repository management.",
                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Available</div><div class=\"state-detail\">The gh CLI is installed and ready. Version matters for some features â€” older versions may not support environment management or fine-grained tokens.\n\nThis is the same tool that powered remote URL pre-fill in Git Setup. If you authenticated there, you're already logged in here too.</div></div>"
                                    }
                                ],
                                "children": []
                            },
                            {
                                "id": "detect-auth-row",
                                "title": "Authentication",
                                "icon": "ğŸ”‘",
                                "selector": "#gh-detect-auth-row",
                                "content": "Authentication determines whether the control plane can actually make API calls to GitHub on your behalf.",
                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ”‘ API Access</div><div class=\"state-detail\">The gh CLI stores an OAuth token that grants access to GitHub's API. The token's scope determines what operations are available â€” some tokens can read repos but not create environments.\n\nAuthentication is shared across all control plane features. If you logged in during Git Setup, you're already authenticated here.</div></div>",
                                "variants": [
                                    {
                                        "when": {
                                            "textContains": "Not logged"
                                        },
                                        "content": "Not authenticated â€” the control plane can't query repositories, environments, or secrets. Log in to continue.",
                                        "expanded": "<div class=\"assistant-state-card state-error\"><div class=\"state-label\">âŒ Auth Required</div><div class=\"state-detail\">Without authentication, GitHub's API rejects all requests. Everything after this point in the wizard depends on a valid login.\n\nClick <strong>ğŸ”‘ Authenticate GitHub</strong> below â€” this opens an OAuth flow in your browser. The token is stored locally by the gh CLI.\n\nAfter authenticating, click <strong>Re-scan</strong> to refresh the detection.</div></div>"
                                    },
                                    {
                                        "when": {
                                            "textContains": "Logged in"
                                        },
                                        "content": "Authenticated â€” API calls to GitHub will work. The account shown below is the identity all operations happen under.",
                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Authenticated</div><div class=\"state-detail\">Your gh CLI has a valid token. All API operations â€” environment creation, secret pushes, visibility changes â€” will use this identity.\n\nToken scope determines limits. If an operation fails with a 403, the token may lack the required scope (e.g., <code>admin:org</code> for org-level secrets).</div></div>"
                                    }
                                ],
                                "children": []
                            }
                        ]
                    },
                    {
                        "id": "detect-missing-tools",
                        "title": "Install Tools",
                        "icon": "ğŸ“¦",
                        "selector": "#gh-wiz-missing-tools",
                        "content": "The gh CLI needs to be installed before anything else in this wizard can work. Use the install button or install manually via your system package manager.",
                        "children": []
                    },
                    {
                        "id": "detect-user-card",
                        "title": "GitHub Account",
                        "icon": "ğŸ‘¤",
                        "selector": "#gh-detect-user-card",
                        "content": "This is the GitHub identity the control plane acts as. Creating environments, pushing secrets, changing visibility â€” it all happens under this account.",
                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ‘¤ Identity Context</div><div class=\"state-detail\">All GitHub API operations use this account's permissions. If the repository is owned by an organization, your role in that org determines what you can do:\n\nâ€¢ <strong>Owner/Admin</strong> â€” full access: visibility, environments, secrets, branch protection\nâ€¢ <strong>Maintainer</strong> â€” environments and secrets, but not visibility or danger zone settings\nâ€¢ <strong>Member</strong> â€” limited: can push code but may not manage environments or secrets\n\nThe <strong>ğŸ”“ Logout</strong> button disconnects the gh CLI. You'll need to re-authenticate to continue using GitHub features.</div></div>",
                        "children": []
                    }
                ]
            },
            {
                "id": "detect-repo-section",
                "title": "Repository",
                "icon": "ğŸ“¦",
                "selector": "#gh-detect-repo",
                "separator": true,
                "content": "Your GitHub repository is where platform features attach â€” environments, secrets, CODEOWNERS, and visibility are all repo-level settings.",
                "children": [
                    {
                        "id": "detect-repo-grid",
                        "title": "Repository Details",
                        "icon": "ğŸ“‹",
                        "selector": "#gh-detect-repo-grid",
                        "content": "Repository identity, access level, and infrastructure â€” the foundation for everything in Configure.",
                        "children": [
                            {
                                "id": "detect-repo-row",
                                "title": "Repository",
                                "icon": "ğŸ“¦",
                                "selector": "#gh-detect-repo-row",
                                "content": "Your code lives on GitHub at this repository. Environments, secrets, CODEOWNERS, and visibility all attach to it.",
                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“¦ Repository Link</div><div class=\"state-detail\">The repository is detected from your git remote â€” the same remote you configured in Git Setup. It's the anchor for everything in this wizard:\n\nâ€¢ <strong>Environments</strong> scope secrets for deployment targets\nâ€¢ <strong>Secrets</strong> power CI/CD pipelines securely\nâ€¢ <strong>CODEOWNERS</strong> automates PR review assignments\nâ€¢ <strong>Visibility</strong> controls who can see your code\n\nIf this shows the wrong repo, go back to Git Setup and check your remote URL.</div></div>",
                                "variants": [
                                    {
                                        "when": {
                                            "textContains": "No GitHub"
                                        },
                                        "content": "No repository linked â€” the control plane can't manage environments, secrets, or visibility without one. You can create a new repo or connect an existing one in Configure.",
                                        "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš ï¸ No Repository</div><div class=\"state-detail\">Without a linked repository, this wizard can't do much. Two paths forward:\n\nâ€¢ <strong>Create New</strong> â€” the Configure step has a form to create a GitHub repo from this project\nâ€¢ <strong>Connect Existing</strong> â€” go to Git Setup and add a remote pointing to an existing GitHub repo\n\nA linked repository is required for environment alignment, secret sync, CODEOWNERS, and visibility management.</div></div>"
                                    }
                                ],
                                "children": []
                            },
                            {
                                "id": "detect-visibility-row",
                                "title": "Visibility",
                                "icon": "ğŸ‘ï¸",
                                "selector": "#gh-detect-visibility-row",
                                "content": "Controls who can see your repository on GitHub.",
                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ‘ï¸ Access Control</div><div class=\"state-detail\">Visibility is a repo-level setting that determines who can read your code, issues, wiki, and discussions.\n\nYou can toggle visibility in the Configure step â€” but be careful: making a private repo public exposes <em>all</em> commit history, including any secrets that were accidentally committed in the past.</div></div>",
                                "variants": [
                                    {
                                        "when": {
                                            "textContains": "PUBLIC"
                                        },
                                        "content": "Your repo is world-readable â€” anyone on GitHub can see your code, clone it, fork it, and read your issues and wiki.",
                                        "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">ğŸŒ Public Repository</div><div class=\"state-detail\">Public means anyone on the internet can:\n\nâ€¢ Read and clone your source code\nâ€¢ See all issues, PRs, and discussions\nâ€¢ Fork the repository\nâ€¢ View your commit history (including old mistakes)\n\nIf this project contains internal tooling, proprietary logic, or references to infrastructure, consider switching to private in Configure.\n\nPublic repos do get free GitHub Actions minutes and community visibility â€” it's intentional for open-source projects.</div></div>"
                                    },
                                    {
                                        "when": {
                                            "textContains": "PRIVATE"
                                        },
                                        "content": "Access restricted to collaborators and org members only. Code, issues, and wiki are hidden from the public.",
                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ”’ Private Repository</div><div class=\"state-detail\">Only invited collaborators and organization members with the right permissions can see this repository.\n\nPrivate repos have some trade-offs:\nâ€¢ GitHub Actions minutes are billed (not free like public repos)\nâ€¢ Community contributions are limited (no forks from outsiders)\nâ€¢ GitHub Pages has restrictions on free plans\n\nYou can toggle to public in Configure if this is an open-source project.</div></div>"
                                    }
                                ],
                                "children": []
                            },
                            {
                                "id": "detect-branch-row",
                                "title": "Default Branch",
                                "icon": "ğŸŒ¿",
                                "selector": "#gh-detect-branch-row",
                                "content": "The branch GitHub considers default â€” it's the landing page of your repo and the base branch for pull requests. This should match what you set in Git Setup.",
                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸŒ¿ Branch Alignment</div><div class=\"state-detail\">GitHub's default branch is used for:\n\nâ€¢ The repository landing page (what visitors see first)\nâ€¢ The base branch for pull requests\nâ€¢ Branch protection rules (if configured)\nâ€¢ GitHub Pages source (often <code>main</code> or <code>gh-pages</code>)\n\nIf this doesn't match your local default branch from Git Setup, <code>git push</code> might target a different branch than GitHub expects. You can change it in Configure.</div></div>",
                                "children": []
                            },
                            {
                                "id": "detect-ghdir-row",
                                "title": ".github/ Directory",
                                "icon": "ğŸ“",
                                "selector": "#gh-detect-ghdir-row",
                                "content": "The .github/ directory houses your CI/CD infrastructure â€” workflows, issue templates, PR templates, and CODEOWNERS.",
                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“ GitHub Infrastructure</div><div class=\"state-detail\">The <code>.github/</code> directory is GitHub's convention for repository-level configuration:\n\nâ€¢ <code>.github/workflows/</code> â€” GitHub Actions CI/CD pipelines\nâ€¢ <code>.github/ISSUE_TEMPLATE/</code> â€” structured issue forms\nâ€¢ <code>.github/PULL_REQUEST_TEMPLATE.md</code> â€” PR description template\nâ€¢ <code>.github/CODEOWNERS</code> â€” auto-assign reviewers\nâ€¢ <code>.github/dependabot.yml</code> â€” automated dependency updates\n\nWorkflows are the most impactful â€” they define your CI/CD pipeline.</div></div>",
                                "variants": [
                                    {
                                        "when": {
                                            "textContains": "Exists"
                                        },
                                        "content": "Your .github/ directory exists â€” CI/CD workflows and repository configuration are in place.",
                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Infrastructure Present</div><div class=\"state-detail\">The <code>.github/</code> directory is present with workflows. These define your CI/CD pipeline â€” automated testing, building, and deployment triggered by pushes, PRs, or schedules.\n\nThe workflow count tells you how many pipelines are configured. Zero workflows means the directory exists but isn't doing CI/CD yet.</div></div>"
                                    },
                                    {
                                        "when": {
                                            "textContains": "Not found"
                                        },
                                        "content": "No .github/ directory â€” you don't have GitHub Actions workflows, issue templates, or PR templates yet. You can create the structure manually or through CI/CD setup.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“ Not Yet Created</div><div class=\"state-detail\">Without a <code>.github/</code> directory:\n\nâ€¢ No GitHub Actions â€” no automated CI/CD\nâ€¢ No issue templates â€” contributors use freeform issues\nâ€¢ No PR template â€” no standardized PR descriptions\nâ€¢ No Dependabot â€” no automated dependency updates\n\nThe CI/CD setup wizard (separate from this one) can generate workflow files. For now, this is informational.</div></div>"
                                    }
                                ],
                                "children": []
                            },
                            {
                                "id": "detect-codeowners-row",
                                "title": "CODEOWNERS",
                                "icon": "ğŸ‘¥",
                                "selector": "#gh-detect-codeowners-row",
                                "content": "CODEOWNERS automates PR review assignments â€” file patterns map to owners who get automatically requested when those files change.",
                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ‘¥ Review Automation</div><div class=\"state-detail\">A CODEOWNERS file at <code>.github/CODEOWNERS</code> tells GitHub who must review changes to specific files or directories.\n\nPattern example:\n<code>* @your-username</code> â€” you review everything\n<code>/src/api/ @backend-team</code> â€” backend team reviews API changes\n<code>*.py @python-leads</code> â€” Python leads review all Python files\n\nWithout CODEOWNERS, PRs rely on manual reviewer selection â€” which means reviews can be missed or delayed.</div></div>",
                                "variants": [
                                    {
                                        "when": {
                                            "textContains": "Found"
                                        },
                                        "content": "CODEOWNERS is configured â€” PRs will auto-request reviews from the right people based on which files change.",
                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Review Automation Active</div><div class=\"state-detail\">Your CODEOWNERS file is in place. GitHub will automatically request reviews from the listed owners when a PR touches files matching their patterns.\n\nYou can review and edit the file content in the Configure step. Common updates include adding team handles for new directories or adjusting patterns as the codebase grows.</div></div>"
                                    },
                                    {
                                        "when": {
                                            "textContains": "Not configured"
                                        },
                                        "content": "No CODEOWNERS configured â€” PRs won't auto-assign reviewers. The Configure step can generate one based on your repository owner.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“ Available in Configure</div><div class=\"state-detail\">Without CODEOWNERS:\n\nâ€¢ PRs don't auto-request reviewers\nâ€¢ No enforced review assignments\nâ€¢ Reviews depend on manual selection\n\nThe Configure step can generate a starter file with <code>* @your-username</code> as a catch-all. You can refine it later with team-specific patterns.</div></div>"
                                    }
                                ],
                                "children": []
                            }
                        ]
                    }
                ]
            },
            {
                "id": "detect-status-section",
                "title": "Integration Status",
                "icon": "ğŸ“Š",
                "selector": "#gh-detect-status",
                "separator": true,
                "content": "How your local project configuration aligns with GitHub's platform features â€” environments and secrets are the bridge between your code and your deployment pipeline.",
                "children": [
                    {
                        "id": "detect-status-grid",
                        "title": "Alignment",
                        "icon": "ğŸ“‹",
                        "selector": "#gh-detect-status-grid",
                        "content": "Environment and secret alignment between your local project config and what exists on GitHub.",
                        "children": [
                            {
                                "id": "detect-envs-row",
                                "title": "Environments",
                                "icon": "ğŸŒ",
                                "selector": "#gh-detect-envs-row",
                                "content": "Environments connect your local configuration to GitHub's deployment infrastructure â€” scoped secrets, protection rules, and deployment history.",
                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸŒ Environment Alignment</div><div class=\"state-detail\">Your project defines environments in <code>project.yml</code> (Step 1 of the wizard). GitHub deployment environments are a separate concept on GitHub's platform.\n\n<strong>Aligned</strong> means a local environment has a matching GitHub deployment environment. <strong>Missing</strong> means it exists locally but not on GitHub â€” environment-scoped secrets can't target it.\n\nThe Configure step can create missing GitHub environments automatically.</div></div>",
                                "variants": [
                                    {
                                        "when": {
                                            "textContains": "None defined"
                                        },
                                        "content": "No environments defined in your project config. Go to Step 1 (Project Configuration) to define environments like dev, staging, production before aligning them with GitHub.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â– No Local Environments</div><div class=\"state-detail\">Environments are defined in your <code>project.yml</code> via the Setup Wizard's first step (Project Configuration). Without them:\n\nâ€¢ Secrets can only be stored at repo scope (not per-environment)\nâ€¢ No deployment environment protection rules\nâ€¢ No environment-specific variable overrides\n\nDefine at least <code>development</code> and <code>production</code> to get environment-scoped secrets working.</div></div>"
                                    },
                                    {
                                        "when": {
                                            "textContains": "aligned"
                                        },
                                        "content": "Your local environments are checked against GitHub deployment environments. Aligned ones can receive environment-scoped secrets; missing ones need to be created in Configure.",
                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Environment Check</div><div class=\"state-detail\">The control plane compared your local environments (from <code>project.yml</code>) with GitHub's deployment environments.\n\nAligned environments can:\nâ€¢ Receive environment-scoped secrets via vault sync\nâ€¢ Have protection rules (required reviewers, wait timers)\nâ€¢ Track deployment history in GitHub's UI\n\nIf any are missing, the Configure step offers one-click creation.</div></div>"
                                    }
                                ],
                                "children": []
                            },
                            {
                                "id": "detect-secrets-row",
                                "title": "GitHub Secrets",
                                "icon": "ğŸ”’",
                                "selector": "#gh-detect-secrets-row",
                                "content": "Secrets and variables currently stored on GitHub â€” these power your CI/CD pipelines. Your local vault secrets (Step 3) can be pushed here during Configure.",
                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ”’ Secrets Inventory</div><div class=\"state-detail\">GitHub secrets are encrypted values available to GitHub Actions workflows. Variables are plaintext key-value pairs.\n\n<strong>Secrets</strong> â€” sensitive values like API keys, database passwords, deploy tokens. Never logged in Actions output.\n<strong>Variables</strong> â€” non-sensitive config like region names, feature flags, service URLs.\n\nIn multi-environment projects, secrets are scoped per-environment (dev secrets â‰  production secrets). In single-environment projects, they're repo-scoped.\n\nThe Configure step can push your local vault secrets to GitHub, keeping them in sync.</div></div>",
                                "children": []
                            }
                        ]
                    }
                ]
            },
            {
                "id": "detect-hints",
                "title": "Next Steps",
                "icon": "ğŸ’¡",
                "selector": "#gh-detect-hints",
                "content": "Actionable recommendations based on what's missing or misaligned. Most of these can be resolved in the Configure step â€” click Configure â†’ to proceed.",
                "children": []
            },
            {
                "id": "cfg-repo-section",
                "title": "Repository",
                "icon": "ğŸ“¦",
                "selector": "#gh-cfg-repo",
                "separator": true,
                "content": "Your repository identity and access level. Be aware â€” some changes here take effect immediately on GitHub when you confirm, while others are queued for Review.",
                "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš¡ Immediate vs Deferred</div><div class=\"state-detail\">This Configure step mixes two types of actions:\n\n<strong>Immediate</strong> (happen on click):\nâ€¢ Visibility toggle â€” changes repo access right now\nâ€¢ Default branch â€” changes the base branch right now\nâ€¢ Create repository â€” creates a real GitHub repo right now\n\n<strong>Deferred</strong> (queued for Review):\nâ€¢ CODEOWNERS file â€” written when you click Finish\nâ€¢ Environment creation â€” created when you click Finish\nâ€¢ Secrets push â€” synced when you click Finish\n\nImmediate actions have confirmation dialogs to prevent accidents.</div></div>",
                "children": [
                    {
                        "id": "cfg-repo-card",
                        "title": "Linked Repository",
                        "icon": "ğŸ”—",
                        "selector": "#gh-cfg-repo-card",
                        "content": "Your project is connected to this GitHub repository. Everything in this wizard â€” environments, secrets, CODEOWNERS â€” attaches to it.",
                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ”— Repository Link</div><div class=\"state-detail\">This is the same repository detected from your git remote in the Detect step. The \"Open on GitHub\" link takes you there.\n\nThe visibility toggle below changes access <strong>immediately</strong> â€” there's a confirmation dialog, but once confirmed, the change is live on GitHub. No need to wait for Review.\n\nIf the wrong repo is shown, go back to Git Setup and update your remote URL.</div></div>",
                        "children": [
                            {
                                "id": "cfg-vis-toggle",
                                "title": "Visibility Toggle",
                                "icon": "ğŸ‘ï¸",
                                "selector": "#gh-vis-toggle",
                                "content": "Toggling visibility is immediate â€” it changes your repo's access level on GitHub the moment you confirm.",
                                "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš¡ Immediate Action</div><div class=\"state-detail\">A confirmation dialog will ask you to verify â€” this is your safety net. Once confirmed, the change is live.\n\nImplications to consider:\nâ€¢ <strong>Private â†’ Public:</strong> Exposes your entire commit history, including any secrets that were committed and later removed. Git history is permanent.\nâ€¢ <strong>Public â†’ Private:</strong> Existing forks remain public. Scheduled GitHub Actions may stop on the free plan. External links to your code will break.</div></div>",
                                "variants": [
                                    {
                                        "when": {
                                            "textContains": "Make public"
                                        },
                                        "content": "Going public exposes your entire commit history â€” including anything that was committed and later removed. Make sure no secrets were ever in the repo before toggling.",
                                        "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">ğŸŒ Going Public</div><div class=\"state-detail\">Making a repository public is a significant decision:\n\nâ€¢ All code, issues, PRs, and wiki become readable by anyone\nâ€¢ Commit history is searchable â€” secrets committed in the past are exposed\nâ€¢ The repo becomes forkable by anyone on GitHub\nâ€¢ GitHub Actions minutes become free (a benefit)\n\nIf this is intentional for open-source, go ahead. If you're unsure, keep it private â€” you can always open-source later.</div></div>"
                                    },
                                    {
                                        "when": {
                                            "textContains": "Make private"
                                        },
                                        "content": "Going private restricts access immediately. Existing forks stay public, but new forks are blocked and external links to your code will stop working.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ”’ Going Private</div><div class=\"state-detail\">Switching to private:\n\nâ€¢ New visitors can't see or clone the repository\nâ€¢ Existing forks remain as independent public repos\nâ€¢ GitHub Actions minutes become billed (no longer free)\nâ€¢ GitHub Pages may be restricted on free plans\nâ€¢ External references to files, issues, or PRs will return 404\n\nCollaborators with explicit access will still see the repo.</div></div>"
                                    }
                                ],
                                "children": []
                            }
                        ]
                    },
                    {
                        "id": "cfg-create-repo",
                        "title": "Create Repository",
                        "icon": "ğŸš€",
                        "selector": "#gh-cfg-create-repo",
                        "content": "No repository linked yet. You can create one here â€” it's immediate. A real GitHub repo is created and added as your origin remote in one step.",
                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸš€ New Repository</div><div class=\"state-detail\">Creating a repository does two things at once:\n\n1. Creates a new repo on GitHub under your authenticated account\n2. Adds it as the <code>origin</code> remote in your local git config\n\nAfter creation, your next <code>git push</code> goes to this repo. The wizard will re-detect and unlock environments, secrets, and CODEOWNERS.\n\nAlternatively, you can set a remote manually via Git Setup if you already have a repo on GitHub.</div></div>",
                        "children": [
                            {
                                "id": "cfg-repo-name",
                                "title": "Repository Name",
                                "icon": "ğŸ“",
                                "selector": "#mf-gh-repo-name",
                                "content": "Convention: lowercase, hyphens, no spaces. This becomes part of your GitHub URL and shows up in clone commands, CI references, and deployment configs.",
                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“ Naming</div><div class=\"state-detail\">The placeholder suggests your first module name â€” that's usually a good default.\n\nYour repo URL will be: <code>github.com/your-username/repo-name</code>\n\nGitHub URLs are case-insensitive, but lowercase with hyphens is the universal convention. Avoid underscores (they're valid but uncommon) and special characters.</div></div>",
                                "children": []
                            },
                            {
                                "id": "cfg-repo-vis-select",
                                "title": "Visibility",
                                "icon": "ğŸ”’",
                                "selector": "#mf-gh-repo-vis",
                                "content": "Private is the safe default â€” you can always make it public later. Going the other direction means your entire commit history becomes permanently visible.",
                                "children": []
                            },
                            {
                                "id": "cfg-repo-desc",
                                "title": "Description",
                                "icon": "ğŸ’¬",
                                "selector": "#mf-gh-repo-desc",
                                "content": "Shows on the GitHub repo page and in search results. Optional, but a good description helps discoverability â€” especially if you make the repo public later.",
                                "children": []
                            },
                            {
                                "id": "cfg-create-btn",
                                "title": "Create Button",
                                "icon": "ğŸš€",
                                "selector": "#gh-create-repo-btn",
                                "content": "This creates the repo on GitHub immediately and adds it as your origin remote. Once done, the wizard re-scans and unlocks the rest of the Configure sections.",
                                "children": []
                            }
                        ]
                    }
                ]
            },
            {
                "id": "cfg-branch-section",
                "title": "Default Branch",
                "icon": "ğŸŒ¿",
                "selector": "#gh-cfg-branch",
                "separator": true,
                "content": "The branch GitHub treats as default â€” it's the landing page, the PR base, and the anchor for branch protection rules. Changing it here takes effect immediately.",
                "children": [
                    {
                        "id": "cfg-branch-card",
                        "title": "Branch Setting",
                        "icon": "ğŸŒ¿",
                        "selector": "#gh-cfg-branch-card",
                        "content": "This should match the branch you set in Git Setup. If they diverge, git push targets one branch while GitHub's UI and PR system reference another.",
                        "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš¡ Immediate Action</div><div class=\"state-detail\">Clicking <strong>âœï¸ Change</strong> prompts for a new branch name and changes it immediately on GitHub.\n\nWhat the change affects:\nâ€¢ Repository landing page shows the new branch\nâ€¢ New pull requests target the new branch by default\nâ€¢ Branch protection rules may need to be updated\nâ€¢ Existing PRs targeting the old branch <strong>won't</strong> auto-retarget\n\nMost projects use <code>main</code>. Legacy projects may use <code>master</code>. If your local Git Setup uses a different name, update one of them to match.</div></div>",
                        "children": []
                    }
                ]
            },
            {
                "id": "cfg-codeowners-section",
                "title": "CODEOWNERS",
                "icon": "ğŸ‘¥",
                "selector": "#gh-cfg-codeowners",
                "separator": true,
                "content": "CODEOWNERS maps file patterns to reviewers. When a PR touches files matching a pattern, GitHub automatically requests a review from the listed owner â€” no manual assignment needed.",
                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ‘¥ How It Works</div><div class=\"state-detail\">Each line in the CODEOWNERS file is a pattern followed by one or more owners:\n\n<code>*                @your-username</code>    â€” you review everything\n<code>/src/api/        @backend-team</code>  â€” team reviews API changes\n<code>*.py             @python-leads</code>   â€” leads review all Python files\n<code>/docs/           @docs-team</code>      â€” docs team owns documentation\n\n<strong>Last match wins</strong> â€” more specific patterns override broader ones. A file matching both <code>*</code> and <code>/src/api/</code> gets the <code>/src/api/</code> owner.\n\nChanges here are <strong>deferred</strong> â€” the file is written when you click Finish in Review.</div></div>",
                "children": [
                    {
                        "id": "cfg-co-preview",
                        "title": "Current CODEOWNERS",
                        "icon": "ğŸ“„",
                        "selector": "#gh-cfg-co-preview",
                        "content": "Your current CODEOWNERS file. Click Edit to modify â€” changes are queued for Review, not applied immediately.",
                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ“„ Existing File</div><div class=\"state-detail\">The file is shown read-only here. Use <strong>âœï¸ Edit</strong> to open the editor below.\n\nEditing replaces the entire file content â€” there's no merge. Make sure to keep any patterns you want to preserve.\n\nThe file lives at <code>.github/CODEOWNERS</code> â€” GitHub only recognizes it in this location (or the repo root, but .github is preferred).</div></div>",
                        "children": []
                    },
                    {
                        "id": "cfg-co-editor",
                        "title": "CODEOWNERS Editor",
                        "icon": "âœï¸",
                        "selector": "#co-editor-wrap",
                        "content": "Edit or create the CODEOWNERS file. The content below will be written to .github/CODEOWNERS when you click Finish in Review.",
                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">âœï¸ Editing</div><div class=\"state-detail\">The checkbox controls whether the file gets written at all. Unchecking it skips the CODEOWNERS step entirely.\n\nSyntax reference:\nâ€¢ Lines starting with <code>#</code> are comments\nâ€¢ <code>*</code> matches all files (catch-all at the bottom)\nâ€¢ <code>/path/</code> matches a directory recursively\nâ€¢ <code>*.ext</code> matches files by extension\nâ€¢ Owners: <code>@username</code>, <code>@org/team-name</code>, or <code>email@example.com</code>\n\nOrder matters â€” last matching pattern wins. Put broad patterns first and specific overrides after.</div></div>",
                        "children": [
                            {
                                "id": "cfg-co-checkbox",
                                "title": "Write Toggle",
                                "icon": "â˜‘ï¸",
                                "selector": "#mf-write-codeowners",
                                "content": "Controls whether CODEOWNERS gets written when you finish. Unchecking this means no changes to the file, even if you've edited the content below.",
                                "children": []
                            },
                            {
                                "id": "cfg-co-textarea",
                                "title": "File Content",
                                "icon": "ğŸ“",
                                "selector": "#mf-codeowners-content",
                                "content": "Each line is a glob pattern followed by @owner handles. Put broad patterns first, specific overrides last â€” the last matching pattern wins.",
                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“ Common Patterns</div><div class=\"state-detail\">Start simple and refine:\n\n<code>* @your-username</code>\nThis is the minimum â€” you review everything. It's the default if you're a solo developer.\n\nAs the team grows, add specifics:\n<code>/backend/  @backend-team</code>\n<code>/frontend/ @frontend-team</code>\n<code>*.tf       @infra-team</code>\n\nThe catch-all <code>*</code> should remain as a fallback â€” it catches new files that don't match any specific pattern.</div></div>",
                                "children": []
                            }
                        ]
                    }
                ]
            },
            {
                "id": "cfg-envs-section",
                "title": "Environment Alignment",
                "icon": "ğŸŒ",
                "selector": "#gh-cfg-envs",
                "separator": true,
                "content": "This maps your project environments (from Step 1) to GitHub deployment environments. Aligned environments can receive scoped secrets â€” missing ones block environment-level CI/CD until they're created.",
                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸŒ Why Alignment Matters</div><div class=\"state-detail\">GitHub deployment environments are separate from your local project config. They need to match for three things to work:\n\nâ€¢ <strong>Scoped secrets</strong> â€” each environment gets its own secrets (dev â‰  production)\nâ€¢ <strong>Protection rules</strong> â€” required reviewers, wait timers before deploy\nâ€¢ <strong>Deployment history</strong> â€” GitHub tracks which commit was deployed where\n\nEnvironments are defined in <code>project.yml</code> (Step 1). To add or remove environments, go back to Project Configuration â€” this section only creates the GitHub side.\n\nCreation is <strong>deferred</strong> â€” checked environments are created when you click Finish in Review.</div></div>",
                "children": [
                    {
                        "id": "cfg-envs-table",
                        "title": "Alignment Table",
                        "icon": "ğŸ“‹",
                        "selector": "#gh-cfg-envs-table",
                        "content": "Each row compares a local environment to GitHub. Hover a row to see its alignment state and what it means for your CI/CD pipeline.",
                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“‹ Reading the Table</div><div class=\"state-detail\">Three columns tell the story:\n\nâ€¢ <strong>Local</strong> â€” your project.yml environment name (â­ marks the default)\nâ€¢ <strong>GitHub</strong> â€” whether a matching deployment environment exists on GitHub\nâ€¢ <strong>Action</strong> â€” \"aligned\" if it already exists, or a checkbox to create it\n\nDimmed rows at the bottom (if any) are <strong>GitHub-only</strong> environments â€” they exist on GitHub but aren't defined in your project config. They may be from a previous configuration, another tool, or manual creation.\n\nAll creation checkboxes default to checked â€” uncheck only if you intentionally don't want that environment on GitHub.</div></div>",
                        "children": [
                            {
                                "id": "cfg-env-row",
                                "title": "Environment Row",
                                "icon": "ğŸŒ",
                                "selector": "[id^=\"gh-cfg-env-\"]:not([id*=\"remote\"])",
                                "content": "This environment is defined in your project config. Its alignment state with GitHub determines whether environment-scoped secrets can target it.",
                                "variants": [
                                    {
                                        "when": {
                                            "dataAttr": {
                                                "aligned": "true"
                                            }
                                        },
                                        "content": "âœ… Aligned â€” this environment exists on both sides. It can receive scoped secrets, protection rules, and deployment tracking. Nothing to do here.",
                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Aligned</div><div class=\"state-detail\">This environment exists on GitHub and matches your local config. It can:\n\nâ€¢ Receive environment-scoped secrets via vault sync\nâ€¢ Have protection rules (required reviewers, wait timers)\nâ€¢ Track deployment history in GitHub's UI\n\nNo action needed â€” this row is purely informational.</div></div>"
                                    },
                                    {
                                        "when": {
                                            "dataAttr": {
                                                "aligned": "false"
                                            }
                                        },
                                        "content": "â¬œ Missing on GitHub â€” the checkbox will create it when you click Finish. Unchecking means environment-scoped secrets targeting this environment will fail in CI/CD.",
                                        "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">â¬œ Missing</div><div class=\"state-detail\">This environment is defined locally but doesn't exist on GitHub yet. If you leave the checkbox checked, it will be created during Review â†’ Finish.\n\n<strong>If you uncheck it:</strong>\nâ€¢ No GitHub environment is created\nâ€¢ Vault secrets scoped to this environment can't be pushed\nâ€¢ CI/CD workflows referencing this environment will fail\nâ€¢ Protection rules can't be applied\n\nUncheck only if you intentionally don't want this environment on GitHub.</div></div>"
                                    }
                                ],
                                "children": []
                            },
                            {
                                "id": "cfg-env-remote",
                                "title": "GitHub-Only Environment",
                                "icon": "â–",
                                "selector": "[id^=\"gh-cfg-env-remote-\"]",
                                "content": "This environment exists on GitHub but isn't defined in your project config. It may be from a previous configuration, another tool, or manual GitHub setup. It's harmless â€” this wizard doesn't manage it.",
                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â– GitHub Only</div><div class=\"state-detail\">This environment has no matching entry in your <code>project.yml</code>. Possible sources:\n\nâ€¢ Created manually in GitHub Settings â†’ Environments\nâ€¢ Leftover from a previous project config\nâ€¢ Created by another CI/CD tool (Terraform, Pulumi)\n\nIt's not harmful, but this wizard can't manage it â€” no secrets will be pushed to it during sync. If you want to manage it, add a matching environment in Step 1 (Project Configuration).</div></div>",
                                "children": []
                            },
                            {
                                "id": "cfg-env-tip",
                                "title": "Environment Tip",
                                "icon": "ğŸ’¡",
                                "selector": "#gh-cfg-envs-tip",
                                "content": "Environments are defined in Step 1 (Project Configuration), not here. This section only creates the GitHub side to match what you already defined locally.",
                                "children": []
                            }
                        ]
                    },
                    {
                        "id": "cfg-co-notfound",
                        "title": "No CODEOWNERS",
                        "icon": "ğŸ“",
                        "selector": "#gh-cfg-co-notfound",
                        "content": "No CODEOWNERS file exists yet. The editor below lets you create one â€” it will be written to .github/CODEOWNERS when you click Finish in Review.",
                        "children": []
                    },
                    {
                        "id": "cfg-no-envs",
                        "title": "No Environments",
                        "icon": "â–",
                        "selector": "#gh-cfg-no-envs",
                        "content": "Without environments, secrets can only be stored at repo scope â€” every CI/CD workflow sees the same values regardless of which environment it targets.",
                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â– Single-Scope Limitation</div><div class=\"state-detail\">Repo-scoped secrets are shared across all workflows. This means:\n\nâ€¢ Dev and production use the same database credentials\nâ€¢ No environment-specific overrides\nâ€¢ No protection rules (anyone can deploy anywhere)\n\nFor most real projects, you'll want at least <code>development</code> and <code>production</code>. Define them in the Setup Wizard â†’ Step 1 (Project Configuration), then come back here to align.</div></div>",
                        "children": []
                    }
                ]
            },
            {
                "id": "cfg-secrets-section",
                "title": "Secrets Sync",
                "icon": "ğŸ”’",
                "selector": "#gh-cfg-secrets",
                "separator": true,
                "content": "What's currently on GitHub, and the option to push your vault secrets there. The green ğŸ”’ pills are secrets (encrypted, never logged). The blue ğŸ“‹ pills are variables (plaintext, visible in workflow logs).",
                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ”’ Secrets vs Variables</div><div class=\"state-detail\">GitHub has two types of stored values:\n\n<strong>Secrets</strong> (ğŸ”’ green pills) â€” encrypted at rest, masked in Actions logs. Use for API keys, database passwords, deploy tokens, anything sensitive.\n\n<strong>Variables</strong> (ğŸ“‹ blue pills) â€” plaintext, visible in logs. Use for region names, feature flags, service URLs, non-sensitive configuration.\n\nIn multi-environment projects, each environment has its own scope â€” dev secrets don't leak into production workflows.\n\nYour vault (Step 3) is the source of truth. Pushing syncs vault keys to GitHub â€” matching keys are overwritten, new keys are added, <strong>nothing is deleted</strong>. That's intentional: secrets set outside this tool are preserved.</div></div>",
                "children": [
                    {
                        "id": "cfg-secrets-stats",
                        "title": "Current Counts",
                        "icon": "ğŸ“Š",
                        "selector": "#gh-cfg-secrets-stats",
                        "content": "What GitHub already has. These counts reflect the current state â€” they'll update after a push. Zero doesn't mean something is wrong; it means nothing has been pushed yet.",
                        "children": []
                    },
                    {
                        "id": "cfg-secrets-env-block",
                        "title": "Environment",
                        "icon": "ğŸ·ï¸",
                        "selector": ".gh-secrets-env-block",
                        "content": "All secrets and variables scoped to this environment. Only workflows referencing this deployment environment can access them.",
                        "variants": [
                            {
                                "when": {
                                    "dataAttr": {
                                        "env": "production"
                                    }
                                },
                                "title": "Production",
                                "content": "ğŸ”´ Production scope â€” these are the real credentials your live application uses. Consider enabling required reviewers and wait timers on this environment for an extra safety layer.",
                                "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">ğŸ”´ Production Environment</div><div class=\"state-detail\">This is your most sensitive environment. Values here:\n\nâ€¢ <strong>Real credentials</strong> â€” production database, API keys, deploy tokens\nâ€¢ <strong>Protected</strong> â€” enable required reviewers so deployments need approval\nâ€¢ <strong>Isolated</strong> â€” development workflows cannot see these values\n\nIf you push from vault, only vault keys tagged for production land here. Development keys stay in their own scope.\n\nConsider adding a <strong>wait timer</strong> (e.g., 5 minutes) to give time to cancel accidental production deployments.</div></div>"
                            },
                            {
                                "when": {
                                    "dataAttr": {
                                        "env": "development"
                                    }
                                },
                                "title": "Development",
                                "content": "ğŸŸ¢ Development scope â€” safe to use test credentials, sandbox API keys, or dummy values here. These are invisible to production workflows.",
                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸŸ¢ Development Environment</div><div class=\"state-detail\">Development is your safe sandbox:\n\nâ€¢ Use <strong>test credentials</strong> â€” sandbox databases, staging API keys\nâ€¢ <strong>Iterate freely</strong> â€” changes here don't affect production\nâ€¢ <strong>No protection needed</strong> â€” skip required reviewers for faster iteration\n\nIf you push from vault, only vault keys tagged for development land here. Production keys stay isolated.\n\nTip: keep development values close to your test environment's actual configuration to catch integration issues early.</div></div>"
                            },
                            {
                                "when": {
                                    "dataAttr": {
                                        "env": "staging"
                                    }
                                },
                                "title": "Staging",
                                "content": "ğŸŸ¡ Staging scope â€” mirrors production for pre-release validation. Use real-like credentials but against staging infrastructure, not live systems.",
                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸŸ¡ Staging Environment</div><div class=\"state-detail\">Staging should mirror production as closely as possible:\n\nâ€¢ Use <strong>real-like credentials</strong> against staging infrastructure\nâ€¢ Consider enabling <strong>required reviewers</strong> to practice the deployment approval flow\nâ€¢ Values here should be different from production â€” never share credentials between staging and production\n\nThis is your last validation step before production. Treat it with respect.</div></div>"
                            },
                            {
                                "when": {
                                    "dataAttr": {
                                        "env": "_repo"
                                    }
                                },
                                "title": "Repository Scope",
                                "content": "ğŸ“¦ Repo-scoped â€” visible to ALL workflows regardless of environment. Use only for values that genuinely need to be shared across all environments.",
                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“¦ Repository Scope</div><div class=\"state-detail\">Repo-scoped values are not tied to any environment:\n\nâ€¢ <strong>All workflows</strong> can access them (dev, staging, production)\nâ€¢ Useful for shared config like org name, package registry tokens\nâ€¢ <strong>Less secure for secrets</strong> â€” any workflow sees them\n\nPrefer environment-scoped values when possible. Repo scope is for truly cross-environment items.</div></div>"
                            }
                        ],
                        "children": [
                            {
                                "id": "cfg-secrets-list",
                                "title": "Secrets",
                                "icon": "ğŸ”’",
                                "selector": ".gh-secrets-list",
                                "content": "Encrypted secrets â€” masked in Actions logs, not readable via API. Workflows access them via ${{ secrets.NAME }}.",
                                "variants": [
                                    {
                                        "when": {
                                            "dataAttr": {
                                                "env": "production"
                                            }
                                        },
                                        "content": "ğŸ”’ Production secrets â€” live credentials. Encrypted at rest, masked in logs. Treat with extreme care â€” rotation should be planned, not reactive."
                                    },
                                    {
                                        "when": {
                                            "dataAttr": {
                                                "env": "development"
                                            }
                                        },
                                        "content": "ğŸ”’ Development secrets â€” scoped to dev only. Production can't see these. Safe to use test credentials or sandbox keys."
                                    },
                                    {
                                        "when": {
                                            "dataAttr": {
                                                "env": "_repo"
                                            }
                                        },
                                        "content": "ğŸ”’ Repo-scoped secrets â€” visible to ALL workflows. Use only for secrets that genuinely need to be shared (e.g., package registry tokens)."
                                    }
                                ],
                                "children": [
                                    {
                                        "id": "cfg-secret-pill",
                                        "title": "Secret",
                                        "icon": "ğŸ”’",
                                        "selector": ".gh-secret-pill",
                                        "content": "An encrypted secret on GitHub. Its value is masked in Actions logs and not readable via API or UI â€” only overwritable.",
                                        "variants": [
                                            {
                                                "when": {
                                                    "dataAttr": {
                                                        "env": "production"
                                                    }
                                                },
                                                "content": "ğŸ”’ Production secret â€” this is a live credential. If you push from vault, a matching production-scoped vault key overwrites it.",
                                                "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">ğŸ”’ Production Secret</div><div class=\"state-detail\">This secret is scoped to your production environment:\n\nâ€¢ <strong>Only production workflows</strong> can access it\nâ€¢ <strong>Encrypted at rest</strong> â€” GitHub stores it securely\nâ€¢ <strong>Masked in logs</strong> â€” GitHub Actions redacts the value\nâ€¢ <strong>Not readable</strong> â€” once set, you can only overwrite\n\nTreat production secrets with extreme care â€” rotation should be planned, not reactive.</div></div>"
                                            },
                                            {
                                                "when": {
                                                    "dataAttr": {
                                                        "env": "development"
                                                    }
                                                },
                                                "content": "ğŸ”’ Development secret â€” scoped to dev workflows only. Production can't see this value. Safe to use test credentials.",
                                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ”’ Development Secret</div><div class=\"state-detail\">This secret is scoped to development:\n\nâ€¢ <strong>Only dev workflows</strong> can access it â€” production is isolated\nâ€¢ <strong>Safe to iterate</strong> â€” change values freely without production risk\nâ€¢ <strong>Test credentials welcome</strong> â€” use sandbox API keys, test databases\n\nDevelopment secrets should be easy to rotate and non-critical.</div></div>"
                                            },
                                            {
                                                "when": {
                                                    "dataAttr": {
                                                        "env": "_repo"
                                                    }
                                                },
                                                "content": "ğŸ”’ Repo-scoped secret â€” visible to ALL workflows. Use only for truly shared secrets (e.g., package registry tokens).",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ”’ Repository Secret</div><div class=\"state-detail\">This secret is available to every workflow in the repo:\n\nâ€¢ <strong>All environments</strong> can access it\nâ€¢ <strong>Less secure</strong> than environment-scoped\nâ€¢ Useful for shared credentials like registry auth\n\nPrefer environment-scoped secrets when possible.</div></div>"
                                            }
                                        ],
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "id": "cfg-vars-list",
                                "title": "Variables",
                                "icon": "ğŸ“‹",
                                "selector": ".gh-vars-list",
                                "content": "Plaintext variables â€” visible in workflow logs. Workflows access them via ${{ vars.NAME }}. Never put sensitive data here.",
                                "variants": [
                                    {
                                        "when": {
                                            "dataAttr": {
                                                "env": "production"
                                            }
                                        },
                                        "content": "ğŸ“‹ Production variables â€” plaintext config for production. Visible in logs. Use for region, feature flags, or API URLs. Never put credentials here."
                                    },
                                    {
                                        "when": {
                                            "dataAttr": {
                                                "env": "development"
                                            }
                                        },
                                        "content": "ğŸ“‹ Development variables â€” plaintext config for dev workflows. Safe to use test values, sandbox URLs, or debug flags."
                                    },
                                    {
                                        "when": {
                                            "dataAttr": {
                                                "env": "_repo"
                                            }
                                        },
                                        "content": "ğŸ“‹ Repo-scoped variables â€” visible to ALL workflows. Use for config that's the same across all environments (e.g., org name)."
                                    }
                                ],
                                "children": [
                                    {
                                        "id": "cfg-var-pill",
                                        "title": "Variable",
                                        "icon": "ğŸ“‹",
                                        "selector": ".gh-var-pill",
                                        "content": "A plaintext variable on GitHub â€” visible in workflow logs. Never put sensitive data in variables.",
                                        "variants": [
                                            {
                                                "when": {
                                                    "dataAttr": {
                                                        "env": "production"
                                                    }
                                                },
                                                "content": "ğŸ“‹ Production variable â€” plaintext config visible in logs. Use for region, feature flags, or API URLs. Never put credentials here.",
                                                "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">ğŸ“‹ Production Variable</div><div class=\"state-detail\">This variable is scoped to production:\n\nâ€¢ <strong>Plaintext</strong> â€” readable in GitHub Settings, visible in Actions logs\nâ€¢ <strong>Production-only</strong> â€” dev workflows can't see it\nâ€¢ <strong>Not for secrets</strong> â€” if sensitive, use a secret instead\n\nCommon production variables: deployment region, CDN URL, feature flags, API base URL.</div></div>"
                                            },
                                            {
                                                "when": {
                                                    "dataAttr": {
                                                        "env": "development"
                                                    }
                                                },
                                                "content": "ğŸ“‹ Development variable â€” plaintext config for dev. Safe to use test values, sandbox URLs, or debug flags.",
                                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ“‹ Development Variable</div><div class=\"state-detail\">This variable is scoped to development:\n\nâ€¢ <strong>Plaintext</strong> â€” readable and visible in logs\nâ€¢ <strong>Dev-only</strong> â€” production can't see it\nâ€¢ <strong>Iterate freely</strong> â€” change without production risk\n\nCommon dev variables: debug flags, test API URLs, verbose logging toggles.</div></div>"
                                            },
                                            {
                                                "when": {
                                                    "dataAttr": {
                                                        "env": "_repo"
                                                    }
                                                },
                                                "content": "ğŸ“‹ Repo-scoped variable â€” visible to ALL workflows. Use for config shared across all environments.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“‹ Repository Variable</div><div class=\"state-detail\">This variable is available to every workflow:\n\nâ€¢ <strong>All environments</strong> see the same value\nâ€¢ Useful for org name, project identifiers, common build settings\nâ€¢ If environments need different values, use environment-scoped instead\n\nRepo-scoped variables are the simplest but least flexible option.</div></div>"
                                            }
                                        ],
                                        "children": []
                                    }
                                ]
                            }
                        ]
                    },
                    {
                        "id": "cfg-push-card",
                        "title": "Push Secrets",
                        "icon": "â¬†ï¸",
                        "selector": "#gh-cfg-push-card",
                        "content": "This is a bulk operation â€” every vault key goes to GitHub at once. Matching keys are overwritten, new keys are added, nothing is deleted. For granular per-key control, use the ğŸ” Secrets tab instead.",
                        "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">â¬†ï¸ Bulk Push</div><div class=\"state-detail\">When checked, the push happens during Review â†’ Finish. Here's exactly what it does:\n\n1. Reads all vault keys (from Step 3)\n2. Classifies each as secret or variable based on its kind\n3. Skips <code>GITHUB_TOKEN</code> and <code>GITHUB_REPOSITORY</code> (auto-provided by GitHub)\n4. Skips keys marked as <code>local_only</code>\n5. Pushes everything else to the matching GitHub scope\n\nIn multi-environment projects, keys are pushed per-environment. In single-environment projects, they go to repo scope.\n\nIf your vault is locked, the push will fail â€” vault values can't be read without unlocking first.</div></div>",
                        "children": [
                            {
                                "id": "cfg-push-checkbox",
                                "title": "Push Toggle",
                                "icon": "â˜‘ï¸",
                                "selector": "#mf-push-secrets",
                                "content": "Check this to queue a vault-to-GitHub sync during Review. All vault keys (except auto-provided and local-only) will be pushed. If vault is locked, the push will fail at apply time.",
                                "children": []
                            }
                        ]
                    }
                ]
            },
            {
                "id": "review-section",
                "title": "Review & Apply",
                "icon": "âœ…",
                "selector": ".wiz-section-header",
                "separator": true,
                "content": "The last stop before changes go live. Everything listed here happens when you click Finish. Immediate actions (visibility, branch, repo creation) already happened in Configure â€” this covers only the deferred ones.",
                "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âœ… What Happens on Finish</div><div class=\"state-detail\">Clicking <strong>âœ… Apply Changes</strong> executes queued operations in order:\n\n1. <strong>Create environments</strong> â€” any checked environments from the alignment table\n2. <strong>Write CODEOWNERS</strong> â€” if the checkbox was checked in Configure\n3. <strong>Push secrets</strong> â€” bulk vault-to-GitHub sync if enabled\n\nIf nothing is queued, the button is informational â€” clicking it just closes the wizard.\n\nAfter apply, all caches are invalidated and the GitHub card on the dashboard refreshes automatically.\n\n<strong>Next integration:</strong> Docker Setup containerizes your application. The button at the bottom opens it directly.</div></div>",
                "children": []
            }
        ]
    },
    {
        "context": "setup/docker",
        "title": "Docker Setup",
        "icon": "ğŸ³",
        "content": "Three steps to containerize your project â€” detect what's here, configure each service, then preview and write the files.\n\nThis wizard generates production-ready Dockerfiles and Compose configuration based on your project's modules and stack.",
        "children": [
            {
                "id": "docker-detect-env-section",
                "title": "Docker Environment",
                "icon": "ğŸ³",
                "selector": "#docker-detect-env-section",
                "separator": true,
                "content": "A snapshot of your Docker tooling and existing config files. Everything here is read-only â€” the wizard uses this to decide what it can generate and what's already covered.",
                "children": [
                    {
                        "id": "docker-detect-grid",
                        "title": "Detection Grid",
                        "icon": "ğŸ“Š",
                        "selector": "#docker-detect-grid",
                        "content": "Five checks that determine what the wizard can do. Docker Engine is the foundation â€” without it, builds and runs are off the table. The file checks tell the wizard whether to generate fresh configs or work around existing ones.",
                        "children": [
                            {
                                "id": "docker-detect-engine",
                                "title": "Docker Engine",
                                "icon": "ğŸ³",
                                "selector": "#docker-detect-engine",
                                "content": "The Docker daemon â€” the foundation everything else depends on. Compose, image builds, container management, and local testing all require this.",
                                "variants": [
                                    {
                                        "when": {
                                            "textContains": "not found"
                                        },
                                        "content": "Docker isn't installed on this machine. You can still generate Dockerfiles and Compose configs â€” they'll be ready for when Docker is available.",
                                        "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš ï¸ Docker Not Found</div><div class=\"state-detail\">The wizard can generate all configuration files without Docker installed. You just won't be able to:\n\nâ€¢ <strong>Build images</strong> â€” `docker build` requires the daemon\nâ€¢ <strong>Run containers</strong> â€” `docker run` / `docker compose up`\nâ€¢ <strong>Test locally</strong> â€” no local container environment\n\nInstall Docker Desktop or Docker Engine, then re-scan to pick it up.</div></div>"
                                    },
                                    {
                                        "when": {
                                            "textContains": "."
                                        },
                                        "content": "Docker is installed and reachable. Builds, runs, and Compose orchestration are all available. The version shown is what the daemon reports.",
                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Engine Ready</div><div class=\"state-detail\">The Docker daemon is running and responding. This means you can:\n\nâ€¢ <strong>Build images</strong> locally after generating Dockerfiles\nâ€¢ <strong>Run containers</strong> with `docker compose up`\nâ€¢ <strong>Test your stack</strong> before pushing to CI/CD\n\nThe version matters for multi-stage builds and BuildKit features â€” anything 20+ is modern enough.</div></div>"
                                    }
                                ],
                                "children": []
                            },
                            {
                                "id": "docker-detect-compose",
                                "title": "Docker Compose",
                                "icon": "âš™ï¸",
                                "selector": "#docker-detect-compose",
                                "content": "Compose orchestrates multi-container stacks â€” your app, database, cache, reverse proxy all wired together with one `docker compose up`.",
                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Compose Available</div><div class=\"state-detail\">Docker Compose is installed. The wizard will generate a <code>docker-compose.yml</code> that wires your services together â€” application containers, infrastructure services (databases, caches), networking, and volume mounts.\n\nCompose v2 (the <code>docker compose</code> plugin) is the modern standard. If you see v2.x here, you're on the current path.</div></div>",
                                "children": []
                            },
                            {
                                "id": "docker-detect-dockerfile",
                                "title": "Dockerfile",
                                "icon": "ğŸ“„",
                                "selector": "#docker-detect-dockerfile",
                                "content": "Whether a Dockerfile already exists in the project root.",
                                "variants": [
                                    {
                                        "when": {
                                            "textContains": "present"
                                        },
                                        "content": "A Dockerfile already exists. The Configure step will let you regenerate it from your stack template or leave the existing one untouched.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“„ Existing Dockerfile</div><div class=\"state-detail\">The wizard detected an existing Dockerfile. In Configure, you'll have the choice to:\n\nâ€¢ <strong>Keep it</strong> â€” the wizard won't overwrite it\nâ€¢ <strong>Regenerate</strong> â€” replace with a stack-optimized template (multi-stage build, proper caching layers, security best practices)\n\nIf you have module-specific Dockerfiles in subdirectories, those are handled per-module in the Configure step.</div></div>"
                                    },
                                    {
                                        "when": {
                                            "textContains": "missing"
                                        },
                                        "content": "No Dockerfile found. The Configure step will generate one based on your module's stack â€” with multi-stage builds, layer caching, and security defaults baked in.",
                                        "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">ğŸ“„ No Dockerfile Yet</div><div class=\"state-detail\">The wizard will generate a production-ready Dockerfile in the Configure step. Stack-specific templates include:\n\nâ€¢ <strong>Multi-stage builds</strong> â€” separate build and runtime stages\nâ€¢ <strong>Layer caching</strong> â€” dependencies installed before code copy\nâ€¢ <strong>Security defaults</strong> â€” non-root user, minimal base image\nâ€¢ <strong>Port exposure</strong> â€” based on your stack's default port</div></div>"
                                    }
                                ],
                                "children": []
                            },
                            {
                                "id": "docker-detect-composefile",
                                "title": "Compose File",
                                "icon": "ğŸ“‹",
                                "selector": "#docker-detect-composefile",
                                "content": "Whether a docker-compose.yml (or .yaml) exists in the project root.",
                                "variants": [
                                    {
                                        "when": {
                                            "textContains": "present"
                                        },
                                        "content": "A Compose file already exists. The wizard can regenerate it with your detected modules and infrastructure services, or you can keep the existing one.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“‹ Existing Compose File</div><div class=\"state-detail\">The wizard found a Compose file. In Configure, infrastructure services (databases, caches) will be offered as additions â€” the wizard understands what's already defined.\n\nIf your existing Compose file has custom networking, volumes, or service dependencies, regenerating will replace those. Consider keeping it and making manual adjustments instead.</div></div>"
                                    },
                                    {
                                        "when": {
                                            "textContains": "missing"
                                        },
                                        "content": "No Compose file yet. The wizard will generate one in Configure â€” wiring your application containers with any infrastructure services you select (databases, caches, proxies).",
                                        "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">ğŸ“‹ No Compose File Yet</div><div class=\"state-detail\">A Compose file ties your containers together. The wizard will generate one that includes:\n\nâ€¢ <strong>Application services</strong> â€” one per deployable module\nâ€¢ <strong>Infrastructure</strong> â€” databases, caches, proxies you select\nâ€¢ <strong>Networking</strong> â€” a shared network for inter-service communication\nâ€¢ <strong>Volume mounts</strong> â€” persistent data for databases, source code for dev mode\nâ€¢ <strong>Environment variables</strong> â€” wired from your vault secrets</div></div>"
                                    }
                                ],
                                "children": []
                            },
                            {
                                "id": "docker-detect-ignore",
                                "title": ".dockerignore",
                                "icon": "ğŸš«",
                                "selector": "#docker-detect-ignore",
                                "content": "Controls what gets sent to the Docker daemon during builds. Without it, everything in your project directory â€” node_modules, .git, test data â€” gets copied into the build context.",
                                "variants": [
                                    {
                                        "when": {
                                            "textContains": "present"
                                        },
                                        "content": "A .dockerignore exists. It keeps your build context lean â€” excluding .git, node_modules, __pycache__, and other non-essential files from the image.",
                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸš« Build Context Filtered</div><div class=\"state-detail\">Your .dockerignore prevents unnecessary files from being sent to the Docker daemon during builds. This matters for:\n\nâ€¢ <strong>Build speed</strong> â€” smaller context = faster COPY operations\nâ€¢ <strong>Image size</strong> â€” no accidental inclusion of test data or dev dependencies\nâ€¢ <strong>Security</strong> â€” .env files, secrets, and .git history stay out of the image</div></div>"
                                    },
                                    {
                                        "when": {
                                            "textContains": "missing"
                                        },
                                        "content": "No .dockerignore found. Without one, your entire project directory â€” including .git, node_modules, and .env files â€” gets sent to the Docker daemon on every build. The wizard will generate one.",
                                        "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">ğŸš« No .dockerignore</div><div class=\"state-detail\">Without a .dockerignore, <code>docker build</code> copies <strong>everything</strong> in your project to the daemon. This means:\n\nâ€¢ <strong>Slow builds</strong> â€” hundreds of MB of node_modules / .git transferred\nâ€¢ <strong>Bloated images</strong> â€” test fixtures, docs, and dev files in production\nâ€¢ <strong>Security risk</strong> â€” .env files with credentials baked into the image\n\nThe wizard will generate a stack-appropriate .dockerignore in the Preview step.</div></div>"
                                    }
                                ],
                                "children": []
                            }
                        ]
                    }
                ]
            },
            {
                "id": "docker-detect-mod-section",
                "title": "Project Modules",
                "icon": "ğŸ“¦",
                "selector": "#docker-detect-mod-section",
                "separator": true,
                "content": "The modules detected from your project configuration. Each one is classified based on its domain and stack â€” the wizard uses this to decide which modules become containers and which don't.",
                "children": [
                    {
                        "id": "docker-detect-modules",
                        "title": "Module List",
                        "icon": "ğŸ“¦",
                        "selector": "#docker-detect-modules",
                        "content": "Your project's modules, classified for containerization. Deployable modules get Dockerfiles in the next step. Libraries, docs, and ops-tools are listed for context but don't become containers.",
                        "dynamic": true,
                        "childTemplate": {
                            "title": "{{name}}",
                            "content": "The {{name}} module â€” detected from your project configuration.",
                            "selector": "[id^=\"docker-detect-mod-\"]",
                            "nameSelector": "strong",
                            "variants": [
                                {
                                    "when": {
                                        "dataAttr": {
                                            "modclass": "deployable"
                                        }
                                    },
                                    "content": "{{name}} is deployable â€” it has a recognized stack that maps to a Dockerfile template. In Configure, you'll choose port, base image variant, and environment variables for this service.",
                                    "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸŸ¢ Deployable Module</div><div class=\"state-detail\">This module has a stack the wizard knows how to containerize. In the Configure step, you'll set:\n\nâ€¢ <strong>Base image</strong> â€” the runtime for this service\nâ€¢ <strong>Exposed port</strong> â€” default based on the stack\nâ€¢ <strong>Build stages</strong> â€” multi-stage for smaller production images\nâ€¢ <strong>Environment variables</strong> â€” wired from your vault\n\nThe generated Dockerfile will follow best practices for this stack â€” layer caching, non-root user, minimal base.</div></div>"
                                },
                                {
                                    "when": {
                                        "dataAttr": {
                                            "modclass": "library"
                                        }
                                    },
                                    "content": "{{name}} is a library â€” shared code consumed by other modules. Libraries don't get their own container; they're included as dependencies in the modules that import them.",
                                    "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“š Library Module</div><div class=\"state-detail\">Libraries are shared code packages â€” they don't run independently, so they don't need their own Dockerfile.\n\nIf a deployable module depends on this library, the Dockerfile's build stage will include it via the package manager (pip install, npm install, etc.) or a workspace reference.</div></div>"
                                },
                                {
                                    "when": {
                                        "dataAttr": {
                                            "modclass": "docs"
                                        }
                                    },
                                    "content": "{{name}} is a documentation module â€” Markdown, Docusaurus, or similar. Docs modules typically get a separate build pipeline (Pages) rather than a container.",
                                    "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“ Documentation Module</div><div class=\"state-detail\">Documentation doesn't need containerization â€” it's usually built and deployed as static files via GitHub Pages or a similar service.\n\nIf you do want to containerize docs (e.g., for a docs preview server), you can manually add a Dockerfile in the Configure step.</div></div>"
                                },
                                {
                                    "when": {
                                        "dataAttr": {
                                            "modclass": "ops-tool"
                                        }
                                    },
                                    "content": "{{name}} is an infrastructure/ops module â€” Kubernetes manifests, Helm charts, Terraform configs, or Compose definitions. These define how other containers run, not containers themselves.",
                                    "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">âš™ï¸ Ops Tool Module</div><div class=\"state-detail\">Infrastructure modules contain deployment configuration â€” they orchestrate containers rather than becoming one.\n\nKubernetes manifests, Helm charts, and Terraform configs are consumed by their respective tools at deploy time. The Docker wizard skips these during Dockerfile generation.</div></div>"
                                }
                            ]
                        },
                        "children": []
                    },
                    {
                        "id": "docker-detect-deployable-hint",
                        "title": "Deployable Summary",
                        "icon": "ğŸ’¡",
                        "selector": "#docker-detect-deployable-hint",
                        "content": "A count of modules the wizard can containerize. These are the modules that will appear in Configure with Dockerfile generation options.",
                        "children": []
                    }
                ]
            },
            {
                "id": "dk-cfg-compose-section",
                "title": "Compose Project",
                "icon": "ğŸ“¦",
                "selector": "#dk-cfg-compose-section",
                "separator": true,
                "content": "Global settings that apply to the entire docker-compose.yml â€” the project name and target platform. These are optional and usually fine as defaults.",
                "children": [
                    {
                        "id": "dk-cfg-project-name",
                        "title": "Project Name",
                        "icon": "âœï¸",
                        "selector": "#mf-dk-project-name",
                        "content": "The Compose project name â€” used as a prefix for container names, networks, and volumes. If left empty, Compose uses the directory name.",
                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">âœï¸ Project Naming</div><div class=\"state-detail\">The project name controls the prefix Compose applies to all resources:\n\nâ€¢ <strong>Containers</strong> â€” <code>{project}_{service}_1</code>\nâ€¢ <strong>Networks</strong> â€” <code>{project}_default</code>\nâ€¢ <strong>Volumes</strong> â€” <code>{project}_{volume}</code>\n\nLeaving this empty is fine for most cases â€” Compose defaults to the directory name. Set it explicitly if you run multiple Compose stacks in the same directory or want predictable names for scripting.</div></div>",
                        "children": []
                    },
                    {
                        "id": "dk-cfg-platform",
                        "title": "Platform",
                        "icon": "ğŸ–¥ï¸",
                        "selector": "#mf-dk-platform",
                        "content": "Overrides the platform for all containers. Usually 'auto' is correct â€” set this only for cross-platform builds (e.g., building ARM images on an Intel Mac).",
                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ–¥ï¸ Platform Override</div><div class=\"state-detail\">The <code>platform</code> field tells Docker what CPU architecture to target:\n\nâ€¢ <strong>linux/amd64</strong> â€” Intel/AMD 64-bit (most servers, CI runners)\nâ€¢ <strong>linux/arm64</strong> â€” ARM 64-bit (Apple Silicon, Graviton)\nâ€¢ <strong>auto</strong> â€” use the host's architecture (default)\n\nOnly set this if you're building for a different architecture than your local machine. Cross-platform builds use QEMU emulation, which is slower.</div></div>",
                        "children": []
                    }
                ]
            },
            {
                "id": "dk-cfg-containers-section",
                "title": "Containers",
                "icon": "ğŸ³",
                "selector": "#dk-cfg-containers-section",
                "separator": true,
                "content": "Each selected module becomes a Docker service. Uncheck a module to exclude it. Expand Dockerfile and Compose sections for fine-grained control.",
                "children": [
                    {
                        "id": "dk-cfg-mod-card",
                        "title": "Module Container",
                        "icon": "ğŸ“¦",
                        "selector": "[id^='dk-mod-card-']",
                        "nameSelector": "strong",
                        "content": "Configuration for this module's Docker container â€” the image, build process, networking, and environment.",
                        "children": [
                            {
                                "id": "dk-cfg-base-image",
                                "title": "Base Image",
                                "icon": "ğŸ—ï¸",
                                "selector": "[id^='mf-dk-img-'], #mf-dk-manual-img",
                                "content": "The Docker base image for this service. The wizard pre-selects images based on the detected stack â€” pick an alpine variant for smaller images.",
                                "variants": [
                                    {
                                        "when": {
                                            "hasSelector": "option:checked[value*='python']"
                                        },
                                        "icon": "ğŸ",
                                        "content": "ğŸ Python runtime â€” slim variants give best balance for Python. Alpine can break C-extension packages (numpy, psycopg2). Pin the version to match your local Python.",
                                        "expanded": "{{dkSetupBaseBreakdown}}<div class=\"assistant-state-card state-success\" style=\"margin-top:0.4rem\"><div class=\"state-label\">ğŸ Python Notes</div><div class=\"state-detail\">â€¢ <strong>slim</strong> (~150MB) â€” Debian-based, all pip packages work. Best default.\nâ€¢ <strong>alpine</strong> (~50MB) â€” uses musl libc. numpy, pandas, psycopg2 may fail without extra build deps.\nâ€¢ <strong>full</strong> (~400MB+) â€” includes dev headers. Use when slim builds fail.\n\nVirtual environments are optional inside containers â€” pip install directly is the convention.</div></div>"
                                    },
                                    {
                                        "when": {
                                            "hasSelector": "option:checked[value*='node']"
                                        },
                                        "icon": "ğŸŸ¢",
                                        "content": "ğŸŸ¢ Node.js runtime â€” alpine works well for most Node apps. Use slim if you hit native addon build failures.",
                                        "expanded": "{{dkSetupBaseBreakdown}}<div class=\"assistant-state-card state-success\" style=\"margin-top:0.4rem\"><div class=\"state-label\">ğŸŸ¢ Node.js Notes</div><div class=\"state-detail\">â€¢ <strong>alpine</strong> (~50MB) â€” excellent for Node. Most npm packages work.\nâ€¢ <strong>slim</strong> (~150MB) â€” use if native modules fail on alpine (sharp, bcrypt).\n\nFor production: use <code>npm ci --only=production</code> for reproducible installs from lockfile.\n\nIncludes V8 engine, npm, npx. Yarn via corepack enable.</div></div>"
                                    },
                                    {
                                        "when": {
                                            "hasSelector": "option:checked[value*='golang']"
                                        },
                                        "icon": "ğŸ”µ",
                                        "content": "ğŸ”µ Go runtime â€” ideal for multi-stage builds. Compile in the Go image, copy the binary to scratch or alpine for a tiny final image.",
                                        "expanded": "{{dkSetupBaseBreakdown}}<div class=\"assistant-state-card state-success\" style=\"margin-top:0.4rem\"><div class=\"state-label\">ğŸ”µ Go Notes</div><div class=\"state-detail\">Best practice is multi-stage:\n\n<strong>Stage 1:</strong> compile your binary (<code>CGO_ENABLED=0 go build</code>)\n<strong>Stage 2:</strong> copy into <code>scratch</code> or <code>alpine</code>\n\nResult: final image under 20MB. Go compiles to static binaries by default, so the final stage needs zero runtime dependencies.</div></div>"
                                    },
                                    {
                                        "when": {
                                            "hasSelector": "option:checked[value*='rust']"
                                        },
                                        "icon": "ğŸ¦€",
                                        "content": "ğŸ¦€ Rust runtime â€” like Go, best with multi-stage builds. Compile in rust image, deploy the binary to a minimal base.",
                                        "expanded": "{{dkSetupBaseBreakdown}}<div class=\"assistant-state-card state-success\" style=\"margin-top:0.4rem\"><div class=\"state-label\">ğŸ¦€ Rust Notes</div><div class=\"state-detail\">Multi-stage approach:\n\n<strong>Stage 1:</strong> <code>cargo build --release</code>\n<strong>Stage 2:</strong> copy the binary to <code>debian:bookworm-slim</code> or <code>alpine</code>\n\nRust binaries are statically linked by default on musl targets, so alpine final stages work well.</div></div>"
                                    },
                                    {
                                        "when": {
                                            "hasSelector": "option:checked[value*='temurin']"
                                        },
                                        "icon": "â˜•",
                                        "content": "â˜• Java runtime (Eclipse Temurin) â€” for runtime-only deployments, consider JRE variant instead of JDK for smaller images.",
                                        "expanded": "{{dkSetupBaseBreakdown}}<div class=\"assistant-state-card state-success\" style=\"margin-top:0.4rem\"><div class=\"state-label\">â˜• Java Notes</div><div class=\"state-detail\">â€¢ <strong>JDK</strong> â€” full development kit. Needed for builds.\nâ€¢ <strong>JRE</strong> â€” runtime only, smaller. Use for production.\nâ€¢ <strong>alpine</strong> â€” smallest variant, works for most Spring/Quarkus apps.\n\nFor Gradle/Maven projects, multi-stage works well â€” build in JDK, run in JRE.</div></div>"
                                    },
                                    {
                                        "when": {
                                            "hasSelector": "option:checked[value='__custom']"
                                        },
                                        "icon": "âœï¸",
                                        "content": "âœï¸ Custom image â€” enter any image from Docker Hub or a private registry. Make sure the tag is pinned for reproducible builds.",
                                        "expanded": "{{dkSetupBaseBreakdown}}<div class=\"assistant-state-card state-info\" style=\"margin-top:0.4rem\"><div class=\"state-label\">âœï¸ Custom Image Tips</div><div class=\"state-detail\">â€¢ <strong>Pin the tag</strong> â€” use <code>registry/image:1.2.3</code> not <code>:latest</code>\nâ€¢ <strong>Use official images</strong> when possible â€” they get security patches\nâ€¢ <strong>Private registry?</strong> â€” <code>docker login</code> first, or pass credentials as a build arg</div></div>"
                                    }
                                ],
                                "expanded": "{{dkSetupBaseBreakdown}}<div class=\"assistant-state-card state-info\" style=\"margin-top:0.4rem\"><div class=\"state-label\">ğŸ—ï¸ Base Image</div><div class=\"state-detail\">The base image is the FROM line in your Dockerfile. It determines:\n\nâ€¢ <strong>Runtime</strong> â€” which language runtime and version\nâ€¢ <strong>Size</strong> â€” alpine variants are ~5-10Ã— smaller than full images\nâ€¢ <strong>Security</strong> â€” official images get regular CVE patches\nâ€¢ <strong>Compatibility</strong> â€” some packages don't compile on alpine (musl libc)</div></div>",
                                "children": []
                            },
                            {
                                "id": "dk-cfg-dockerfile-path",
                                "title": "Dockerfile Path",
                                "icon": "ğŸ“‚",
                                "selector": "[id^='mf-dk-dkpath-']",
                                "content": "Where to write the generated Dockerfile. Defaults to 'Dockerfile' at the project root, or '{module-path}/Dockerfile' for multi-module repos.",
                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“‚ Dockerfile Placement</div><div class=\"state-detail\">In a multi-module monorepo, each module gets its own Dockerfile:\n\nâ€¢ <strong>Single module</strong> â†’ <code>Dockerfile</code> at project root\nâ€¢ <strong>Multi-module</strong> â†’ <code>services/api/Dockerfile</code>, <code>services/worker/Dockerfile</code>, etc.\n\nThe build context for each is set in <code>docker-compose.yml</code> to match the module's path, so COPY instructions resolve correctly.</div></div>",
                                "children": []
                            },
                            {
                                "id": "dk-cfg-restart-policy",
                                "title": "Restart Policy",
                                "icon": "ğŸ”„",
                                "selector": "[id^='mf-dk-restart-'], #mf-dk-manual-restart",
                                "content": "How Docker handles container crashes. 'unless-stopped' is the safe default â€” the container restarts automatically unless you explicitly stop it.",
                                "variants": [
                                    {
                                        "when": {
                                            "hasSelector": "option:checked[value='unless-stopped']"
                                        },
                                        "icon": "âœ…",
                                        "content": "âœ… unless-stopped â€” recommended default. Restarts automatically on crash or reboot, but respects manual <code>docker compose stop</code>.",
                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Restart Â· unless-stopped</div><div class=\"state-detail\">Best default for most services. The container will:\n\nâ€¢ âœ“ Restart after a crash (non-zero exit)\nâ€¢ âœ“ Restart after host reboot\nâ€¢ âœ— Stay stopped if you manually run <code>docker compose stop</code>\n\nThis gives you automatic recovery without being impossible to shut down.</div></div>"
                                    },
                                    {
                                        "when": {
                                            "hasSelector": "option:checked[value='no']"
                                        },
                                        "icon": "â¹ï¸",
                                        "content": "â¹ï¸ no â€” container stays stopped after exit. Good for one-shot tasks, cron jobs, or CI scripts that should run once.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â¹ï¸ Restart Â· no</div><div class=\"state-detail\">No automatic restart. Use this for:\n\nâ€¢ One-shot migration or seed scripts\nâ€¢ Batch jobs triggered externally\nâ€¢ Containers managed by an external orchestrator (K8s, Swarm)\n\nIf this is a long-running service, you probably want <code>unless-stopped</code> instead.</div></div>"
                                    },
                                    {
                                        "when": {
                                            "hasSelector": "option:checked[value='on-failure']"
                                        },
                                        "icon": "âš ï¸",
                                        "content": "âš ï¸ on-failure â€” restarts only on crash (non-zero exit). Clean exits (code 0) stay stopped. Good for workers and queue consumers.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">âš ï¸ Restart Â· on-failure</div><div class=\"state-detail\">Only restarts on non-zero exit codes. The container will:\n\nâ€¢ âœ“ Restart after a crash or unhandled exception\nâ€¢ âœ— Stay stopped after clean exit (code 0)\nâ€¢ âœ— Not restart after host reboot\n\nIdeal for background workers that should recover from errors but not loop endlessly on a successful completion.</div></div>"
                                    },
                                    {
                                        "when": {
                                            "hasSelector": "option:checked[value='always']"
                                        },
                                        "icon": "ğŸ”",
                                        "content": "ğŸ” always â€” aggressively restarts even after manual stop. Use with caution â€” makes the container hard to shut down during debugging.",
                                        "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">ğŸ” Restart Â· always</div><div class=\"state-detail\">Aggressive: restarts under ALL circumstances.\n\nâ€¢ âœ“ Restarts after crash\nâ€¢ âœ“ Restarts after host reboot\nâ€¢ âš  Restarts even after <code>docker compose stop</code>\n\nThis can be annoying during development â€” the container keeps coming back when you're trying to debug. Consider <code>unless-stopped</code> for the same reliability without the stubbornness.</div></div>"
                                    }
                                ],
                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ”„ Restart Policies</div><div class=\"state-detail\">Docker restart policies control recovery behavior:\n\nâ€¢ <strong>no</strong> â€” never restart automatically (good for one-shot tasks)\nâ€¢ <strong>on-failure</strong> â€” restart only on non-zero exit code (good for workers)\nâ€¢ <strong>always</strong> â€” restart even after <code>docker compose stop</code> (aggressive)\nâ€¢ <strong>unless-stopped</strong> â€” restart unless manually stopped (best default)\n\nFor development, <code>unless-stopped</code> keeps services running across reboots without being annoying. In production with orchestration (K8s, Swarm), set <code>no</code> and let the orchestrator handle restarts.</div></div>",
                                "children": []
                            },
                            {
                                "id": "dk-cfg-dockerfile-details",
                                "title": "Dockerfile Settings",
                                "icon": "ğŸ“œ",
                                "selector": "[id^='dk-mod-dockerfile-']",
                                "content": "Fine-tune the Dockerfile build stages â€” working directory, install commands, build steps, and the runtime command.",
                                "children": [
                                    {
                                        "id": "dk-cfg-workdir",
                                        "title": "Working Directory",
                                        "icon": "ğŸ“",
                                        "selector": "[id^='mf-dk-workdir-'], #mf-dk-manual-workdir",
                                        "content": "The WORKDIR in the Dockerfile â€” where your app code lives inside the container. Defaults to /app, which is the convention for most stacks.",
                                        "children": []
                                    },
                                    {
                                        "id": "dk-cfg-install",
                                        "title": "Install Command",
                                        "icon": "ğŸ“¥",
                                        "selector": "[id^='mf-dk-install-'], #mf-dk-manual-install",
                                        "content": "The dependency install step â€” runs before your code is copied to leverage Docker's layer cache. Changed dependencies invalidate this layer and everything below it.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“¥ Install Layer Caching</div><div class=\"state-detail\">Docker builds in layers. The install command runs in its own layer:\n\n<strong>1.</strong> Copy dependency manifest (requirements.txt, package.json)\n<strong>2.</strong> Run install command â†’ <em>cached if manifest unchanged</em>\n<strong>3.</strong> Copy source code\n<strong>4.</strong> Run build\n\nThis ordering means code changes don't re-trigger dependency installation â€” only changing your dependency file does. This can save minutes on each build.</div></div>",
                                        "children": []
                                    },
                                    {
                                        "id": "dk-cfg-build-cmd",
                                        "title": "Build Command",
                                        "icon": "ğŸ”¨",
                                        "selector": "[id^='mf-dk-build-'], #mf-dk-manual-build",
                                        "content": "A compile or transpile step that runs after install. For interpreted languages (Python, Ruby), leave this empty. For compiled/bundled stacks (TypeScript, Go, Rust), this is required.",
                                        "children": []
                                    },
                                    {
                                        "id": "dk-cfg-entrypoint",
                                        "title": "Entrypoint",
                                        "icon": "ğŸšª",
                                        "selector": "[id^='mf-dk-entrypoint-'], #mf-dk-manual-entrypoint",
                                        "content": "The ENTRYPOINT instruction â€” the fixed base command. Arguments passed at runtime (or via CMD) are appended to it.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸšª Entrypoint vs CMD</div><div class=\"state-detail\">ENTRYPOINT and CMD work together:\n\nâ€¢ <strong>ENTRYPOINT</strong> â€” the executable that always runs (e.g., <code>gunicorn</code>, <code>node</code>)\nâ€¢ <strong>CMD</strong> â€” default arguments, overridable at runtime\n\nExample: <code>ENTRYPOINT [\"gunicorn\"]</code> + <code>CMD [\"app:app\", \"--bind\", \"0.0.0.0:8000\"]</code>\n\nLeave ENTRYPOINT empty if your CMD is the complete command. Use ENTRYPOINT when you want <code>docker run myimage --some-flag</code> to append flags to a fixed binary.</div></div>",
                                        "children": []
                                    },
                                    {
                                        "id": "dk-cfg-cmd",
                                        "title": "CMD",
                                        "icon": "â–¶ï¸",
                                        "selector": "[id^='mf-dk-cmd-'], #mf-dk-manual-cmd",
                                        "content": "The default command to run when the container starts. If ENTRYPOINT is set, this becomes the arguments to it. If not, this is the full startup command.",
                                        "children": []
                                    },
                                    {
                                        "id": "dk-cfg-expose",
                                        "title": "EXPOSE Port",
                                        "icon": "ğŸ”Œ",
                                        "selector": "[id^='mf-dk-expose-'], #mf-dk-manual-expose",
                                        "content": "The port declared in the Dockerfile's EXPOSE instruction. This is documentation â€” it tells other developers and tooling which port the app listens on. Actual binding happens in the port mappings below.",
                                        "expanded": "{{dkExposeHover}}",
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "id": "dk-cfg-compose-details",
                                "title": "Compose Settings",
                                "icon": "ğŸ”§",
                                "selector": "[id^='dk-mod-compose-']",
                                "content": "Docker Compose-specific settings â€” container name, health checks, build args, networks, and the sub-sections for environment variables, ports, and volumes.",
                                "children": [
                                    {
                                        "id": "dk-cfg-container-name",
                                        "title": "Container Name",
                                        "icon": "ğŸ·ï¸",
                                        "selector": "[id^='mf-dk-cname-'], #mf-dk-manual-cname",
                                        "content": "An explicit container name. If left empty, Compose auto-generates one from the project and service names. Set this if you need a predictable name for scripts or health checks.",
                                        "children": []
                                    },
                                    {
                                        "id": "dk-cfg-healthcheck",
                                        "title": "Health Check",
                                        "icon": "ğŸ’“",
                                        "selector": "[id^='mf-dk-health-'], #mf-dk-manual-health",
                                        "content": "A command Compose runs periodically to check if the container is healthy. Typically a curl or wget to a /health endpoint. Services depending on this one won't start until it's healthy.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ’“ Health Check Patterns</div><div class=\"state-detail\">Common health check commands by stack:\n\nâ€¢ <strong>HTTP apps</strong> â€” <code>curl -f http://localhost:PORT/health</code>\nâ€¢ <strong>PostgreSQL</strong> â€” <code>pg_isready -U $POSTGRES_USER</code>\nâ€¢ <strong>Redis</strong> â€” <code>redis-cli ping</code>\nâ€¢ <strong>Custom</strong> â€” any command that exits 0 on success\n\nCompose retries the check every 30s (configurable). A service marked <code>condition: service_healthy</code> in <code>depends_on</code> waits for the healthcheck to pass before starting.</div></div>",
                                        "children": []
                                    },
                                    {
                                        "id": "dk-cfg-build-args",
                                        "title": "Build Args",
                                        "icon": "ğŸ”‘",
                                        "selector": "[id^='mf-dk-buildargs-'], #mf-dk-manual-buildargs",
                                        "content": "Build-time variables passed to the Dockerfile as ARG values. These are available during build but NOT in the running container. Use for private registry tokens, build flags, or version stamps.",
                                        "children": []
                                    },
                                    {
                                        "id": "dk-cfg-networks",
                                        "title": "Networks",
                                        "icon": "ğŸŒ",
                                        "selector": "[id^='mf-dk-networks-'], #mf-dk-manual-networks",
                                        "content": "Custom networks this service joins. By default, all services share one network. Add named networks to isolate groups of services â€” e.g., 'backend' for API + DB, 'frontend' for web + proxy.",
                                        "children": []
                                    },
                                    {
                                        "id": "dk-cfg-env-section",
                                        "title": "Environment Variables",
                                        "icon": "ğŸ”",
                                        "selector": "[id^='dk-mod-env-']",
                                        "content": "Environment variables injected into the container at runtime. Each row defines a key and its value source â€” hardcoded, from a vault variable, or from a vault secret.",
                                        "variants": [
                                            {
                                                "when": {
                                                    "hasSelector": ".dk-env-row"
                                                },
                                                "content": "Environment variables configured â€” each row maps a key to a value source. Secrets and variables reference your vault; hardcoded values go directly into the compose file.",
                                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ” Env Vars Â· configured</div><div class=\"state-detail\">You have environment variables defined for this service.\n\nInjection modes:\nâ€¢ <strong>ğŸ“‹ Hardcoded</strong> â€” value written directly in docker-compose.yml. Visible in source control.\nâ€¢ <strong>ğŸ”„ Variable</strong> â€” substituted at deploy time from your vault's <code>.env</code> export.\nâ€¢ <strong>ğŸ”’ Secret</strong> â€” like Variable, but sourced from the encrypted vault secrets.\n\nIf a referenced variable doesn't exist in your vault yet, check 'â˜ Create on execution' to auto-provision it. The ğŸ² Generate button creates a random value suitable for secrets.\n\nâš  Duplicate keys are flagged â€” only the last one takes effect in Docker.</div></div>"
                                            }
                                        ],
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ” Environment Variables</div><div class=\"state-detail\">No environment variables configured yet. Click '+ Add variable' to define one.\n\nCommon variables by stack:\nâ€¢ <strong>Python</strong> â€” PYTHONUNBUFFERED=1, FLASK_ENV, DATABASE_URL\nâ€¢ <strong>Node.js</strong> â€” NODE_ENV, PORT, DATABASE_URL\nâ€¢ <strong>Go</strong> â€” GIN_MODE, PORT\nâ€¢ <strong>Java</strong> â€” SPRING_PROFILES_ACTIVE, JAVA_OPTS\n\nFor sensitive values (passwords, API keys), use ğŸ”’ Secret injection so they never appear in your compose file.</div></div>",
                                        "children": [
                                            {
                                                "id": "dk-cfg-env-row",
                                                "title": "Variable Row",
                                                "icon": "ğŸ“",
                                                "selector": ".dk-env-row",
                                                "content": "A single environment variable â€” the key it's injected as, how the value is sourced, and which vault entry it maps to.",
                                                "variants": [
                                                    {
                                                        "when": {
                                                            "hasSelector": "select option:checked[value='secret']"
                                                        },
                                                        "icon": "ğŸ”’",
                                                        "content": "ğŸ”’ Secret â€” this variable's value will be sourced from your encrypted vault. It won't appear in the compose file, only in the generated .env at deploy time."
                                                    },
                                                    {
                                                        "when": {
                                                            "hasSelector": "select option:checked[value='variable']"
                                                        },
                                                        "icon": "ğŸ”„",
                                                        "content": "ğŸ”„ Variable â€” this value is substituted from your vault's variables at deploy time. The compose file will contain ${VAR_NAME} syntax."
                                                    },
                                                    {
                                                        "when": {
                                                            "hasSelector": "select option:checked[value='hardcoded']"
                                                        },
                                                        "icon": "ğŸ“‹",
                                                        "content": "ğŸ“‹ Hardcoded â€” this value is written directly in docker-compose.yml. Make sure it's not sensitive â€” anyone with the file can read it."
                                                    }
                                                ],
                                                "children": []
                                            }
                                        ]
                                    },
                                    {
                                        "id": "dk-cfg-ports-section",
                                        "title": "Port Mappings",
                                        "icon": "ğŸ”Œ",
                                        "selector": "[id^='dk-mod-ports-wrap-']",
                                        "content": "Maps host ports to container ports so the service is reachable from your machine.",
                                        "variants": [
                                            {
                                                "when": {
                                                    "hasSelector": ".dk-port-row"
                                                },
                                                "content": "Port mappings active â€” each row binds a host port to a container port. The wizard checks for conflicts across all services.",
                                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ”Œ Ports Â· mapped</div><div class=\"state-detail\">Port mappings follow <code>HOST:CONTAINER</code> convention:\n\nâ€¢ <strong>Host port</strong> â€” the port on your machine. Must be unique across all services.\nâ€¢ <strong>Container port</strong> â€” what the app listens on inside Docker. Can repeat across services.\nâ€¢ <strong>Protocol</strong> â€” tcp (default) or udp.\n\nExample: <code>3000â†’8080/tcp</code> means <code>localhost:3000</code> reaches port 8080 inside the container.\n\nIf two services try to bind the same host port, validation will flag the conflict.</div></div>"
                                            }
                                        ],
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ”Œ Port Mappings</div><div class=\"state-detail\">No port mappings yet. Click '+ Add port' to expose this service.\n\nWithout a port mapping, the service runs but is only reachable from other containers on the same Docker network â€” not from your host machine.\n\nCommon defaults by stack:\nâ€¢ <strong>Python (Flask/Django)</strong> â€” 5000 or 8000\nâ€¢ <strong>Node.js (Express)</strong> â€” 3000\nâ€¢ <strong>Go (Gin/Fiber)</strong> â€” 8080\nâ€¢ <strong>Java (Spring)</strong> â€” 8080\n\nThe host port can differ from the container port â€” map 3000â†’8080 if you prefer accessing on 3000.</div></div>",
                                        "children": [
                                            {
                                                "id": "dk-cfg-port-row",
                                                "title": "Port Row",
                                                "icon": "ğŸ”—",
                                                "selector": ".dk-port-row",
                                                "content": "A single host â†’ container port binding. Change the host port to avoid conflicts; the container port should match what the app expects.",
                                                "expanded": "{{dkPortHover}}",
                                                "children": []
                                            }
                                        ]
                                    },
                                    {
                                        "id": "dk-cfg-vols-section",
                                        "title": "Volume Mappings",
                                        "icon": "ğŸ’¾",
                                        "selector": "[id^='dk-mod-vols-wrap-']",
                                        "content": "Maps data between the host and container for persistence and live-reload.",
                                        "variants": [
                                            {
                                                "when": {
                                                    "hasSelector": ".dk-vol-row"
                                                },
                                                "content": "Volume mappings active â€” data at each source path is available inside the container at the mount point.",
                                                "expanded": "{{dkSetupVolBreakdown}}<div class=\"assistant-state-card state-info\" style=\"margin-top:0.4rem\"><div class=\"state-label\">ğŸ’¾ Volume Types</div><div class=\"state-detail\">â€¢ <strong>Named volumes</strong> (e.g., <code>pgdata</code>) â€” Docker manages storage. Persist across restarts. Best for databases.\nâ€¢ <strong>Bind mounts</strong> (e.g., <code>./src</code>) â€” maps a host directory. Live changes visible both ways. Best for development.\nâ€¢ <strong>Read-only</strong> (<code>:ro</code>) â€” protects config files from accidental container writes.</div></div>"
                                            }
                                        ],
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ’¾ Volume Mappings</div><div class=\"state-detail\">No volumes configured. Click '+ Add volume' to map host data into the container.\n\nWithout volumes, all data inside the container is lost when it stops. Common use cases:\n\nâ€¢ <strong>Database storage</strong> â€” <code>pgdata:/var/lib/postgresql/data</code> (named volume)\nâ€¢ <strong>App source</strong> â€” <code>./src:/app/src</code> (bind mount for live-reload in dev)\nâ€¢ <strong>Config files</strong> â€” <code>./nginx.conf:/etc/nginx/nginx.conf:ro</code> (read-only)\nâ€¢ <strong>Logs</strong> â€” <code>./logs:/app/logs</code> (access logs from host)</div></div>",
                                        "children": [
                                            {
                                                "id": "dk-cfg-vol-row",
                                                "title": "Volume Row",
                                                "icon": "ğŸ“€",
                                                "selector": ".dk-vol-row",
                                                "content": "A single source : mount binding. Source can be a named volume (e.g., 'pgdata') or a host path (e.g., './data'). Mount is the path inside the container.",
                                                "expanded": "{{dkSetupVolBreakdown}}",
                                                "children": []
                                            }
                                        ]
                                    },
                                    {
                                        "id": "dk-cfg-deps-section",
                                        "title": "Depends On",
                                        "icon": "ğŸ”—",
                                        "selector": "[id^='dk-mod-deps-wrap-']",
                                        "content": "Services this container depends on. Compose starts dependencies first.",
                                        "variants": [
                                            {
                                                "when": {
                                                    "hasSelector": "input:checked"
                                                },
                                                "icon": "ğŸ”—",
                                                "content": "Dependencies selected â€” Compose will start these services before this one. If they have health checks, startup waits until healthy.",
                                                "expanded": "{{dkSetupDepBreakdown}}<div class=\"assistant-state-card state-info\" style=\"margin-top:0.4rem\"><div class=\"state-label\">âš™ï¸ Startup Ordering</div><div class=\"state-detail\">The generated <code>depends_on</code> uses:\nâ€¢ <strong>condition: service_healthy</strong> â€” if the dependency has a healthcheck\nâ€¢ <strong>condition: service_started</strong> â€” if no healthcheck is defined\n\nWith healthchecks, Compose waits until the dependency is actually ready (not just started). Without them, your app may crash on first connect.</div></div>"
                                            },
                                            {
                                                "when": {
                                                    "textContains": "No other services"
                                                },
                                                "icon": "ğŸ“­",
                                                "content": "No other services defined yet. Dependencies will be available once you add infrastructure services (database, cache, etc.) or additional modules."
                                            }
                                        ],
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ”— Service Dependencies</div><div class=\"state-detail\">No dependencies selected. This service will start independently.\n\nDependencies matter when your app needs another service at startup â€” for example, a web API that requires PostgreSQL. Without <code>depends_on</code>, Compose starts all services simultaneously, and your app may crash because the database isn't ready yet.\n\nCheck the services this container needs to be running before it starts.</div></div>",
                                        "children": [
                                            {
                                                "id": "dk-cfg-dep-item",
                                                "title": "Service Dependency",
                                                "icon": "ğŸ”—",
                                                "selector": "[id^='dk-mod-deps-wrap-'] label",
                                                "content": "Hover over a dependency to preview what it provides. Check it to add it as a startup dependency.",
                                                "expanded": "{{dkSetupDepHover}}",
                                                "children": []
                                            }
                                        ]
                                    }
                                ]
                            }
                        ]
                    }
                ]
            },
            {
                "id": "dk-cfg-infra-section",
                "title": "Infrastructure Services",
                "icon": "ğŸ—ï¸",
                "selector": "#dk-infra-list",
                "separator": true,
                "content": "Optionally add common services (databases, caches, brokers, proxies) to your docker-compose.yml. Each service is pre-configured with sensible defaults.",
                "variants": [
                    {
                        "when": {
                            "hasSelector": ".dk-infra-toggle:checked"
                        },
                        "icon": "ğŸ—ï¸",
                        "content": "Infrastructure services are enabled â€” they will be added as separate services in your compose file with their own images, ports, and environment."
                    }
                ],
                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ—ï¸ Infrastructure Services</div><div class=\"state-detail\">Browse categories and check the services your app needs. Each comes pre-configured:\n\nâ€¢ <strong>Image</strong> â€” official Docker image with version pinning\nâ€¢ <strong>Ports</strong> â€” default ports mapped to your host\nâ€¢ <strong>Environment</strong> â€” required config variables with vault integration\nâ€¢ <strong>Volumes</strong> â€” named volumes for data persistence\n\nYour app services can reference these as <code>depends_on</code> dependencies for proper startup ordering.\n\nPopular categories (Relational DB, Caches, Message Brokers) are open by default.</div></div>",
                "children": [
                    {
                        "id": "dk-cfg-infra-category",
                        "title": "Service Category",
                        "icon": "ğŸ“‚",
                        "selector": "#dk-infra-list > details",
                        "content": "A category of infrastructure services. Open to browse and enable individual services.",
                        "expanded": "{{dkInfraCategoryInfo}}",
                        "children": [
                            {
                                "id": "dk-cfg-infra-item",
                                "title": "Infrastructure Service",
                                "icon": "ğŸ”§",
                                "selector": ".dk-infra-toggle",
                                "content": "An infrastructure service you can add to your compose stack. Hover for details â€” check to enable and configure.",
                                "expanded": "{{dkInfraHover}}",
                                "children": []
                            },
                            {
                                "id": "dk-cfg-infra-panel",
                                "title": "Service Configuration",
                                "icon": "âš™ï¸",
                                "selector": "[id^='dk-infra-cfg-']",
                                "content": "Configuration panel for this infrastructure service â€” image, ports, env vars, volumes, and command.",
                                "expanded": "{{dkInfraHover}}",
                                "children": [
                                    {
                                        "id": "dk-cfg-infra-img",
                                        "title": "Image Select",
                                        "icon": "ğŸ³",
                                        "selector": "[id^='mf-dk-infra-img-']",
                                        "content": "Docker image for this service. Pick from official images or enter a custom registry path.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ³ Image Selection</div><div class=\"state-detail\">Official images are maintained by the project or Docker community. They include:\n\nâ€¢ <strong>Version tags</strong> â€” pin to a specific major/minor version (e.g., <code>16-alpine</code>) for reproducibility\nâ€¢ <strong>Alpine variants</strong> â€” smaller images (~5MB base) with musl libc. Best for production where size matters\nâ€¢ <strong>Custom option</strong> â€” use <code>âŒ¨ Customâ€¦</code> to specify any registry/image:tag\n\nTip: avoid <code>:latest</code> in production â€” pin versions to prevent surprise breaking changes on <code>docker pull</code>.</div></div>",
                                        "children": []
                                    },
                                    {
                                        "id": "dk-cfg-infra-ports",
                                        "title": "Port Configuration",
                                        "icon": "ğŸ”Œ",
                                        "selector": "[id^='mf-dk-infra-port-']",
                                        "content": "Host port mapping for this service. Change the port number if you have conflicts with other services or local processes.",
                                        "expanded": "{{dkInfraPortHover}}",
                                        "children": []
                                    },
                                    {
                                        "id": "dk-cfg-infra-env-section",
                                        "title": "Environment Variables",
                                        "icon": "ğŸ”",
                                        "selector": "[id^='dk-svc-env-list-infra-']",
                                        "content": "Environment variables for this service â€” credentials, configuration, and operational settings. Each can be hardcoded, sourced from vault variables, or vault secrets.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ” Environment Variables</div><div class=\"state-detail\">Each row configures one environment variable:\n\nâ€¢ <strong>Key</strong> â€” the variable name as the service expects it\nâ€¢ <strong>Value</strong> â€” default value shown; override as needed\nâ€¢ <strong>Var / Secret</strong> â€” optionally source from your vault\nâ€¢ <strong>Injection</strong> â€” <code>hardcoded</code> (in compose), <code>variable</code> (from vault vars), or <code>secret</code> (from vault secrets)\n\nğŸ”’ Password fields default to <code>changeme</code> â€” always override for production.\nâš ï¸ Required fields are marked and validated before generation.</div></div>",
                                        "children": [
                                            {
                                                "id": "dk-cfg-infra-env-row",
                                                "title": "Environment Variable",
                                                "icon": "ğŸ“‹",
                                                "selector": ".dk-env-row",
                                                "content": "A single environment variable â€” key, value, vault source, and injection type.",
                                                "variants": [
                                                    {
                                                        "when": {
                                                            "hasSelector": "select option:checked[value='secret']"
                                                        },
                                                        "icon": "ğŸ”’",
                                                        "content": "ğŸ”’ Secret â€” this variable's value will be sourced from your encrypted vault at deploy time."
                                                    },
                                                    {
                                                        "when": {
                                                            "hasSelector": "select option:checked[value='variable']"
                                                        },
                                                        "icon": "ğŸ”„",
                                                        "content": "ğŸ”„ Variable â€” sourced from vault variables. The compose file will contain ${VAR_NAME} syntax."
                                                    },
                                                    {
                                                        "when": {
                                                            "hasSelector": "select option:checked[value='hardcoded']"
                                                        },
                                                        "icon": "ğŸ“‹",
                                                        "content": "ğŸ“‹ Hardcoded â€” written directly in docker-compose.yml. Don't use for passwords or API keys."
                                                    }
                                                ],
                                                "children": []
                                            }
                                        ]
                                    },
                                    {
                                        "id": "dk-cfg-infra-vols",
                                        "title": "Service Volumes",
                                        "icon": "ğŸ’¾",
                                        "selector": "[id^='mf-dk-infra-vol-']",
                                        "content": "Named volume for persistent data. Check to include in docker-compose.yml.",
                                        "expanded": "{{dkInfraVolState}}",
                                        "children": []
                                    },
                                    {
                                        "id": "dk-cfg-infra-cmd",
                                        "title": "Command Override",
                                        "icon": "âš™ï¸",
                                        "selector": "[id^='mf-dk-infra-cmd-']",
                                        "content": "Custom command that overrides the image's default entrypoint. Edit carefully â€” incorrect commands prevent the container from starting.",
                                        "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš™ï¸ Command Override</div><div class=\"state-detail\">This overrides the image's default <code>CMD</code>. The pre-filled value is the recommended startup command for this service.\n\nâ€¢ Changing this can break the service if the syntax is wrong\nâ€¢ Remove the field entirely to use the image's built-in default\nâ€¢ Arguments are space-separated â€” no shell expansion unless wrapped in <code>sh -c</code>\n\nOnly modify if you understand the service's command-line interface.</div></div>",
                                        "children": []
                                    },
                                    {
                                        "id": "dk-cfg-infra-restart",
                                        "title": "Restart Policy",
                                        "icon": "ğŸ”„",
                                        "selector": "[id^='mf-dk-infra-restart-']",
                                        "content": "Controls when Docker automatically restarts this container.",
                                        "expanded": "{{dkInfraRestartState}}",
                                        "children": []
                                    }
                                ]
                            }
                        ]
                    }
                ]
            },
            {
                "id": "dk-cfg-overwrite-wrap",
                "title": "Overwrite Warning",
                "icon": "âš ï¸",
                "selector": "#dk-cfg-overwrite-wrap",
                "content": "An existing Dockerfile was detected. Check this to let the wizard replace it â€” otherwise it will skip modules that already have a Dockerfile in place.",
                "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš ï¸ Existing Dockerfile</div><div class=\"state-detail\">The Detect step found a Dockerfile in your project. The wizard defaults to <strong>not overwriting</strong> it.\n\nâ€¢ <strong>Unchecked</strong> â€” the wizard skips generating a Dockerfile for modules whose path already has one. Your existing Dockerfile is preserved.\nâ€¢ <strong>Checked</strong> â€” the wizard regenerates the Dockerfile using the stack template configured below. Your existing file is replaced.\n\nIf you've customized your Dockerfile (multi-stage tricks, custom caching, CI-specific args), leave this unchecked and adjust settings in Compose only.</div></div>",
                "children": []
            },
            {
                "id": "dk-cfg-genopts-section",
                "title": "Generation Options",
                "icon": "âš™ï¸",
                "selector": "#dk-cfg-genopts-section",
                "separator": true,
                "content": "Controls which files the wizard writes when you click Apply. Dockerfile generation is always enabled for selected modules â€” these checkboxes control the companion files.",
                "children": [
                    {
                        "id": "dk-cfg-compose-gen",
                        "title": "Generate docker-compose.yml",
                        "icon": "ğŸ“‹",
                        "selector": "#mf-dk-compose",
                        "content": "Whether to generate a docker-compose.yml that wires all your selected containers and infrastructure services together.",
                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“‹ Compose File Generation</div><div class=\"state-detail\">The generated <code>docker-compose.yml</code> includes:\n\nâ€¢ <strong>Application services</strong> â€” one per selected module\nâ€¢ <strong>Infrastructure services</strong> â€” any checked below (databases, caches, etc.)\nâ€¢ <strong>Port mappings</strong> â€” from each service's port configuration\nâ€¢ <strong>Volume mounts</strong> â€” persistent data and source mounts\nâ€¢ <strong>Environment variables</strong> â€” hardcoded, vault substitutions, or secrets\nâ€¢ <strong>Networks</strong> â€” shared network for inter-service communication\nâ€¢ <strong>Dependency ordering</strong> â€” <code>depends_on</code> from your selections\n\nIf you already have a Compose file and only want Dockerfiles, uncheck this.</div></div>",
                        "children": []
                    },
                    {
                        "id": "dk-cfg-ignore-gen",
                        "title": "Generate .dockerignore",
                        "icon": "ğŸš«",
                        "selector": "#mf-dk-ignore",
                        "content": "Whether to generate a .dockerignore file that keeps your build context lean â€” excluding .git, node_modules, __pycache__, and other non-essential files.",
                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸš« .dockerignore Generation</div><div class=\"state-detail\">A .dockerignore prevents unnecessary files from being sent to the Docker daemon during builds:\n\nâ€¢ <strong>.git/</strong> â€” repository history (often 100s of MB)\nâ€¢ <strong>node_modules/</strong> â€” reinstalled during build anyway\nâ€¢ <strong>__pycache__/</strong> â€” Python bytecode\nâ€¢ <strong>.env files</strong> â€” credentials that should never be in images\nâ€¢ <strong>*.md, docs/</strong> â€” documentation not needed at runtime\n\nThe generated file is stack-aware â€” it includes patterns relevant to your module's language and framework. If you already maintain a custom .dockerignore, uncheck this.</div></div>",
                        "children": []
                    }
                ]
            }
        ]
    },
    {
        "context": "setup/k8s",
        "title": "Kubernetes Setup",
        "icon": "â˜¸ï¸",
        "content": "Your Kubernetes deployment pipeline â€” from project scan to production-ready manifests.",
        "children": [
            {
                "id": "k8s-detect-env",
                "title": "Kubernetes Environment",
                "icon": "â˜¸ï¸",
                "selector": "#k8s-detect-env",
                "separator": true,
                "content": "Your K8s tooling and cluster connectivity. These determine what the wizard can do â€” generate manifests offline, or validate and deploy against a live cluster.",
                "children": [
                    {
                        "id": "k8s-detect-kubectl",
                        "title": "kubectl",
                        "icon": "â˜¸ï¸",
                        "selector": "#k8s-detect-kubectl",
                        "content": "The CLI that talks to your cluster â€” without it, manifests can't be applied, pods can't be inspected, and deployments can't roll out.",
                        "variants": [
                            {
                                "when": {
                                    "textContains": "Available"
                                },
                                "content": "kubectl is ready â€” you can apply manifests, inspect pods, and manage rollouts directly from the control plane.",
                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Available</div><div class=\"state-detail\">kubectl is your primary interface to any Kubernetes cluster. With it available, the wizard can:\n\nâ€¢ <strong>Validate manifests</strong> â€” dry-run apply catches errors before deployment\nâ€¢ <strong>Query cluster state</strong> â€” pods, services, deployments in real time\nâ€¢ <strong>Apply changes</strong> â€” push generated manifests directly to your cluster\n\nThe Helm and Cluster checks below also depend on kubectl being present.</div></div>"
                            },
                            {
                                "when": {
                                    "textContains": "Not found"
                                },
                                "content": "kubectl isn't installed â€” you can still generate manifests, but can't validate or deploy them from here.",
                                "expanded": "<div class=\"assistant-state-card state-error\"><div class=\"state-label\">âŒ Not Found</div><div class=\"state-detail\">Without kubectl, the wizard can still generate YAML manifests, but you won't be able to:\n\nâ€¢ Validate manifests against your cluster\nâ€¢ Query running pods or services\nâ€¢ Apply changes directly\n\nYou'd need to install kubectl and configure a kubeconfig before deploying.\n\nğŸ“¦ Install: <code>curl -LO https://dl.k8s.io/release/stable.txt && curl -LO \"https://dl.k8s.io/release/$(cat stable.txt)/bin/linux/amd64/kubectl\"</code></div></div>"
                            }
                        ],
                        "children": []
                    },
                    {
                        "id": "k8s-detect-helm",
                        "title": "Helm",
                        "icon": "âˆ",
                        "selector": "#k8s-detect-helm",
                        "content": "The K8s package manager â€” lets you template manifests with values files, manage releases, and pull community charts for databases, monitoring, and ingress.",
                        "variants": [
                            {
                                "when": {
                                    "textContains": "Available"
                                },
                                "content": "Helm is available â€” the wizard can generate Helm charts with templated values for multi-environment deployments.",
                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Available</div><div class=\"state-detail\">With Helm available, the Configure step can optionally scaffold a full Helm chart:\n\nâ€¢ <strong>Chart.yaml</strong> â€” metadata, version, dependencies\nâ€¢ <strong>values.yaml</strong> â€” per-environment overrides\nâ€¢ <strong>templates/</strong> â€” templated Deployment, Service, Ingress\n\nHelm charts are the standard way to package K8s applications for reuse across environments and teams.</div></div>"
                            },
                            {
                                "when": {
                                    "textContains": "Not found"
                                },
                                "content": "Helm isn't installed â€” not a blocker. The wizard generates raw YAML manifests that work without it.",
                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â„¹ï¸ Not Installed</div><div class=\"state-detail\">Helm is optional. Without it, the wizard generates plain YAML manifests â€” perfectly valid Kubernetes resources that you apply directly with kubectl.\n\nConsider Helm if you need:\nâ€¢ Multiple environments with different values (dev/staging/prod)\nâ€¢ Reusable charts shared across teams\nâ€¢ Community charts for databases, monitoring, ingress controllers\n\nğŸ“¦ Install: <code>curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash</code></div></div>"
                            }
                        ],
                        "children": []
                    },
                    {
                        "id": "k8s-detect-cluster",
                        "title": "Cluster",
                        "icon": "ğŸ”—",
                        "selector": "#k8s-detect-cluster",
                        "content": "Whether kubectl can reach a live Kubernetes cluster â€” determines if you can validate, deploy, and inspect in real time.",
                        "variants": [
                            {
                                "when": {
                                    "textContains": "Not connected"
                                },
                                "content": "No cluster connection â€” manifests can still be generated, but validation and deployment happen elsewhere.",
                                "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš ï¸ Not Connected</div><div class=\"state-detail\">kubectl can't reach a cluster. This is fine for manifest generation â€” the wizard creates valid YAML regardless.\n\nCommon reasons:\nâ€¢ No kubeconfig file (~/.kube/config)\nâ€¢ Cluster is down or unreachable\nâ€¢ Context points to a deleted cluster\n\nYou can deploy the generated manifests later from a machine with cluster access, or through a CI/CD pipeline.</div></div>"
                            },
                            {
                                "when": {
                                    "textContains": "Connected"
                                },
                                "content": "A live cluster is reachable â€” you can validate manifests, inspect running workloads, and deploy directly.",
                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Connected</div><div class=\"state-detail\">kubectl can reach your cluster. This could be a local cluster (minikube, kind, Docker Desktop) or a remote one (EKS, GKE, AKS).\n\nWith a live connection, the Review step can:\nâ€¢ <strong>Dry-run apply</strong> â€” validate manifests against the actual API server\nâ€¢ <strong>Show running workloads</strong> â€” see what's already deployed\nâ€¢ <strong>Deploy directly</strong> â€” apply generated manifests to the cluster</div></div>"
                            }
                        ],
                        "children": []
                    },
                    {
                        "id": "k8s-detect-manifests",
                        "title": "Manifests",
                        "icon": "ğŸ“„",
                        "selector": "#k8s-detect-manifests",
                        "content": "Existing K8s YAML files in your project â€” the wizard can extend or replace them.",
                        "variants": [
                            {
                                "when": {
                                    "textContains": "found"
                                },
                                "content": "Existing manifests detected â€” the Configure step will show what you already have and let you extend or regenerate.",
                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ“„ Manifests Found</div><div class=\"state-detail\">The wizard found existing K8s YAML files in your project. In the Configure step, you'll be able to:\n\nâ€¢ Keep existing manifests as-is\nâ€¢ Override specific resources with new configuration\nâ€¢ Add new resources alongside existing ones\n\nExisting manifests won't be deleted unless you explicitly choose to regenerate them.</div></div>"
                            },
                            {
                                "when": {
                                    "textContains": "None"
                                },
                                "content": "No existing manifests â€” the wizard will generate everything from scratch based on your project structure.",
                                "children": []
                            }
                        ],
                        "children": []
                    },
                    {
                        "id": "k8s-detect-chart",
                        "title": "Helm Chart",
                        "icon": "ğŸ“¦",
                        "selector": "#k8s-detect-chart",
                        "content": "Whether a Chart.yaml already exists in your project.",
                        "variants": [
                            {
                                "when": {
                                    "textContains": "Present"
                                },
                                "content": "A Helm chart already exists â€” the wizard will work alongside it rather than overwriting.",
                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ“¦ Chart Present</div><div class=\"state-detail\">An existing Chart.yaml was found. The wizard respects your existing chart structure â€” it won't overwrite templates you've already written.\n\nIf you want the wizard to regenerate the chart from scratch, you can delete the existing one first.</div></div>"
                            },
                            {
                                "when": {
                                    "textContains": "None"
                                },
                                "content": "No Helm chart yet â€” if Helm is available, the Configure step can scaffold one for you.",
                                "children": []
                            }
                        ],
                        "children": []
                    }
                ]
            },
            {
                "id": "k8s-detect-docker",
                "title": "Docker Context",
                "icon": "ğŸ³",
                "selector": "#k8s-detect-docker",
                "separator": true,
                "content": "K8s deploys container images â€” this section checks whether Docker is available and what container definitions already exist. Your Dockerfiles and Compose services feed directly into the K8s workloads configured in the next step.",
                "children": [
                    {
                        "id": "k8s-detect-docker-cli",
                        "title": "Docker",
                        "icon": "ğŸ³",
                        "selector": "#k8s-detect-docker-cli",
                        "content": "The container runtime â€” K8s pulls and runs images that Docker (or a compatible builder) creates.",
                        "variants": [
                            {
                                "when": {
                                    "textContains": "Available"
                                },
                                "content": "Docker is available â€” images can be built locally and pushed to a registry for K8s to pull.",
                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Available</div><div class=\"state-detail\">Docker can build your container images locally. The typical flow:\n\n1. <strong>Build</strong> â€” Docker creates images from your Dockerfiles\n2. <strong>Push</strong> â€” images go to a registry (ghcr.io, Docker Hub, ECR)\n3. <strong>Pull</strong> â€” K8s nodes pull images from that registry\n\nIf you haven't set up Docker yet, the Docker Setup wizard can generate Dockerfiles and Compose config.</div></div>"
                            },
                            {
                                "when": {
                                    "textContains": "Not installed"
                                },
                                "content": "Docker isn't installed â€” you'll need a way to build container images before K8s can deploy them.",
                                "expanded": "<div class=\"assistant-state-card state-error\"><div class=\"state-label\">âŒ Not Installed</div><div class=\"state-detail\">Without Docker, you can't build container images locally. K8s needs images in a registry to pull from.\n\nOptions:\nâ€¢ Install Docker and use the Docker Setup wizard to generate Dockerfiles\nâ€¢ Build images in CI/CD (GitHub Actions can build and push without local Docker)\nâ€¢ Use a remote builder like Google Cloud Build\n\nThe wizard can still generate K8s manifests â€” they'll reference image names that you'll build elsewhere.</div></div>"
                            }
                        ],
                        "children": []
                    },
                    {
                        "id": "k8s-detect-compose-file",
                        "title": "Compose File",
                        "icon": "ğŸ“‹",
                        "selector": "#k8s-detect-compose-file",
                        "content": "A docker-compose.yml is the richest source of intelligence for K8s configuration â€” it defines services, ports, volumes, environment variables, and dependencies that map directly to K8s resources.",
                        "variants": [
                            {
                                "when": {
                                    "textContains": "Missing"
                                },
                                "content": "No Compose file â€” the wizard will use your project modules instead. Consider running Docker Setup first for richer service definitions.",
                                "children": []
                            }
                        ],
                        "children": []
                    },
                    {
                        "id": "k8s-detect-dockerfiles",
                        "title": "Dockerfiles",
                        "icon": "ğŸ“„",
                        "selector": "#k8s-detect-dockerfiles",
                        "content": "Each Dockerfile becomes a buildable container image. The wizard maps these to K8s Deployment specs with the right image references.",
                        "variants": [
                            {
                                "when": {
                                    "textContains": "Missing"
                                },
                                "content": "No Dockerfiles found â€” K8s needs container images. Run Docker Setup first, or reference pre-built images from a registry.",
                                "children": []
                            }
                        ],
                        "children": []
                    },
                    {
                        "id": "k8s-detect-docker-warn",
                        "title": "Docker Required",
                        "icon": "ğŸ’¡",
                        "selector": "#k8s-detect-docker-warn",
                        "content": "K8s orchestrates containers â€” without Dockerfiles or a Compose file, there's nothing to deploy. The Docker Setup wizard generates both, tailored to your project's stack.",
                        "children": []
                    }
                ]
            },
            {
                "id": "k8s-detect-compose",
                "title": "Compose Services",
                "icon": "ğŸš€",
                "selector": "#k8s-detect-compose",
                "separator": true,
                "content": "The wizard analyzed your docker-compose.yml and classified each service as either application (your code â€” becomes a Deployment) or infrastructure (databases, caches â€” becomes a StatefulSet or managed service). This classification drives the Configure step.",
                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸš€ Service Classification</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-grid\"><span style=\"font-weight:600;color:var(--success)\">ğŸš€ application</span><span>Your code â€” services that build from source or use your project's images. Become K8s Deployments with replicas, probes, and HPA autoscaling.</span><span style=\"font-weight:600;color:var(--text-muted)\">ğŸ—„ï¸ infrastructure</span><span>Backing services â€” databases, caches, queues, proxies. In Configure, you choose: self-hosted StatefulSet, managed cloud service, or skip.</span></div></div></div>",
                "children": [
                    {
                        "id": "k8s-detect-svc-list",
                        "title": "Service List",
                        "icon": "ğŸ“‹",
                        "selector": "#k8s-detect-svc-list",
                        "content": "Each row shows a detected Compose service â€” its image, ports, environment variables, volumes, and healthcheck. The small icons on the right tell you what configuration the service already carries from Compose.",
                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“‹ Reading the Service Rows</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-grid\"><span class=\"state-key\">ğŸ”§ N</span><span>number of environment variables defined</span><span class=\"state-key\">ğŸ’¾ N</span><span>number of volume mounts</span><span class=\"state-key\">â¤ï¸</span><span>has a healthcheck â€” will be converted to K8s liveness/readiness probes</span></div><div class=\"state-text-spaced\">In the next step, each application service gets its own configuration panel with resource limits, probes, and scaling options.</div></div></div>",
                        "dynamic": true,
                        "childTemplate": {
                            "title": "ğŸš€ {{name}}",
                            "content": "Compose service {{name}} â€” hover for classification details and what happens in the Configure step.",
                            "selector": "#k8s-detect-svc-list .k8s-detect-svc-row",
                            "nameSelector": "strong",
                            "variants": [
                                {
                                    "when": {
                                        "textContains": "infrastructure"
                                    },
                                    "title": "ğŸ—„ï¸ {{name}}",
                                    "content": "Infrastructure service {{name}} â€” a backing dependency (database, cache, queue). In the Configure step, choose: self-hosted StatefulSet, managed cloud service, or skip.",
                                    "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ—„ï¸ Infrastructure Service</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">This service was classified as <strong>infrastructure</strong> â€” it's a backing dependency your application services connect to.</div><div class=\"state-grid\"><span class=\"state-key\">StatefulSet</span><span>self-hosted in-cluster â€” persistent storage, stable network identity</span><span class=\"state-key\">Managed</span><span>cloud-managed service (RDS, Cloud SQL, ElastiCache) â€” no pods to manage</span><span class=\"state-key\">Skip</span><span>exclude from K8s manifests â€” handled externally or not needed</span></div><div class=\"state-text-spaced\">In production, managed services are generally preferred for databases and caches â€” less operational burden, automated backups, and built-in HA.</div></div></div>"
                                },
                                {
                                    "when": {
                                        "textContains": "application"
                                    },
                                    "title": "ğŸš€ {{name}}",
                                    "content": "Application service {{name}} â€” your code. Becomes a K8s Deployment with replicas, health probes, resource limits, and optional HPA autoscaling.",
                                    "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸš€ Application Service</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">This service was classified as <strong>application</strong> â€” your code that runs as a K8s Deployment.</div><div class=\"state-grid\"><span class=\"state-key\">Deployment</span><span>manages replicated pods with rolling updates and rollbacks</span><span class=\"state-key\">Probes</span><span>liveness + readiness checks keep traffic away from unhealthy pods</span><span class=\"state-key\">Resources</span><span>CPU/memory requests and limits prevent noisy-neighbor issues</span><span class=\"state-key\">HPA</span><span>auto-scale replicas based on CPU, memory, or custom metrics</span></div><div class=\"state-text-spaced\">The Configure step lets you tune all of these per service.</div></div></div>"
                                }
                            ]
                        },
                        "children": []
                    }
                ]
            },
            {
                "id": "k8s-detect-modules",
                "title": "Project Modules",
                "icon": "ğŸ“¦",
                "selector": "#k8s-detect-modules",
                "separator": true,
                "content": "No Compose file was found, so the wizard falls back to your project's module structure. Deployable modules will become K8s Deployments â€” libraries, docs, and tools are shown but skipped.",
                "children": [
                    {
                        "id": "k8s-detect-mod-list",
                        "title": "Module List",
                        "icon": "ğŸ“‹",
                        "selector": "#k8s-detect-mod-list",
                        "content": "Each row shows a detected project module â€” its stack, path, and classification. Only modules classified as 'deployable' will become K8s workloads in the Configure step.",
                        "children": []
                    }
                ]
            },
            {
                "id": "k8s-detect-registry",
                "title": "Registry Context",
                "icon": "ğŸ“¦",
                "selector": "#k8s-detect-registry",
                "separator": true,
                "content": "Where your container images will live. The wizard uses your GitHub repository to construct image names that follow the ghcr.io convention â€” consistent naming across Docker builds, CI/CD pipelines, and K8s manifests.",
                "children": [
                    {
                        "id": "k8s-detect-repo",
                        "title": "Repository",
                        "icon": "ğŸ™",
                        "selector": "#k8s-detect-repo",
                        "content": "Your GitHub repository â€” the owner and name feed into the container image naming convention.",
                        "children": []
                    },
                    {
                        "id": "k8s-detect-registry-url",
                        "title": "Registry URL",
                        "icon": "ğŸ“¦",
                        "selector": "#k8s-detect-registry-url",
                        "content": "The full registry path your K8s manifests will reference â€” images pushed here by Docker builds or CI/CD are what your pods actually run.",
                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“¦ GitHub Container Registry</div><div class=\"state-detail\">ghcr.io is GitHub's built-in container registry. Images pushed here are:\n\nâ€¢ <strong>Tied to your repo</strong> â€” permissions follow repository access\nâ€¢ <strong>Free for public repos</strong> â€” no separate registry subscription\nâ€¢ <strong>CI/CD native</strong> â€” GitHub Actions can push without extra credentials\n\nThe generated K8s manifests will use this as the image prefix â€” e.g., <code>ghcr.io/owner/repo/service:latest</code></div></div>",
                        "children": []
                    }
                ]
            },
            {
                "id": "k8s-detect-envs",
                "title": "Environments",
                "icon": "ğŸ·ï¸",
                "selector": "#k8s-detect-envs",
                "separator": true,
                "content": "Deployment environments from your project configuration. These drive namespace separation, environment-specific values, and multi-stage rollout strategies in your K8s manifests.",
                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ·ï¸ Environment â†’ K8s Mapping</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Each environment typically maps to:</div><div class=\"state-grid\"><span class=\"state-key\">Namespace</span><span>isolated resource boundary per environment</span><span class=\"state-key\">Values</span><span>different replica counts, resource limits, image tags</span><span class=\"state-key\">Secrets</span><span>environment-specific credentials from vault</span></div><div class=\"state-text-spaced\">The â­ default environment is where local development deploys. Other environments are typically targeted by CI/CD pipelines.</div></div></div>",
                "children": [
                    {
                        "id": "k8s-detect-env-list",
                        "title": "Environment Badges",
                        "icon": "ğŸ·ï¸",
                        "selector": "#k8s-detect-env-list",
                        "content": "Your configured environments â€” â­ marks the default. Each one can get its own namespace and values in the Configure step.",
                        "children": []
                    }
                ]
            },
            {
                "id": "k8s-cfg-app-svcs",
                "title": "Application Deployments",
                "icon": "ğŸš€",
                "selector": "#k8s-app-svc-list",
                "separator": true,
                "content": "Your application services â€” each one becomes a K8s workload. Hover any field for guidance on what it does and what to watch out for.",
                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸš€ Configure â†’ Review â†’ Generate</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Each service card produces a set of K8s resources:</div><div class=\"state-grid\"><span class=\"state-key\">Deployment</span><span>pod template + replica management + rolling update strategy</span><span class=\"state-key\">Service</span><span>stable DNS name + load balancing across replicas</span><span class=\"state-key\">ConfigMap</span><span>non-secret environment variables</span><span class=\"state-key\">Secret</span><span>sensitive values injected at deploy time</span></div><div class=\"state-text-spaced\">Unchecked services are excluded entirely â€” no resources generated.</div></div></div>",
                "children": [
                    {
                        "id": "k8s-cfg-svc-card",
                        "title": "Service Card",
                        "icon": "ğŸ“¦",
                        "selector": "[id^=k8s-svc-card-]",
                        "content": "Everything in this card shapes one workload. The kind on the right is the most important choice â€” it changes what options appear below.",
                        "variants": [
                            {
                                "when": {
                                    "resolver": "k8sSvcCardKind",
                                    "equals": "Skip"
                                },
                                "content": "Excluded â€” this service won't generate any K8s manifest. If other services depend_on it, make sure it's available another way (managed cloud service, external endpoint).",
                                "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">â­ï¸ Skipped</div><div class=\"state-detail\">No Deployment, Service, ConfigMap, or Secret will be generated for this service. It won't appear in the Review step.\n\nIf another service references this one (via depends_on or env vars), you'll need to provide the connection details manually â€” K8s won't manage it.</div></div>"
                            },
                            {
                                "when": {
                                    "resolver": "k8sSvcCardKind",
                                    "equals": "Deployment"
                                },
                                "content": "Deploying as a K8s Deployment â€” replicated stateless pods with rolling updates. The most common choice for application code (APIs, web servers, workers).",
                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸš€ Deployment</div><div class=\"state-detail\">Deployments manage identical, interchangeable pods:\n\nâ€¢ <strong>Rolling updates</strong> â€” new pods come up before old ones go down\nâ€¢ <strong>Replicas</strong> â€” scale horizontally for HA and throughput\nâ€¢ <strong>HPA</strong> â€” auto-scale based on CPU, memory, or custom metrics\nâ€¢ <strong>Rollback</strong> â€” one command reverts to the previous revision\n\nPods have no stable identity or persistent storage. If your service writes to disk, consider StatefulSet instead.</div></div>"
                            },
                            {
                                "when": {
                                    "resolver": "k8sSvcCardKind",
                                    "equals": "StatefulSet"
                                },
                                "content": "StatefulSet â€” each pod gets a stable hostname and its own persistent volume. Good for services that write to disk or need peer discovery.",
                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ—„ï¸ StatefulSet</div><div class=\"state-detail\">Unlike Deployments, StatefulSet pods are not interchangeable:\n\nâ€¢ <strong>Stable identity</strong> â€” pod-0, pod-1, pod-2 persist across restarts\nâ€¢ <strong>Per-pod storage</strong> â€” each pod gets its own PVC via volumeClaimTemplates\nâ€¢ <strong>Ordered operations</strong> â€” pods start/stop in sequence (unless Parallel)\nâ€¢ <strong>Headless Service</strong> â€” DNS like <code>svc-0.svc-headless.ns</code>\n\nHeavier to operate than Deployments. Use only when stable identity or per-pod storage is genuinely needed.</div></div>"
                            },
                            {
                                "when": {
                                    "resolver": "k8sSvcCardKind",
                                    "equals": "DaemonSet"
                                },
                                "content": "DaemonSet â€” one pod on every node in the cluster. No replica count â€” K8s automatically places pods as nodes come and go.",
                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸŒ DaemonSet</div><div class=\"state-detail\">DaemonSets guarantee exactly one pod per node:\n\nâ€¢ <strong>No replicas</strong> â€” pod count equals node count\nâ€¢ <strong>Node selectors</strong> â€” restrict to specific nodes if needed\nâ€¢ <strong>Tolerations</strong> â€” run on tainted nodes (control-plane, GPU)\nâ€¢ <strong>Host access</strong> â€” optional host network, PID, IPC sharing\n\nTypical uses: log collectors, monitoring agents, network plugins, storage drivers.</div></div>"
                            },
                            {
                                "when": {
                                    "resolver": "k8sSvcCardKind",
                                    "equals": "Job"
                                },
                                "content": "A run-to-completion Job â€” runs once, exits, and K8s reports success or failure. No service, no replicas, no probes.",
                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">âš¡ Job</div><div class=\"state-detail\">Jobs run a container to completion:\n\nâ€¢ <strong>Backoff limit</strong> â€” how many times to retry on failure\nâ€¢ <strong>Completions</strong> â€” how many successful runs are needed\nâ€¢ <strong>Parallelism</strong> â€” how many pods run simultaneously\nâ€¢ <strong>TTL</strong> â€” auto-cleanup after the job finishes\n\nNo Service, no health probes, no replicas. The container runs its command and exits.</div></div>"
                            },
                            {
                                "when": {
                                    "resolver": "k8sSvcCardKind",
                                    "equals": "CronJob"
                                },
                                "content": "CronJob â€” wraps a Job in a cron schedule. Kubernetes creates a fresh Job each time the schedule fires.",
                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â° CronJob</div><div class=\"state-detail\">CronJobs schedule recurring work:\n\nâ€¢ <strong>Schedule</strong> â€” standard cron syntax (minute hour day month weekday)\nâ€¢ <strong>Concurrency</strong> â€” Allow, Forbid (skip if running), Replace (kill + restart)\nâ€¢ <strong>Suspend</strong> â€” pause scheduling without deleting the CronJob\nâ€¢ <strong>History</strong> â€” how many successful/failed jobs to keep\n\nEach trigger creates a new Job pod. Long-running CronJobs with Forbid concurrency skip missed runs.</div></div>"
                            }
                        ],
                        "children": [
                            {
                                "id": "k8s-cfg-svc-img",
                                "title": "Container Image",
                                "icon": "ğŸ“¦",
                                "selector": ".k8s-field-img",
                                "content": "Must be pullable by your cluster nodes â€” local Docker images won't work. Use a registry your nodes can reach (GHCR, DockerHub, ECR, private registry).",
                                "variants": [
                                    {
                                        "when": {
                                            "resolver": "k8sFieldValue",
                                            "contains": "ghcr.io"
                                        },
                                        "content": "GitHub Container Registry â€” aligned with your repo. GitHub Actions pushes here automatically. If the image is private, your cluster needs an imagePullSecret.",
                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ“¦ ghcr.io</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">GitHub Container Registry images are tied to your repository. Advantages:</div><div class=\"state-grid\"><span class=\"state-key\">Auth</span><span>permissions follow repository access â€” no separate creds</span><span class=\"state-key\">CI/CD</span><span>GitHub Actions can push with <code>GITHUB_TOKEN</code> â€” no secrets needed</span><span class=\"state-key\">Cost</span><span>free for public repos</span></div><div class=\"state-text-spaced\">For private images, create an imagePullSecret in each namespace where this service runs.</div></div></div>"
                                    },
                                    {
                                        "when": {
                                            "resolver": "k8sFieldValue",
                                            "contains": ":latest"
                                        },
                                        "content": "Using :latest tag â€” convenient for development, risky for production. K8s can't tell if the image changed. Pin to a commit SHA or semver tag for reproducible deployments.",
                                        "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš ï¸ :latest tag</div><div class=\"state-detail\">The :latest tag is a moving target â€” two deploys with the same manifest can run different code.\n\nâ€¢ <strong>imagePullPolicy: Always</strong> forces K8s to check the registry every time (slow)\nâ€¢ <strong>Rollbacks</strong> don't work â€” reverting the Deployment still pulls :latest\nâ€¢ <strong>Debugging</strong> is harder â€” which version is actually running?\n\nFor production, use: <code>image:v1.2.3</code> or <code>image:abc1234</code></div></div>"
                                    },
                                    {
                                        "when": {
                                            "resolver": "k8sFieldValue",
                                            "contains": "localhost"
                                        },
                                        "content": "Local image reference â€” K8s nodes pull from registries, not your local Docker daemon. Push to a registry (ghcr.io, Docker Hub) before deploying.",
                                        "expanded": "<div class=\"assistant-state-card state-error\"><div class=\"state-label\">âŒ Local reference</div><div class=\"state-detail\">Kubernetes nodes pull images from container registries over the network. An image on your local Docker daemon is invisible to the cluster.\n\nTo fix: push the image to a registry, then update this field to the registry path.\n\nException: if using minikube with <code>eval $(minikube docker-env)</code>, local images work â€” but only on that single node.</div></div>"
                                    },
                                    {
                                        "when": {
                                            "resolver": "k8sFieldValue",
                                            "equals": ""
                                        },
                                        "content": "No image specified â€” this field is required. K8s needs an image reference to create the container. It was probably auto-detected from your Compose file.",
                                        "expanded": "<div class=\"assistant-state-card state-error\"><div class=\"state-label\">âŒ Missing image</div><div class=\"state-detail\">Every K8s container spec needs an <code>image</code> field. Without it, the pod can't start.\n\nExpected format: <code>registry/owner/name:tag</code>\nExample: <code>ghcr.io/myorg/api:v1.0.0</code></div></div>"
                                    }
                                ],
                                "children": []
                            },
                            {
                                "id": "k8s-cfg-svc-port",
                                "title": "Port",
                                "icon": "ğŸ”Œ",
                                "selector": ".k8s-field-port",
                                "content": "The port your app binds to inside the container. Gets wired into the Service targetPort, probe endpoints, and ingress rules.",
                                "variants": [],
                                "children": [],
                                "expanded": "{{k8sPortHover}}"
                            },
                            {
                                "id": "k8s-cfg-svc-replicas",
                                "title": "Replicas",
                                "icon": "ğŸ“Š",
                                "selector": ".k8s-field-replicas",
                                "content": "Pod count â€” the tension between availability and cost. Hidden for DaemonSet (node count) and Job/CronJob (one-shot).",
                                "variants": [
                                    {
                                        "when": {
                                            "resolver": "k8sFieldValue",
                                            "equals": "0"
                                        },
                                        "content": "Zero replicas â€” the Deployment exists but no pods run. Useful for KEDA event-driven scaling or intentionally scaled-down environments.",
                                        "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš ï¸ 0 replicas</div><div class=\"state-detail\">The manifest is created, but no pods are scheduled. The Deployment sits idle until manually scaled up or an autoscaler (KEDA, HPA with custom metrics) kicks in.\n\nCommon uses:\nâ€¢ Staging environments scaled to zero when unused\nâ€¢ Event-driven workloads that scale from zero on demand\nâ€¢ Services disabled but not deleted</div></div>"
                                    },
                                    {
                                        "when": {
                                            "resolver": "k8sFieldValue",
                                            "equals": "1"
                                        },
                                        "content": "Single replica â€” no high availability. If this pod crashes, is evicted, or gets rescheduled, there's a gap in service. Rolling updates cause brief downtime. Fine for dev, risky for prod.",
                                        "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš ï¸ 1 replica</div><div class=\"state-detail\">With one pod, any disruption causes downtime:\n\nâ€¢ <strong>Rolling update</strong> â€” old pod dies before new pod is ready (unless maxSurge > 0)\nâ€¢ <strong>Node failure</strong> â€” pod reschedules to another node, but there's a gap\nâ€¢ <strong>Eviction</strong> â€” resource pressure can kill your only pod\n\nFor production, use at least 2 replicas. For development, 1 is fine â€” saves resources.</div></div>"
                                    },
                                    {
                                        "when": {
                                            "resolver": "k8sFieldValue",
                                            "equals": "2"
                                        },
                                        "content": "Two replicas â€” basic high availability. During rolling updates, one pod serves traffic while the other rolls. Covers single-node failure.",
                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… 2 replicas</div><div class=\"state-detail\">The minimum for high availability:\n\nâ€¢ <strong>Rolling updates</strong> work â€” one pod serves while the other is replaced\nâ€¢ <strong>Node failure</strong> â€” if one pod dies, the other still handles traffic\nâ€¢ <strong>Pod Disruption Budget</strong> â€” set minAvailable: 1 to prevent both being evicted\n\nFor services with heavy traffic or strict SLAs, consider 3+ replicas.</div></div>"
                                    },
                                    {
                                        "when": {
                                            "resolver": "k8sFieldValue",
                                            "equals": "3"
                                        },
                                        "content": "Three replicas â€” solid for production. Handles rolling updates, node failures, and zone failures with headroom. Consider adding an HPA to auto-scale based on load."
                                    }
                                ],
                                "children": []
                            },
                            {
                                "id": "k8s-cfg-svc-type",
                                "title": "Service Type",
                                "icon": "ğŸŒ",
                                "selector": ".k8s-field-svctype",
                                "content": "Controls who can reach this service â€” the network boundary decision.<div class=\"assistant-state-card state-info\" style=\"margin-top:0.4rem\"><div class=\"state-detail\" class=\"state-wrap\"><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.25rem 0.5rem;font-size:0.75rem\"><span style=\"font-weight:600;color:var(--success)\">ğŸŒ ClusterIP</span><span>Internal only. Other pods reach it via DNS. For external access, use Ingress. <em>The default â€” most secure, most common.</em></span><span style=\"font-weight:600;color:var(--info)\">ğŸ”Œ NodePort</span><span>Exposed on every node's IP at a static port (30000-32767). No cloud LB needed. <em>Bare-metal clusters, local dev.</em></span><span style=\"font-weight:600;color:var(--warning)\">â˜ï¸ LoadBalancer</span><span>Provisions a cloud load balancer (ELB, NLB). Each one costs ~$18/month. <em>Use sparingly â€” prefer Ingress + ClusterIP.</em></span></div></div></div>",
                                "variants": [
                                    {
                                        "when": {
                                            "resolver": "k8sFieldValue",
                                            "equals": "ClusterIP"
                                        },
                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸŒ ClusterIP</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">The default and most secure option. Traffic stays inside the cluster.</div><div class=\"state-grid\"><span class=\"state-key\">DNS</span><span><code>svc-name.namespace.svc.cluster.local</code></span><span class=\"state-key\">External access</span><span>via Ingress, Gateway API, or port-forward for debugging</span><span class=\"state-key\">Cost</span><span>no cloud resources provisioned</span></div></div></div>"
                                    },
                                    {
                                        "when": {
                                            "resolver": "k8sFieldValue",
                                            "equals": "NodePort"
                                        },
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸŒ NodePort</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">NodePort allocates a port on every node (30000-32767). Access via <code>node-ip:port</code>.</div><div class=\"state-grid\"><span class=\"state-key\">Access</span><span><code>any-node-ip:30000+</code></span><span class=\"state-key\">Firewall</span><span>requires opening the NodePort range on all nodes</span><span class=\"state-key\">No HA</span><span>if the node dies, that IP is gone â€” no automatic failover</span></div><div class=\"state-text-spaced\">For production, prefer LoadBalancer or Ingress + ClusterIP.</div></div></div>"
                                    },
                                    {
                                        "when": {
                                            "resolver": "k8sFieldValue",
                                            "equals": "LoadBalancer"
                                        },
                                        "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">ğŸŒ LoadBalancer</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Each LoadBalancer service provisions a cloud resource:</div><div class=\"state-grid\"><span class=\"state-key\">AWS</span><span>ELB/NLB â€” ~$18/month per LB</span><span class=\"state-key\">GCP</span><span>Network LB â€” ~$18/month per rule</span><span class=\"state-key\">Azure</span><span>Standard LB â€” ~$18/month + rules</span></div><div class=\"state-text-spaced\">5 services Ã— $18 = $90/month just for load balancers. An Ingress Controller (nginx, traefik) behind a single LoadBalancer routes all services via path/host rules.</div></div></div>"
                                    }
                                ],
                                "children": []
                            },
                            {
                                "id": "k8s-cfg-svc-strategy",
                                "title": "Update Strategy",
                                "icon": "ğŸ”„",
                                "selector": ".k8s-field-strategy",
                                "content": "How K8s replaces old pods with new ones during a deploy.<div class=\"assistant-state-card state-info\" style=\"margin-top:0.4rem\"><div class=\"state-detail\" class=\"state-wrap\"><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.25rem 0.5rem;font-size:0.75rem\"><span style=\"font-weight:600;color:var(--success)\">ğŸ”„ RollingUpdate</span><span>New pods come up before old pods go down. Both versions run briefly in parallel. <em>Zero-downtime deploys â€” the default for most services.</em></span><span style=\"font-weight:600;color:var(--warning)\">âš ï¸ Recreate</span><span>All old pods are killed before new ones start. Causes downtime but guarantees only one version runs at a time. <em>Schema migrations, singleton processes, ReadWriteOnce PVCs.</em></span></div></div></div>",
                                "variants": [
                                    {
                                        "when": {
                                            "resolver": "k8sFieldValue",
                                            "equals": "RollingUpdate"
                                        },
                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ”„ RollingUpdate</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Pods are replaced incrementally. At any point during the rollout, both old and new versions may be running simultaneously.</div><div class=\"state-grid\"><span class=\"state-key\">Max Surge</span><span>how many extra pods can exist above the desired count during rollout</span><span class=\"state-key\">Max Unavailable</span><span>how many pods can be down during rollout</span><span class=\"state-key\">Readiness Probe</span><span>new pods must pass readiness before old pods are terminated</span></div><div class=\"state-text-spaced\">If your app can't handle two versions running at once (schema migrations, breaking API changes), use Recreate instead.</div></div></div>"
                                    },
                                    {
                                        "when": {
                                            "resolver": "k8sFieldValue",
                                            "equals": "Recreate"
                                        },
                                        "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš ï¸ Recreate</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">All existing pods are terminated before new ones are created. The service is unavailable during the gap.</div><div class=\"state-grid\"><span class=\"state-key\">Downtime</span><span>depends on pod startup time â€” could be seconds to minutes</span><span class=\"state-key\">Use when</span><span>ReadWriteOnce PVCs (can't mount on two nodes), breaking schema changes, singleton processes</span><span class=\"state-key\">Max Surge / Unavail</span><span>hidden â€” not applicable with Recreate</span></div></div></div>"
                                    }
                                ],
                                "children": []
                            },
                            {
                                "id": "k8s-cfg-svc-maxsurge",
                                "title": "Max Surge",
                                "icon": "ğŸ“ˆ",
                                "selector": ".k8s-field-maxsurge",
                                "content": "Extra pods during rollout â€” speed vs resource cost. Combined with Max Unavailable, controls how aggressive the rollout is.",
                                "variants": [
                                    {
                                        "when": {
                                            "resolver": "k8sFieldValue",
                                            "equals": "1"
                                        },
                                        "content": "Max Surge 1 â€” one extra pod at a time. Conservative â€” uses minimal extra resources but rollouts are slower with many replicas.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“ˆ +1 pod</div><div class=\"state-detail\">During rollout, K8s creates 1 extra pod (replicas + 1 total). Once the new pod passes readiness, an old pod is terminated. Then the next new pod starts.\n\nWith 3 replicas: 4 pods exist briefly during each step. If your cluster is tight on resources, this is the safest choice.</div></div>"
                                    },
                                    {
                                        "when": {
                                            "resolver": "k8sFieldValue",
                                            "contains": "%"
                                        },
                                        "content": "Percentage-based surge â€” scales with replica count. 25% of 4 replicas = 1 extra pod. 25% of 12 replicas = 3 extra pods.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“ˆ Percentage surge</div><div class=\"state-detail\">K8s rounds up: 25% of 3 replicas = ceil(0.75) = 1 extra pod.\n\nPercentage-based surge scales better than fixed numbers for services with many replicas or HPA-managed scaling.</div></div>"
                                    },
                                    {
                                        "when": {
                                            "resolver": "k8sFieldValue",
                                            "not": ""
                                        },
                                        "content": "Extra pods created above the desired count during rollout. Higher values = faster rollouts but more resource consumption during the transition.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“ˆ Max Surge</div><div class=\"state-detail\">Accepts an integer (e.g. 2) or a percentage (e.g. 25%).\n\nâ€¢ <strong>Integer</strong> â€” fixed number of extra pods regardless of replica count\nâ€¢ <strong>Percentage</strong> â€” scales with replicas, rounded up\n\nCombined with Max Unavailable, this controls how aggressively K8s rolls out changes. Both cannot be 0 at the same time.</div></div>"
                                    }
                                ],
                                "children": []
                            },
                            {
                                "id": "k8s-cfg-svc-maxunavail",
                                "title": "Max Unavailable",
                                "icon": "ğŸ“‰",
                                "selector": ".k8s-field-maxunavail",
                                "content": "Pods allowed to be down during rollout â€” availability vs speed. Both this and Max Surge can't be zero at the same time.",
                                "variants": [
                                    {
                                        "when": {
                                            "resolver": "k8sFieldValue",
                                            "equals": "0"
                                        },
                                        "content": "Max Unavailable 0 â€” no pod goes down until a new pod is ready. Maximum availability but requires Max Surge > 0 (both can't be zero).",
                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ“‰ Zero downtime</div><div class=\"state-detail\">No existing pod is terminated until a new pod passes its readiness probe. This guarantees the desired replica count is always met during rollout.\n\nRequires Max Surge â‰¥ 1 â€” K8s needs room to create the new pod before it can retire the old one.\n\nBest for: production services where you can't afford any capacity loss.</div></div>"
                                    },
                                    {
                                        "when": {
                                            "resolver": "k8sFieldValue",
                                            "equals": "1"
                                        },
                                        "content": "Max Unavailable 1 â€” one pod can be down at a time. Balanced â€” maintains most capacity while allowing rollout progress.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“‰ -1 pod</div><div class=\"state-detail\">During rollout, K8s can terminate 1 old pod before a new one is ready. With 3 replicas, at least 2 are serving traffic at all times.\n\nCombined with Max Surge 1: at most 4 pods exist and at least 2 serve â€” the default K8s behavior.</div></div>"
                                    },
                                    {
                                        "when": {
                                            "resolver": "k8sFieldValue",
                                            "contains": "%"
                                        },
                                        "content": "Percentage-based unavailability â€” scales with replica count. 25% of 4 replicas = 1 pod can be down.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“‰ Percentage</div><div class=\"state-detail\">K8s rounds down: 25% of 3 replicas = floor(0.75) = 0 pods can be down (effectively zero-downtime).\n\nPercentage-based unavailability scales better for services managed by HPA where replica count changes dynamically.</div></div>"
                                    },
                                    {
                                        "when": {
                                            "resolver": "k8sFieldValue",
                                            "not": ""
                                        },
                                        "content": "Pods that can be unavailable during rollout. Higher values = faster rollouts but reduced capacity during the transition."
                                    }
                                ],
                                "children": []
                            },
                            {
                                "id": "k8s-cfg-svc-kind",
                                "title": "Workload Kind",
                                "icon": "ğŸ“‹",
                                "selector": ".k8s-field-kind",
                                "content": "The most consequential choice per service â€” everything below changes based on this.<div class=\"assistant-state-card state-info\" style=\"margin-top:0.4rem\"><div class=\"state-detail\" class=\"state-wrap\"><div style=\"display:grid;grid-template-columns:auto 1fr;gap:0.25rem 0.5rem;font-size:0.75rem\"><span style=\"font-weight:600;color:var(--success)\">ğŸš€ Deployment</span><span>Stateless. Pods are interchangeable, support rolling updates and autoscaling. <em>Web servers, APIs, workers.</em></span><span style=\"font-weight:600;color:var(--info)\">ğŸ—„ï¸ StatefulSet</span><span>Stable identity. Each pod gets a sticky name (app-0, app-1), its own PVC, and ordered startup. <em>Databases, caches with persistence.</em></span><span style=\"font-weight:600;color:var(--info)\">ğŸŒ DaemonSet</span><span>One pod per node. No replica count. Auto-scales with cluster size. <em>Log collectors, monitoring agents, network plugins.</em></span><span style=\"font-weight:600;color:var(--info)\">âš¡ Job</span><span>Runs to completion, then stops. <em>Migrations, imports, batch processing.</em></span><span style=\"font-weight:600;color:var(--info)\">â° CronJob</span><span>Scheduled Job on a cron pattern. <em>Backups, reports, periodic cleanup.</em></span><span style=\"font-weight:600;color:var(--warning)\">â­ï¸ Skip</span><span>No K8s resource generated for this service.</span></div></div></div>",
                                "variants": [
                                    {
                                        "when": {
                                            "resolver": "k8sFieldValue",
                                            "equals": "Deployment"
                                        },
                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸš€ Deployment selected</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Best for: APIs, web servers, workers, microservices â€” anything that doesn't write to local disk.</div><div class=\"state-grid\"><span class=\"state-key\">Replicas</span><span>horizontal scaling â€” more pods, more throughput</span><span class=\"state-key\">Rolling Update</span><span>zero-downtime deploys â€” new pods before old pods die</span><span class=\"state-key\">HPA</span><span>auto-scale on CPU, memory, or custom metrics</span><span class=\"state-key\">Probes</span><span>readiness + liveness keep traffic away from unhealthy pods</span></div></div></div>"
                                    },
                                    {
                                        "when": {
                                            "resolver": "k8sFieldValue",
                                            "equals": "StatefulSet"
                                        },
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ—„ï¸ StatefulSet selected</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Each pod gets a stable hostname and its own PVC. A Headless Service enables DNS-based discovery.</div><div class=\"state-grid\"><span class=\"state-key\">Identity</span><span>pod-0, pod-1, pod-2 â€” survives restarts and rescheduling</span><span class=\"state-key\">Storage</span><span>volumeClaimTemplates create a PVC per pod</span><span class=\"state-key\">Ordering</span><span>OrderedReady = sequential start/stop; Parallel = all at once</span><span class=\"state-key\">Headless DNS</span><span><code>pod-0.svc-headless.namespace</code></span></div></div></div>"
                                    },
                                    {
                                        "when": {
                                            "resolver": "k8sFieldValue",
                                            "equals": "DaemonSet"
                                        },
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸŒ DaemonSet selected</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Replicas, HPA, and scaling options are hidden â€” pod count equals node count.</div><div class=\"state-grid\"><span class=\"state-key\">Node Selector</span><span>restrict to specific nodes by label</span><span class=\"state-key\">Tolerations</span><span>run on tainted nodes (control-plane, NoSchedule)</span><span class=\"state-key\">Host Access</span><span>share the node's network, PID, or IPC namespace</span></div><div class=\"state-text-spaced\">Typical uses: Fluentd, Datadog agent, Cilium, node-problem-detector.</div></div></div>"
                                    },
                                    {
                                        "when": {
                                            "resolver": "k8sFieldValue",
                                            "equals": "Job"
                                        },
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">âš¡ Job selected</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">A Job creates one or more pods that run a command and exit. No K8s Service is created.</div><div class=\"state-grid\"><span class=\"state-key\">Completions</span><span>how many successful pod runs are needed</span><span class=\"state-key\">Parallelism</span><span>how many pods run at once</span><span class=\"state-key\">Backoff Limit</span><span>retries before marking the Job as failed</span><span class=\"state-key\">TTL</span><span>seconds before finished Job is auto-deleted</span></div></div></div>"
                                    },
                                    {
                                        "when": {
                                            "resolver": "k8sFieldValue",
                                            "equals": "CronJob"
                                        },
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â° CronJob selected</div><div class=\"state-detail\" class=\"state-wrap\"><div class=\"state-text\">Wraps a Job spec in a cron schedule. Kubernetes creates a new Job each time.</div><div class=\"state-grid\"><span class=\"state-key\">Schedule</span><span>standard cron: <code>*/5 * * * *</code> = every 5 minutes</span><span class=\"state-key\">Forbid</span><span>skip this run if the previous one is still going</span><span class=\"state-key\">Replace</span><span>kill the running job and start a new one</span><span class=\"state-key\">Deadline</span><span>skip the run if it can't start within N seconds</span></div></div></div>"
                                    },
                                    {
                                        "when": {
                                            "resolver": "k8sFieldValue",
                                            "equals": "Skip"
                                        },
                                        "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">â­ï¸ Skipped</div><div class=\"state-detail\">This service won't produce any manifest. If another service has a dependency on it (depends_on, env vars pointing to it), that reference will be orphaned.\n\nUse Skip for services you'll handle outside K8s â€” managed databases, external APIs, or services already running elsewhere.</div></div>"
                                    }
                                ],
                                "children": []
                            },
                            {
                                "id": "k8s-cfg-job",
                                "title": "Job Configuration",
                                "icon": "âš¡",
                                "selector": ".k8s-field-job-cfg",
                                "content": "Jobs are <strong>fire-and-forget</strong> â€” the container runs, does its work, and exits.<div class=\"assistant-state-card state-info\" style=\"margin-top:0.4rem\"><div class=\"state-detail\">No Service, no replicas, no probes. The settings below control what happens when things go wrong (retries, timeouts) and how many units of work to process.</div></div>",
                                "children": [
                                    {
                                        "id": "k8s-cfg-job-cmd",
                                        "title": "Command",
                                        "icon": "âŒ¨ï¸",
                                        "selector": ".k8s-field-job-cmd",
                                        "content": "This overrides the container's <strong>ENTRYPOINT</strong>. If your image already has a proper entrypoint, leave this empty and use Args instead.<div class=\"assistant-state-card state-info\" style=\"margin-top:0.4rem\"><div class=\"state-detail\">For shell commands, use <code>/bin/sh -c \"your-command\"</code> â€” otherwise Kubernetes passes each word as a separate exec argument, which breaks pipes and redirects.</div></div>",
                                        "children": []
                                    },
                                    {
                                        "id": "k8s-cfg-job-args",
                                        "title": "Arguments",
                                        "icon": "ğŸ“",
                                        "selector": ".k8s-field-job-args",
                                        "content": "Passed to the Command â€” or to the container's default entrypoint if Command is empty.<div class=\"assistant-state-card state-info\" style=\"margin-top:0.4rem\"><div class=\"state-detail\">Space-separated. If your command is <code>/bin/sh -c</code>, your actual script goes here as a single quoted argument.</div></div>",
                                        "children": []
                                    },
                                    {
                                        "id": "k8s-cfg-job-restart",
                                        "title": "Restart Policy",
                                        "icon": "ğŸ”„",
                                        "selector": ".k8s-field-job-restart",
                                        "content": "Controls how Kubernetes handles container failures.<div class=\"assistant-state-card state-info\" style=\"margin-top:0.4rem\"><div class=\"state-detail\"><strong>Never</strong> â€” each failure creates a brand-new pod (clean slate).<br><strong>OnFailure</strong> â€” retries in the same pod (preserves local state).</div></div><span class=\"assistant-tip\">Choose based on whether your task can resume from partial progress.</span>",
                                        "variants": [
                                            {
                                                "when": {
                                                    "resolver": "k8sFieldValue",
                                                    "equals": "Never"
                                                },
                                                "content": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ”„ Never â€” fresh pod each attempt</div><div class=\"state-detail\">Each failure spawns a brand-new pod. Old pod stays around (for logs) until the Job is cleaned up. This means each retry gets a clean filesystem, potentially a different node, and a new set of volume mounts. Good for idempotent tasks where leftover state could cause problems.</div></div>The Backoff Limit controls how many new pods Kubernetes will create before giving up."
                                            },
                                            {
                                                "when": {
                                                    "resolver": "k8sFieldValue",
                                                    "equals": "OnFailure"
                                                },
                                                "content": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">ğŸ”„ OnFailure â€” retry in the same pod</div><div class=\"state-detail\">The container restarts inside the same pod â€” same node, same volumes, same emptyDir contents. Useful when your task writes partial progress to disk and can resume. But be careful: if the failure is caused by a bad node or resource starvation, retrying in the same place won't help.</div></div>Combined with Backoff Limit, this controls how many in-place retries happen before the Job fails."
                                            }
                                        ],
                                        "children": []
                                    },
                                    {
                                        "id": "k8s-cfg-job-backoff",
                                        "title": "Backoff Limit",
                                        "icon": "ğŸ”",
                                        "selector": ".k8s-field-job-backoff",
                                        "content": "Total retries before Kubernetes marks the Job as <strong>Failed</strong>.<div class=\"assistant-state-card state-info\" style=\"margin-top:0.4rem\"><div class=\"state-detail\">Each retry uses exponential backoff (<code>10s â†’ 20s â†’ 40sâ€¦</code>). Set to <code>0</code> for no retries â€” succeed or fail on the first attempt.</div></div><span class=\"assistant-tip\">Combined with Restart Policy, this is your safety net against infinite retry loops.</span>",
                                        "children": []
                                    },
                                    {
                                        "id": "k8s-cfg-job-completions",
                                        "title": "Completions",
                                        "icon": "âœ…",
                                        "selector": ".k8s-field-job-completions",
                                        "content": "How many successful pod runs before the Job is <strong>done</strong>.<div class=\"assistant-state-card state-info\" style=\"margin-top:0.4rem\"><div class=\"state-detail\"><code>1</code> = simple run-once task.<br>Higher = work-queue pattern where each pod processes one item.</div></div><span class=\"assistant-tip\">Works hand-in-hand with Parallelism to control throughput.</span>",
                                        "children": []
                                    },
                                    {
                                        "id": "k8s-cfg-job-parallelism",
                                        "title": "Parallelism",
                                        "icon": "âš¡",
                                        "selector": ".k8s-field-job-parallelism",
                                        "content": "How many pods run <strong>simultaneously</strong>.<div class=\"assistant-state-card state-info\" style=\"margin-top:0.4rem\"><div class=\"state-detail\">Example: <code>Completions=10</code> + <code>Parallelism=3</code> â†’ 3 pods at a time until all 10 are done.</div></div><span class=\"assistant-tip\">Setting this higher than Completions has no effect â€” can't have more workers than work items.</span>",
                                        "children": []
                                    },
                                    {
                                        "id": "k8s-cfg-job-timeout",
                                        "title": "Timeout",
                                        "icon": "â±ï¸",
                                        "selector": ".k8s-field-job-timeout",
                                        "content": "The hard ceiling on total Job duration (<code>activeDeadlineSeconds</code>).<div class=\"assistant-state-card state-warning\" style=\"margin-top:0.4rem\"><div class=\"state-detail\">If the Job is still running after this many seconds â€” including all retries â€” Kubernetes <strong>kills it</strong>. Protects against stuck processes that never exit.</div></div><span class=\"assistant-tip\">Set generously: if your Job normally takes 5 min, use 600s to give it breathing room.</span>",
                                        "children": []
                                    },
                                    {
                                        "id": "k8s-cfg-job-ttl",
                                        "title": "TTL After Finished",
                                        "icon": "ğŸ§¹",
                                        "selector": ".k8s-field-job-ttl",
                                        "content": "Auto-cleanup timer â€” Kubernetes deletes the Job and its pods after this many seconds.<div class=\"assistant-state-card state-info\" style=\"margin-top:0.4rem\"><div class=\"state-detail\"><code>0</code> = immediate cleanup (no debug window).<br><code>3600</code> = keep logs for 1 hour.</div></div><span class=\"assistant-tip\">Without this, completed Jobs pile up forever in your namespace.</span>",
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "id": "k8s-cfg-cron",
                                "title": "CronJob Schedule",
                                "icon": "â°",
                                "selector": ".k8s-field-cron-cfg",
                                "content": "A CronJob wraps a Job in a <strong>schedule</strong> â€” Kubernetes creates a fresh Job each time it fires.<div class=\"assistant-state-card state-info\" style=\"margin-top:0.4rem\"><div class=\"state-detail\">The Job Configuration above controls <em>what</em> runs. The settings here control <em>when</em> and <em>how often</em>.</div></div>",
                                "children": [
                                    {
                                        "id": "k8s-cfg-cron-schedule",
                                        "title": "Schedule",
                                        "icon": "ğŸ“…",
                                        "selector": ".k8s-field-cron-schedule",
                                        "content": "Standard cron format: <code>minute hour day month weekday</code><div class=\"assistant-state-card state-info\" style=\"margin-top:0.4rem\"><div class=\"state-detail\" style=\"display:grid;grid-template-columns:auto 1fr;gap:0.2rem 0.5rem;font-size:0.75rem\"><code>*/5 * * * *</code><span>every 5 minutes</span><code>0 */6 * * *</code><span>every 6 hours</span><code>0 2 * * *</code><span>daily at 2 AM</span><code>0 0 * * 0</code><span>weekly on Sunday</span></div></div><span class=\"assistant-tip\">Timezone is the cluster's â€” for a specific TZ, handle it in your Job logic.</span>",
                                        "children": []
                                    },
                                    {
                                        "id": "k8s-cfg-cron-concurrency",
                                        "title": "Concurrency",
                                        "icon": "ğŸ”€",
                                        "selector": ".k8s-field-cron-concurrency",
                                        "content": "What happens when a new schedule fires while the previous Job is <strong>still running</strong>.<div class=\"assistant-state-card state-info\" style=\"margin-top:0.4rem\"><div class=\"state-detail\"><strong>Forbid</strong> â€” skip the new run (safest).<br><strong>Replace</strong> â€” kill old, start new.<br><strong>Allow</strong> â€” both run simultaneously.</div></div><span class=\"assistant-tip\">Most workloads want Forbid to avoid data corruption.</span>",
                                        "variants": [
                                            {
                                                "when": {
                                                    "resolver": "k8sFieldValue",
                                                    "equals": "Forbid"
                                                },
                                                "content": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ”€ Forbid â€” skip if still running</div><div class=\"state-detail\">If the previous Job is still running when the cron fires, this run is simply skipped. No overlap, no race conditions. The safest choice for database backups, report generation, or anything that touches shared state.</div></div>If your Job regularly overruns its schedule, you'll see missed runs. Consider increasing the schedule interval or optimizing the Job."
                                            },
                                            {
                                                "when": {
                                                    "resolver": "k8sFieldValue",
                                                    "equals": "Replace"
                                                },
                                                "content": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">ğŸ”€ Replace â€” kill and restart</div><div class=\"state-detail\">The currently running Job is terminated and a new one starts. Data from the killed Job is lost. Use this when freshness matters more than completion â€” e.g., a cache warmer or status check where old results are irrelevant.</div></div>Be careful with Jobs that write to databases or external systems â€” partial writes from the killed Job won't be rolled back."
                                            },
                                            {
                                                "when": {
                                                    "resolver": "k8sFieldValue",
                                                    "equals": "Allow"
                                                },
                                                "content": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš ï¸ Allow â€” overlap permitted</div><div class=\"state-detail\">Multiple Job instances can run simultaneously. If your Job takes longer than the schedule interval, you'll get pileups. This is only safe for purely idempotent, stateless tasks that don't compete for resources.</div></div>Watch out: if 50 schedules fire while the cluster is down and you have no Starting Deadline set, Kubernetes will launch all 50 at once."
                                            }
                                        ],
                                        "children": []
                                    },
                                    {
                                        "id": "k8s-cfg-cron-history",
                                        "title": "History Limits",
                                        "icon": "ğŸ“š",
                                        "selector": ".k8s-field-cron-history",
                                        "content": "How many completed Job objects to keep around â€” successful and failed counts are <strong>separate</strong>.<div class=\"assistant-state-card state-info\" style=\"margin-top:0.4rem\"><div class=\"state-detail\">Keeping a few of each helps with debugging â€” you can check logs from the last failed run. Set too high and you'll accumulate thousands of Job resources.</div></div><span class=\"assistant-tip\">The TTL on the Job handles pod cleanup; this handles the Job <em>resource</em> itself.</span>",
                                        "children": []
                                    },
                                    {
                                        "id": "k8s-cfg-cron-deadline",
                                        "title": "Starting Deadline",
                                        "icon": "â°",
                                        "selector": ".k8s-field-cron-deadline",
                                        "content": "If the Job can't start within this window, <strong>skip it</strong> instead of running late.<div class=\"assistant-state-card state-warning\" style=\"margin-top:0.4rem\"><div class=\"state-detail\">Without a deadline, Kubernetes counts missed schedules and can fire <strong>100+ Jobs at once</strong> when the cluster comes back online.</div></div><span class=\"assistant-tip\">If a backup missed its 2 AM window by 5 min, <code>300s</code> is a good cutoff.</span>",
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "id": "k8s-cfg-ds",
                                "title": "DaemonSet Configuration",
                                "icon": "ğŸŒ",
                                "selector": ".k8s-field-ds-cfg",
                                "content": "DaemonSets run <strong>one pod per node</strong> â€” you don't set a replica count.<div class=\"assistant-state-card state-info\" style=\"margin-top:0.4rem\"><div class=\"state-detail\">As nodes join or leave the cluster, pods are added or removed automatically. The settings below control how updates roll out and which nodes are eligible.</div></div>",
                                "children": [
                                    {
                                        "id": "k8s-cfg-ds-strategy",
                                        "title": "Update Strategy",
                                        "icon": "ğŸ”„",
                                        "selector": ".k8s-field-ds-strategy",
                                        "content": "How pods are replaced when you update the DaemonSet spec.<div class=\"assistant-state-card state-info\" style=\"margin-top:0.4rem\"><div class=\"state-detail\"><strong>RollingUpdate</strong> â€” replaces pods node-by-node. Max Unavailable controls the pace.<br><strong>OnDelete</strong> â€” nothing updates until you manually delete each pod.</div></div><span class=\"assistant-tip\">Select a strategy to see detailed guidance.</span>",
                                        "variants": [
                                            {
                                                "when": {
                                                    "resolver": "k8sFieldValue",
                                                    "contains": "Rolling"
                                                },
                                                "content": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ”„ RollingUpdate â€” automatic node-by-node</div><div class=\"state-detail\">Kubernetes replaces the old pod with the new one on each node, one at a time. Max Unavailable sets how many nodes can be without the DaemonSet pod simultaneously during the rollout.</div></div>Set Max Unavailable to 1 for safest rollouts. On large clusters (100+ nodes), increase it to avoid hour-long rollouts. You can use a percentage too (e.g. \"25%\")."
                                            },
                                            {
                                                "when": {
                                                    "resolver": "k8sFieldValue",
                                                    "equals": "OnDelete"
                                                },
                                                "content": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">ğŸ”„ OnDelete â€” manual pod-by-pod control</div><div class=\"state-detail\">Nothing updates automatically. The old pod runs until you explicitly <code>kubectl delete pod</code> it â€” then Kubernetes creates a new one with the updated spec. This gives you full control over which nodes get updated and when.</div></div>Use this for critical infrastructure DaemonSets (CNI, storage drivers) where you want to update one node at a time and verify before moving on."
                                            }
                                        ],
                                        "children": []
                                    },
                                    {
                                        "id": "k8s-cfg-ds-nodeselector",
                                        "title": "Node Selector",
                                        "icon": "ğŸ¯",
                                        "selector": ".k8s-field-ds-nodeselector",
                                        "content": "Restricts which nodes get a DaemonSet pod â€” without a selector, <strong>every node</strong> runs one.<div class=\"assistant-state-card state-info\" style=\"margin-top:0.4rem\"><div class=\"state-detail\">Use label pairs like <code>role=worker</code> or <code>disk=ssd</code> to target specific node groups. Label nodes with:<br><code>kubectl label node &lt;name&gt; key=value</code></div></div><span class=\"assistant-tip\">Run GPU monitoring only on GPU nodes, or Fluentd only on workers.</span>",
                                        "children": []
                                    },
                                    {
                                        "id": "k8s-cfg-ds-tolerations",
                                        "title": "Tolerations",
                                        "icon": "ğŸ”“",
                                        "selector": ".k8s-field-ds-tolerations",
                                        "content": "Nodes can have <strong>taints</strong> that repel pods â€” control-plane nodes are tainted by default.<div class=\"assistant-state-card state-info\" style=\"margin-top:0.4rem\"><div class=\"state-detail\">Checking these boxes adds tolerations that let your DaemonSet ignore those taints and run on those nodes anyway.</div></div><span class=\"assistant-tip\">Monitoring agents (Datadog, node-exporter) almost always want both â€” they need to observe every node.</span>",
                                        "variants": [
                                            {
                                                "when": {
                                                    "hasSelector": "input:checked"
                                                },
                                                "content": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ”“ Tolerations active</div><div class=\"state-detail\">Your DaemonSet will be allowed onto tainted nodes matching these tolerations. For monitoring agents, this is exactly what you want â€” they need to observe every node including control-plane.</div></div>If you're running a regular application (not infrastructure), think twice about tolerating control-plane taints. Those nodes are meant to be reserved for cluster management."
                                            }
                                        ],
                                        "children": []
                                    },
                                    {
                                        "id": "k8s-cfg-ds-hostaccess",
                                        "title": "Host Access",
                                        "icon": "ğŸ”Œ",
                                        "selector": ".k8s-field-ds-hostaccess",
                                        "content": "These break the pod's <strong>isolation boundary</strong> â€” sharing the node's actual namespaces.<div class=\"assistant-state-card state-warning\" style=\"margin-top:0.4rem\"><div class=\"state-detail\"><strong>Host Network</strong> â€” pod uses the node's IP directly.<br><strong>Host PID</strong> â€” pod sees all processes on the node.<br><strong>Host IPC</strong> â€” pod shares inter-process communication.</div></div><span class=\"assistant-tip\">Only for CNI plugins, node monitoring, or log collectors. This is a security-sensitive decision.</span>",
                                        "variants": [
                                            {
                                                "when": {
                                                    "hasSelector": "input:checked"
                                                },
                                                "content": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš ï¸ Host namespace sharing enabled</div><div class=\"state-detail\">This pod will break out of its container isolation. It can see the host's network interfaces, processes, or IPC resources depending on which options are checked. This is a significant security surface â€” make sure this is an infrastructure component (CNI, monitoring, logging) and not a regular application.</div></div>Pod Security Admission (PSA) in <code>restricted</code> mode will block pods with host access. You may need <code>privileged</code> or <code>baseline</code> namespace labels."
                                            }
                                        ],
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "id": "k8s-cfg-ss",
                                "title": "StatefulSet Configuration",
                                "icon": "ğŸ—„ï¸",
                                "selector": ".k8s-field-ss-cfg",
                                "content": "This is where StatefulSets diverge from Deployments â€” every setting here exists because <strong>pods have identity</strong>.<div class=\"assistant-state-card state-info\" style=\"margin-top:0.4rem\"><div class=\"state-detail\">The Headless Service is the foundation. Everything else builds on stable DNS names and persistent ordinals.</div></div>",
                                "children": [
                                    {
                                        "id": "k8s-cfg-ss-headless",
                                        "title": "Headless Service",
                                        "icon": "ğŸ”—",
                                        "selector": ".k8s-field-ss-headless",
                                        "content": "This isn't optional â€” Kubernetes <strong>requires</strong> a Headless Service for StatefulSets.<div class=\"assistant-state-card state-info\" style=\"margin-top:0.4rem\"><div class=\"state-detail\">Each pod gets a stable DNS name like:<br><code>pod-0.svc-headless.namespace</code><br>Without it, pods can't find each other â€” replication, leader election, and cluster formation all break.</div></div><span class=\"assistant-tip\">The name you choose here becomes part of every pod's FQDN.</span>",
                                        "children": []
                                    },
                                    {
                                        "id": "k8s-cfg-ss-podmgmt",
                                        "title": "Pod Management",
                                        "icon": "ğŸ“Š",
                                        "selector": ".k8s-field-ss-podmgmt",
                                        "content": "Controls the <strong>startup and shutdown order</strong> of pods.<div class=\"assistant-state-card state-info\" style=\"margin-top:0.4rem\"><div class=\"state-detail\"><strong>OrderedReady</strong> â€” pod-0 before pod-1 before pod-2 (sequential).<br><strong>Parallel</strong> â€” all pods at once (faster, less safe).</div></div><span class=\"assistant-tip\">Select a policy to see when each is the right choice.</span>",
                                        "variants": [
                                            {
                                                "when": {
                                                    "resolver": "k8sFieldValue",
                                                    "equals": "OrderedReady"
                                                },
                                                "content": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“Š OrderedReady â€” sequential startup</div><div class=\"state-detail\">Pod-0 must be Running and Ready before pod-1 is created, pod-1 before pod-2, and so on. Shutdown happens in reverse. This guarantees the leader/primary is always the first up and last down.</div></div>This is the right choice for PostgreSQL, MySQL, etcd, ZooKeeper, or any system where one node must initialize before others can join. Slower to scale, but safe."
                                            },
                                            {
                                                "when": {
                                                    "resolver": "k8sFieldValue",
                                                    "equals": "Parallel"
                                                },
                                                "content": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">ğŸ“Š Parallel â€” all pods at once</div><div class=\"state-detail\">All pods launch simultaneously, no ordering guarantees. Faster scaling, but your application must handle its own coordination â€” if pod-2 starts before pod-0, it needs to be able to wait or self-configure.</div></div>Use this for stateful apps that handle peer discovery dynamically (like Cassandra with seed nodes configured externally, or Redis Cluster with manual join). Most databases want OrderedReady instead."
                                            }
                                        ],
                                        "children": []
                                    },
                                    {
                                        "id": "k8s-cfg-ss-clusterip",
                                        "title": "ClusterIP Service",
                                        "icon": "ğŸŒ",
                                        "selector": ".k8s-field-ss-clusterip",
                                        "content": "The Headless Service gives per-pod DNS â€” but clients may not care <em>which</em> pod they reach.<div class=\"assistant-state-card state-info\" style=\"margin-top:0.4rem\"><div class=\"state-detail\">Checking this adds a regular ClusterIP Service that <strong>load-balances</strong> across all pods, giving clients a single stable endpoint.</div></div><span class=\"assistant-tip\">Check the box to see how the dual-service pattern works.</span>",
                                        "variants": [
                                            {
                                                "when": {
                                                    "hasSelector": "input:checked"
                                                },
                                                "content": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸŒ ClusterIP Service will be created</div><div class=\"state-detail\">You'll get two Services: the Headless Service (for per-pod DNS) and a regular ClusterIP Service (for load-balanced access). Clients that don't care about specific replicas can use the ClusterIP endpoint.</div></div>This is common for web frontends backed by a StatefulSet â€” the frontend connects to the ClusterIP, while the StatefulSet pods use the Headless DNS for internal replication."
                                            }
                                        ],
                                        "children": []
                                    },
                                    {
                                        "id": "k8s-cfg-ss-strategy",
                                        "title": "Update Strategy",
                                        "icon": "ğŸ”„",
                                        "selector": ".k8s-field-ss-strategy",
                                        "content": "How pod updates are rolled out across the StatefulSet.<div class=\"assistant-state-card state-info\" style=\"margin-top:0.4rem\"><div class=\"state-detail\"><strong>RollingUpdate</strong> â€” highest ordinal first (pod-2 â†’ pod-1 â†’ pod-0). Use with Partition for canary rollouts.<br><strong>OnDelete</strong> â€” nothing updates until you manually delete a pod.</div></div><span class=\"assistant-tip\">Select a strategy to see detailed guidance and how Partition interacts.</span>",
                                        "variants": [
                                            {
                                                "when": {
                                                    "resolver": "k8sFieldValue",
                                                    "contains": "Rolling"
                                                },
                                                "content": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ”„ RollingUpdate â€” ordinal-based rollout</div><div class=\"state-detail\">Updates roll from highest ordinal to lowest: pod-2 first, then pod-1, then pod-0 (the primary). Each pod must be Ready before the next one is updated. Use the Partition field below to control exactly how far the rollout goes.</div></div>This natural ordering means you always update replicas before the primary â€” the safest pattern for databases with leader/follower architectures."
                                            },
                                            {
                                                "when": {
                                                    "resolver": "k8sFieldValue",
                                                    "equals": "OnDelete"
                                                },
                                                "content": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">ğŸ”„ OnDelete â€” fully manual control</div><div class=\"state-detail\">No pod updates until you explicitly delete each one. When you delete pod-2, Kubernetes recreates it with the new spec. Pod-0 and pod-1 keep running the old version until you delete them too.</div></div>This is the safest strategy for production databases where you want to drain connections, take backups, and verify replication health before touching each replica. The Partition field has no effect in this mode."
                                            }
                                        ],
                                        "children": []
                                    },
                                    {
                                        "id": "k8s-cfg-ss-partition",
                                        "title": "Partition",
                                        "icon": "âœ‚ï¸",
                                        "selector": ".k8s-field-ss-partition",
                                        "content": "A <strong>safety fence</strong> for canary deployments.<div class=\"assistant-state-card state-info\" style=\"margin-top:0.4rem\"><div class=\"state-detail\">Set to <code>2</code> â†’ only pod-2, pod-3, etc. get the new version. Pod-0 and pod-1 stay on the old one.<br>Set to <code>0</code> â†’ update everything.</div></div><span class=\"assistant-tip\">Workflow: push update â†’ watch high-ordinal pods â†’ lower partition to 0 when confident.</span>",
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "id": "k8s-cfg-ss-storage",
                                "title": "Persistent Storage",
                                "icon": "ğŸ’¾",
                                "selector": ".k8s-field-ss-storage",
                                "content": "Each pod gets its own <strong>PersistentVolumeClaim</strong> that survives restarts, rescheduling, even deletion.<div class=\"assistant-state-card state-info\" style=\"margin-top:0.4rem\"><div class=\"state-detail\">PVC names follow the pattern:<br><code>name-podname-ordinal</code> (e.g. <code>data-myapp-0</code>)</div></div><div class=\"assistant-state-card state-warning\" style=\"margin-top:0.3rem\"><div class=\"state-detail\">Deleting the StatefulSet does <strong>NOT</strong> delete PVCs â€” clean them up manually with <code>kubectl delete pvc</code>.</div></div>",
                                "children": []
                            },
                            {
                                "id": "k8s-cfg-resources",
                                "title": "Resource Limits",
                                "icon": "ğŸ“Š",
                                "selector": ".k8s-field-resources",
                                "content": "Resources shape <strong>how much</strong> of the node your pod can use â€” and what happens when it tries to use more.<div class=\"assistant-state-card state-info\" style=\"margin-top:0.4rem\"><div class=\"state-detail\"><strong>Request</strong> = guaranteed minimum. The scheduler uses this to place pods on nodes with enough capacity.<br><strong>Limit</strong> = hard ceiling. CPU over-limit â†’ throttled. Memory over-limit â†’ <strong>OOM-killed</strong>.</div></div><span class=\"assistant-tip\">The combination of these four values determines your pod's QoS class â€” shown live below the grid.</span>",
                                "children": [
                                    {
                                        "id": "k8s-cfg-cpu-req",
                                        "title": "CPU Request",
                                        "icon": "âš™ï¸",
                                        "selector": ".k8s-field-cpu-req",
                                        "content": "The <strong>guaranteed minimum</strong> CPU for this container â€” the scheduler won't place the pod on a node that can't provide this.<div class=\"assistant-state-card state-info\" style=\"margin-top:0.4rem\"><div class=\"state-detail\"><code>100m</code> = 100 millicores = 10% of one CPU core.<br><code>1</code> = one full core.<br><code>500m</code> = half a core.</div></div><span class=\"assistant-tip\">Start low and increase based on actual usage â€” <code>kubectl top pods</code> shows real consumption.</span>",
                                        "variants": [
                                            {
                                                "when": {
                                                    "resolver": "k8sFieldValue",
                                                    "equals": ""
                                                },
                                                "content": "No CPU request â€” the scheduler treats this pod as needing <strong>zero CPU</strong> for placement.<div class=\"assistant-state-card state-warning\" style=\"margin-top:0.4rem\"><div class=\"state-detail\">Without a request, the pod can be placed on an already-saturated node. Under pressure, it's the first to get throttled because it \"asked for nothing.\"</div></div><span class=\"assistant-tip\">Even <code>50m</code> gives the scheduler something to work with.</span>"
                                            }
                                        ],
                                        "children": []
                                    },
                                    {
                                        "id": "k8s-cfg-cpu-lim",
                                        "title": "CPU Limit",
                                        "icon": "âš™ï¸",
                                        "selector": ".k8s-field-cpu-lim",
                                        "content": "The <strong>hard ceiling</strong> on CPU â€” if the container tries to exceed this, it gets <strong>throttled</strong> (not killed).<div class=\"assistant-state-card state-info\" style=\"margin-top:0.4rem\"><div class=\"state-detail\">CFS (Completely Fair Scheduler) enforces this via CPU quota. The container isn't killed â€” it just waits for its next time slice. Latency-sensitive services notice this as response time spikes.</div></div><span class=\"assistant-tip\">For Guaranteed QoS, set this equal to CPU Request.</span>",
                                        "variants": [
                                            {
                                                "when": {
                                                    "resolver": "k8sFieldValue",
                                                    "equals": ""
                                                },
                                                "content": "No CPU limit â€” the container can use <strong>all available CPU</strong> on the node.<div class=\"assistant-state-card state-info\" style=\"margin-top:0.4rem\"><div class=\"state-detail\">Some teams intentionally leave CPU unlimited and rely on requests for scheduling. This lets pods burst during traffic spikes without artificial throttling.</div></div><span class=\"assistant-tip\">Without a limit, QoS will be Burstable (at best) â€” never Guaranteed.</span>"
                                            }
                                        ],
                                        "children": []
                                    },
                                    {
                                        "id": "k8s-cfg-mem-req",
                                        "title": "Memory Request",
                                        "icon": "ğŸ§ ",
                                        "selector": ".k8s-field-mem-req",
                                        "content": "The <strong>guaranteed minimum</strong> memory â€” affects scheduling and the pod's OOM priority score.<div class=\"assistant-state-card state-info\" style=\"margin-top:0.4rem\"><div class=\"state-detail\"><code>128Mi</code> = 128 mebibytes.<br><code>1Gi</code> = 1 gibibyte.<br>The scheduler reserves this on the node â€” even if the container isn't using it yet.</div></div><span class=\"assistant-tip\">Under node memory pressure, pods using more than their request are killed first.</span>",
                                        "variants": [
                                            {
                                                "when": {
                                                    "resolver": "k8sFieldValue",
                                                    "equals": ""
                                                },
                                                "content": "No memory request â€” the pod's OOM score will be <strong>maximum</strong>, making it the first to die under pressure.<div class=\"assistant-state-card state-warning\" style=\"margin-top:0.4rem\"><div class=\"state-detail\">Without a memory request, the kubelet considers this pod expendable. When the node runs low on memory, this pod is killed before pods that declared their needs.</div></div><span class=\"assistant-tip\">Even a conservative value like <code>64Mi</code> signals intent to the scheduler.</span>"
                                            }
                                        ],
                                        "children": []
                                    },
                                    {
                                        "id": "k8s-cfg-mem-lim",
                                        "title": "Memory Limit",
                                        "icon": "ğŸ§ ",
                                        "selector": ".k8s-field-mem-lim",
                                        "content": "The <strong>hard ceiling</strong> on memory â€” if the container exceeds this, it gets <strong>OOM-killed</strong> instantly.<div class=\"assistant-state-card state-warning\" style=\"margin-top:0.4rem\"><div class=\"state-detail\">Unlike CPU throttling, memory over-limit is <strong>fatal</strong>. The container is terminated immediately with no graceful shutdown. The kubelet records an OOMKilled event and restarts the container per the restart policy.</div></div><span class=\"assistant-tip\">Set this at least 1.5â€“2Ã— your expected working set. Memory leaks hit this wall hard.</span>",
                                        "variants": [
                                            {
                                                "when": {
                                                    "resolver": "k8sFieldValue",
                                                    "equals": ""
                                                },
                                                "content": "No memory limit â€” the container can allocate <strong>unbounded memory</strong> until it exhausts the node.<div class=\"assistant-state-card state-warning\" style=\"margin-top:0.4rem\"><div class=\"state-detail\">A memory leak in this container can starve every other pod on the same node. The kubelet will eventually OOM-kill something â€” but it might not be this pod.</div></div><span class=\"assistant-tip\">Always set a memory limit. This is the single most important resource constraint.</span>"
                                            }
                                        ],
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "id": "k8s-cfg-envvars",
                                "title": "Environment Variables",
                                "icon": "ğŸ”",
                                "selector": ".k8s-field-envvars",
                                "content": "Each variable becomes either a <strong>ConfigMap</strong> entry or a <strong>Secret</strong> entry in your generated manifests.<div class=\"assistant-state-card state-info\" style=\"margin-top:0.4rem\"><div class=\"state-detail\"><strong>ğŸ“‹ Hardcoded</strong> â†’ value goes into a ConfigMap. Visible in source control and <code>kubectl get configmap -o yaml</code>.<br><strong>ğŸ”„ Variable</strong> â†’ substituted at deploy time from your vault's <code>.env</code> export. Value stays outside the manifest.<br><strong>ğŸ”’ Secret</strong> â†’ stored in a K8s Secret resource. Base64-encoded (not encrypted) â€” RBAC controls who can read it.</div></div><span class=\"assistant-tip\">Keys matching common secret patterns (PASSWORD, API_KEY, TOKEN) are auto-detected and set to ğŸ”’ Secret.</span>",
                                "children": []
                            },
                            {
                                "id": "k8s-cfg-probes",
                                "title": "Health Checks",
                                "icon": "ğŸ©º",
                                "selector": ".k8s-field-probes",
                                "content": "Probes tell Kubernetes whether your container is <strong>alive</strong> and <strong>ready for traffic</strong> â€” without them, K8s is flying blind.<div class=\"assistant-state-card state-info\" style=\"margin-top:0.4rem\"><div class=\"state-detail\"><strong>Readiness</strong> â€” gates traffic. A failing readiness probe removes the pod from the Service endpoints. No traffic reaches it until it passes again.<br><strong>Liveness</strong> â€” triggers restarts. A failing liveness probe tells the kubelet the container is stuck. It restarts it per the restart policy.</div></div><span class=\"assistant-tip\">Both probes are independent. A pod can be alive but not ready (warming up), or ready but about to die (memory leak). Configure them separately.</span>",
                                "children": [
                                    {
                                        "id": "k8s-cfg-probe-readiness",
                                        "title": "Readiness Probe",
                                        "icon": "âœ…",
                                        "selector": "[id^=k8s-svc-rdy-]",
                                        "content": "Controls whether this pod receives <strong>traffic from the Service</strong>. Fails = pod removed from endpoints.",
                                        "variants": [
                                            {
                                                "when": {
                                                    "resolver": "k8sFieldValue",
                                                    "equals": "http"
                                                },
                                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸŒ HTTP GET selected</div><div class=\"state-detail\">Kubernetes sends a GET request to the <strong>Path</strong> on the specified <strong>Port</strong> every <strong>Period</strong> seconds. A 200â€“399 response is a pass â€” anything else is a failure.<br><br>Best for web servers and APIs that expose a health endpoint. The endpoint should be lightweight â€” don't query the database or do heavy computation in your health check.</div></div>"
                                            },
                                            {
                                                "when": {
                                                    "resolver": "k8sFieldValue",
                                                    "equals": "tcp"
                                                },
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ”Œ TCP Socket selected</div><div class=\"state-detail\">Kubernetes attempts a TCP connection to the specified <strong>Port</strong>. If the connection succeeds, the probe passes. No data is sent.<br><br>Best for databases, message queues, and services that don't speak HTTP â€” PostgreSQL, Redis, RabbitMQ, custom TCP services.</div></div>"
                                            },
                                            {
                                                "when": {
                                                    "resolver": "k8sFieldValue",
                                                    "equals": "exec"
                                                },
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">âŒ¨ï¸ Exec selected</div><div class=\"state-detail\">Kubernetes runs the <strong>Command</strong> inside the container. Exit code 0 = pass, anything else = failure.<br><br>Most flexible but most expensive â€” it forks a process every probe interval. Use for services with custom health check scripts like <code>pg_isready -U postgres</code> or <code>redis-cli ping</code>.</div></div>"
                                            }
                                        ],
                                        "children": []
                                    },
                                    {
                                        "id": "k8s-cfg-probe-liveness",
                                        "title": "Liveness Probe",
                                        "icon": "ğŸ’“",
                                        "selector": "[id^=k8s-svc-liv-]",
                                        "content": "Detects <strong>stuck containers</strong> â€” if this probe fails, the kubelet <strong>restarts</strong> the container.<div class=\"assistant-state-card state-warning\" style=\"margin-top:0.4rem\"><div class=\"state-detail\">Too aggressive = restart loops. If your app takes 30s to start, set <code>Delay</code> â‰¥ 30 so the liveness check doesn't kill it during startup.<br><br><strong>Failures</strong> = how many consecutive failures before restart. Default 3 is safe for most workloads.</div></div>",
                                        "variants": [
                                            {
                                                "when": {
                                                    "resolver": "k8sFieldValue",
                                                    "equals": "http"
                                                },
                                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸŒ HTTP GET selected</div><div class=\"state-detail\">Kubernetes GETs the <strong>Path</strong> on the <strong>Port</strong> every <strong>Period</strong> seconds. Non-2xx/3xx after <strong>Failures</strong> consecutive misses â†’ container restart.<br><br>For liveness, use a different endpoint than readiness (e.g. <code>/livez</code> vs <code>/readyz</code>). Liveness should check the process itself â€” not downstream dependencies.</div></div>"
                                            },
                                            {
                                                "when": {
                                                    "resolver": "k8sFieldValue",
                                                    "equals": "tcp"
                                                },
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ”Œ TCP Socket selected</div><div class=\"state-detail\">TCP connect to the specified <strong>Port</strong>. If the port stops responding, the container is considered dead and gets restarted.<br><br>Good safety net for databases â€” if the process crashes or stops accepting connections, this catches it.</div></div>"
                                            },
                                            {
                                                "when": {
                                                    "resolver": "k8sFieldValue",
                                                    "equals": "exec"
                                                },
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">âŒ¨ï¸ Exec selected</div><div class=\"state-detail\">Runs the <strong>Command</strong> inside the container. Non-zero exit â†’ failure count increments. After <strong>Failures</strong> consecutive misses â†’ container restart.<br><br>Use for deep health checks â€” e.g. <code>pg_isready</code>, <code>redis-cli ping</code>, or a custom script that checks internal state.</div></div>"
                                            }
                                        ],
                                        "children": []
                                    },
                                    {
                                        "id": "k8s-cfg-probe-path",
                                        "title": "Probe Path",
                                        "icon": "ğŸ”—",
                                        "selector": ".k8s-field-probe-path",
                                        "content": "The HTTP endpoint Kubernetes hits for each probe check. Should return <strong>200â€“399</strong> when healthy.<div class=\"assistant-state-card state-info\" style=\"margin-top:0.4rem\"><div class=\"state-detail\">Use a dedicated health endpoint, not your main route. A good health endpoint is:<br>â€¢ <strong>Lightweight</strong> â€” no DB queries, no heavy computation<br>â€¢ <strong>Fast</strong> â€” responds in <100ms<br>â€¢ <strong>Internal-only</strong> â€” not exposed to end users<br><br>Common choices: <code>/health</code>, <code>/healthz</code>, <code>/readyz</code>, <code>/livez</code></div></div>",
                                        "children": []
                                    },
                                    {
                                        "id": "k8s-cfg-probe-port",
                                        "title": "Probe Port",
                                        "icon": "ğŸ”Œ",
                                        "selector": ".k8s-field-probe-port",
                                        "content": "The container port Kubernetes connects to for health checks. Must match the port your app actually listens on.<div class=\"assistant-state-card state-info\" style=\"margin-top:0.4rem\"><div class=\"state-detail\">This is the <strong>container port</strong>, not the Service port. If your app listens on 8080 inside the container, set this to 8080 â€” regardless of what the Service exposes.<br><br>Some apps expose a separate management port (e.g. 8081) for health checks. Use that if available â€” it keeps health traffic off the main port.</div></div>",
                                        "children": []
                                    },
                                    {
                                        "id": "k8s-cfg-probe-cmd",
                                        "title": "Probe Command",
                                        "icon": "âŒ¨ï¸",
                                        "selector": ".k8s-field-probe-cmd",
                                        "content": "The command Kubernetes runs <strong>inside the container</strong> for exec probes. Exit code 0 = healthy, anything else = failure.<div class=\"assistant-state-card state-info\" style=\"margin-top:0.4rem\"><div class=\"state-detail\">The command must exist in your container image. Common examples:<br>â€¢ <code>pg_isready -U postgres</code> â€” PostgreSQL<br>â€¢ <code>redis-cli ping</code> â€” Redis<br>â€¢ <code>mysqladmin ping -h localhost</code> â€” MySQL<br>â€¢ <code>mongo --eval \"db.runCommand('ping')\"</code> â€” MongoDB<br><br>âš ï¸ Each probe forks a process. Keep the command fast and avoid shell pipes when possible.</div></div>",
                                        "children": []
                                    },
                                    {
                                        "id": "k8s-cfg-probe-delay",
                                        "title": "Initial Delay",
                                        "icon": "â±ï¸",
                                        "selector": ".k8s-field-probe-delay",
                                        "content": "Seconds to wait after the container starts before the first probe check. Gives your app time to boot.<div class=\"assistant-state-card state-info\" style=\"margin-top:0.4rem\"><div class=\"state-detail\"><strong>Readiness</strong> â€” set to your app's typical boot time (e.g. 5s for a Go API, 15â€“30s for a Java app with Spring Boot).<br><br><strong>Liveness</strong> â€” set <em>longer</em> than readiness. If liveness fires before the app is up, Kubernetes kills and restarts it in a loop. A safe starting point: <code>2Ã— readiness delay</code>.<br><br>Too low = restart loops during startup. Too high = delayed traffic routing after deploy.</div></div>",
                                        "children": []
                                    },
                                    {
                                        "id": "k8s-cfg-probe-period",
                                        "title": "Probe Period",
                                        "icon": "ğŸ”",
                                        "selector": ".k8s-field-probe-period",
                                        "content": "Seconds between each probe check. Controls how quickly Kubernetes detects failures.<div class=\"assistant-state-card state-info\" style=\"margin-top:0.4rem\"><div class=\"state-detail\"><strong>Readiness</strong> â€” shorter period (5â€“10s) means faster traffic routing when a pod recovers.<br><br><strong>Liveness</strong> â€” can be longer (10â€“30s) since you don't want false positives triggering restarts. The total detection time is <code>period Ã— failureThreshold</code>.<br><br>Lower period = faster detection but more kubelet overhead. For most workloads, 10s is a good default.</div></div>",
                                        "children": []
                                    },
                                    {
                                        "id": "k8s-cfg-probe-extra",
                                        "title": "Timeout / Failures",
                                        "icon": "ğŸ¯",
                                        "selector": ".k8s-field-probe-extra",
                                        "content": "For <strong>readiness</strong>: timeout in seconds â€” how long to wait for a probe response before marking it as failed.<br>For <strong>liveness</strong>: failure threshold â€” how many consecutive failures before the container is restarted.<div class=\"assistant-state-card state-info\" style=\"margin-top:0.4rem\"><div class=\"state-detail\"><strong>Timeout</strong> â€” if your health endpoint sometimes takes 2s under load, set timeout to 3. Default 1s is aggressive for apps with heavy health checks.<br><br><strong>Failures</strong> â€” the number of misses before action. Default 3 means 3 Ã— period seconds of failure before restart. Higher = more tolerant of transient blips.</div></div>",
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "id": "k8s-cfg-volumes",
                                "title": "Volume Mounts",
                                "icon": "ğŸ’¾",
                                "selector": ".k8s-field-volumes",
                                "content": "Maps storage into your container â€” each row becomes a <code>volume</code> + <code>volumeMount</code> in the pod spec.<span class=\"assistant-tip\">Compose named volumes become PVC (dynamic) by default. Source-code bind mounts are auto-skipped â€” they're baked into the image at build time.</span>",
                                "children": [
                                    {
                                        "id": "k8s-cfg-vol-type",
                                        "title": "Volume Type",
                                        "icon": "ğŸ“¦",
                                        "selector": "[id^=k8s-svc-vol-type-]",
                                        "content": "Determines how storage is provisioned and what lifecycle it follows.",
                                        "variants": [
                                            {
                                                "when": {
                                                    "resolver": "k8sFieldValue",
                                                    "equals": "pvc-dynamic"
                                                },
                                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ’¾ PVC (dynamic) selected</div><div class=\"state-detail\">The StorageClass provisions a new disk automatically when the pod starts. Data persists across restarts and rescheduling.<br><br>This is the <strong>recommended default</strong> for any data that needs to survive pod restarts â€” databases, uploads, logs, caches with warm-up cost.</div></div>"
                                            },
                                            {
                                                "when": {
                                                    "resolver": "k8sFieldValue",
                                                    "equals": "pvc-static"
                                                },
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ’¾ PVC (static) selected</div><div class=\"state-detail\">Binds to a <strong>pre-existing PersistentVolume</strong> in the cluster. You provide the PV Name â€” Kubernetes doesn't create the disk, it just claims it.<br><br>Use for pre-provisioned NFS shares, existing disks, or storage managed outside K8s. Requires the PV to exist before the pod starts.</div></div>"
                                            },
                                            {
                                                "when": {
                                                    "resolver": "k8sFieldValue",
                                                    "equals": "emptyDir"
                                                },
                                                "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">ğŸ“‚ emptyDir selected</div><div class=\"state-detail\">Ephemeral scratch space â€” created when the pod starts, <strong>deleted when the pod dies</strong>. Data does not survive restarts or rescheduling.<br><br>Use for: temp files, download caches, shared data between containers in the same pod (sidecar pattern). Not for anything you need to keep.</div></div>"
                                            },
                                            {
                                                "when": {
                                                    "resolver": "k8sFieldValue",
                                                    "equals": "configMap"
                                                },
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“„ ConfigMap selected</div><div class=\"state-detail\">Mounts a ConfigMap's data as <strong>files</strong> inside the container. Each key becomes a filename, each value becomes the file content.<br><br>Use for: <code>nginx.conf</code>, <code>settings.json</code>, <code>my-app.properties</code>. Changes to the ConfigMap are reflected in the pod (with a delay) â€” no restart needed.</div></div>"
                                            },
                                            {
                                                "when": {
                                                    "resolver": "k8sFieldValue",
                                                    "equals": "secret"
                                                },
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ” Secret selected</div><div class=\"state-detail\">Mounts a Secret's data as <strong>files</strong> inside the container. Stored as tmpfs in memory â€” never written to disk on the node.<br><br>Use for: TLS certificates (<code>tls.crt</code>, <code>tls.key</code>), SSH keys, license files, or any binary secret data that needs to be a file rather than an environment variable.</div></div>"
                                            },
                                            {
                                                "when": {
                                                    "resolver": "k8sFieldValue",
                                                    "equals": "hostPath"
                                                },
                                                "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš ï¸ hostPath selected</div><div class=\"state-detail\">Mounts a directory from the <strong>host node's filesystem</strong> directly into the pod. The pod is now tied to that specific node.<br><br><strong>Not recommended for production.</strong> Breaks portability, bypasses storage policies, and creates security risks. Use only for node-level agents (log collectors, monitoring) or development clusters.</div></div>"
                                            }
                                        ],
                                        "children": []
                                    },
                                    {
                                        "id": "k8s-cfg-vol-access",
                                        "title": "Access Mode",
                                        "icon": "ğŸ”“",
                                        "selector": "[id^=k8s-svc-vol-access-]",
                                        "content": "Controls how many nodes can mount this volume simultaneously.",
                                        "variants": [
                                            {
                                                "when": {
                                                    "resolver": "k8sFieldValue",
                                                    "equals": "ReadWriteOnce"
                                                },
                                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ”“ ReadWriteOnce (RWO)</div><div class=\"state-detail\">The volume can be mounted as <strong>read-write by a single node</strong>. Multiple pods on the same node can share it, but pods on different nodes cannot.<br><br>This is the <strong>most common and most compatible</strong> mode â€” all storage providers support it. Use for databases, single-instance apps, anything with one writer.</div></div>"
                                            },
                                            {
                                                "when": {
                                                    "resolver": "k8sFieldValue",
                                                    "equals": "ReadWriteMany"
                                                },
                                                "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">ğŸ”“ ReadWriteMany (RWX)</div><div class=\"state-detail\">The volume can be mounted as <strong>read-write by multiple nodes</strong> simultaneously. All pods can read and write.<br><br><strong>Not all storage providers support this.</strong> NFS-based provisioners (nfs-client, EFS, Azure Files) support it. Block storage (EBS, GCE PD, Longhorn) typically does not. Check your StorageClass.</div></div>"
                                            },
                                            {
                                                "when": {
                                                    "resolver": "k8sFieldValue",
                                                    "equals": "ReadOnlyMany"
                                                },
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ”“ ReadOnlyMany (ROX)</div><div class=\"state-detail\">The volume can be mounted as <strong>read-only by multiple nodes</strong>. No pod can write to it.<br><br>Use for shared static assets, reference data, or configuration distributed across many pods. The volume must be pre-populated before pods mount it.</div></div>"
                                            }
                                        ],
                                        "children": []
                                    },
                                    {
                                        "id": "k8s-cfg-vol-sc",
                                        "title": "Storage Class",
                                        "icon": "ğŸ—ï¸",
                                        "selector": ".k8s-vol-sc-select",
                                        "content": "Determines <strong>what kind of disk</strong> gets provisioned for this PVC. Choose based on your cluster provider and performance needs.",
                                        "variants": [
                                            {
                                                "when": {
                                                    "resolver": "k8sFieldValue",
                                                    "equals": ""
                                                },
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ—ï¸ Cluster default</div><div class=\"state-detail\">No explicit StorageClass â€” Kubernetes uses whatever is marked as <code>default</code> in the cluster. On most managed clusters this is a reasonable general-purpose option.<br><br>Run <code>kubectl get sc</code> to see what's available and which one is default.</div></div>"
                                            },
                                            {
                                                "when": {
                                                    "resolver": "k8sFieldValue",
                                                    "equals": "longhorn"
                                                },
                                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ‚ Longhorn</div><div class=\"state-detail\">Distributed block storage for bare-metal/self-hosted clusters. Provisioner: <code>driver.longhorn.io</code><br><br><strong>Replicated</strong> across nodes (configurable replica count), supports snapshots, backup to S3, and live volume expansion. The best option for self-hosted clusters that need HA storage.</div></div>"
                                            },
                                            {
                                                "when": {
                                                    "resolver": "k8sFieldValue",
                                                    "equals": "local-path"
                                                },
                                                "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">ğŸ“ local-path</div><div class=\"state-detail\">Local node disk provisioner â€” default in K3s and Rancher clusters. Provisioner: <code>rancher.io/local-path</code><br><br>Fast and simple, but <strong>no replication</strong>. If the node dies, the data is gone. Only supports ReadWriteOnce. Use for development or data you can afford to lose.</div></div>"
                                            },
                                            {
                                                "when": {
                                                    "resolver": "k8sFieldValue",
                                                    "equals": "nfs-client"
                                                },
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“ nfs-client</div><div class=\"state-detail\">NFS external provisioner â€” creates subdirectories on an existing NFS server. Provisioner: <code>cluster.local/nfs-subdir-external</code><br><br>Supports <strong>ReadWriteMany</strong> â€” multiple pods on different nodes can share the same volume. Slower than block storage but great for shared configuration or media assets.</div></div>"
                                            },
                                            {
                                                "when": {
                                                    "resolver": "k8sFieldValue",
                                                    "equals": "openebs-hostpath"
                                                },
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“ openebs-hostpath</div><div class=\"state-detail\">OpenEBS local PV provisioner. Provisioner: <code>openebs.io/local</code><br><br>Similar to local-path but with better lifecycle management, monitoring, and optional Mayastor backend for replication. A good step up from local-path on self-hosted clusters.</div></div>"
                                            },
                                            {
                                                "when": {
                                                    "resolver": "k8sFieldValue",
                                                    "equals": "rook-ceph-block"
                                                },
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“ rook-ceph-block</div><div class=\"state-detail\">Ceph block storage managed by Rook. Provisioner: <code>rook-ceph.rbd.csi.ceph.com</code><br><br>Enterprise-grade distributed storage with replication, snapshots, and cloning. Complex to deploy and operate â€” requires dedicated OSDs (storage daemons) and monitors. Overkill for small clusters.</div></div>"
                                            },
                                            {
                                                "when": {
                                                    "resolver": "k8sFieldValue",
                                                    "equals": "gp3"
                                                },
                                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">â˜ï¸ AWS gp3</div><div class=\"state-detail\">General-purpose SSD on AWS EBS. Provisioner: <code>ebs.csi.aws.com</code><br><br><strong>Recommended for most AWS workloads.</strong> 3000 IOPS and 125 MB/s baseline included â€” no burst credits to worry about. Cheaper than gp2 for the same performance. IOPS and throughput can be provisioned independently.</div></div>"
                                            },
                                            {
                                                "when": {
                                                    "resolver": "k8sFieldValue",
                                                    "equals": "gp2"
                                                },
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â˜ï¸ AWS gp2</div><div class=\"state-detail\">Legacy general-purpose SSD on AWS EBS. Provisioner: <code>kubernetes.io/aws-ebs</code><br><br>Burst IOPS scales with volume size (3 IOPS/GB, max 16000). Smaller volumes can run out of burst credits under sustained load. Prefer <strong>gp3</strong> for new workloads â€” it's cheaper and more predictable.</div></div>"
                                            },
                                            {
                                                "when": {
                                                    "resolver": "k8sFieldValue",
                                                    "equals": "io1"
                                                },
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â˜ï¸ AWS io1</div><div class=\"state-detail\">Provisioned IOPS SSD on AWS EBS. Provisioner: <code>ebs.csi.aws.com</code><br><br>Guaranteed I/O performance up to 64000 IOPS. Use for databases that need consistent, high-throughput storage â€” high-traffic PostgreSQL, MySQL, Cassandra. Expensive â€” only use when gp3's 3000 IOPS baseline isn't enough.</div></div>"
                                            },
                                            {
                                                "when": {
                                                    "resolver": "k8sFieldValue",
                                                    "equals": "efs-sc"
                                                },
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â˜ï¸ AWS EFS</div><div class=\"state-detail\">Elastic File System â€” managed NFS on AWS. Provisioner: <code>efs.csi.aws.com</code><br><br>Supports <strong>ReadWriteMany</strong> â€” multiple pods across multiple nodes can share the same volume. Unlimited size (pay per GB stored). Slower than EBS for random I/O. Use for shared assets, config, or media.</div></div>"
                                            },
                                            {
                                                "when": {
                                                    "resolver": "k8sFieldValue",
                                                    "equals": "standard-rwo"
                                                },
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â˜ï¸ GKE standard-rwo</div><div class=\"state-detail\">Standard persistent disk on Google Cloud. Provisioner: <code>pd.csi.storage.gke.io</code><br><br>HDD-backed â€” cheapest option on GKE. Adequate for low-IOPS workloads like batch processing, log storage, or development environments.</div></div>"
                                            },
                                            {
                                                "when": {
                                                    "resolver": "k8sFieldValue",
                                                    "equals": "premium-rwo"
                                                },
                                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">â˜ï¸ GKE premium-rwo</div><div class=\"state-detail\">SSD persistent disk on Google Cloud. Provisioner: <code>pd.csi.storage.gke.io</code><br><br>Higher IOPS and lower latency than standard. <strong>Recommended for databases</strong> and latency-sensitive workloads on GKE.</div></div>"
                                            },
                                            {
                                                "when": {
                                                    "resolver": "k8sFieldValue",
                                                    "equals": "managed-csi"
                                                },
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â˜ï¸ Azure managed-csi</div><div class=\"state-detail\">Azure managed disk (Standard LRS). Provisioner: <code>disk.csi.azure.com</code><br><br>Locally-redundant storage â€” data replicated 3Ã— within a single datacenter. General-purpose workloads at a reasonable price point.</div></div>"
                                            },
                                            {
                                                "when": {
                                                    "resolver": "k8sFieldValue",
                                                    "equals": "managed-csi-premium"
                                                },
                                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">â˜ï¸ Azure managed-csi-premium</div><div class=\"state-detail\">Premium SSD managed disk on Azure. Provisioner: <code>disk.csi.azure.com</code><br><br>Low-latency, high-throughput SSD. <strong>Recommended for databases and production workloads</strong> on AKS. Provisioned IOPS scale with disk size.</div></div>"
                                            },
                                            {
                                                "when": {
                                                    "resolver": "k8sFieldValue",
                                                    "equals": "azurefile-csi"
                                                },
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â˜ï¸ Azure File Share</div><div class=\"state-detail\">Azure File Share via SMB/NFS. Provisioner: <code>file.csi.azure.com</code><br><br>Supports <strong>ReadWriteMany</strong> â€” multiple pods across nodes can share the same volume. Use for shared configuration, media assets, or workloads that need concurrent file access.</div></div>"
                                            },
                                            {
                                                "when": {
                                                    "resolver": "k8sFieldValue",
                                                    "equals": "do-block-storage"
                                                },
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â˜ï¸ DigitalOcean Block Storage</div><div class=\"state-detail\">Block storage volume on DigitalOcean. Provisioner: <code>dobs.csi.digitalocean.com</code><br><br>The only storage option on DOKS. SSD-backed, supports ReadWriteOnce. Simple and reliable â€” it just works.</div></div>"
                                            },
                                            {
                                                "when": {
                                                    "resolver": "k8sFieldValue",
                                                    "equals": "_custom"
                                                },
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">âœï¸ Custom Storage Class</div><div class=\"state-detail\">Type the name of a StorageClass that exists in your cluster but isn't in this list. Run <code>kubectl get sc</code> to see available classes.<br><br>Make sure the class exists before deploying â€” a missing StorageClass will leave the PVC in Pending state indefinitely.</div></div>"
                                            }
                                        ],
                                        "children": []
                                    },
                                    {
                                        "id": "k8s-cfg-vol-medium",
                                        "title": "emptyDir Medium",
                                        "icon": "ğŸ’¿",
                                        "selector": "[id^=k8s-svc-vol-medium-]",
                                        "content": "Controls the backing storage for this ephemeral volume.",
                                        "variants": [
                                            {
                                                "when": {
                                                    "resolver": "k8sFieldValue",
                                                    "equals": ""
                                                },
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ’¿ Disk (default)</div><div class=\"state-detail\">Uses the node's local disk â€” whatever the kubelet's root filesystem is (usually ext4 on SSD or HDD). Slower than Memory but doesn't count against the container's memory limit.<br><br>Good for: temp files, build caches, download staging areas.</div></div>"
                                            },
                                            {
                                                "when": {
                                                    "resolver": "k8sFieldValue",
                                                    "equals": "Memory"
                                                },
                                                "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">ğŸ§  Memory (tmpfs)</div><div class=\"state-detail\">Backed by RAM â€” extremely fast but <strong>counts against the container's memory limit</strong>. If your emptyDir + container usage exceeds the memory limit, the pod gets OOM-killed.<br><br>Use for: high-speed scratch space, shared IPC buffers between containers. Always set a Size Limit to avoid unbounded memory consumption.</div></div>"
                                            }
                                        ],
                                        "children": []
                                    },
                                    {
                                        "id": "k8s-cfg-vol-hosttype",
                                        "title": "hostPath Type",
                                        "icon": "ğŸ“",
                                        "selector": "[id^=k8s-svc-vol-hosttype-]",
                                        "content": "Validation rule for the host path before mounting.",
                                        "variants": [
                                            {
                                                "when": {
                                                    "resolver": "k8sFieldValue",
                                                    "equals": "DirectoryOrCreate"
                                                },
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“ DirectoryOrCreate</div><div class=\"state-detail\">If the path doesn't exist on the host, Kubernetes creates it as an empty directory (owned by kubelet, mode 0755). Safest option â€” the pod won't fail if the directory is missing.<br><br>Most common choice for log directories, cache paths, or any directory-based mount.</div></div>"
                                            },
                                            {
                                                "when": {
                                                    "resolver": "k8sFieldValue",
                                                    "equals": "Directory"
                                                },
                                                "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">ğŸ“ Directory</div><div class=\"state-detail\">The path <strong>must already exist</strong> as a directory on every node where this pod runs. If it doesn't exist, the pod fails to start.<br><br>Use when you need to guarantee the directory was set up by an admin or provisioning script before the pod is scheduled.</div></div>"
                                            },
                                            {
                                                "when": {
                                                    "resolver": "k8sFieldValue",
                                                    "equals": "FileOrCreate"
                                                },
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“„ FileOrCreate</div><div class=\"state-detail\">If the path doesn't exist, Kubernetes creates it as an empty file (mode 0644). Use for mounting a specific file (e.g. a socket, a config file) rather than a directory.</div></div>"
                                            },
                                            {
                                                "when": {
                                                    "resolver": "k8sFieldValue",
                                                    "equals": "File"
                                                },
                                                "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">ğŸ“„ File</div><div class=\"state-detail\">The path <strong>must already exist</strong> as a file on every node. If missing, the pod fails to start. Use for pre-existing sockets, device files, or node-level config files you know are provisioned.</div></div>"
                                            }
                                        ],
                                        "children": []
                                    },
                                    {
                                        "id": "k8s-cfg-vol-lh-locality",
                                        "title": "Longhorn Data Locality",
                                        "icon": "ğŸ‚",
                                        "selector": "[id^=k8s-vol-lh-locality-]",
                                        "content": "Controls where Longhorn places data replicas relative to the pod.",
                                        "variants": [
                                            {
                                                "when": {
                                                    "resolver": "k8sFieldValue",
                                                    "equals": "best-effort"
                                                },
                                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ‚ Best-effort</div><div class=\"state-detail\">Longhorn <strong>tries</strong> to keep at least one replica on the same node as the pod. If the pod moves, Longhorn rebuilds a local replica in the background.<br><br><strong>Recommended default.</strong> Best balance of performance and resilience â€” local reads when possible, no hard failure if the local replica can't be maintained.</div></div>"
                                            },
                                            {
                                                "when": {
                                                    "resolver": "k8sFieldValue",
                                                    "equals": "strict"
                                                },
                                                "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">ğŸ‚ Strict</div><div class=\"state-detail\">Longhorn <strong>guarantees</strong> a replica on the same node as the pod. If it can't maintain local data, the volume becomes degraded and may block the pod.<br><br>Use for latency-critical workloads where network reads are unacceptable. Risk: if the node fills up or fails, the pod can't reschedule until data locality is restored.</div></div>"
                                            },
                                            {
                                                "when": {
                                                    "resolver": "k8sFieldValue",
                                                    "equals": "disabled"
                                                },
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ‚ Disabled</div><div class=\"state-detail\">No data locality constraint â€” replicas are placed wherever Longhorn finds space. All reads go over the network to whichever replica responds first.<br><br>Use when storage capacity distribution matters more than read latency. Good for batch workloads or large clusters with uneven disk sizes.</div></div>"
                                            }
                                        ],
                                        "children": []
                                    },
                                    {
                                        "id": "k8s-cfg-vol-source",
                                        "title": "Volume Source",
                                        "icon": "ğŸ“‚",
                                        "selector": ".k8s-field-vol-source",
                                        "content": "The name or reference for this volume â€” what this means depends on the volume type selected above.",
                                        "variants": [
                                            {
                                                "when": {
                                                    "resolver": "k8sVolRowType",
                                                    "equals": "pvc-dynamic"
                                                },
                                                "title": "PVC Name",
                                                "icon": "ğŸ’¾",
                                                "content": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ’¾ PVC Name (dynamic provisioning)</div><div class=\"state-detail\">This becomes the <code>PersistentVolumeClaim</code> name in your manifest. The cluster's StorageClass provisioner creates the actual volume automatically when the PVC is bound.<br><br><strong>Naming rules:</strong> lowercase, hyphens only, no dots, max 253 chars. Must be unique within the namespace. <br><br>Good names: <code>my-app-data</code>, <code>postgres-db</code>, <code>uploads-store</code><br>Bad names: <code>My_Data.vol</code>, <code>data</code> (too generic)</div></div>"
                                            },
                                            {
                                                "when": {
                                                    "resolver": "k8sVolRowType",
                                                    "equals": "pvc-static"
                                                },
                                                "title": "PVC Name",
                                                "icon": "ğŸ’¾",
                                                "content": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">ğŸ’¾ PVC Name (static binding)</div><div class=\"state-detail\">This must match an <strong>existing PVC</strong> in the target namespace. No new PVC is created â€” the manifest references this name directly.<br><br>Use <code>kubectl get pvc -n &lt;namespace&gt;</code> to list available PVCs. If the PVC doesn't exist at deploy time, the pod will be stuck in <code>Pending</code>.<br><br>âš ï¸ Static PVCs can't be resized through the wizard. Manage them via <code>kubectl</code> directly.</div></div>"
                                            },
                                            {
                                                "when": {
                                                    "resolver": "k8sVolRowType",
                                                    "equals": "configMap"
                                                },
                                                "title": "ConfigMap Name",
                                                "icon": "ğŸ“„",
                                                "content": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“„ ConfigMap Name</div><div class=\"state-detail\">The name of the <code>ConfigMap</code> resource to mount. Each key in the ConfigMap becomes a file in the mount directory.<br><br>The ConfigMap must exist in the same namespace as the pod. If it doesn't exist at deploy time, the pod won't start (unless you mark the volume as optional).<br><br><strong>Common patterns:</strong><br>â€¢ <code>nginx-config</code> â†’ mounts <code>nginx.conf</code> into <code>/etc/nginx</code><br>â€¢ <code>app-settings</code> â†’ mounts <code>settings.json</code> into <code>/app/config</code><br>â€¢ <code>prometheus-rules</code> â†’ mounts rule files into <code>/etc/prometheus/rules</code></div></div>"
                                            },
                                            {
                                                "when": {
                                                    "resolver": "k8sVolRowType",
                                                    "equals": "secret"
                                                },
                                                "title": "Secret Name",
                                                "icon": "ğŸ”",
                                                "content": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ” Secret Name</div><div class=\"state-detail\">The name of the <code>Secret</code> resource to mount as files. Each key in the Secret becomes a file with the decoded (not base64) value as content.<br><br>The Secret must exist in the same namespace. If missing, the pod won't start.<br><br><strong>Common patterns:</strong><br>â€¢ <code>tls-certs</code> â†’ mounts <code>tls.crt</code> + <code>tls.key</code> into <code>/etc/tls</code><br>â€¢ <code>ssh-keys</code> â†’ mounts <code>id_rsa</code> into <code>/root/.ssh</code><br>â€¢ <code>ca-bundle</code> â†’ mounts <code>ca.crt</code> for custom CA trust<br><br>Files are mounted with mode 0644 by default. For sensitive keys like SSH, set <code>defaultMode: 0400</code> in the manifest.</div></div>"
                                            },
                                            {
                                                "when": {
                                                    "resolver": "k8sVolRowType",
                                                    "equals": "hostPath"
                                                },
                                                "title": "Host Path",
                                                "icon": "âš ï¸",
                                                "content": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš ï¸ Host Path</div><div class=\"state-detail\">The <strong>absolute path on the host node</strong> to mount into the container. This ties the pod to a specific node's filesystem.<br><br><strong>Common uses:</strong><br>â€¢ <code>/var/log</code> â†’ node-level log access for DaemonSet collectors<br>â€¢ <code>/var/run/docker.sock</code> â†’ Docker socket (security risk)<br>â€¢ <code>/dev</code> â†’ device access for hardware plugins<br><br>âš ï¸ <strong>Security risks:</strong> pods can read/write the host filesystem. Avoid in production. PodSecurityPolicies or OPA can restrict this. Not portable across nodes.</div></div>"
                                            }
                                        ],
                                        "children": []
                                    },
                                    {
                                        "id": "k8s-cfg-vol-mount",
                                        "title": "Mount Path",
                                        "icon": "ğŸ“",
                                        "selector": ".k8s-field-vol-mount",
                                        "content": "The absolute path <strong>inside the container</strong> where the volume is mounted.",
                                        "variants": [
                                            {
                                                "when": {
                                                    "resolver": "k8sVolRowType",
                                                    "equals": "pvc-dynamic"
                                                },
                                                "content": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“ Mount Path â€” PVC volume</div><div class=\"state-detail\">Where persistent data lives inside the container. This directory gets a dedicated disk provisioned by the StorageClass.<br><br><strong>Common paths by workload:</strong><br>â€¢ PostgreSQL: <code>/var/lib/postgresql/data</code><br>â€¢ MySQL: <code>/var/lib/mysql</code><br>â€¢ Redis: <code>/data</code><br>â€¢ MongoDB: <code>/data/db</code><br>â€¢ App uploads: <code>/app/uploads</code> or <code>/var/www/uploads</code><br><br>âš ï¸ Don't mount at <code>/app</code> â€” it would hide your application code. Mount at a subdirectory instead.</div></div>"
                                            },
                                            {
                                                "when": {
                                                    "resolver": "k8sVolRowType",
                                                    "equals": "pvc-static"
                                                },
                                                "content": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“ Mount Path â€” static PVC</div><div class=\"state-detail\">Where the pre-existing volume is mounted inside the container. Same rules as dynamic PVC mount paths.<br><br>Make sure the existing PV's data layout matches what your app expects at this path. If migrating from another volume, verify directory structure first.</div></div>"
                                            },
                                            {
                                                "when": {
                                                    "resolver": "k8sVolRowType",
                                                    "equals": "emptyDir"
                                                },
                                                "content": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">ğŸ“ Mount Path â€” emptyDir (ephemeral)</div><div class=\"state-detail\">Scratch space that starts empty and is <strong>deleted when the pod is removed or rescheduled</strong>.<br><br><strong>Good for:</strong><br>â€¢ <code>/tmp</code> â€” temporary processing files<br>â€¢ <code>/var/cache</code> â€” build caches, downloaded assets<br>â€¢ <code>/shared</code> â€” data exchange between init and main containers<br><br>âš ï¸ Don't put anything here you can't afford to lose. Pod restart = data gone.</div></div>"
                                            },
                                            {
                                                "when": {
                                                    "resolver": "k8sVolRowType",
                                                    "equals": "configMap"
                                                },
                                                "content": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“ Mount Path â€” ConfigMap files</div><div class=\"state-detail\">Directory where ConfigMap keys appear as files. Each key becomes a filename, each value becomes the file content.<br><br><strong>Common paths:</strong><br>â€¢ <code>/etc/nginx</code> â€” nginx configuration<br>â€¢ <code>/etc/config</code> â€” generic app config<br>â€¢ <code>/app/config</code> â€” application config directory<br><br>âš ï¸ Mounting here <strong>replaces the entire directory</strong>. If the directory has existing files (e.g. from the image), they're hidden. Use <code>subPath</code> in the manifest to mount a single file without hiding siblings.</div></div>"
                                            },
                                            {
                                                "when": {
                                                    "resolver": "k8sVolRowType",
                                                    "equals": "secret"
                                                },
                                                "content": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“ Mount Path â€” Secret files</div><div class=\"state-detail\">Directory where Secret keys appear as decoded files. Sensitive data (certs, keys, passwords) is written here in plaintext â€” protect with filesystem permissions.<br><br><strong>Common paths:</strong><br>â€¢ <code>/etc/tls</code> â€” TLS certificate + key pair<br>â€¢ <code>/etc/ssl/certs</code> â€” CA certificates<br>â€¢ <code>/root/.ssh</code> â€” SSH keys<br>â€¢ <code>/etc/secrets</code> â€” generic secret files<br><br>Files default to mode 0644. For keys that need restricted access, set <code>defaultMode: 0400</code> in the volume spec.</div></div>"
                                            },
                                            {
                                                "when": {
                                                    "resolver": "k8sVolRowType",
                                                    "equals": "hostPath"
                                                },
                                                "content": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">ğŸ“ Mount Path â€” hostPath</div><div class=\"state-detail\">Where the host's directory/file appears inside the container. The <em>Host Path</em> field (left side) is the source on the node, this is the destination in the container.<br><br><strong>Common mappings:</strong><br>â€¢ <code>/var/log</code> â†’ <code>/host/log</code> (log collector access)<br>â€¢ <code>/var/run/docker.sock</code> â†’ <code>/var/run/docker.sock</code> (same path)<br><br>âš ï¸ The container can read/write the host filesystem through this mount. Use <code>readOnly: true</code> unless writes are required.</div></div>"
                                            }
                                        ],
                                        "children": []
                                    },
                                    {
                                        "id": "k8s-cfg-vol-size",
                                        "title": "PVC Size",
                                        "icon": "ğŸ“",
                                        "selector": ".k8s-field-vol-size",
                                        "content": "Storage request size for the PersistentVolumeClaim. Uses Kubernetes resource quantities.<div class=\"assistant-state-card state-info\" style=\"margin-top:0.4rem\"><div class=\"state-detail\">Common values: <code>1Gi</code>, <code>5Gi</code>, <code>10Gi</code>, <code>50Gi</code>, <code>100Gi</code><br><br>Units: <code>Ki</code> (kibibyte), <code>Mi</code> (mebibyte), <code>Gi</code> (gibibyte), <code>Ti</code> (tebibyte)<br><br>âš ï¸ <strong>Shrinking a PVC is not supported</strong> in most storage classes. Start smaller and expand later. Many providers support online volume expansion if the StorageClass has <code>allowVolumeExpansion: true</code>.</div></div>",
                                        "children": []
                                    },
                                    {
                                        "id": "k8s-cfg-vol-pvname",
                                        "title": "PV Name",
                                        "icon": "ğŸ”—",
                                        "selector": ".k8s-field-vol-pvname",
                                        "content": "Binds the PVC to a specific pre-existing PersistentVolume by name.<div class=\"assistant-state-card state-warning\" style=\"margin-top:0.4rem\"><div class=\"state-detail\">The PV must already exist in the cluster before the pod is created. The PVC's storage request and access mode must match the PV's capacity and access modes.<br><br>Use for: pre-provisioned NFS shares, manually created disks, or migrating data from an existing volume. Leave empty for dynamic provisioning.</div></div>",
                                        "children": []
                                    },
                                    {
                                        "id": "k8s-cfg-vol-sizelimit",
                                        "title": "emptyDir Size Limit",
                                        "icon": "ğŸ“",
                                        "selector": ".k8s-field-vol-sizelimit",
                                        "content": "Optional maximum size for the emptyDir volume. When exceeded, the pod is evicted.<div class=\"assistant-state-card state-info\" style=\"margin-top:0.4rem\"><div class=\"state-detail\">If set, kubelet monitors usage and evicts the pod when the limit is exceeded. This protects the node from a runaway container filling up disk.<br><br>For <strong>Memory</strong> medium, this counts against the container's memory limit. A 512Mi tmpfs + 256Mi app memory = 768Mi total RAM used.<br><br>Leave empty for no limit (default) â€” the volume can grow until the node's ephemeral storage is full.</div></div>",
                                        "children": []
                                    },
                                    {
                                        "id": "k8s-cfg-vol-cmkey",
                                        "title": "ConfigMap Key",
                                        "icon": "ğŸ”‘",
                                        "selector": ".k8s-field-vol-cmkey",
                                        "content": "Mount a <strong>single key</strong> from the ConfigMap as a file instead of the entire ConfigMap.<div class=\"assistant-state-card state-info\" style=\"margin-top:0.4rem\"><div class=\"state-detail\"><strong>Empty (default)</strong> â†’ mounts ALL keys as files in the mount path. Each key becomes a filename, each value becomes the file content.<br><br><strong>Specific key</strong> â†’ mounts only that key. The mount path + key become the full file path. For example:<br>ConfigMap: <code>nginx-config</code>, Key: <code>nginx.conf</code>, Mount: <code>/etc/nginx</code><br>â†’ file at <code>/etc/nginx/nginx.conf</code><br><br>Use a key when your ConfigMap has multiple entries but you only need one file mounted.</div></div>",
                                        "children": []
                                    },
                                    {
                                        "id": "k8s-cfg-vol-seckey",
                                        "title": "Secret Key",
                                        "icon": "ğŸ”‘",
                                        "selector": ".k8s-field-vol-seckey",
                                        "content": "Mount a <strong>single key</strong> from the Secret as a file instead of the entire Secret.<div class=\"assistant-state-card state-info\" style=\"margin-top:0.4rem\"><div class=\"state-detail\"><strong>Empty (default)</strong> â†’ mounts ALL keys as files. Each key becomes a filename with the decoded value as content.<br><br><strong>Specific key</strong> â†’ mounts only that key. Common patterns:<br>â€¢ <code>tls.crt</code> + <code>tls.key</code> â€” TLS certificate pair<br>â€¢ <code>ca.crt</code> â€” CA certificate bundle<br>â€¢ <code>id_rsa</code> â€” SSH private key<br>â€¢ <code>.dockerconfigjson</code> â€” Docker registry credentials<br><br>Files mounted from Secrets are automatically set to mode 0644. Use <code>defaultMode</code> in the manifest if you need stricter permissions.</div></div>",
                                        "children": []
                                    },
                                    {
                                        "id": "k8s-cfg-vol-lh-replicas",
                                        "title": "Longhorn Replicas",
                                        "icon": "ğŸ‚",
                                        "selector": ".k8s-field-vol-lh-replicas",
                                        "content": "Number of data replicas Longhorn maintains across nodes for this volume.<div class=\"assistant-state-card state-info\" style=\"margin-top:0.4rem\"><div class=\"state-detail\"><strong>1</strong> â€” no redundancy. If the node dies, data is lost. Only use for ephemeral or easily-recreatable data.<br><strong>2</strong> â€” survives one node failure. Good balance of safety and storage cost.<br><strong>3 (default)</strong> â€” survives two simultaneous node failures. Recommended for production databases and critical data.<br><br>More replicas = more disk usage (3 replicas of a 10Gi volume = 30Gi consumed across the cluster) and slightly higher write latency. Reads are served from the local replica when data locality is enabled.</div></div>",
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "id": "k8s-cfg-deps",
                                "title": "Depends On",
                                "icon": "ğŸ”—",
                                "selector": ".k8s-field-deps",
                                "content": "Infrastructure services this workload depends on. Checking a dependency unlocks its env vars for injection into your pod.",
                                "variants": [
                                    {
                                        "when": {
                                            "hasSelector": "input:checked"
                                        },
                                        "icon": "ğŸ”—",
                                        "content": "Dependencies selected â€” their environment variables can now be injected into this pod's containers via the Env Vars section above.",
                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ”— Active Dependencies</div><div class=\"state-detail\">Checked services are wired into your pod:<br><br>â€¢ <strong>Env var injection</strong> â€” the Var / Secret dropdown in Environment Variables now includes keys from your dependencies. Select a dep's key (e.g. <code>POSTGRES_PASSWORD</code>) and it maps to a K8s Secret reference automatically.<br><br>â€¢ <strong>Service discovery</strong> â€” in K8s, services find each other by DNS name, not <code>depends_on</code> ordering. Your app connects to <code>postgres:5432</code> (or <code>postgres.namespace.svc.cluster.local</code>).<br><br>â€¢ <strong>No startup ordering</strong> â€” unlike Docker Compose, K8s doesn't guarantee dependency startup order. Use <strong>init containers</strong> or <strong>readiness probes</strong> if your app needs a service ready before starting.<br><br><span class=\"assistant-tip\">If a dependency is set to <strong>Managed</strong> in the Infrastructure section, its connection vars are injected as Secrets â€” no K8s workload is created for it.</span></div></div>"
                                    },
                                    {
                                        "when": {
                                            "textContains": "â€”"
                                        },
                                        "icon": "ğŸ“­",
                                        "content": "No infrastructure services detected â€” dependencies will appear here once you add database, cache, or other backing services in the Infrastructure section below.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“­ No Infrastructure Services</div><div class=\"state-detail\">Your Docker Compose didn't define any infrastructure services (databases, caches, brokers, etc.), or they haven't been added yet.<br><br>If your app needs backing services:<br>1. Scroll down to <strong>Infrastructure Services</strong><br>2. Use the \"+ Add infrastructure service\" dropdown<br>3. Select from the catalog (PostgreSQL, Redis, RabbitMQ, etc.)<br>4. They'll appear here as checkable dependencies<br><br>If your app is truly standalone (no external services), this section stays empty â€” that's fine.</div></div>"
                                    }
                                ],
                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ”— Service Dependencies</div><div class=\"state-detail\">No dependencies selected. Your pod will start independently without env var injection from infrastructure services.<br><br>Dependencies matter when your app connects to a database, cache, or message broker. Checking a service here does two things:<br><br>1. <strong>Env vars unlock</strong> â€” the service's keys (e.g. <code>POSTGRES_USER</code>, <code>REDIS_URL</code>) become selectable in your Environment Variables section<br>2. <strong>Manifest awareness</strong> â€” the generated manifests reference the dependency's Service and Secret resources<br><br>Unlike Docker Compose, K8s doesn't use <code>depends_on</code> for startup ordering. Pods start concurrently. Use <strong>init containers</strong> (e.g. <code>wait-for-it</code>) or application-level retry logic to handle startup races.</div></div>",
                                "children": [
                                    {
                                        "id": "k8s-cfg-dep-item",
                                        "title": "Service Dependency",
                                        "icon": "ğŸ”—",
                                        "selector": ".k8s-dep-label",
                                        "content": "Hover a dependency to preview what it provides. Check it to unlock its env vars for injection.",
                                        "expanded": "{{k8sDepHover}}",
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "id": "k8s-cfg-mesh",
                                "title": "Service Mesh",
                                "icon": "ğŸ•¸ï¸",
                                "selector": ".k8s-field-mesh",
                                "content": "Injects a sidecar proxy into the pod for traffic management, mTLS, and observability.<div class=\"assistant-state-card state-info\" style=\"margin-top:0.4rem\"><div class=\"state-detail\">When enabled, the mesh control plane injects a proxy container (Envoy, linkerd-proxy, etc.) alongside your app. This proxy intercepts all network traffic and provides:<br>â€¢ <strong>mTLS</strong> â€” automatic encryption between services, zero-trust networking<br>â€¢ <strong>Observability</strong> â€” request metrics, tracing, and access logs without code changes<br>â€¢ <strong>Traffic management</strong> â€” retries, timeouts, circuit breaking, canary deployments<br><br>Only annotations are added to your manifest â€” the proxy itself is injected by the mesh's webhook.</div></div>",
                                "children": [
                                    {
                                        "id": "k8s-cfg-mesh-provider",
                                        "title": "Mesh Provider",
                                        "icon": "ğŸ”§",
                                        "selector": ".k8s-field-mesh-provider",
                                        "content": "Which service mesh implementation to use.",
                                        "variants": [
                                            {
                                                "when": {
                                                    "resolver": "k8sFieldValue",
                                                    "equals": "istio"
                                                },
                                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ”· Istio selected</div><div class=\"state-detail\">The most feature-rich mesh. Envoy-based sidecar with powerful traffic management, security policies, and telemetry.<br><br><strong>Pros:</strong> industry standard, massive ecosystem, VirtualService/DestinationRule for fine-grained routing<br><strong>Cons:</strong> heavy resource footprint (~128Mi+ per sidecar), complex configuration, slower to adopt<br><br>Best for: large teams, complex routing needs, organizations already invested in the Istio ecosystem.</div></div>"
                                            },
                                            {
                                                "when": {
                                                    "resolver": "k8sFieldValue",
                                                    "equals": "linkerd"
                                                },
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ”— Linkerd selected</div><div class=\"state-detail\">Lightweight, Rust-based proxy. Simpler than Istio with lower resource overhead.<br><br><strong>Pros:</strong> fast, low memory (~20Mi per sidecar), easy to install, automatic mTLS out of the box<br><strong>Cons:</strong> fewer traffic management features, smaller ecosystem<br><br>Best for: small-to-medium clusters, teams that want mTLS and observability without Istio's complexity.</div></div>"
                                            },
                                            {
                                                "when": {
                                                    "resolver": "k8sFieldValue",
                                                    "equals": "consul"
                                                },
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸŸ¢ Consul Connect selected</div><div class=\"state-detail\">HashiCorp's service mesh. Envoy-based with deep integration into the HashiCorp ecosystem (Vault, Nomad, Terraform).<br><br><strong>Pros:</strong> multi-platform (K8s + VMs + bare metal), built-in service discovery, Vault integration for cert management<br><strong>Cons:</strong> heavier ops overhead, requires Consul servers<br><br>Best for: hybrid environments, teams already using HashiCorp tools.</div></div>"
                                            },
                                            {
                                                "when": {
                                                    "resolver": "k8sFieldValue",
                                                    "equals": "kuma"
                                                },
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ» Kuma selected</div><div class=\"state-detail\">CNCF-graduated mesh by Kong. Envoy-based with multi-zone and multi-mesh support.<br><br><strong>Pros:</strong> simple UX, multi-zone federation, supports both K8s and Universal (VM) mode<br><strong>Cons:</strong> smaller community than Istio, fewer third-party integrations<br><br>Best for: teams wanting Envoy power with simpler operations, multi-cluster setups.</div></div>"
                                            }
                                        ],
                                        "children": []
                                    },
                                    {
                                        "id": "k8s-cfg-mesh-enable",
                                        "title": "Enable Sidecar Injection",
                                        "icon": "âœ…",
                                        "selector": ".k8s-mesh-field-enable",
                                        "content": "Toggles mesh sidecar injection for this pod. When enabled, the mesh control plane's mutating webhook adds a proxy container during scheduling.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">âœ… Sidecar Injection</div><div class=\"state-detail\">This checkbox controls whether the mesh proxy is injected into the pod. It works by adding an annotation (e.g. <code>sidecar.istio.io/inject: \"true\"</code>) to the pod template.<br><br>When enabled:<br>â€¢ A proxy container (Envoy, linkerd-proxy, etc.) is added to every pod<br>â€¢ All inbound and outbound traffic is routed through the proxy<br>â€¢ mTLS, retries, circuit breaking, and telemetry are automatically applied<br><br>When disabled: the pod communicates directly â€” no mesh features, no proxy overhead.<br><br>âš ï¸ The mesh control plane (Istio, Linkerd, etc.) must be installed on your cluster for injection to work. Without it, the annotation is ignored.</div></div>",
                                        "children": []
                                    },
                                    {
                                        "id": "k8s-cfg-mesh-resources",
                                        "title": "Proxy Resources",
                                        "icon": "ğŸ“Š",
                                        "selector": ".k8s-mesh-field-resources",
                                        "content": "CPU and memory requests/limits for the mesh proxy sidecar. These are added to the pod's total resource footprint.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“Š Proxy Resources</div><div class=\"state-detail\">The mesh proxy consumes its own CPU and memory. These values become annotations that the mesh control plane reads during injection.<br><br>Typical ranges:<br>â€¢ <strong>CPU Request:</strong> 100m (0.1 core) â€” baseline for modest traffic<br>â€¢ <strong>CPU Limit:</strong> 500mâ€“1000m â€” spike headroom for high-throughput services<br>â€¢ <strong>Mem Request:</strong> 128Mi â€” Envoy's base working set<br>â€¢ <strong>Mem Limit:</strong> 256Miâ€“512Mi â€” increase for services with many active connections<br><br>Under-provisioning causes throttling (CPU) or OOM-kills (memory) on the proxy â€” your app stays up but all traffic stops flowing.<span class=\"assistant-tip\">These resources are <em>in addition to</em> your main container's resources. If your app needs 256Mi and the proxy needs 128Mi, the pod needs at least 384Mi total.</span></div></div>",
                                        "children": []
                                    },
                                    {
                                        "id": "k8s-cfg-mesh-advanced",
                                        "title": "Advanced Mesh Config",
                                        "icon": "ğŸ”§",
                                        "selector": ".k8s-mesh-field-advanced",
                                        "content": "Port exclusions and logging â€” fine-tune which traffic goes through the mesh proxy and what gets logged.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ”§ Advanced Mesh Config</div><div class=\"state-detail\"><strong>Exclude inbound ports</strong> â€” traffic arriving on these ports bypasses the mesh proxy entirely. Use for health check ports that shouldn't be wrapped in mTLS, or for protocols the proxy doesn't understand (e.g. MySQL wire protocol on 3306).<br><br><strong>Exclude outbound ports</strong> â€” outgoing connections to these ports bypass the proxy. Useful for external databases or services that don't participate in the mesh.<br><br><strong>Log level</strong> â€” controls the proxy's verbosity. <code>warning</code> is the right default. Switch to <code>info</code> or <code>debug</code> to troubleshoot connectivity, then switch back â€” debug logging on Envoy generates enormous volumes.<span class=\"assistant-tip\">Port exclusions become annotations like <code>traffic.sidecar.istio.io/excludeInboundPorts</code>. They're mesh-provider-specific â€” the wizard generates the right annotation for your selected provider.</span></div></div>",
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "id": "k8s-cfg-init",
                                "title": "Init Containers",
                                "icon": "â³",
                                "selector": ".k8s-field-init",
                                "content": "Init containers run <strong>to completion</strong> before the main container starts. They execute sequentially â€” each must succeed before the next begins.<div class=\"assistant-state-card state-info\" style=\"margin-top:0.4rem\"><div class=\"state-detail\"><strong>Wait for TCP</strong> â€” blocks until a dependency port is accepting connections (e.g. wait for Postgres on port 5432)<br><strong>Wait for HTTP</strong> â€” blocks until an HTTP endpoint returns 200 (e.g. wait for an API to be ready)<br><strong>Run migrations</strong> â€” executes database migrations before the app starts<br><strong>Fix permissions</strong> â€” <code>chown</code>/<code>chmod</code> on mounted volumes before the non-root main container reads them<br><strong>Custom</strong> â€” any one-off setup task with your own image and command</div></div><span class=\"assistant-tip\">Init containers share the pod's volumes. Use them to pre-populate data, wait for dependencies, or fix filesystem permissions.</span>",
                                "children": [
                                    {
                                        "id": "k8s-cfg-init-row",
                                        "title": "Init Container",
                                        "icon": "â³",
                                        "selector": ".k8s-init-row",
                                        "content": "One init container â€” runs to completion before the main container starts. Order matters: they execute sequentially by their number.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â³ Init Container</div><div class=\"state-detail\">This container runs <strong>once</strong> and must exit with code 0 before the next init container (or the main container) starts.<br><br>If it fails, the pod enters <code>Init:CrashLoopBackOff</code> â€” the main container never starts. This is intentional: it prevents your app from booting before its dependencies are ready.<br><br>Init containers are re-run on pod restart, so they must be <strong>idempotent</strong> â€” running them twice should produce the same result.<span class=\"assistant-tip\">Init containers share the pod's volumes. A \"fix permissions\" init can <code>chown</code> a PVC before the non-root main container reads it.</span></div></div>",
                                        "children": [
                                            {
                                                "id": "k8s-cfg-init-name",
                                                "title": "Container Name",
                                                "icon": "ğŸ·ï¸",
                                                "selector": ".k8s-init-field-name",
                                                "content": "A unique name for this init container within the pod. Must be a valid DNS label â€” lowercase, letters, numbers, hyphens.",
                                                "children": []
                                            },
                                            {
                                                "id": "k8s-cfg-init-image",
                                                "title": "Image",
                                                "icon": "ğŸ“¦",
                                                "selector": ".k8s-init-field-image",
                                                "content": "The container image for this init task. Use lightweight images â€” init containers run once and exit.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“¦ Init Container Image</div><div class=\"state-detail\">Common choices:<br>â€¢ <code>busybox:1.36</code> â€” shell utilities for wait-for, file operations<br>â€¢ <code>curlimages/curl:latest</code> â€” HTTP health checks<br>â€¢ Your app image itself â€” for migration runners that use the same codebase<br><br>Keep init images small. They're pulled on every pod schedule, not just once. A 500MB init image adds 500MB to your cold-start time.</div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "k8s-cfg-init-command",
                                                "title": "Command",
                                                "icon": "âŒ¨ï¸",
                                                "selector": ".k8s-init-field-command",
                                                "content": "The command this init container runs. It must exit with code 0 for the pod to proceed.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">âŒ¨ï¸ Init Command</div><div class=\"state-detail\">The command entry overrides the image's default <code>ENTRYPOINT</code>. Common patterns:<br><br>â€¢ <strong>Wait for TCP:</strong> <code>sh -c \"until nc -z postgres 5432; do sleep 2; done\"</code><br>â€¢ <strong>Wait for HTTP:</strong> <code>sh -c \"until curl -sf http://api:8080/health; do sleep 2; done\"</code><br>â€¢ <strong>Fix permissions:</strong> <code>sh -c \"chown -R 1000:1000 /data\"</code><br>â€¢ <strong>Run migrations:</strong> leave empty if the image's default entrypoint runs migrations<br><br>Wrap complex commands in <code>sh -c \"...\"</code> to use shell features like loops, pipes, and boolean operators.</div></div>",
                                                "children": []
                                            }
                                        ]
                                    }
                                ]
                            },
                            {
                                "id": "k8s-cfg-sidecar",
                                "title": "Sidecar Containers",
                                "icon": "ğŸš—",
                                "selector": ".k8s-field-sidecar",
                                "content": "Sidecar containers run <strong>alongside</strong> the main container for the entire pod lifecycle. They share the pod's network and volumes.<div class=\"assistant-state-card state-info\" style=\"margin-top:0.4rem\"><div class=\"state-detail\"><strong>Log forwarder</strong> â€” tails log files from a shared volume and ships them to your logging stack (Fluentd, Filebeat)<br><strong>Config reloader</strong> â€” watches ConfigMaps/Secrets and hot-reloads the main container when config changes<br><strong>Metrics exporter</strong> â€” exposes Prometheus metrics for apps that don't natively support it<br><strong>Auth proxy</strong> â€” OAuth2 proxy or mTLS termination in front of your app<br><strong>Cloud SQL Proxy</strong> â€” secure connection to GCP Cloud SQL without exposing credentials<br><strong>Vault agent</strong> â€” auto-renews Vault tokens and injects secrets as files</div></div><span class=\"assistant-tip\">Each sidecar adds to the pod's resource footprint. Set resource limits on sidecars to prevent them from starving the main container.</span>",
                                "children": [
                                    {
                                        "id": "k8s-cfg-sidecar-row",
                                        "title": "Sidecar Container",
                                        "icon": "ğŸ“",
                                        "selector": ".k8s-sc-row",
                                        "content": "One sidecar container â€” runs alongside the main container for the entire pod lifecycle. Shares network (localhost) and volumes.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“ Sidecar Container</div><div class=\"state-detail\">This container runs <strong>continuously</strong> alongside your main container. Unlike init containers, it doesn't need to exit â€” it lives for the lifetime of the pod.<br><br>Both containers share:<br>â€¢ <strong>Network namespace</strong> â€” sidecar can reach main container on <code>localhost</code><br>â€¢ <strong>Volumes</strong> â€” shared emptyDir volumes for log files, sockets, or config<br>â€¢ <strong>Lifecycle</strong> â€” both start and stop together (K8s â‰¥ 1.28 with native sidecars)<br><br>Sidecar resource usage adds to the pod's total. Account for CPU and memory requests when sizing your nodes.<span class=\"assistant-tip\">If the \"Native sidecar\" checkbox is on, K8s treats this as a <code>restartPolicy: Always</code> init container â€” it starts before the main container and outlives it. This is the recommended approach for K8s â‰¥ 1.28.</span></div></div>",
                                        "children": [
                                            {
                                                "id": "k8s-cfg-sc-name",
                                                "title": "Container Name",
                                                "icon": "ğŸ·ï¸",
                                                "selector": ".k8s-sc-field-name",
                                                "content": "A unique name for this sidecar within the pod. Convention: describe the function â€” log-forwarder, auth-proxy, vault-agent.",
                                                "children": []
                                            },
                                            {
                                                "id": "k8s-cfg-sc-image",
                                                "title": "Image",
                                                "icon": "ğŸ“¦",
                                                "selector": ".k8s-sc-field-image",
                                                "content": "The container image for this sidecar. Use the vendor's official image where available.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“¦ Sidecar Image</div><div class=\"state-detail\">Common sidecar images:<br>â€¢ <code>fluent/fluent-bit:2.2</code> â€” log collection and forwarding<br>â€¢ <code>jimmidyson/configmap-reload:v0.13</code> â€” ConfigMap change detection<br>â€¢ <code>prom/statsd-exporter:v0.26</code> â€” StatsD â†’ Prometheus metrics<br>â€¢ <code>oauth2-proxy/oauth2-proxy:v7</code> â€” OAuth2/OIDC authentication proxy<br>â€¢ <code>gcr.io/cloud-sql-connectors/cloud-sql-proxy:2</code> â€” GCP Cloud SQL<br>â€¢ <code>hashicorp/vault:1.15</code> â€” Vault secret injection<br><br>Pin to a specific tag â€” <code>:latest</code> can break without warning.</div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "k8s-cfg-sc-command",
                                                "title": "Command",
                                                "icon": "âŒ¨ï¸",
                                                "selector": ".k8s-sc-field-command",
                                                "content": "Optional command override. If left empty, the image's default ENTRYPOINT runs â€” which is usually correct for standard sidecar images.",
                                                "children": []
                                            },
                                            {
                                                "id": "k8s-cfg-sc-native",
                                                "title": "Native Sidecar",
                                                "icon": "ğŸ”§",
                                                "selector": ".k8s-sc-field-native",
                                                "content": "Enable the K8s 1.28+ native sidecar feature â€” the sidecar starts before the main container and stays running until the pod terminates.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ”§ Native Sidecar (K8s â‰¥ 1.28)</div><div class=\"state-detail\">Native sidecars use the <code>SidecarContainers</code> feature gate (stable in K8s 1.29). They're defined as init containers with <code>restartPolicy: Always</code>.<br><br><strong>Benefits over classic sidecars:</strong><br>â€¢ <strong>Startup order</strong> â€” sidecar starts and becomes ready <em>before</em> the main container<br>â€¢ <strong>Shutdown order</strong> â€” sidecar stays running until the main container exits<br>â€¢ <strong>Job compatibility</strong> â€” jobs complete correctly because the sidecar doesn't prevent pod termination<br><br><strong>Classic (unchecked):</strong> plain container in the pod's <code>containers</code> array. No ordering guarantees â€” both start simultaneously, both terminate on SIGTERM.<br><br>If your cluster is K8s â‰¥ 1.28, always prefer native sidecars.<span class=\"assistant-tip\">âš ï¸ If you're on K8s < 1.28, uncheck this â€” the feature gate doesn't exist and the pod spec will fail validation.</span></div></div>",
                                                "children": []
                                            }
                                        ]
                                    }
                                ]
                            },
                            {
                                "id": "k8s-cfg-companions",
                                "title": "Companion Containers",
                                "icon": "ğŸ“¦",
                                "selector": ".k8s-field-companions",
                                "content": "Services that were moved into this pod â€” they run as additional containers sharing the same network namespace and volumes.",
                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“¦ Companion Containers</div><div class=\"state-detail\">These are services that were originally separate Compose services but have been merged into this pod via \"Move into another pod.\"<br><br>What co-location means:<br>â€¢ <strong>Shared localhost</strong> â€” companion containers reach the main container and each other on <code>127.0.0.1</code><br>â€¢ <strong>Shared volumes</strong> â€” they can mount the host pod's volumes<br>â€¢ <strong>Shared lifecycle</strong> â€” all containers in the pod start, stop, and restart together<br>â€¢ <strong>Single scheduling unit</strong> â€” always on the same node<br><br>This is the Kubernetes equivalent of running multiple processes on the same machine. Use it when two services are tightly coupled (e.g. app + nginx reverse proxy, app + log processor).<br><br>Each companion keeps its own image, port, env vars, and resource limits. Use the \"â¤´ Split back\" button to reverse the merge.<span class=\"assistant-tip\">Companions generate additional <code>containers</code> entries in the pod spec â€” NOT separate Deployments. They don't get their own Service resource.</span></div></div>",
                                "children": [
                                    {
                                        "id": "k8s-cfg-comp-row",
                                        "title": "Companion Container",
                                        "icon": "ğŸ“¦",
                                        "selector": ".k8s-comp-row",
                                        "content": "One companion container â€” a service that was merged into this pod. It shares localhost networking, volumes, and lifecycle with the main container.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“¦ Companion Container</div><div class=\"state-detail\">This was originally a standalone service that was merged into this pod via \"Move into another pod.\" It now runs as an additional <code>containers</code> entry in the same pod spec.<br><br>In Kubernetes, all containers in a pod:<br>â€¢ Share the same <strong>network namespace</strong> â€” reach each other on <code>localhost</code><br>â€¢ Share the same <strong>IPC namespace</strong> â€” can use shared memory<br>â€¢ Can mount the same <strong>volumes</strong><br>â€¢ Are <strong>co-scheduled</strong> â€” always on the same node<br>â€¢ Share the same <strong>lifecycle</strong> â€” restart together on failure<br><br>The companion keeps its own image, port, env vars, resource limits, and volumes. Edit any of these below.<span class=\"assistant-tip\">Use \"â¤´ Split back\" to restore this as an independent Deployment with its own Service.</span></div></div>",
                                        "children": [
                                            {
                                                "id": "k8s-cfg-comp-image",
                                                "title": "Image",
                                                "icon": "ğŸ“¦",
                                                "selector": ".k8s-comp-field-image",
                                                "content": "The container image for this companion. This was carried over from the original service card â€” edit it here if needed.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“¦ Companion Image</div><div class=\"state-detail\">The image is inherited from the original service configuration. You can override it here without affecting the original.<br><br>Since this companion runs inside another pod, the image is pulled exactly like any other container in the pod â€” same pull policy, same image pull secrets.<br><br>If the companion was split back, the image value is written back to the original service card.</div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "k8s-cfg-comp-port",
                                                "title": "Port",
                                                "icon": "ğŸ”Œ",
                                                "selector": ".k8s-comp-field-port",
                                                "content": "The port this companion listens on. Since it shares the pod's network, it's reachable from the main container on localhost.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ”Œ Companion Port</div><div class=\"state-detail\">Because all containers in a pod share the same network namespace, this port is accessible on <code>localhost:PORT</code> from the main container and any other companions.<br><br><strong>Important:</strong> ports must be unique across all containers in the pod. If the main container runs on 8080 and this companion also uses 8080, there's a port conflict â€” one container will fail to bind.<br><br>This port is declared in the pod spec's <code>containerPort</code> but does NOT create a Kubernetes Service endpoint. Only the main service's port is exposed externally.<span class=\"assistant-tip\">For a reverse proxy pattern (nginx on 80 â†’ app on 8080), the main service's <code>targetPort</code> should point at the proxy's port, not the app's.</span></div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "k8s-cfg-comp-dep",
                                                "title": "Startup Dependency",
                                                "icon": "â³",
                                                "selector": ".k8s-comp-field-dep",
                                                "content": "Select an infrastructure service this companion depends on â€” a wait-for init container will be generated to delay startup until the dependency is ready.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â³ Startup Dependency</div><div class=\"state-detail\">When you select an infra service here, the wizard generates a <code>wait-for-tcp</code> init container that blocks the pod from starting until the selected service is accepting connections.<br><br>The init container uses Kubernetes internal DNS to resolve the dependency:<br><code>until nc -z SERVICE_NAME PORT; do sleep 2; done</code><br><br>This ensures the companion (and the main container) don't start until the database, cache, or broker is ready.<br><br><strong>â¸ None</strong> means no startup dependency â€” the companion starts immediately with the rest of the pod.<span class=\"assistant-tip\">The init container is added to the pod, not just the companion â€” so all containers in the pod wait. If only the companion needs the dependency, consider whether it should be a separate Deployment instead.</span></div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "k8s-cfg-comp-resources",
                                                "title": "Resource Limits",
                                                "icon": "ğŸ“Š",
                                                "selector": ".k8s-comp-field-resources",
                                                "content": "CPU and memory requests/limits for this companion container. These are added to the pod's total resource footprint.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“Š Companion Resources</div><div class=\"state-detail\">Each container in a pod has its own resource requests and limits. The pod's total is the sum of all containers.<br><br>If the main container requests 256Mi and this companion requests 128Mi, the node must have at least 384Mi available for the pod to schedule.<br><br>Set these carefully â€” an under-provisioned companion can starve the main container, and an over-provisioned one wastes node capacity.<br><br>If left empty, the companion runs without resource constraints â€” it can use any available CPU/memory, which risks being OOM-killed or throttled by other workloads.</div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "k8s-cfg-comp-splitback",
                                                "title": "Split Back",
                                                "icon": "â¤´",
                                                "selector": ".k8s-comp-field-splitback",
                                                "content": "Reverses the merge â€” restores this companion as an independent workload with its own Deployment & Service.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â¤´ Split Back</div><div class=\"state-detail\">This action reverses \"Move into pod\" â€” the companion is extracted back into its own standalone service card.<br><br>What happens on split:<br>â€¢ The companion card disappears from this pod<br>â€¢ The original service card reappears in the main list<br>â€¢ Image, port, env vars, and resource limits are written back to the source card<br>â€¢ The service becomes an independent Deployment with its own replicas, scaling, and Service<br><br>Split back when:<br>â€¢ You need this service to scale independently<br>â€¢ The service has grown and needs its own lifecycle (separate rolling updates)<br>â€¢ Port conflicts make co-location impractical</div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "k8s-cfg-comp-hostvols",
                                                "title": "Host Pod Volumes",
                                                "icon": "ğŸ“",
                                                "selector": ".k8s-comp-field-hostvols",
                                                "content": "Volumes defined on the main service â€” check them to mount into this companion. The list is live-populated when you open this section.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“ Host Pod Volumes</div><div class=\"state-detail\">These are volumes already defined on the host service card. Since all containers in a pod share the same volume set, the companion can mount any of them.<br><br>Check a volume to mount it in this companion at the specified path. The mount path can be different from the main container's mount path â€” each container has its own <code>volumeMounts</code> entry.<br><br>Common patterns:<br>â€¢ <strong>Shared log volume</strong> â€” app writes to <code>/var/log/app</code>, log forwarder reads from the same path<br>â€¢ <strong>Shared socket</strong> â€” nginx reads from <code>/tmp/app.sock</code>, app writes to it<br>â€¢ <strong>Config volume</strong> â€” ConfigMap mounted for both app and config-reloader<br><br>This list is live-detected â€” it reflects the current state of the host service's volume section.</div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "k8s-cfg-comp-ownvols",
                                                "title": "Companion Volumes",
                                                "icon": "ğŸ“¦",
                                                "selector": ".k8s-comp-field-ownvols",
                                                "content": "Volumes that belong to this companion â€” carried over from the original service or added manually.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“¦ Companion-Own Volumes</div><div class=\"state-detail\">These are volumes that were carried over from the original service when it was moved into this pod, plus any you've added manually.<br><br>Each volume creates a new entry in the pod's <code>volumes</code> array. All containers in the pod can potentially mount them, but by default only this companion does.<br><br>Volume types:<br>â€¢ <strong>ğŸ“‚ emptyDir</strong> â€” temporary storage, erased on pod restart. Good for scratch space.<br>â€¢ <strong>ğŸ’¾ PVC</strong> â€” persistent storage that survives pod restarts. Creates a PersistentVolumeClaim.<br>â€¢ <strong>ğŸ“„ ConfigMap</strong> â€” mounts a ConfigMap as files. Read-only.<br>â€¢ <strong>ğŸ” Secret</strong> â€” mounts a Secret as files. Read-only, suitable for certs or config files with credentials.</div></div>",
                                                "children": []
                                            }
                                        ]
                                    }
                                ]
                            },
                            {
                                "id": "k8s-cfg-moveto",
                                "title": "Move into Pod",
                                "icon": "â¤µ",
                                "selector": ".k8s-field-moveto",
                                "content": "Merge this service into another service's pod as a companion container. They'll share network, volumes, and lifecycle.",
                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â¤µ Move into Another Pod</div><div class=\"state-detail\">This action converts the current service from a standalone workload into a <strong>companion container</strong> inside another service's pod.<br><br>What happens:<br>â€¢ This service's card disappears from the main list<br>â€¢ It appears as a companion card inside the target service<br>â€¢ Its image, port, env vars, and volumes are preserved<br>â€¢ A wait-for init container can be auto-generated if there's a startup dependency<br><br><strong>When to use:</strong><br>â€¢ Nginx/Caddy reverse proxy in front of an app â€” they need localhost communication<br>â€¢ App + log processor that reads the app's log files from a shared volume<br>â€¢ API gateway + backend that must be co-located for latency<br><br><strong>When NOT to use:</strong><br>â€¢ Services that scale independently (web frontend vs. API backend)<br>â€¢ Services with different resource profiles (lightweight API vs. memory-heavy ML model)<br>â€¢ Services that need separate rolling updates<br><br>The merge is reversible â€” use \"â¤´ Split back\" on the companion card to restore it as an independent service.</div></div>",
                                "children": []
                            }
                        ]
                    }
                ]
            },
            {
                "id": "k8s-cfg-infra-section",
                "title": "Infrastructure Services",
                "icon": "ğŸ—ï¸",
                "selector": "#k8s-infra-list",
                "separator": true,
                "content": "Backing services your app depends on â€” databases, caches, brokers. Each becomes a K8s workload or an external reference depending on the kind you choose.",
                "variants": [
                    {
                        "when": {
                            "hasSelector": ".k8s-infra-card"
                        },
                        "content": "Infrastructure services configured â€” each card controls how a backing service is deployed. The kind dropdown is the most important decision per service.",
                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ—ï¸ Infrastructure Services</div><div class=\"state-detail\">Each card represents a backing service. The <strong>kind dropdown</strong> at the top of each card is the single most important choice:<br><br><strong>ğŸ—„ï¸ StatefulSet</strong> â€” the default for databases and caches. Gives each pod a stable hostname and dedicated PVC. Use for PostgreSQL, MySQL, MongoDB, Redis with persistence.<br><br><strong>â˜ï¸ Managed</strong> â€” the service lives outside K8s (AWS RDS, GCP Cloud SQL, Azure Cosmos DB). No workload is generated â€” only connection env vars are injected as Secrets into dependent pods.<br><br><strong>â­ï¸ Skip</strong> â€” excluded entirely. No manifests, no Secrets. Use for dev-only services (adminer, mailhog) that don't belong in K8s.<br><br>App services in the section above can check these as dependencies to unlock env var injection.<span class=\"assistant-tip\">Use the \"+&nbsp;Add infrastructure service\" dropdown below to add services from the catalog (PostgreSQL, Redis, RabbitMQ, etc.) even if they weren't in your Compose file.</span></div></div>"
                    }
                ],
                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“­ No Infrastructure Services</div><div class=\"state-detail\">No infrastructure services detected from your Docker Compose file, and none added manually.<br><br>If your app connects to a database, cache, or message broker, add them here using the \"+&nbsp;Add infrastructure service\" dropdown. The catalog includes pre-configured templates for:<br><br>â€¢ <strong>Databases</strong> â€” PostgreSQL, MySQL, MariaDB, MongoDB<br>â€¢ <strong>Caches</strong> â€” Redis, Memcached, Valkey<br>â€¢ <strong>Brokers</strong> â€” RabbitMQ, Kafka, NATS<br>â€¢ <strong>Search</strong> â€” Elasticsearch, Meilisearch<br>â€¢ <strong>Storage</strong> â€” MinIO (S3-compatible)<br><br>Each comes with default image, ports, and env vars. You can also add custom services by name.<br><br>If your app is truly standalone, skip this section â€” it's optional.</div></div>",
                "children": [
                    {
                        "id": "k8s-cfg-infra-card",
                        "title": "Infrastructure Service",
                        "icon": "ğŸ—ï¸",
                        "selector": ".k8s-infra-card",
                        "content": "A backing service card â€” configure how this infrastructure component is deployed in your cluster.",
                        "expanded": "{{k8sInfraCardHover}}",
                        "children": [
                            {
                                "id": "k8s-cfg-infra-kind",
                                "title": "Workload Kind",
                                "icon": "ğŸ“¦",
                                "selector": ".k8s-infra-field-kind",
                                "content": "How this infrastructure service is deployed in Kubernetes â€” StatefulSet, Deployment, Managed externally, or Skip entirely.",
                                "variants": [
                                    {
                                        "when": {
                                            "resolver": "k8sInfraKind",
                                            "equals": "StatefulSet"
                                        },
                                        "icon": "ğŸ—„ï¸",
                                        "content": "StatefulSet â€” stable pod identity + persistent storage. The right choice for most databases and stateful caches.",
                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ—„ï¸ StatefulSet</div><div class=\"state-detail\">Each pod gets a stable DNS name (e.g. <code>postgres-0.postgres</code>) and its own PersistentVolumeClaim.<br><br>Key behaviors:<br>â€¢ <strong>Ordered startup</strong> â€” pods start sequentially (0, then 1, then 2)<br>â€¢ <strong>Stable storage</strong> â€” PVCs are not deleted when pods are rescheduled<br>â€¢ <strong>Headless Service</strong> â€” each pod is individually addressable by name<br>â€¢ <strong>Ordered shutdown</strong> â€” pods are terminated in reverse order<br><br>This is the correct choice for PostgreSQL, MySQL, MongoDB, Redis with AOF/RDB, Elasticsearch, and any service that writes to disk.<span class=\"assistant-tip\">If you switch to Managed later, the PVC and StatefulSet manifests are removed â€” only env var Secrets remain.</span></div></div>"
                                    },
                                    {
                                        "when": {
                                            "resolver": "k8sInfraKind",
                                            "equals": "Deployment"
                                        },
                                        "icon": "ğŸš€",
                                        "content": "Deployment â€” stateless replicas with rolling updates. Be careful: most infrastructure services need stable storage and Deployment doesn't provide it.",
                                        "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">ğŸš€ Deployment</div><div class=\"state-detail\">Pods are interchangeable â€” no stable hostname, no dedicated PVC. Data stored in ephemeral storage is lost on pod restart.<br><br>âš ï¸ <strong>Warning:</strong> Deployment is usually wrong for databases. If this service writes data to disk (PostgreSQL, MySQL, MongoDB, Redis with persistence), switch to <strong>StatefulSet</strong>.<br><br>Appropriate for: Nginx reverse proxy, HAProxy, Traefik, Vault in HA mode, or any infrastructure service that is truly stateless.<span class=\"assistant-tip\">If you're using a Deployment because you want auto-scaling, consider StatefulSet + HPA instead â€” it preserves stable identity while allowing scaling.</span></div></div>"
                                    },
                                    {
                                        "when": {
                                            "resolver": "k8sInfraKind",
                                            "equals": "DaemonSet"
                                        },
                                        "icon": "ğŸŒ",
                                        "content": "DaemonSet â€” one pod per node. Used for node-level infrastructure like log collectors or monitoring agents.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸŒ DaemonSet</div><div class=\"state-detail\">One pod per node â€” automatically scales as nodes join or leave. No replica count needed.<br><br>Appropriate for:<br>â€¢ Log collectors (Fluentd, Filebeat, Vector)<br>â€¢ Monitoring agents (node-exporter, Datadog agent)<br>â€¢ Network plugins, storage drivers<br><br>Rarely appropriate for databases, caches, or message brokers â€” those need explicit replica counts and stable identity.</div></div>"
                                    },
                                    {
                                        "when": {
                                            "resolver": "k8sInfraKind",
                                            "equals": "Managed"
                                        },
                                        "icon": "â˜ï¸",
                                        "content": "Managed externally â€” no K8s workload generated. Connection variables are injected as Secrets into dependent pods.",
                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">â˜ï¸ Managed Externally</div><div class=\"state-detail\">This service lives outside your Kubernetes cluster â€” you handle provisioning and lifecycle separately.<br><br>What happens:<br>â€¢ <strong>No Deployment/StatefulSet</strong> generated<br>â€¢ <strong>No Service</strong> resource â€” your app connects via the provider's endpoint<br>â€¢ Connection env vars below are packaged as K8s <strong>Secrets</strong> and injected into dependent pods<br><br>Fill in the <strong>Provider / Notes</strong> field below for documentation. Set the env var values to your managed service's actual connection strings.<br><br>Common providers: AWS RDS, GCP Cloud SQL, Azure Database, Amazon ElastiCache, GCP Memorystore, Confluent Cloud, Amazon MQ.</div></div>"
                                    },
                                    {
                                        "when": {
                                            "resolver": "k8sInfraKind",
                                            "equals": "Skip"
                                        },
                                        "icon": "â­ï¸",
                                        "content": "Skipped â€” no K8s resources will be generated for this service at all.",
                                        "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">â­ï¸ Excluded</div><div class=\"state-detail\">This service will not appear in any generated manifest. No Deployment, no Service, no Secrets, no ConfigMap.<br><br>Use this for:<br>â€¢ Development-only tools (adminer, pgadmin, mailhog, phpmyadmin)<br>â€¢ Services you manage entirely outside this wizard<br>â€¢ Compose services that don't translate to K8s (e.g. bind-mount-only build tools)<br><br>âš ï¸ If app services depend on this service, their dependency checkbox will still be visible â€” but no env vars will be injected. Make sure connection details are handled manually.<span class=\"assistant-tip\">You can remove the card entirely with the âœ• button â€” \"Skip\" keeps it visible for reference while excluding it from generation.</span></div></div>"
                                    }
                                ],
                                "children": []
                            },
                            {
                                "id": "k8s-cfg-infra-provider",
                                "title": "Provider / Notes",
                                "icon": "â˜ï¸",
                                "selector": ".k8s-infra-field-provider",
                                "content": "Document which managed provider hosts this service â€” helpful for the team and for future reference in generated comments.",
                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â˜ï¸ Provider / Notes</div><div class=\"state-detail\">This field appears when the service is set to <strong>Managed (external)</strong>. It's for documentation â€” the value isn't used in manifests but helps your team understand what backs this service.<br><br>Examples:<br>â€¢ <code>AWS RDS PostgreSQL 15, us-east-1</code><br>â€¢ <code>GCP Cloud SQL MySQL 8.0, project-id</code><br>â€¢ <code>Azure Cosmos DB (MongoDB API)</code><br>â€¢ <code>Self-hosted on bare metal at 10.0.1.50</code><br><br>The connection details that matter (host, port, credentials) go in the env vars below.</div></div>",
                                "children": []
                            },
                            {
                                "id": "k8s-cfg-infra-env",
                                "title": "Environment Variables",
                                "icon": "ğŸ“‹",
                                "selector": ".k8s-infra-field-env",
                                "content": "Environment variables for this infrastructure service â€” credentials, connection strings, and configuration. Each becomes a ConfigMap entry or Secret depending on the injection type.",
                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“‹ Environment Variables</div><div class=\"state-detail\">Each row configures one env var for this infrastructure service:<br><br>â€¢ <strong>Key</strong> â€” the variable name as the service expects it (e.g. <code>POSTGRES_PASSWORD</code>)<br>â€¢ <strong>Value</strong> â€” default from Compose or catalog; override as needed<br>â€¢ <strong>Var / Secret</strong> â€” optionally source from a K8s Secret or ConfigMap reference<br>â€¢ <strong>Injection</strong> â€” <code>hardcoded</code> (in manifest), <code>variable</code> (ConfigMap ref), or <code>secret</code> (Secret ref)<br><br>ğŸ”’ Keys containing <code>PASSWORD</code>, <code>SECRET</code>, or <code>KEY</code> are auto-classified as secrets. Override the injection type if the auto-detection is wrong.<br><br>When app services check this service as a dependency, these keys become available for injection into the app's own env vars.<span class=\"assistant-tip\">For <strong>Managed</strong> services, these are labeled \"Connection Environment Variables\" â€” they represent the external service's connection details, not container configuration.</span></div></div>",
                                "children": [
                                    {
                                        "id": "k8s-cfg-infra-env-row",
                                        "title": "Environment Variable",
                                        "icon": "ğŸ“‹",
                                        "selector": ".k8s-env-row",
                                        "content": "One environment variable â€” key, value, optional vault/secret source, and injection type.",
                                        "variants": [
                                            {
                                                "when": {
                                                    "hasSelector": "select.k8s-env-field-injection option:checked[value='secret']"
                                                },
                                                "icon": "ğŸ”’",
                                                "content": "ğŸ”’ Secret injection â€” this key's value will be stored in a K8s Secret and mounted into the pod via <code>secretKeyRef</code>. The value never appears in your manifest YAML.",
                                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ”’ Secret Injection</div><div class=\"state-detail\">The value for this key is stored in a Kubernetes <code>Secret</code> object (base64-encoded, optionally encrypted at rest with KMS).<br><br>At deploy time, it's injected via:<br><code>envFrom â†’ secretKeyRef â†’ {secret-name}.{key}</code><br><br>This is the right choice for passwords, API keys, tokens, and connection strings containing credentials. The value won't appear in your Deployment YAML, ConfigMap, or <code>kubectl describe</code> output.<span class=\"assistant-tip\">If the variable doesn't exist in your vault yet, the wizard will offer to create it during execution.</span></div></div>"
                                            },
                                            {
                                                "when": {
                                                    "hasSelector": "select.k8s-env-field-injection option:checked[value='variable']"
                                                },
                                                "icon": "ğŸ”„",
                                                "content": "ğŸ”„ Variable injection â€” this key's value comes from a ConfigMap entry. Good for non-sensitive config that varies between environments.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ”„ Variable Injection</div><div class=\"state-detail\">The value for this key is stored in a Kubernetes <code>ConfigMap</code> and injected via:<br><code>envFrom â†’ configMapKeyRef â†’ {configmap-name}.{key}</code><br><br>ConfigMaps are <strong>not encrypted</strong> â€” anyone with namespace read access can see the values. Use this for:<br>â€¢ Database names, hosts, ports<br>â€¢ Feature flags, log levels<br>â€¢ Non-sensitive connection parameters<br><br>For passwords or tokens, switch to <strong>ğŸ”’ Secret</strong> injection instead.</div></div>"
                                            },
                                            {
                                                "when": {
                                                    "hasSelector": "select.k8s-env-field-injection option:checked[value='hardcoded']"
                                                },
                                                "icon": "ğŸ“‹",
                                                "content": "ğŸ“‹ Hardcoded â€” written directly into the container spec. Simple but inflexible â€” changing requires a new deployment.",
                                                "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">ğŸ“‹ Hardcoded</div><div class=\"state-detail\">The value is written directly into the Deployment/StatefulSet manifest as an inline <code>env</code> entry:<br><code>env: [{name: KEY, value: \"...\"}]</code><br><br>âš ï¸ <strong>Avoid for sensitive values</strong> â€” hardcoded values are visible in <code>kubectl get deployment -o yaml</code>, in your Git history, and in any CI/CD logs that display manifests.<br><br>Best for: truly static values that never change between environments (e.g. <code>TZ=UTC</code>).<br><br>For anything environment-specific, switch to <strong>ğŸ”„ Variable</strong>. For anything sensitive, use <strong>ğŸ”’ Secret</strong>.</div></div>"
                                            }
                                        ],
                                        "children": [
                                            {
                                                "id": "k8s-cfg-infra-env-key",
                                                "title": "Key",
                                                "icon": "ğŸ·ï¸",
                                                "selector": ".k8s-env-field-key",
                                                "content": "The environment variable name â€” exactly as the service expects it. Case-sensitive. Convention is UPPER_SNAKE_CASE.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ·ï¸ Variable Key</div><div class=\"state-detail\">This becomes the <code>name</code> field in the pod's <code>env</code> or <code>envFrom</code> spec. The service reads it at startup via <code>os.getenv(\"KEY\")</code> or equivalent.<br><br>Common conventions:<br>â€¢ <code>POSTGRES_PASSWORD</code> â€” PostgreSQL superuser password<br>â€¢ <code>REDIS_URL</code> â€” Redis connection string<br>â€¢ <code>RABBITMQ_DEFAULT_USER</code> â€” RabbitMQ credentials<br><br>Renaming a key here doesn't rename it in the service â€” make sure it matches what the container image expects. Check the image's documentation if unsure.</div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "k8s-cfg-infra-env-value",
                                                "title": "Value",
                                                "icon": "âœï¸",
                                                "selector": ".k8s-env-field-value",
                                                "content": "The value for this variable. Visible when injection is hardcoded â€” hidden when sourced from a variable or secret.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">âœï¸ Variable Value</div><div class=\"state-detail\">This field is only visible when injection type is <strong>ğŸ“‹ Hardcoded</strong>. For Variable and Secret injection, the value comes from your vault or ConfigMap/Secret â€” you pick the source in the Var/Secret dropdown instead.<br><br>Pre-filled values come from your Compose file or the catalog template. Defaults like <code>changeme</code> or <code>postgres</code> are placeholders â€” <strong>always override for production</strong>.<br><br>For password fields, the input is masked. The value is still stored in plaintext in the manifest unless you switch to Secret injection.</div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "k8s-cfg-infra-env-varsecret",
                                                "title": "Var / Secret Source",
                                                "icon": "ğŸ”—",
                                                "selector": ".k8s-env-field-varsecret",
                                                "content": "Which vault variable or secret to source this value from. Only visible when injection is Variable or Secret.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ”— Var / Secret Source</div><div class=\"state-detail\">Pick from existing vault keys, or choose <strong>âŒ¨ Custom</strong> to type a new variable name.<br><br>The dropdown shows variables that match the current injection type â€” <strong>Variables</strong> for ConfigMap injection, <strong>Secrets</strong> for Secret injection. It also includes env vars from dependency services.<br><br>If the selected key doesn't exist yet:<br>â€¢ âš ï¸ A notice appears below the row<br>â€¢ A checkbox lets you create it automatically during wizard execution<br>â€¢ You can optionally set a default value or generate one<br><br>This is how env vars are shared between infrastructure and app services â€” your app's <code>DATABASE_URL</code> can reference the same vault secret as the database's <code>POSTGRES_PASSWORD</code>.</div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "k8s-cfg-infra-env-injection",
                                                "title": "Injection Type",
                                                "icon": "ğŸ’‰",
                                                "selector": ".k8s-env-field-injection",
                                                "content": "How this variable's value reaches the container â€” hardcoded in the manifest, from a ConfigMap (variable), or from a Secret.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ’‰ Injection Type</div><div class=\"state-detail\">Controls how the value is stored and delivered to the pod:<br><br><strong>ğŸ“‹ Hardcoded</strong> â€” inline in the Deployment YAML. Simple but insecure for sensitive data. Visible in Git history, CI logs, and <code>kubectl describe</code>.<br><br><strong>ğŸ”„ Variable</strong> â€” stored in a ConfigMap, referenced via <code>configMapKeyRef</code>. Not encrypted, but separate from the manifest. Ideal for environment-specific non-secret values.<br><br><strong>ğŸ”’ Secret</strong> â€” stored in a K8s Secret, referenced via <code>secretKeyRef</code>. Base64-encoded, optionally encrypted at rest. The right choice for passwords, tokens, and credentials.<br><br>Changing the type toggles the value field (hardcoded) vs. the var/secret dropdown (variable/secret).<span class=\"assistant-tip\">Keys containing PASSWORD, SECRET, KEY, or TOKEN are auto-classified as ğŸ”’ Secret. You can always override.</span></div></div>",
                                                "children": []
                                            }
                                        ]
                                    }
                                ]
                            },
                            {
                                "id": "k8s-cfg-infra-volumes",
                                "title": "Persistent Storage",
                                "icon": "ğŸ’¾",
                                "selector": ".k8s-infra-field-volumes",
                                "content": "Persistent storage for this infrastructure service â€” each volume becomes a PVC + volumeMount in the pod spec.",
                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ’¾ Persistent Storage</div><div class=\"state-detail\">Volumes detected from your Compose file (named volumes) are converted to PersistentVolumeClaims. Each PVC:<br><br>â€¢ Survives pod restarts and rescheduling<br>â€¢ Is bound to the StatefulSet pod by ordinal index<br>â€¢ Uses the cluster's default StorageClass unless you override it<br><br>Common patterns:<br>â€¢ <code>/var/lib/postgresql/data</code> â€” PostgreSQL data directory<br>â€¢ <code>/data</code> â€” Redis, MongoDB default data paths<br>â€¢ <code>/var/lib/mysql</code> â€” MySQL data directory<br><br>Size defaults to 1Gi â€” increase for production databases. You can also add volumes for backups, logs, or configuration files.<span class=\"assistant-tip\">This section is hidden when the service is set to <strong>Managed</strong> or <strong>Skip</strong> â€” managed services handle their own storage, and skipped services generate nothing.</span></div></div>",
                                "children": []
                            }
                        ]
                    }
                ]
            },
            {
                "id": "k8s-cfg-infra-add",
                "title": "Add Infrastructure Service",
                "icon": "â•",
                "selector": ".k8s-field-infra-add",
                "content": "Pick from the catalog to add a pre-configured backing service â€” databases, caches, brokers, search engines. Each comes with default image, ports, and env vars.",
                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â• Add Infrastructure Service</div><div class=\"state-detail\">The dropdown contains pre-configured templates for common infrastructure:<br><br>â€¢ <strong>Databases</strong> â€” PostgreSQL, MySQL, MariaDB, MongoDB<br>â€¢ <strong>Caches</strong> â€” Redis, Memcached, Valkey<br>â€¢ <strong>Brokers</strong> â€” RabbitMQ, Kafka, NATS<br>â€¢ <strong>Search</strong> â€” Elasticsearch, Meilisearch<br>â€¢ <strong>Storage</strong> â€” MinIO (S3-compatible)<br><br>Each template sets a sensible image, ports, and env vars. You can also type a custom name to create a blank service card.<br><br>Services added here behave identically to those detected from Compose â€” app services can check them as dependencies to get env var injection.<span class=\"assistant-tip\">This is useful even if you started from a Compose file â€” add services you plan to introduce later for the K8s environment.</span></div></div>",
                "children": []
            },
            {
                "id": "k8s-cfg-cluster-settings",
                "title": "Cluster Settings",
                "icon": "âš™ï¸",
                "selector": "#k8s-cluster-settings",
                "separator": true,
                "content": "Global settings that apply to every resource the wizard generates â€” namespace, output path, and optional extras like Ingress, Skaffold, and Helm.",
                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">âš™ï¸ Cluster Settings</div><div class=\"state-detail\">Everything in this section affects all generated manifests, not individual services.<br><br>Think of it as the envelope around your workloads â€” where they live (namespace), where the files go (output dir), and what tooling wraps them (Skaffold, Helm).<br><br>The choices here are safe to change later â€” they don't alter the workload structure, just the metadata and packaging.</div></div>",
                "children": [
                    {
                        "id": "k8s-cfg-namespace",
                        "title": "Namespace",
                        "icon": "ğŸ“›",
                        "selector": "#mf-k8s-namespace",
                        "content": "The Kubernetes namespace all resources will be created in. This is how K8s isolates workloads.",
                        "variants": [
                            {
                                "when": {
                                    "resolver": "k8sFieldValue",
                                    "equals": "default"
                                },
                                "icon": "âš ï¸",
                                "content": "You're using the default namespace â€” that works, but it's risky in shared clusters. Any team's resources can collide with yours.",
                                "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš ï¸ Namespace: default</div><div class=\"state-detail\">The <code>default</code> namespace is where resources land when no namespace is specified. The problem:<br><br>â€¢ <strong>No isolation</strong> â€” other workloads in the cluster share it<br>â€¢ <strong>No resource quotas</strong> â€” cluster admins can't limit your usage independently<br>â€¢ <strong>Harder cleanup</strong> â€” <code>kubectl delete namespace default</code> is destructive in ways you don't want<br>â€¢ <strong>RBAC confusion</strong> â€” permissions meant for other teams may bleed into your resources<br><br>Use a dedicated namespace instead: your project name (<code>my-app</code>), team (<code>backend</code>), or environment-scoped (<code>my-app-staging</code>).<span class=\"assistant-tip\">If the namespace doesn't exist in your cluster yet, create it with <code>kubectl create namespace NAME</code> before deploying.</span></div></div>"
                            },
                            {
                                "when": {
                                    "resolver": "k8sFieldValue",
                                    "equals": ""
                                },
                                "icon": "âŒ",
                                "content": "Namespace is empty â€” every manifest needs a namespace. Without one, resources land in whatever namespace your kubectl context defaults to.",
                                "expanded": "<div class=\"assistant-state-card state-error\"><div class=\"state-label\">âŒ No Namespace Set</div><div class=\"state-detail\">An empty namespace means generated manifests will omit <code>metadata.namespace</code>. The result depends on your kubectl context:<br><br>â€¢ If your context has a default namespace set, resources go there<br>â€¢ If not, they go to <code>default</code><br>â€¢ Either way, it's unpredictable across environments<br><br>Always set an explicit namespace for reproducible deployments.</div></div>"
                            }
                        ],
                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ“› Namespace</div><div class=\"state-detail\">Every generated manifest will include <code>metadata.namespace</code> set to this value.<br><br>A namespace provides:<br>â€¢ <strong>Isolation</strong> â€” resources in different namespaces don't collide by name<br>â€¢ <strong>RBAC scope</strong> â€” you can grant access per namespace<br>â€¢ <strong>Resource quotas</strong> â€” cluster admins can limit CPU/memory per namespace<br>â€¢ <strong>Network policies</strong> â€” isolate traffic between namespaces<br><br>Common patterns: project name (<code>my-app</code>), team (<code>backend</code>), or environment (<code>my-app-staging</code>).<span class=\"assistant-tip\">If the namespace doesn't exist in your cluster yet, you'll need to create it with <code>kubectl create namespace NAME</code> before deploying.</span></div></div>",
                        "children": []
                    },
                    {
                        "id": "k8s-cfg-outputdir",
                        "title": "Output Directory",
                        "icon": "ğŸ“",
                        "selector": "#mf-k8s-output-dir",
                        "content": "Where the wizard writes manifest files. Relative to your project root.",
                        "variants": [
                            {
                                "when": {
                                    "resolver": "k8sFieldValue",
                                    "equals": ""
                                },
                                "icon": "âŒ",
                                "content": "Output directory is empty â€” the wizard needs to know where to write manifest files. The default k8s/ is a common convention.",
                                "expanded": "<div class=\"assistant-state-card state-error\"><div class=\"state-label\">âŒ No Output Directory</div><div class=\"state-detail\">Without an output directory, the wizard won't know where to write generated YAML files. Set it to <code>k8s/</code> (the convention) or any path relative to your project root.</div></div>"
                            },
                            {
                                "when": {
                                    "resolver": "k8sFieldValue",
                                    "equals": "k8s/"
                                },
                                "content": "Standard output directory â€” all manifests will be written to k8s/ in your project root. This is the most common convention.",
                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ“ Output: k8s/</div><div class=\"state-detail\">The standard convention. Works well with:<br>â€¢ <code>kubectl apply -f k8s/</code> â€” deploys everything in one command<br>â€¢ Skaffold â€” its <code>manifests</code> section points at this directory<br>â€¢ Kustomize â€” <code>k8s/base/</code> + <code>k8s/overlays/</code> structure<br><br>Make sure this directory is committed to Git. Consider adding <code>k8s/*-secret.yaml</code> to <code>.gitignore</code> if any manifests contain hardcoded credentials.</div></div>"
                            }
                        ],
                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“ Output Directory</div><div class=\"state-detail\">All generated YAML files land here â€” Deployments, Services, ConfigMaps, Secrets, PVCs, and optional extras. The path is relative to your project root.<br><br>Make sure this directory is committed to Git â€” it's part of your deployment artifact.</div></div>",
                        "children": []
                    },
                    {
                        "id": "k8s-cfg-ingress",
                        "title": "Generate Ingress",
                        "icon": "ğŸŒ",
                        "selector": "#mf-k8s-ingress",
                        "content": "Whether to generate an Ingress manifest for external HTTP access.",
                        "variants": [
                            {
                                "when": {
                                    "hasSelector": "input:checked"
                                },
                                "icon": "âœ…",
                                "content": "Ingress enabled â€” an ingress.yaml will be generated with HTTP routing rules for your services. Make sure you have an Ingress controller installed.",
                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Ingress Enabled</div><div class=\"state-detail\">The wizard will generate an <code>ingress.yaml</code> mapping external HTTP(S) traffic to your ClusterIP services.<br><br><strong>Prerequisites you'll need at deploy time:</strong><br>â€¢ An Ingress controller (nginx-ingress, Traefik, HAProxy)<br>â€¢ For HTTPS: cert-manager or a manual TLS Secret<br>â€¢ DNS pointing to your Ingress controller's external IP<br><br>Locally: <code>minikube addons enable ingress</code> or <code>kind</code> + metallb.<span class=\"assistant-tip\">The DNS/CDN wizard can generate the DNS records pointing at your Ingress â€” run it after K8s setup.</span></div></div>"
                            }
                        ],
                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸŒ Ingress Disabled</div><div class=\"state-detail\">No Ingress manifest will be generated. Your services will only be reachable inside the cluster (ClusterIP) or via NodePort/LoadBalancer if you set that on individual services.<br><br>Leave unchecked if you're using:<br>â€¢ LoadBalancer service type (cloud providers auto-provision an LB)<br>â€¢ A service mesh gateway (Istio, Linkerd)<br>â€¢ An external reverse proxy (Nginx, Caddy outside K8s)<br>â€¢ Local dev with port-forwarding (Skaffold handles this)<br><br>Enable it when you want standard HTTP routing with path-based or host-based rules.</div></div>",
                        "children": []
                    },
                    {
                        "id": "k8s-cfg-skaffold",
                        "title": "Skaffold Pipeline",
                        "icon": "ğŸ›¤",
                        "selector": ".k8s-field-skaffold",
                        "content": "Skaffold automates build â†’ push â†’ deploy for iterative K8s development.",
                        "variants": [
                            {
                                "when": {
                                    "hasSelector": "#k8s-skaffold-toggle:checked"
                                },
                                "icon": "âœ…",
                                "content": "Skaffold enabled â€” a skaffold.yaml will be generated with build artifacts, deploy config, and optional profiles. Configure the details below.",
                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Skaffold Enabled</div><div class=\"state-detail\">The wizard will generate <code>skaffold.yaml</code> with:<br>â€¢ Build artifacts for each app service (uses your Dockerfiles)<br>â€¢ Deploy config pointing at your manifest directory<br>â€¢ Optional profiles for per-environment overrides<br><br>After generation:<br>â€¢ <code>skaffold dev</code> â€” live-reload loop (build â†’ deploy â†’ watch â†’ repeat)<br>â€¢ <code>skaffold run</code> â€” one-shot build + deploy<br>â€¢ <code>skaffold delete</code> â€” tear down everything it created<br><br>Configure the deploy method, tag policy, and toggles below.</div></div>"
                            }
                        ],
                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ›¤ Skaffold Disabled</div><div class=\"state-detail\">No <code>skaffold.yaml</code> will be generated. You'll deploy manually:<br><br>â€¢ <code>docker build -t myapp .</code><br>â€¢ <code>docker push myapp</code><br>â€¢ <code>kubectl apply -f k8s/</code><br><br>This is fine for simple setups or when you have your own CI/CD pipeline. Enable Skaffold when you want automated build-deploy cycles or live-reload during development.</div></div>",
                        "children": [
                            {
                                "id": "k8s-cfg-skf-deploy",
                                "title": "Deploy Method",
                                "icon": "ğŸš€",
                                "selector": ".k8s-field-skf-deploy",
                                "content": "How Skaffold applies manifests to the cluster.",
                                "variants": [
                                    {
                                        "when": {
                                            "resolver": "k8sFieldValue",
                                            "equals": "kustomize"
                                        },
                                        "content": "Kustomize â€” Skaffold will use kustomize overlays to apply manifests. Best for multi-environment setups with base + overlay pattern.",
                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸš€ Deploy: kustomize</div><div class=\"state-detail\">Skaffold will run <code>kustomize build</code> + <code>kubectl apply</code>. This enables the overlay pattern:<br><br>â€¢ <code>k8s/base/</code> â€” shared manifests<br>â€¢ <code>k8s/overlays/dev/</code> â€” dev patches (fewer replicas, debug flags)<br>â€¢ <code>k8s/overlays/prod/</code> â€” prod patches (full replicas, strict resources)<br><br>Kustomize is the default because it's the most flexible â€” you can start simple (flat manifests) and add overlays later without restructuring.<br><br>Requires: <code>kubectl</code> 1.14+ (kustomize is built in) or standalone <code>kustomize</code> CLI.</div></div>"
                                    },
                                    {
                                        "when": {
                                            "resolver": "k8sFieldValue",
                                            "equals": "kubectl"
                                        },
                                        "content": "Raw kubectl â€” Skaffold will apply YAML files directly. Simplest option, no extra tooling required.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸš€ Deploy: kubectl</div><div class=\"state-detail\">Skaffold runs <code>kubectl apply -f</code> against your manifest directory. No kustomization.yaml needed, no overlays â€” just flat YAML.<br><br>Good for:<br>â€¢ Single-environment deployments<br>â€¢ Small projects with few services<br>â€¢ Getting started quickly<br><br>Limitation: per-environment config requires duplicating manifests or using envsubst. If you need env-specific overrides, consider kustomize or helm.</div></div>"
                                    },
                                    {
                                        "when": {
                                            "resolver": "k8sFieldValue",
                                            "equals": "helm"
                                        },
                                        "content": "Helm â€” Skaffold will deploy via helm install/upgrade. Requires Helm chart generation to be enabled below.",
                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸš€ Deploy: helm</div><div class=\"state-detail\">Skaffold runs <code>helm upgrade --install</code> to deploy your chart. Gives you:<br><br>â€¢ <code>values.yaml</code> overrides per environment<br>â€¢ Helm release history and rollback<br>â€¢ Template rendering with <code>{{ .Values.* }}</code><br>â€¢ Dependency management for sub-charts<br><br>Requires the Helm chart toggle below to be enabled. If it's disabled, this option is grayed out.<span class=\"assistant-tip\">Helm deploy works best when your manifests are templatized. The wizard generates templates automatically from your service configuration.</span></div></div>"
                                    }
                                ],
                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸš€ Deploy Method</div><div class=\"state-detail\">Controls which deployer Skaffold uses to apply manifests.</div></div>",
                                "children": []
                            },
                            {
                                "id": "k8s-cfg-skf-tag",
                                "title": "Tag Policy",
                                "icon": "ğŸ·ï¸",
                                "selector": ".k8s-field-skf-tag",
                                "content": "How Skaffold tags built images â€” determines reproducibility and rollback strategy.",
                                "variants": [
                                    {
                                        "when": {
                                            "resolver": "k8sFieldValue",
                                            "equals": "gitCommit"
                                        },
                                        "content": "gitCommit â€” images are tagged with the Git SHA. Fully reproducible: this image = this commit. Best for traceability and rollbacks.",
                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ·ï¸ Tag: gitCommit</div><div class=\"state-detail\">Every built image gets a tag like <code>myapp:abc1234</code> derived from the Git commit SHA.<br><br>Why this is the safest default:<br>â€¢ <strong>Reproducible</strong> â€” you can always rebuild the exact same image from the same commit<br>â€¢ <strong>Traceable</strong> â€” <code>kubectl describe pod</code> â†’ image tag â†’ <code>git show abc1234</code><br>â€¢ <strong>Rollback</strong> â€” <code>git revert</code> + <code>skaffold run</code> deploys the previous version<br><br>Requires a Git repository with at least one commit.</div></div>"
                                    },
                                    {
                                        "when": {
                                            "resolver": "k8sFieldValue",
                                            "equals": "sha256"
                                        },
                                        "content": "sha256 â€” content-hash tag. Rebuilds only happen when files change, not on every commit. Ideal for monorepos with multiple services.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ·ï¸ Tag: sha256</div><div class=\"state-detail\">The tag is a hash of the build context (source files). Two identical file trees produce the same tag â€” no rebuild, no redeploy.<br><br>Great for monorepos: if only the frontend changed, only the frontend image gets a new tag and redeploy. Backend stays untouched.<br><br>Downside: the tag isn't human-readable â€” you can't tell which commit it came from by looking at it.</div></div>"
                                    },
                                    {
                                        "when": {
                                            "resolver": "k8sFieldValue",
                                            "equals": "dateTime"
                                        },
                                        "content": "dateTime â€” timestamp tag. Every build gets a new tag regardless of changes. Simple but not reproducible.",
                                        "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">ğŸ·ï¸ Tag: dateTime</div><div class=\"state-detail\">Tags like <code>myapp:2024-01-15_14-30-00</code>. Every build gets a unique tag.<br><br>âš ï¸ Not reproducible â€” you can't rebuild the same tag from the same source. Two builds from the same commit get different tags.<br><br>Useful for: quick iteration where traceability doesn't matter. Not recommended for production clusters.</div></div>"
                                    },
                                    {
                                        "when": {
                                            "resolver": "k8sFieldValue",
                                            "equals": "inputDigest"
                                        },
                                        "content": "inputDigest â€” hashes build inputs including the Dockerfile. Like sha256 but also considers Dockerfile changes.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ·ï¸ Tag: inputDigest</div><div class=\"state-detail\">Similar to sha256 but the hash includes the Dockerfile itself, not just source files. This means a Dockerfile change triggers a rebuild even if source files haven't changed.<br><br>Best when: you frequently modify Dockerfiles and want changes to always trigger rebuilds. Otherwise sha256 or gitCommit are simpler.</div></div>"
                                    },
                                    {
                                        "when": {
                                            "resolver": "k8sFieldValue",
                                            "equals": "envTemplate"
                                        },
                                        "content": "envTemplate â€” custom tag from environment variables. Advanced â€” build tags like v1.2.3-${BRANCH} from CI vars.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ·ï¸ Tag: envTemplate</div><div class=\"state-detail\">Build custom tags from environment variables using Go template syntax: <code>{{.IMAGE_NAME}}:{{.VERSION}}-{{.GIT_BRANCH}}</code><br><br>Use when: CI pipelines set version variables and you want structured, human-readable tags like <code>myapp:v1.2.3-main</code>.<br><br>Requires the referenced env vars to be set at build time.</div></div>"
                                    }
                                ],
                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ·ï¸ Tag Policy</div><div class=\"state-detail\">Controls the image tag Skaffold generates after each build.</div></div>",
                                "children": []
                            },
                            {
                                "id": "k8s-cfg-skf-profiles",
                                "title": "Profiles",
                                "icon": "ğŸ“‹",
                                "selector": ".k8s-field-skf-profiles",
                                "content": "Named configurations for per-environment overrides.",
                                "variants": [
                                    {
                                        "when": {
                                            "hasSelector": "div"
                                        },
                                        "content": "Profiles configured â€” each one becomes a named override you can activate with skaffold run -p NAME.",
                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ“‹ Profiles Configured</div><div class=\"state-detail\">Each profile patches the base Skaffold config for a specific scenario:<br><br>â€¢ <code>skaffold run -p staging</code> â€” deploy with staging-specific settings<br>â€¢ <code>skaffold run -p production</code> â€” full replicas, production tags<br><br>Profiles are additive â€” they patch the base configuration rather than replacing it.<br><br>Common profiles: <code>dev</code> (local, hot-reload), <code>staging</code> (shared cluster, reduced replicas), <code>production</code> (full replicas, strict limits).</div></div>"
                                    }
                                ],
                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“‹ No Profiles Yet</div><div class=\"state-detail\">No Skaffold profiles configured. The base pipeline runs as-is for all environments.<br><br>Add profiles when you need per-environment overrides. Type a name in the input below and click \"+ Add profile\".<span class=\"assistant-tip\">You can always add profiles later by editing skaffold.yaml directly. This is optional for getting started.</span></div></div>",
                                "children": [],
                                "dynamic": true,
                                "childTemplate": {
                                    "title": "Profile: {{name}}",
                                    "selector": "#k8s-skaffold-profiles > div",
                                    "nameSelector": "code",
                                    "content": "Skaffold profile â€” named configuration override.",
                                    "expanded": ""
                                }
                            },
                            {
                                "id": "k8s-cfg-skf-portfwd",
                                "title": "Port Forwarding",
                                "icon": "ğŸ”Œ",
                                "selector": ".k8s-field-skf-portfwd",
                                "content": "Automatically forward container ports to localhost during skaffold dev.",
                                "variants": [
                                    {
                                        "when": {
                                            "hasSelector": "input:checked"
                                        },
                                        "icon": "âœ…",
                                        "content": "Port forwarding enabled â€” skaffold dev will auto-forward each service's port to localhost. Reach your app at localhost:PORT without manual port-forward commands.",
                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Port Forwarding On</div><div class=\"state-detail\">During <code>skaffold dev</code>, each service's container port is automatically forwarded to the same port on your localhost.<br><br>Your app becomes reachable at <code>localhost:8080</code> (or whatever port) without running <code>kubectl port-forward</code> manually. The forward is maintained as pods restart.<br><br>This is the expected default for local development.</div></div>"
                                    }
                                ],
                                "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">ğŸ”Œ Port Forwarding Off</div><div class=\"state-detail\">Port forwarding is disabled. During <code>skaffold dev</code>, services won't be reachable at localhost automatically.<br><br>You'll need to either:<br>â€¢ Run <code>kubectl port-forward</code> manually for each service<br>â€¢ Use an Ingress controller for local routing<br>â€¢ Use <code>minikube tunnel</code> for LoadBalancer services<br><br>Disable this only if you're using a service mesh, Ingress, or another routing mechanism for local access.</div></div>",
                                "children": []
                            },
                            {
                                "id": "k8s-cfg-skf-sync",
                                "title": "File Sync",
                                "icon": "ğŸ”„",
                                "selector": ".k8s-field-skf-sync",
                                "content": "Hot-reload without rebuilding â€” copies changed files directly into running containers.",
                                "variants": [
                                    {
                                        "when": {
                                            "hasSelector": "input:checked"
                                        },
                                        "icon": "âœ…",
                                        "content": "File sync enabled â€” changed source files are copied into running containers without rebuilding. Cuts the feedback loop from ~30s to ~1s for interpreted languages.",
                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… File Sync On</div><div class=\"state-detail\">Instead of rebuilding the Docker image on every change, Skaffold copies modified files directly into the running container.<br><br><strong>Works great for:</strong> Python (Django/Flask with reload), Node.js (nodemon/tsx --watch), Ruby, PHP â€” any language with a file watcher.<br><br><strong>Doesn't work for:</strong> Go, Rust, C/C++ â€” compiled languages still need a full rebuild. Dependency changes (package.json, go.mod) also trigger a full rebuild.<br><br>Skaffold falls back to full rebuild when syncing fails.</div></div>"
                                    }
                                ],
                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ”„ File Sync Off</div><div class=\"state-detail\">Every code change triggers a full Docker image rebuild + pod restart. This is the safe default â€” always correct but slower (~20-40s per change).<br><br>Enable file sync if you're working with interpreted languages (Python, Node.js, Ruby) and want sub-second feedback during development.</div></div>",
                                "children": []
                            },
                            {
                                "id": "k8s-cfg-skf-ssa",
                                "title": "Server-Side Apply",
                                "icon": "ğŸ“¡",
                                "selector": ".k8s-field-skf-ssa",
                                "content": "Use kubectl's server-side apply for safer multi-tool environments.",
                                "variants": [
                                    {
                                        "when": {
                                            "hasSelector": "input:checked"
                                        },
                                        "icon": "âœ…",
                                        "content": "Server-side apply enabled â€” the API server tracks field ownership. Safer when multiple tools (Skaffold + HPA, Skaffold + ArgoCD) modify the same resources.",
                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Server-Side Apply On</div><div class=\"state-detail\">Adds <code>--server-side</code> to every <code>kubectl apply</code> call. The API server tracks which tool owns each field, preventing accidental overwrites.<br><br>Important when:<br>â€¢ HPA modifies <code>spec.replicas</code> while Skaffold also sets it<br>â€¢ ArgoCD or Flux manage some resources alongside Skaffold<br>â€¢ Multiple teams deploy to the same namespace<br><br>Requires K8s 1.22+ (SSA graduated to stable).</div></div>"
                                    }
                                ],
                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“¡ Server-Side Apply Off</div><div class=\"state-detail\">Client-side apply (the default). Skaffold sends the full manifest and the server replaces it. Simpler but can conflict with other tools that modify the same resources.<br><br>Fine for single-tool deployments where only Skaffold manages your resources.</div></div>",
                                "children": []
                            },
                            {
                                "id": "k8s-cfg-skf-verify",
                                "title": "Post-Deploy Verify",
                                "icon": "âœ…",
                                "selector": ".k8s-field-skf-verify",
                                "content": "Wait for pods to become healthy after each deploy before reporting success.",
                                "variants": [
                                    {
                                        "when": {
                                            "hasSelector": "input:checked"
                                        },
                                        "icon": "âœ…",
                                        "content": "Post-deploy verification enabled â€” Skaffold waits for Deployments to report all replicas ready and pods to pass readiness probes before declaring success.",
                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Verification On</div><div class=\"state-detail\">After applying manifests, Skaffold:<br>â€¢ Waits for Deployments to report all replicas ready<br>â€¢ Checks pods pass readiness probes<br>â€¢ Runs custom verify commands if defined<br>â€¢ Fails the pipeline if verification times out<br><br>Critical for CI/CD â€” without this, <code>skaffold run</code> returns success immediately after applying, even if pods are crash-looping.</div></div>"
                                    }
                                ],
                                "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš ï¸ Verification Off</div><div class=\"state-detail\">Fire-and-forget mode. Skaffold applies manifests and returns success immediately without checking if pods actually started correctly.<br><br>âš ï¸ In CI/CD, this means a broken deploy can silently succeed. Crash-looping pods won't fail the pipeline.<br><br>Keep enabled unless you have external health checks or deployment verification in place.</div></div>",
                                "children": []
                            },
                            {
                                "id": "k8s-cfg-skf-hooks",
                                "title": "Lifecycle Hooks",
                                "icon": "ğŸª",
                                "selector": ".k8s-field-skf-hooks",
                                "content": "Pre and post-deploy commands â€” migrations, health checks, data seeding.",
                                "variants": [
                                    {
                                        "when": {
                                            "hasSelector": "textarea:not(:placeholder-shown)"
                                        },
                                        "content": "Hooks configured â€” commands will run before and/or after each deploy as part of the Skaffold pipeline.",
                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸª Hooks Configured</div><div class=\"state-detail\">Commands run on your local machine (not inside the cluster):<br><br><strong>Pre-deploy</strong> â€” before <code>kubectl apply</code>: database migrations, namespace creation, config generation.<br><br><strong>Post-deploy</strong> â€” after manifests are applied: smoke tests, readiness checks, data seeding.<br><br>One command per line, executed in order. Non-zero exit codes fail the pipeline.</div></div>"
                                    }
                                ],
                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸª No Hooks</div><div class=\"state-detail\">No lifecycle commands configured. Skaffold applies manifests directly without running any pre or post-deploy scripts.<br><br>Add hooks for:<br>â€¢ <code>make migrate</code> â€” database migrations before deploy<br>â€¢ <code>curl http://localhost/healthz</code> â€” smoke test after deploy<br>â€¢ <code>kubectl apply -f k8s/namespace.yaml</code> â€” ensure namespace exists<br><br>Expand this section and add commands to the pre-deploy or post-deploy textareas.</div></div>",
                                "children": []
                            }
                        ]
                    },
                    {
                        "id": "k8s-cfg-helm",
                        "title": "Helm Chart",
                        "icon": "âˆ",
                        "selector": ".k8s-field-helm",
                        "content": "Package your K8s manifests into a versioned, parameterised Helm chart.",
                        "variants": [
                            {
                                "when": {
                                    "hasSelector": "#k8s-helm-chart-toggle:checked"
                                },
                                "icon": "âœ…",
                                "content": "Helm chart enabled â€” a charts/ directory will be generated with Chart.yaml, templates, and values.yaml. Configure the details below.",
                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Helm Chart Enabled</div><div class=\"state-detail\">The wizard will generate a full Helm chart:<br>â€¢ <code>Chart.yaml</code> â€” metadata (name, version, description)<br>â€¢ <code>templates/</code> â€” your manifests as Go templates<br>â€¢ <code>values.yaml</code> â€” default values for all configurable parameters<br>â€¢ Optional per-env values files<br><br>Deploy with: <code>helm install myapp ./charts -f values-production.yaml</code><br><br>This also unlocks the \"helm\" deploy method in Skaffold above.<span class=\"assistant-tip\">You don't need Helm CLI installed to generate the chart â€” only to deploy it.</span></div></div>"
                            }
                        ],
                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">âˆ Helm Disabled</div><div class=\"state-detail\">No Helm chart will be generated. Manifests are written as plain YAML â€” deploy with <code>kubectl apply</code> or Skaffold's kustomize/kubectl deployer.<br><br>Enable this when you need:<br>â€¢ Per-environment values overrides (<code>values-staging.yaml</code>)<br>â€¢ Release management (helm history, helm rollback)<br>â€¢ Chart packaging for a Helm repository<br>â€¢ Helm-based Skaffold deployments</div></div>",
                        "children": [
                            {
                                "id": "k8s-cfg-helm-name",
                                "title": "Chart Name",
                                "icon": "ğŸ·ï¸",
                                "selector": ".k8s-field-helm-name",
                                "content": "The chart's name â€” used in Chart.yaml and as the default Helm release name.",
                                "variants": [
                                    {
                                        "when": {
                                            "resolver": "k8sFieldValue",
                                            "equals": ""
                                        },
                                        "icon": "âš ï¸",
                                        "content": "Chart name is empty â€” the wizard will derive one from your project name, but setting it explicitly is better for predictable resource naming.",
                                        "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš ï¸ No Chart Name</div><div class=\"state-detail\">Without a name, the wizard auto-generates one from your project directory. Set it explicitly for predictable <code>helm install</code> behavior â€” the chart name becomes the prefix for all K8s resources: <code>my-app-deployment</code>, <code>my-app-service</code>.<br><br>Convention: lowercase, hyphen-separated. Keep it short to avoid hitting the 63-character DNS label limit.</div></div>"
                                    }
                                ],
                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ·ï¸ Chart Name</div><div class=\"state-detail\">Becomes <code>name:</code> in <code>Chart.yaml</code> and the prefix for all Helm-managed resources. Convention: lowercase, hyphen-separated, matching your project name (<code>my-app</code>, <code>backend-api</code>).</div></div>",
                                "children": []
                            },
                            {
                                "id": "k8s-cfg-helm-dir",
                                "title": "Chart Directory",
                                "icon": "ğŸ“",
                                "selector": ".k8s-field-helm-dir",
                                "content": "Where the Helm chart files are generated.",
                                "variants": [
                                    {
                                        "when": {
                                            "resolver": "k8sFieldValue",
                                            "equals": ""
                                        },
                                        "icon": "âŒ",
                                        "content": "Chart directory is empty â€” set it to charts/ (the convention) or a custom path.",
                                        "expanded": "<div class=\"assistant-state-card state-error\"><div class=\"state-label\">âŒ No Chart Directory</div><div class=\"state-detail\">The wizard needs a directory to write Chart.yaml, templates/, and values.yaml. The standard convention is <code>charts/</code>.</div></div>"
                                    },
                                    {
                                        "when": {
                                            "resolver": "k8sFieldValue",
                                            "equals": "charts/"
                                        },
                                        "content": "Standard chart directory â€” Chart.yaml, templates/, and values.yaml will be generated inside charts/.",
                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ“ Chart Dir: charts/</div><div class=\"state-detail\">The convention used by most Helm projects. The full structure:<br><code>charts/Chart.yaml<br>charts/values.yaml<br>charts/templates/deployment.yaml<br>charts/templates/service.yaml<br>...</code><br><br>This directory should be committed to Git.</div></div>"
                                    }
                                ],
                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“ Chart Directory</div><div class=\"state-detail\">Custom chart output path. If you have multiple charts (frontend + backend), use separate directories like <code>charts/backend/</code>.</div></div>",
                                "children": []
                            },
                            {
                                "id": "k8s-cfg-helm-version",
                                "title": "Chart Version",
                                "icon": "ğŸ“Œ",
                                "selector": ".k8s-field-helm-version",
                                "content": "The chart's SemVer version â€” tracks changes to the chart structure.",
                                "variants": [
                                    {
                                        "when": {
                                            "resolver": "k8sFieldValue",
                                            "equals": "0.1.0"
                                        },
                                        "content": "Initial version 0.1.0 â€” good starting point. Bump this when you change the chart structure (templates, values schema), not when your app code changes.",
                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ“Œ Version: 0.1.0</div><div class=\"state-detail\">Standard initial version for development. SemVer rules for charts:<br>â€¢ <strong>Patch</strong> (0.1.1) â€” minor template fixes<br>â€¢ <strong>Minor</strong> (0.2.0) â€” new values, new templates, backward-compatible<br>â€¢ <strong>Major</strong> (1.0.0) â€” breaking changes to values schema<br><br>This version is independent of your app version (next field).</div></div>"
                                    },
                                    {
                                        "when": {
                                            "resolver": "k8sFieldValue",
                                            "equals": ""
                                        },
                                        "icon": "âš ï¸",
                                        "content": "Chart version is empty â€” Helm requires a version in Chart.yaml. Set it to 0.1.0 to start.",
                                        "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš ï¸ No Chart Version</div><div class=\"state-detail\">The <code>version:</code> field in Chart.yaml is required by Helm. Without it, <code>helm package</code> and <code>helm install</code> will fail.<br><br>Use <code>0.1.0</code> as a starting point.</div></div>"
                                    }
                                ],
                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“Œ Chart Version</div><div class=\"state-detail\">Tracks chart structure changes, not app code. Helm uses this for dependency resolution and chart museum indexing.</div></div>",
                                "children": []
                            },
                            {
                                "id": "k8s-cfg-helm-appver",
                                "title": "App Version",
                                "icon": "ğŸ“¦",
                                "selector": ".k8s-field-helm-appver",
                                "content": "Your application's version â€” informational, shown in helm list output.",
                                "variants": [
                                    {
                                        "when": {
                                            "resolver": "k8sFieldValue",
                                            "equals": ""
                                        },
                                        "content": "App version is empty â€” it's optional but helpful for traceability. Set it to your current release version or Git SHA.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“¦ No App Version</div><div class=\"state-detail\">The <code>appVersion:</code> field is optional. When set, it appears in <code>helm list</code> output so you can see which app version is deployed per release.<br><br>Some teams set this to the Git SHA or Docker image tag for traceability.</div></div>"
                                    }
                                ],
                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“¦ App Version</div><div class=\"state-detail\">Appears in <code>helm list</code> to show which app version is deployed. Independent of the chart version â€” update this when your application code changes, not the chart structure.</div></div>",
                                "children": []
                            },
                            {
                                "id": "k8s-cfg-helm-desc",
                                "title": "Description",
                                "icon": "ğŸ“",
                                "selector": ".k8s-field-helm-desc",
                                "content": "A human-readable description for Chart.yaml.",
                                "variants": [
                                    {
                                        "when": {
                                            "resolver": "k8sFieldValue",
                                            "equals": ""
                                        },
                                        "content": "Description is empty â€” the wizard will auto-generate one from the chart name. Set it explicitly for a better helm search experience.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“ No Description</div><div class=\"state-detail\">If left empty, the wizard generates a generic description. A good description helps when browsing charts: \"Backend API for the platform\" or \"Full-stack deployment with web, API, and workers.\"</div></div>"
                                    }
                                ],
                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“ Chart Description</div><div class=\"state-detail\">Sets <code>description:</code> in Chart.yaml. Appears in <code>helm search</code> output and chart repository listings. Keep it brief and descriptive.</div></div>",
                                "children": []
                            },
                            {
                                "id": "k8s-cfg-helm-envvals",
                                "title": "Per-Env Values",
                                "icon": "ğŸŒ",
                                "selector": ".k8s-field-helm-envvals",
                                "content": "Generate separate values files for each environment.",
                                "variants": [
                                    {
                                        "when": {
                                            "hasSelector": "input:checked"
                                        },
                                        "icon": "âœ…",
                                        "content": "Per-env values enabled â€” the wizard will generate values-staging.yaml and values-production.yaml alongside the base values.yaml.",
                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Per-Env Values On</div><div class=\"state-detail\">Environment-specific values files will be generated:<br>â€¢ <code>values-staging.yaml</code> â€” reduced replicas, staging image tags<br>â€¢ <code>values-production.yaml</code> â€” full replicas, production resource limits<br><br>Deploy with: <code>helm install myapp ./charts -f values-production.yaml</code><br><br>Each file only overrides what's different â€” the base <code>values.yaml</code> provides defaults.</div></div>"
                                    }
                                ],
                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸŒ Per-Env Values Off</div><div class=\"state-detail\">Only the base <code>values.yaml</code> is generated. All environments use the same values unless you create override files manually.<br><br>Enable this when you need different replicas, resource limits, or image tags per environment.</div></div>",
                                "children": []
                            },
                            {
                                "id": "k8s-cfg-helm-ignore",
                                "title": "Generate .helmignore",
                                "icon": "ğŸš«",
                                "selector": ".k8s-field-helm-ignore",
                                "content": "Creates a .helmignore to exclude build artifacts from packaged charts.",
                                "variants": [
                                    {
                                        "when": {
                                            "hasSelector": "input:checked"
                                        },
                                        "icon": "âœ…",
                                        "content": ".helmignore enabled â€” build artifacts, tests, and docs will be excluded from helm package output, keeping the chart archive small.",
                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… .helmignore On</div><div class=\"state-detail\">A <code>.helmignore</code> file will be generated with patterns excluding:<br>â€¢ <code>.git/</code>, <code>node_modules/</code>, <code>__pycache__/</code><br>â€¢ <code>*.md</code>, <code>tests/</code><br>â€¢ <code>.env</code>, <code>.DS_Store</code><br><br>Keeps <code>helm package</code> output small when pushing to a chart registry.</div></div>"
                                    }
                                ],
                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸš« .helmignore Off</div><div class=\"state-detail\">No .helmignore will be generated. When you run <code>helm package</code>, everything in the chart directory is included in the archive â€” including test files, docs, and build artifacts.<br><br>Only matters if you push charts to a registry. For local-only use, this is fine.</div></div>",
                                "children": []
                            }
                        ]
                    }
                ]
            }
        ],
        "variants": [
            {
                "when": {
                    "hasSelector": "#k8s-detect-env"
                },
                "content": "Scanning what you've got â€” tools, cluster access, and running services. Everything here is read-only. The wizard uses this snapshot to shape the Configure step.",
                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ‘ï¸ Detect â€” read-only scan</div><div class=\"state-detail\">Nothing changes in this step. The wizard is reading your local environment to understand:\n\nâ€¢ <strong>Tooling</strong> â€” kubectl, Helm, kubeconfig\nâ€¢ <strong>Cluster</strong> â€” is one reachable? what context is active?\nâ€¢ <strong>Services</strong> â€” what Docker Compose services exist to migrate?\n\nProceed to Configure when you're ready to shape the workloads.</div></div>"
            },
            {
                "when": {
                    "hasSelector": "#k8s-app-svc-list"
                },
                "content": "This is where you shape each workload. Every choice here â€” kind, image, ports, strategy, resources â€” flows directly into the manifests generated in Review.",
                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">âš™ï¸ Configure â€” shape your workloads</div><div class=\"state-detail\">Each card represents a service from your Compose file. Hover any field for specific guidance.\n\nâ€¢ <strong>Workload Kind</strong> â€” the most consequential choice per service\nâ€¢ <strong>Primary settings</strong> â€” image, port, replicas, service type\nâ€¢ <strong>Advanced sections</strong> â€” strategy, resources, probes, env vars\n\nChanges aren't applied yet â€” they feed the Review step's manifest generation.</div></div>"
            },
            {
                "when": {
                    "hasSelector": ".wiz-review-item"
                },
                "content": "Everything the wizard will generate â€” Deployments, Services, ConfigMaps, Secrets, PVCs, and optional extras. Review before writing.",
                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Review â€” ready to generate</div><div class=\"state-detail\">Every resource listed here becomes a manifest file in your output directory.\n\nâ€¢ <strong>Deployments / StatefulSets / Jobs</strong> â€” workload manifests\nâ€¢ <strong>Services</strong> â€” ClusterIP, NodePort, or LoadBalancer\nâ€¢ <strong>ConfigMaps & Secrets</strong> â€” per-service environment variables\nâ€¢ <strong>PVCs</strong> â€” persistent storage claims\nâ€¢ <strong>Optional</strong> â€” Ingress, Skaffold pipeline, Helm chart\n\nHit Finish to write all files.</div></div>"
            }
        ]
    }
]
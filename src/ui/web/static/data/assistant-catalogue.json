[
    {
        "context": "wizard/welcome",
        "title": "Welcome to the Setup Wizard",
        "icon": "ğŸ§™",
        "content": "6 steps to shape your project. Everything starts here â€” your project's identity, where it lives, and how it's organized.\n\nTake your time. Nothing is saved until you hit Finish on the last step, so feel free to explore and come back.",
        "children": [
            {
                "id": "project-name",
                "title": "Project Name",
                "icon": "âœï¸",
                "selector": "#wiz-name",
                "content": "This is your project's identity â€” the name that follows it everywhere.",
                "expanded": "It shows up in Docker image tags, CI/CD pipeline names, Helm chart metadata, generated folder structures, and every config file the control plane produces.\n\nPick something lowercase, hyphen-separated â€” like my-api or data-pipeline. Spaces and special characters can cause issues in Docker tags and file paths downstream.\n\nğŸ’¡ Changing this later is possible but ripples through generated configs. Best to get it right now.",
                "children": []
            },
            {
                "id": "description",
                "title": "Description",
                "icon": "ğŸ“",
                "selector": "#wiz-desc",
                "content": "A short summary of what this project does â€” one or two sentences is perfect.",
                "expanded": "This text appears in your README header, package metadata (package.json, pyproject.toml), GitHub repository description, and Helm chart annotations.\n\nIt's not required, but it's the kind of thing you'll appreciate having when someone new looks at the project six months from now.\n\nğŸ’¡ Write it for a colleague who's never seen this repo before.",
                "children": []
            },
            {
                "id": "repository",
                "title": "Repository",
                "icon": "ğŸ”—",
                "selector": "#wiz-repo",
                "content": "Your Git remote â€” this connects the project to its home on GitHub, GitLab, or wherever it lives.",
                "expanded": "The control plane uses this for:\nâ€¢ CI/CD webhooks â€” triggering pipelines on push\nâ€¢ GitHub integration â€” PR management, secrets sync, Actions dispatch\nâ€¢ Docker registry paths â€” deriving container image names\nâ€¢ Generated configs â€” embedding the repo URL in Helm charts, Dockerfiles, and CI workflows\n\nFormat: github.com/owner/repo (without https://). If you're using GitHub, the control plane can often auto-detect this from your local git remote.",
                "children": []
            },
            {
                "id": "domains",
                "title": "Domains",
                "icon": "ğŸ·ï¸",
                "selector": "#wiz-domains",
                "separator": true,
                "content": "Domains are logical groupings for your codebase â€” not internet domains, more like folders of purpose.",
                "expanded": "When you add modules in Step 2, each one belongs to a domain. Think of it as organizing your project by responsibility:\n\nâ€¢ library â€” shared utilities, core business logic\nâ€¢ ops â€” DevOps tooling, scripts, CI/CD configs\nâ€¢ docs â€” documentation, guides, Docusaurus sites\nâ€¢ services â€” microservices, APIs, workers\n\nYou've got {{domainCount}} so far. You can always add more later â€” this just shapes how modules are categorized in the dashboard.",
                "dynamic": true,
                "childTemplate": {
                    "title": "{{name}}",
                    "content": "One of your project domains. Modules assigned to this domain will be grouped together in the dashboard and reports.",
                    "selector": "#wiz-domains > span"
                },
                "children": [
                    {
                        "id": "add-domain",
                        "title": "Add domainâ€¦",
                        "icon": "â•",
                        "selector": "#wiz-new-domain",
                        "content": "Type a name and press Enter or click + Add.",
                        "expanded": "Good domain names are short and describe a purpose, not a technology. Think library over python, or services over backend.\n\nğŸ’¡ You don't need to plan this perfectly. Domains can be added, renamed, or reorganized anytime.",
                        "children": []
                    }
                ]
            },
            {
                "id": "environments",
                "title": "Environments",
                "icon": "ğŸ“‹",
                "selector": "#wiz-envs",
                "separator": true,
                "content": "Environments scope your secrets and deployment variables. Your project configuration, integrations, and generated files are shared across all of them â€” what changes per environment are the credentials and endpoint values.",
                "expanded": "So your DB_HOST might be localhost:5432 in development but prod-db.internal in production. Same Dockerfile, same CI pipeline, different .env file per environment.\n\nEach environment gets its own encrypted .env file managed by the Vault in Step 3. The control plane keeps them separate â€” secrets from one environment never leak into another.\n\nYou've got {{envCount}} set up. Most projects need at least development and production. Add staging or preview if your workflow needs intermediate deployment targets.",
                "dynamic": true,
                "childTemplate": {
                    "title": "{{name}}",
                    "content": "The {{name}} environment â€” one of your deployment targets. It gets its own .env file with credentials and endpoint values scoped specifically to this context.",
                    "expanded": "When you define secrets and variables in Step 3, each environment has its own set of values. So your API keys, database URLs, and feature flags can differ between environments while sharing the same project config and generated files.\n\nğŸ’¡ Click the name or description to edit. Use Ã— to remove this environment.",
                    "selector": "#wiz-envs > div"
                },
                "children": [
                    {
                        "id": "add-env-name",
                        "title": "Environment name",
                        "icon": "â•",
                        "selector": "#wiz-new-env-name",
                        "content": "Add another deployment target â€” staging, qa, preview, or whatever your workflow needs.",
                        "expanded": "Keep it lowercase, no spaces. This name becomes part of your .env file path (.env.staging), GitHub deployment environment name, and CI/CD workflow target.\n\nEach new environment gets its own secret values in Step 3.\n\nğŸ’¡ Common patterns: development + production for simple projects. Add staging for a QA gate, or preview for PR-based ephemeral environments.",
                        "children": []
                    },
                    {
                        "id": "add-env-desc",
                        "title": "Environment description",
                        "icon": "ğŸ“",
                        "selector": "#wiz-new-env-desc",
                        "content": "A human-readable label â€” helps your team know what each environment is for at a glance.",
                        "expanded": "Examples: \"Local development and testing\", \"Pre-production staging\", \"Live customer-facing\".\n\nThis shows up in the dashboard environment selector and in the Vault management view. It's optional but makes life easier when you have 3+ environments.",
                        "children": []
                    }
                ]
            }
        ]
    },
    {
        "context": "wizard/modules",
        "title": "Modules",
        "icon": "ğŸ”",
        "content": "Modules are the building blocks of your project â€” each one maps to a directory in your codebase with its own stack and purpose.\n\nThe control plane uses them to decide what to generate: Dockerfiles, CI pipelines, linting configs, audit scans, and dashboard structure all flow from what you define here.",
        "children": [
            {
                "id": "auto-detect",
                "title": "Auto-Detect",
                "icon": "ğŸ”",
                "selector": "button[onclick='wizardDetect()']",
                "content": "Scans your project root for recognizable structures â€” pyproject.toml, package.json, docker-compose.yml, Makefile, docs folders â€” and creates module entries from what it finds.",
                "expanded": "Detection looks at file signatures:\nâ€¢ pyproject.toml or setup.py â†’ python-lib or python-cli\nâ€¢ app.py / wsgi.py â†’ python-flask\nâ€¢ package.json â†’ node\nâ€¢ docker-compose.yml â†’ docker-compose\nâ€¢ .md files in a docs/ folder â†’ markdown\n\nIt also reads descriptions from package metadata when available. Detection is non-destructive â€” it won't overwrite modules you've already added manually.\n\nğŸ’¡ If your project has an unusual structure, you can always add modules manually below.",
                "children": []
            },
            {
                "id": "modules-list",
                "title": "Module List",
                "icon": "ğŸ“¦",
                "selector": "#wizard-modules-list",
                "content": "Your configured modules â€” {{moduleCount}} so far. Each one represents a directory the control plane knows about and manages.",
                "expanded": "Every module gets its own treatment in the pipeline:\nâ€¢ Python modules get linting (ruff/flake8), type checking, and test runners\nâ€¢ Flask modules get Dockerfile generation, health check endpoints, and deployment configs\nâ€¢ Node modules get npm scripts, bundler configs, and dependency audits\nâ€¢ Docker-compose modules get service orchestration and K8s migration paths\nâ€¢ Markdown modules get Docusaurus site generation and content management\n\nThe control plane uses module paths to scope operations â€” when you run audit, lint, or generate configs, it targets the right directories.",
                "dynamic": true,
                "childTemplate": {
                    "title": "{{name}}",
                    "content": "The {{name}} module â€” managed by the control plane as part of your project structure.",
                    "expanded": "This module's stack determines what the control plane generates for it: Dockerfiles, CI workflows, linting configs, and audit targets. Its domain assignment controls how it's grouped in the dashboard.\n\nğŸ’¡ Use Ã— to remove this module if it was detected incorrectly or is no longer needed.",
                    "selector": "#wizard-modules-list > div"
                },
                "children": []
            },
            {
                "id": "add-module",
                "title": "Add Module",
                "icon": "â•",
                "selector": "#wiz-add-module",
                "separator": true,
                "content": "Manually define a module the auto-detector missed, or add one for a directory you're about to create. Pick a stack from the dropdown to tell the control plane what technology this module uses.",
                "expanded": "Three fields define a module:\nâ€¢ Name â€” appears in dashboard cards, CI pipeline names, and generated configs\nâ€¢ Path â€” directory relative to project root (e.g. src/core, services/api)\nâ€¢ Stack â€” the technology stack that drives everything the control plane generates\n\nAvailable stacks (47 total):\nğŸ python Â· python-lib Â· python-cli Â· python-flask Â· python-fastapi Â· python-django\nğŸ“¦ node Â· node-express Â· node-nextjs Â· node-react Â· node-lib Â· typescript Â· typescript-lib\nğŸ¹ go Â· go-gin Â· go-fiber Â· go-cli Â· go-lib\nğŸ¦€ rust Â· rust-actix Â· rust-axum Â· rust-cli Â· rust-lib\nâš™ï¸ c Â· cpp Â· âš¡ zig Â· ğŸ swift\nâ˜• java-maven Â· java-maven-spring Â· java-gradle Â· java-gradle-spring\nğŸ”· dotnet Â· dotnet-aspnet Â· dotnet-blazor\nğŸ’ ruby Â· ruby-rails Â· ruby-sinatra Â· ğŸ’§ elixir Â· elixir-phoenix\nğŸ˜ php Â· ğŸ“¡ protobuf\nğŸ³ docker-compose Â· â˜¸ï¸ kubernetes Â· âˆ helm Â· ğŸ—ï¸ terraform\nğŸ“ markdown Â· ğŸŒ static-site\n\nFlavored stacks inherit from their base and add framework-specific capabilities. Each is defined in stacks/<name>/stack.yml.",
                "children": [
                    {
                        "id": "mod-name",
                        "title": "Module Name",
                        "icon": "âœï¸",
                        "selector": "#wiz-mod-name",
                        "content": "A short, descriptive name for this module â€” like core, api, web, or docs.",
                        "expanded": "This name appears in:\nâ€¢ Dashboard module cards\nâ€¢ CI pipeline names (e.g. lint-core, test-api)\nâ€¢ Docker image tags when applicable\nâ€¢ Generated config references\n\nKeep it lowercase, hyphen-separated. It doesn't need to match the directory name, but it helps.",
                        "children": []
                    },
                    {
                        "id": "mod-path",
                        "title": "Module Path",
                        "icon": "ğŸ“‚",
                        "selector": "#wiz-mod-path",
                        "content": "The directory path relative to your project root â€” this is where the control plane looks for source files.",
                        "expanded": "Must point to an actual directory (or one you plan to create). The control plane uses this to:\nâ€¢ Scope linting and audit operations to the right files\nâ€¢ Generate Dockerfiles with correct COPY paths\nâ€¢ Set up CI workflows that only trigger on changes in this directory\nâ€¢ Resolve dependencies between modules\n\nExamples: src/core, src/ui/web, services/auth, docs",
                        "children": []
                    },
                    {
                        "id": "mod-stack",
                        "title": "Stack",
                        "icon": "ğŸ”§",
                        "selector": "#wiz-mod-stack",
                        "content": "A stack is a technology definition â€” it tells the control plane how to detect, build, lint, test, and deploy this module. Flavored stacks inherit capabilities from their base language.",
                        "expanded": "Each stack is defined in stacks/<name>/stack.yml. Flavored stacks declare a parent and inherit detection rules, requirements, and capabilities from their base â€” then add their own.\n\nğŸ Python\nâ€¢ python â€” Generic Python project\nâ€¢ python-lib â€” Library, no entry point (domain: library)\nâ€¢ python-cli â€” Click/argparse CLI tool (+run)\nâ€¢ python-flask â€” Flask web app (+serve)\nâ€¢ python-fastapi â€” FastAPI app (+serve via uvicorn)\nâ€¢ python-django â€” Django app (+serve, migrate, shell)\n\nğŸ“¦ JavaScript / TypeScript\nâ€¢ node â€” Node.js project\nâ€¢ node-express â€” Express.js server (+serve)\nâ€¢ node-nextjs â€” Next.js app (+dev, serve, build override)\nâ€¢ node-react â€” React SPA (+dev)\nâ€¢ node-lib â€” npm library (domain: library)\nâ€¢ typescript â€” TypeScript project\nâ€¢ typescript-lib â€” TS library (domain: library)\n\nğŸ¹ Go\nâ€¢ go â€” Go project (Go modules)\nâ€¢ go-gin â€” Gin web framework (+serve)\nâ€¢ go-fiber â€” Fiber web framework (+serve)\nâ€¢ go-cli â€” CLI tool (Cobra/urfave)\nâ€¢ go-lib â€” Library (domain: library)\n\nğŸ¦€ Rust\nâ€¢ rust â€” Rust project (Cargo)\nâ€¢ rust-actix â€” Actix-web service (+serve)\nâ€¢ rust-axum â€” Axum web service (+serve)\nâ€¢ rust-cli â€” CLI tool (clap)\nâ€¢ rust-lib â€” Library crate (domain: library)\n\nâš™ï¸ Systems\nâ€¢ c â€” C project (Makefile/CMake)\nâ€¢ cpp â€” C++ project (Makefile/CMake)\nâ€¢ zig â€” Zig project\nâ€¢ swift â€” Swift project (SPM)\n\nâ˜• JVM & .NET\nâ€¢ java-maven â€” Java (Maven build)\nâ€¢ java-maven-spring â€” Spring Boot + Maven (+serve)\nâ€¢ java-gradle â€” Java/Kotlin (Gradle build)\nâ€¢ java-gradle-spring â€” Spring Boot + Gradle (+serve)\nâ€¢ dotnet â€” .NET / C#\nâ€¢ dotnet-aspnet â€” ASP.NET web app (+serve)\nâ€¢ dotnet-blazor â€” Blazor app (+serve)\n\nğŸ’ Other Languages\nâ€¢ ruby â€” Ruby (Bundler)\nâ€¢ ruby-rails â€” Rails (+serve, migrate, console)\nâ€¢ ruby-sinatra â€” Sinatra (+serve)\nâ€¢ elixir â€” Elixir (Mix)\nâ€¢ elixir-phoenix â€” Phoenix (+serve, migrate, routes)\nâ€¢ php â€” PHP (Composer)\nâ€¢ protobuf â€” Protocol Buffers / gRPC\n\nğŸ³ Infrastructure\nâ€¢ docker-compose â€” Docker Compose orchestration\nâ€¢ kubernetes â€” Kubernetes manifests\nâ€¢ helm â€” Helm charts\nâ€¢ terraform â€” Terraform infrastructure\n\nğŸ“ Content\nâ€¢ markdown â€” Documentation (Docusaurus/MkDocs)\nâ€¢ static-site â€” Static site (HTML/CSS/JS)\n\nUse \"Custom\" to type an unlisted stack name â€” you can create its YAML later.",
                        "children": []
                    }
                ]
            }
        ]
    },
    {
        "context": "wizard/secrets",
        "title": "Secrets & Encryption",
        "icon": "ğŸ”",
        "content": "This step shows the state of your project's secrets infrastructure â€” one vault per environment, your GitHub connection, and the content encryption key.\n\nUnlike Step 1, some actions here take effect immediately when you click them. The + Create and ğŸ’¾ Save buttons write to disk right away â€” they don't wait for Finish.",
        "children": [
            {
                "id": "env-vault-status",
                "title": "Environment Vault Status",
                "icon": "ğŸŒ",
                "selector": "#wiz-env-vault-list",
                "separator": true,
                "content": "Each environment you defined in Step 1 gets its own encrypted vault file. In multi-environment mode, .env is a working copy of the active environment \u2014 when you switch environments, the control plane swaps the file automatically.",
                "expanded": "The file model:\n\u2022 .env \u2014 live working copy of whichever environment is active\n\u2022 .env.{name} \u2014 stored snapshot of each environment's secrets\n\u2022 .env.active \u2014 marker file recording which environment is selected\n\nWhen you activate production, the control plane saves .env \u2192 .env.development, then copies .env.production \u2192 .env. In single-env mode, there's just .env \u2014 no swapping.\n\n\ud83d\udca1 Vault files (.env.vault) are the encrypted versions. The .gitignore excludes plaintext .env files, and encryption adds the real protection.",
                "dynamic": true,
                "childTemplate": {
                    "title": "{{name}}",
                    "nameSelector": "code",
                    "content": "Vault file for the {{name}} environment.",
                    "expanded": "Checking status\u2026",
                    "selector": "#wiz-env-vault-list > div",
                    "variants": [
                        {
                            "when": {
                                "textContains": "unlocked",
                                "hasSelector": "[data-env-active]"
                            },
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">\ud83d\udd13 unlocked \u00b7 ACTIVE</div><div class=\"state-detail\">This is the active environment \u2014 .env is a live copy of this file right now. The vault is decrypted and ready for editing.\n\nAny changes you make in the \ud83d\udd10 Secrets tab modify this environment's .env directly. Remember to lock it when you're done.\n\nSwitching to another environment will save this file and swap in the new one.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "locked",
                                "hasSelector": "[data-env-active]"
                            },
                            "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">\ud83d\udd12 locked \u00b7 ACTIVE</div><div class=\"state-detail\">This is the active environment but the vault is locked \u2014 .env is encrypted on disk.\n\nUnlock it from the \ud83d\udd10 Secrets tab to view or edit secrets. The vault passphrase decrypts it on demand.\n\nSwitching to another environment will keep this vault locked and swap in the new one.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "missing",
                                "hasSelector": "[data-env-active]"
                            },
                            "expanded": "<div class=\"assistant-state-card state-error\"><div class=\"state-label\">\ud83d\udced missing \u00b7 ACTIVE</div><div class=\"state-detail\">This is the active environment but no .env file exists yet. Hit + Create to generate one \u2014 the file is written to disk immediately.\n\nThis is normal for new setups. Once created, you can add secrets through the \ud83d\udd10 Secrets tab.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "unlocked"
                            },
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">\ud83d\udd13 unlocked</div><div class=\"state-detail\">This vault is decrypted and ready. You can view and edit secrets through the \ud83d\udd10 Secrets tab on the dashboard.\n\nRemember to lock it when you're done \u2014 plaintext .env files should never be committed to git. The .gitignore already excludes them, but encryption is the real protection.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "locked"
                            },
                            "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">\ud83d\udd12 locked</div><div class=\"state-detail\">This vault is encrypted \u2014 its contents are safe on disk. This is the expected state when you're not actively editing credentials.\n\nTo read or edit secrets, unlock it from the \ud83d\udd10 Secrets tab. The vault passphrase decrypts it on demand.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "missing"
                            },
                            "expanded": "<div class=\"assistant-state-card state-error\"><div class=\"state-label\">\ud83d\udced missing</div><div class=\"state-detail\">This vault doesn't exist yet. Hit + Create to generate it \u2014 the file is written to disk immediately with an auto-generated encryption key.\n\nThis is normal for new environments. You can add secrets afterwards through the \ud83d\udd10 Secrets tab.</div></div>"
                        }
                    ]
                },
                "children": []
            },
            {
                "id": "gh-integration",
                "title": "GitHub Integration",
                "icon": "ğŸ”—",
                "selector": "#wiz-gh-integration",
                "separator": true,
                "content": "GITHUB_REPOSITORY connects your local vault to your GitHub remote â€” it's how the control plane knows where to sync secrets and dispatch workflows.",
                "expanded": "This value stays local to your .env file. It's never pushed to GitHub secrets â€” it's the bridge between your local credentials and your remote repository.\n\nWith this set, you get secrets sync to GitHub Actions, workflow dispatch, and PR management from the dashboard.",
                "variants": [
                    {
                        "when": {
                            "textContains": "configured"
                        },
                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… configured</div><div class=\"state-detail\">Your repository is set in .env. The control plane can push secrets, dispatch workflows, and manage PRs.\n\nThis value stays local â€” it's never pushed to GitHub. It's the link between your local vault and your remote repo.</div></div>"
                    },
                    {
                        "when": {
                            "textContains": "detected"
                        },
                        "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš ï¸ detected but not saved</div><div class=\"state-detail\">Your git remote was auto-detected but isn't persisted in .env yet. Click ğŸ’¾ Save to .env to keep it â€” this takes effect immediately.\n\nWithout it saved, GitHub integration features won't know where to target on next startup.</div></div>"
                    },
                    {
                        "when": {
                            "textContains": "could not detect"
                        },
                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â“ not detected</div><div class=\"state-detail\">No git remote found. You can set GITHUB_REPOSITORY manually in your .env file as owner/repo (e.g., my-org/my-project).\n\nThis is needed for secrets sync, GitHub Actions dispatch, and PR management.</div></div>"
                    }
                ],
                "children": [
                    {
                        "id": "gh-deploy-envs",
                        "title": "Deployment Environments",
                        "icon": "ğŸŒ",
                        "selector": "#wiz-gh-deploy-envs",
                        "content": "GitHub Deployment Environments scope secrets to specific environments like development and production. Each environment in your project should have a matching GitHub environment.",
                        "expanded": "Without matching GitHub environments, you can't push environment-scoped secrets. Dev typically uses repo-level secrets, but production needs its own environment for isolation.\n\nğŸ’¡ Hit ğŸš€ Create to provision missing environments on GitHub directly from the wizard.",
                        "dynamic": true,
                        "childTemplate": {
                            "title": "{{name}}",
                            "nameSelector": "code",
                            "content": "GitHub deployment environment.",
                            "selector": "#wiz-gh-deploy-list > div",
                            "variants": [
                                {
                                    "when": {
                                        "textContains": "exists"
                                    },
                                    "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… exists</div><div class=\"state-detail\">This environment is provisioned on GitHub. You can push scoped secrets to it from the \ud83d\udd10 Secrets tab and use environment-level protection rules in GitHub Actions.</div></div>"
                                },
                                {
                                    "when": {
                                        "textContains": "not found"
                                    },
                                    "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">\u26a0\ufe0f not found</div><div class=\"state-detail\">This environment doesn\u2019t exist on GitHub yet. Hit \ud83d\ude80 Create to provision it \u2014 this is required before you can push environment-scoped secrets.\n\nWithout it, secrets sync for this environment will fail.</div></div>"
                                }
                            ]
                        },
                        "children": []
                    }
                ]
            },
            {
                "id": "enc-key-status",
                "title": "Content Encryption Key",
                "icon": "ğŸ”‘",
                "selector": "#wiz-enc-key-status",
                "separator": true,
                "content": "CONTENT_VAULT_ENC_KEY is a general-purpose encryption key stored in your .env file. It enables on-demand encryption for any git-committed item â€” you toggle it per file or message, and the key does the rest.",
                "expanded": "This key protects multiple things across the control plane:\nâ€¢ Content files â€” media, documents, assets in the content vault\nâ€¢ Chat messages â€” encrypted at rest, decrypted on read\nâ€¢ Backup archives â€” encrypted snapshots of your project\nâ€¢ New vault seeding â€” auto-injected when creating environment vaults\n\nIt's separate from the vault passphrase that locks .env files. The vault passphrase protects secrets (API keys, database URLs). This key protects everything else you choose to encrypt.",
                "variants": [
                    {
                        "when": {
                            "textContains": "configured"
                        },
                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… configured</div><div class=\"state-detail\">Your encryption key is active. You can encrypt content files, chat messages, and backup archives on demand.\n\nThis key is auto-injected into new environment vaults when you create them. As long as your .env file is backed up, anything encrypted with this key is recoverable.</div></div>"
                    },
                    {
                        "when": {
                            "textContains": "not set"
                        },
                        "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš ï¸ not set</div><div class=\"state-detail\">No encryption key configured. Without it, you can't encrypt content files, chat messages, or backup archives.\n\nEnter your own key (at least 8 characters) or hit ğŸ² Generate for a strong random one. Either way, it's stored in .env â€” keep that file safe.\n\nâš ï¸ Losing this key means losing access to everything encrypted with it. There's no recovery mechanism.\n\nIf you don't need any of these encryption features, you can safely skip this.</div></div>"
                    }
                ],
                "children": []
            },
            {
                "id": "secrets-list",
                "title": "Detected Secret Files",
                "icon": "ğŸ“„",
                "selector": "#wiz-secrets-list",
                "separator": true,
                "content": "These are secret files found in your project \u2014 .env files, encrypted vaults, and related artifacts. This is a read-only snapshot of what\u2019s on disk right now.",
                "expanded": "In multi-environment mode, .env is a live copy of the active environment \u2014 it will match one of the .env.{name} files. The other .env.{name} files hold each environment's stored secrets.\n\nFor full vault management \u2014 locking, unlocking, adding keys, pushing secrets to GitHub \u2014 use the \ud83d\udd10 Secrets tab on the dashboard after you finish the wizard.\n\n\ud83d\udca1 Encrypted files are safe to commit (they\u2019re ciphertext). Plaintext files should be locked before pushing to git.",
                "dynamic": true,
                "childTemplate": {
                    "title": "{{name}}",
                    "nameSelector": "code",
                    "content": "A secret file in your project.",
                    "selector": "#wiz-detected-files > div",
                    "variants": [
                        {
                            "when": {
                                "textContains": "= .env."
                            },
                            "content": "This is the live working copy of the active environment.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">\ud83d\udd13 Active Copy</div><div class=\"state-detail\">In multi-environment mode, .env is automatically maintained as a copy of whichever environment is currently active.\n\nWhen you switch environments from the \ud83d\udd10 Secrets tab, the control plane saves this file back and copies the new environment into its place.\n\nYou don\u2019t edit .env directly for switching \u2014 use the Activate button in the Secrets tab.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": ".env.development"
                            },
                            "content": "Development environment secrets \u2014 used for local development and testing.",
                            "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">\ud83d\udea7 Development</div><div class=\"state-detail\">This file holds secrets for your development environment \u2014 typically local databases, test API keys, and debug configurations.\n\nIts contents are separate from production. When development is active, .env is a copy of this file.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": ".env.production"
                            },
                            "content": "Production environment secrets \u2014 used for released and deployed applications.",
                            "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">\ud83d\ude80 Production</div><div class=\"state-detail\">This file holds secrets for your production environment \u2014 live database credentials, real API keys, and deployment-specific configurations.\n\nHandle with extra care. When production is active, .env is a copy of this file. We suggest locking the vault when you move away \u2014 each environment can have its own passphrase for independent protection.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "Encrypted"
                            },
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">\ud83d\udd12 Encrypted</div><div class=\"state-detail\">Contents are safe on disk \u2014 this file can be committed to git without exposing secrets. To read or edit it, unlock through the \ud83d\udd10 Secrets tab.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "Plaintext"
                            },
                            "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">\ud83d\udd13 Plaintext</div><div class=\"state-detail\">Anyone with file access can read this file\u2019s contents. Use the \ud83d\udd10 Secrets tab to lock it when you\u2019re done editing \u2014 plaintext .env files should never be committed to git.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "Missing"
                            },
                            "expanded": "<div class=\"assistant-state-card state-error\"><div class=\"state-label\">\u274c Missing</div><div class=\"state-detail\">This file is expected but not found on disk. It may have been deleted or hasn\u2019t been created yet. Use + Create in the vault section above, or the \ud83d\udd10 Secrets tab.</div></div>"
                        }
                    ]
                },
                "children": []
            }
        ]
    },
    {
        "context": "wizard/content",
        "title": "Content Folders",
        "icon": "ğŸ“",
        "content": "Choose which folders appear in the ğŸ“ Content tab â€” your workspace for browsing, previewing, encrypting, and archiving project files.\n\nBelow the folders, you'll see the infrastructure directories that the control plane manages automatically. These track your chat history, audit traces, backups, and optimized large files â€” they're created on demand as you use the system.",
        "children": [
            {
                "id": "content-list",
                "title": "Project Folders",
                "icon": "ğŸ“‚",
                "selector": "#wiz-content-list",
                "separator": true,
                "content": "Select the folders you want to manage through the Content tab. Each selected folder becomes browsable with preview, encryption, download, and archive capabilities.",
                "expanded": "This controls the default folder tabs in the Content view. You can always browse any project directory using ğŸ—‚ Explore All â€” this selection just sets the defaults.\n\nğŸ’¡ Folders marked 'suggested' match common content folder patterns (docs, media, assets, etc). You don't have to include all of them â€” pick the ones that matter to your workflow.",
                "dynamic": true,
                "childTemplate": {
                    "title": "{{name}}",
                    "nameSelector": "div > div:first-child",
                    "content": "A project directory.",
                    "selector": "#wiz-content-list > label",
                    "variants": [
                        {
                            "when": {
                                "textContains": "Active",
                                "hasSelector": "[style*='suggested']"
                            },
                            "content": "This folder is selected and was auto-suggested as a common content folder.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Active Â· suggested</div><div class=\"state-detail\">This folder is included in the ğŸ“ Content tab. It matched a common content folder pattern and was pre-suggested.\n\nYou'll get full management capabilities: browsing, preview, upload, encryption, backup archives, and large file optimization.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "Active"
                            },
                            "content": "This folder is selected for content management.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Active</div><div class=\"state-detail\">This folder will appear as a tab in the ğŸ“ Content view. You can browse, upload, encrypt, download, and archive files inside it.\n\nUncheck it if you don't need to manage these files through the Content tab directly.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "suggested"
                            },
                            "content": "This looks like a good candidate for content management â€” it matches a common content folder pattern.",
                            "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ’¡ Suggested</div><div class=\"state-detail\">This directory name matches a common content folder pattern. Check it to include it in the Content tab â€” you'll get browsing, preview, encryption, and archive capabilities.\n\nSuggested doesn't mean required. If this folder isn't relevant to your workflow, leave it unchecked.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "â€”"
                            },
                            "content": "A project directory. Check the box to include it in the Content tab.",
                            "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">Not selected</div><div class=\"state-detail\">This folder exists in your project but isn't currently managed through the Content tab.\n\nCheck it if you want to browse, upload, encrypt, or archive files in this directory. Leave it unchecked if it's source code or configuration that doesn't need content management.</div></div>"
                        }
                    ]
                },
                "children": []
            },
            {
                "id": "content-infra",
                "title": "Content Infrastructure",
                "icon": "ğŸ—ï¸",
                "selector": "#wiz-content-infra",
                "separator": true,
                "content": "These directories are created and maintained by the control plane. They're gitignored and never need manual management â€” the system handles creation, population, and cleanup.",
                "expanded": "Think of them as internal storage layers:\n\nâ€¢ .ledger â€” shares data via git branches (chat threads, traces, audits)\nâ€¢ .state â€” local caches (preferences, scores, pending audits, run history)\nâ€¢ .backup â€” compressed archive snapshots from the Content tab\nâ€¢ .large â€” optimized oversized files, uploaded to release artifacts for sharing\nâ€¢ .pages â€” generated site builds from the Pages pipeline\n\nEach one is gitignored. The 'shared' badge on .ledger means it syncs with collaborators via git push/pull â€” everything else stays local to your machine.",
                "dynamic": true,
                "childTemplate": {
                    "title": "{{name}}",
                    "nameSelector": "code",
                    "content": "An infrastructure directory managed by the control plane.",
                    "selector": "#wiz-content-infra-list > div",
                    "variants": [
                        {
                            "when": {
                                "textContains": ".ledger"
                            },
                            "content": "Git worktree for shared project data â€” chat threads, trace snapshots, and saved audit records.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ“’ Ledger</div><div class=\"state-detail\">The ledger is a separate git branch checked out as a worktree at your project root. It stores:\n\nâ€¢ Chat threads and messages (from the ğŸ’¬ Chat tab)\nâ€¢ Execution traces (from traced operations)\nâ€¢ Saved audit snapshots (promoted from pending results)\n\nBadge: 'shared' means this data syncs with your remote repository via git push/pull. Collaborators get the same history.\n\nYou never interact with .ledger directly â€” the control plane handles all reads and writes through the ledger service.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": ".state"
                            },
                            "content": "Local cache â€” preferences, audit scores, pending audits, run history, and trace recordings.",
                            "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ’¾ Local State</div><div class=\"state-detail\">Machine-local storage for ephemeral and cached data:\n\nâ€¢ devops_prefs.json â€” your dashboard preferences\nâ€¢ devops_cache.json â€” cached scan results\nâ€¢ audit_activity.json â€” audit execution log\nâ€¢ audit_scores.json â€” audit score history\nâ€¢ pending_audits.json â€” audits awaiting review\nâ€¢ runs.jsonl â€” execution run history\nâ€¢ traces/ â€” local trace recordings before sharing\n\nNone of this leaves your machine. This directory is almost certainly present by now â€” the control plane creates it the first time any feature needs local persistence.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": ".backup"
                            },
                            "content": "Backup archives created from the Content tab's Archive view.",
                            "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ—„ï¸ Backups</div><div class=\"state-detail\">Compressed archive snapshots of folders you choose to protect. Created through the Archive view in the ğŸ“ Content tab.\n\nBackup archives can exist at any level â€” the root .backup holds project-wide archives, while individual content folders can have their own .backup subdirectories.\n\nFor off-machine protection, you can upload archives to GitHub release artifacts.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": ".large"
                            },
                            "content": "Optimized large files â€” gitignored, virtual in parent, uploadable to release artifacts.",
                            "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“¦ Large Files</div><div class=\"state-detail\">When files over 2 MB are uploaded through the Content tab, they're automatically moved to a .large subdirectory. The original filename appears virtually in the parent folder â€” you browse and manage them normally.\n\n.large is gitignored, so large files don't bloat your repository. For sharing, they can be uploaded to GitHub release artifacts (â˜ï¸ icon in the Content tab).\n\nThis directory can appear at any folder level â€” not just inside configured content folders. The content browser's Explore All mode can work with .large directories anywhere in the project.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": ".pages"
                            },
                            "content": "Generated site output from the Pages pipeline.",
                            "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸŒ Pages Output</div><div class=\"state-detail\">Build output from the Pages pipeline â€” your generated Docusaurus site, static assets, and deployment artifacts.\n\nThis directory is rebuilt on each deploy. It's not something you edit directly â€” changes flow from your source content through the Pages build process.\n\nğŸ’¡ If you see this without having used Pages yet, it was likely created by a previous build or site generation run.</div></div>"
                        }
                    ]
                },
                "children": []
            }
        ]
    },
    {
        "context": "wizard/integrations",
        "title": "Integrations & DevOps",
        "icon": "ğŸ”Œ",
        "content": "This step detects your environment and lets you choose which integrations are active. {{toolsInstalled}} of {{toolsTotal}} tools are available, {{filesDetected}} project files detected, and {{integrationCount}} integration cards are ready to configure.\n\nEach integration you enable here becomes a card on the dashboard â€” giving you one-click access to its setup, status, and operations.",
        "children": [
            {
                "id": "scan-bar",
                "title": "Scan Status",
                "icon": "ğŸ”",
                "selector": "#wiz-int-scan-bar",
                "content": "The control plane scans your project root and system PATH to detect available tools, project files, and integration readiness.",
                "expanded": "Results are cached in-memory and in your browser's session storage so you don't wait on every step change. The age shown is how long ago the last scan completed.\n\nHit ğŸ”„ Re-scan to force a fresh detection â€” useful after installing a tool or adding a Dockerfile.",
                "variants": [
                    {
                        "when": {
                            "textContains": "rescan recommended"
                        },
                        "content": "Files on disk have changed since the last scan â€” the detection results may be stale.",
                        "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš¡ Stale</div><div class=\"state-detail\">The staleness watcher detected file changes in your project since the last scan. This means new or modified Dockerfiles, manifests, config files, or tool installations may not be reflected in the current detection.\n\nHit ğŸ”„ Re-scan to refresh. The scan is fast (< 2 seconds) and updates everything: tool availability, file detection, stack defaults, and integration status.</div></div>"
                    },
                    {
                        "when": {
                            "textContains": "fresh"
                        },
                        "content": "The scan is recent and up to date â€” detection results reflect the current state of your project.",
                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ“ Fresh</div><div class=\"state-detail\">Scan completed less than 30 seconds ago. All tool checks, file detection, and integration status reflect the current state of your project.\n\nYou can still force a re-scan anytime if you've made changes since landing on this step.</div></div>"
                    }
                ],
                "children": []
            },
            {
                "id": "system-tools",
                "title": "System Tools",
                "icon": "ğŸ”§",
                "selector": "#wiz-int-tools-section",
                "content": "{{toolsInstalled}} of {{toolsTotal}} development tools are available on your system. These are the CLI binaries the control plane calls to perform real work â€” building images, running tests, scanning for vulnerabilities, deploying to clusters.",
                "expanded": "Tools marked âœ— are missing from your PATH. You can install them directly from here â€” pip-based tools install into your current virtualenv, while system tools need sudo.\n\nEvery tool here maps to a specific pipeline in the control plane. Missing tools don't block setup, but they'll limit what the corresponding integration cards can do.",
                "dynamic": true,
                "childTemplate": {
                    "selector": "[id^='wiz-int-tool-']",
                    "nameSelector": "code",
                    "title": "{{name}}",
                    "content": "Development tool used by the control plane.",
                    "variants": [
                        {
                            "when": {
                                "textContains": "âœ“ git"
                            },
                            "title": "git âœ“",
                            "icon": "âœ…",
                            "content": "Version control â€” the foundation everything else depends on.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Installed</div><div class=\"state-detail\">Git is the bedrock of the control plane. Every integration below â€” GitHub, CI/CD, Docker, K8s â€” assumes a git repository exists.\n\nThe control plane uses git for: commit tracking, remote detection, branch awareness, .gitignore analysis, and the entire sync pipeline that pushes secrets and configs to GitHub.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "git"
                            },
                            "content": "Version control â€” the foundation everything else depends on.",
                            "expanded": "<div class=\"assistant-state-card state-error\"><div class=\"state-label\">âŒ Missing â€” Critical</div><div class=\"state-detail\">Git is not installed. This blocks nearly every integration â€” GitHub, CI/CD, Docker builds, and K8s deployments all assume a git repository.\n\nInstall it now. Without git, the control plane cannot detect your project structure or sync configurations.\n\nğŸ“¦ Installs via: sudo apt-get install git</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "âœ“ gh"
                            },
                            "title": "gh âœ“",
                            "icon": "âœ…",
                            "content": "GitHub CLI â€” manages PRs, secrets, Actions, and environments from the terminal.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Installed</div><div class=\"state-detail\">The GitHub CLI is how the control plane interacts with your GitHub repository without needing API tokens or REST calls.\n\nUsed for: pushing secrets (gh secret set), syncing variables (gh variable set), dispatching workflows, creating deployment environments, and managing pull requests â€” all from the dashboard.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "gh"
                            },
                            "content": "GitHub CLI â€” manages PRs, secrets, Actions, and environments from the terminal.",
                            "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš  Missing</div><div class=\"state-detail\">Without the GitHub CLI, you can't sync secrets to GitHub, dispatch workflows, or manage deployment environments from the control plane.\n\nThe control plane exclusively uses `gh` for all GitHub operations â€” no raw REST API calls. Install it to unlock the full GitHub integration.\n\nğŸ“¦ Installs via: sudo snap install gh</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "âœ“ docker-compose"
                            },
                            "title": "docker-compose âœ“",
                            "icon": "âœ…",
                            "content": "Multi-service orchestration â€” manages docker-compose.yml stacks.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Installed</div><div class=\"state-detail\">Docker Compose is available. The control plane uses it to parse your compose files, enumerate services, manage stack lifecycle (up/down/restart), and generate compose configurations with detected stack defaults.\n\nYour compose services will appear in the Docker integration card with per-service controls.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "docker-compose"
                            },
                            "content": "Multi-service orchestration â€” manages docker-compose.yml stacks.",
                            "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš  Missing</div><div class=\"state-detail\">Docker Compose orchestrates multi-container applications from a single YAML file. Without it, the control plane can't manage your compose stacks, start/stop services, or generate compose configurations.\n\nIf you only run single containers, this is optional. For multi-service setups (API + database + cache), it's essential.\n\nğŸ“¦ Installs via: sudo apt-get install docker-compose-v2</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "âœ“ docker"
                            },
                            "title": "docker âœ“",
                            "icon": "âœ…",
                            "content": "Container runtime â€” builds images, runs containers, talks to the Docker daemon.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Installed</div><div class=\"state-detail\">Docker is available. The control plane uses it for: building container images from your Dockerfile, running docker compose stacks, inspecting the daemon for running containers, and producing deployment artifacts.\n\nThe Docker integration card on the dashboard gives you image management, compose orchestration, and Dockerfile generation â€” all powered by this binary.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "docker"
                            },
                            "content": "Container runtime â€” builds images, runs containers, talks to the Docker daemon.",
                            "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš  Missing</div><div class=\"state-detail\">Docker is not installed. Without it, the control plane can't build container images, run compose stacks, or produce deployment artifacts.\n\nThe Docker integration card will still appear but will be limited to configuration â€” no builds or daemon interaction until Docker is available.\n\nğŸ“¦ Installs via: sudo apt-get install docker.io</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "âœ“ kubectl"
                            },
                            "title": "kubectl âœ“",
                            "icon": "âœ…",
                            "content": "Kubernetes CLI â€” talks to clusters, applies manifests, inspects workloads.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Installed</div><div class=\"state-detail\">kubectl is available and the control plane can interact with Kubernetes clusters. Used for: applying manifests, inspecting pods/services/deployments, checking cluster connectivity, and the K8s manifest wizard.\n\nThe Kubernetes integration card uses kubectl for all cluster operations. Make sure your kubeconfig points to the right cluster.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "kubectl"
                            },
                            "content": "Kubernetes CLI â€” talks to clusters, applies manifests, inspects workloads.",
                            "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš  Missing</div><div class=\"state-detail\">Without kubectl, the control plane can't communicate with Kubernetes clusters. The K8s integration card will be limited to manifest generation â€” no live cluster operations.\n\nIf you're not deploying to Kubernetes, this is safe to skip.\n\nğŸ“¦ Installs via: sudo snap install kubectl --classic</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "âœ“ terraform"
                            },
                            "title": "terraform âœ“",
                            "icon": "âœ…",
                            "content": "Infrastructure as Code â€” provisions cloud resources from declarative configs.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Installed</div><div class=\"state-detail\">Terraform is available. The control plane uses it for: scaffolding provider configurations, generating backend state configs, planning infrastructure changes, and integrating with the Terraform card on the dashboard.\n\nThe Terraform integration detects your providers, backend, and existing state to give you a clear picture of your infrastructure posture.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "terraform"
                            },
                            "content": "Infrastructure as Code â€” provisions cloud resources from declarative configs.",
                            "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš  Missing</div><div class=\"state-detail\">Without Terraform, the control plane can't scaffold IaC configs or inspect your infrastructure state. The Terraform card will be hidden by default unless you have a terraform/ directory.\n\nIf you manage infrastructure through other means (CloudFormation, Pulumi, manual), this is safe to skip.\n\nğŸ“¦ Installs via: sudo snap install terraform --classic</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "âœ“ helm"
                            },
                            "title": "helm âœ“",
                            "icon": "âœ…",
                            "content": "Kubernetes package manager â€” manages charts, releases, and values files.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Installed</div><div class=\"state-detail\">Helm is available. The control plane uses it alongside kubectl for: listing releases, inspecting chart values, and generating Helm-based deployment configurations in the K8s manifest wizard.\n\nHelm charts provide a higher-level abstraction over raw K8s manifests â€” especially useful for complex applications with many resources.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "helm"
                            },
                            "content": "Kubernetes package manager â€” manages charts, releases, and values files.",
                            "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš  Missing</div><div class=\"state-detail\">Without Helm, the control plane can still work with raw K8s manifests via kubectl. Helm adds chart management and release tracking on top.\n\nIf you deploy with raw YAML manifests, Helm is optional. If your project uses Helm charts, install it.\n\nğŸ“¦ Installs via: curl script (sudo required)</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "âœ“ node"
                            },
                            "title": "node âœ“",
                            "icon": "âœ…",
                            "content": "Node.js runtime â€” required for npm, npx, and JavaScript-based tooling.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Installed</div><div class=\"state-detail\">Node.js is available. The control plane uses it indirectly through npm/npx for: JavaScript linting (ESLint), formatting (Prettier), and the Pages pipeline (Docusaurus builds).\n\nIf your project includes JavaScript or TypeScript modules, Node.js enables their full toolchain integration.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "node"
                            },
                            "content": "Node.js runtime â€” required for npm, npx, and JavaScript-based tooling.",
                            "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš  Missing</div><div class=\"state-detail\">Without Node.js, JavaScript-based tools (ESLint, Prettier) and the Pages pipeline (Docusaurus) won't work. If your project is pure Python/Go/Rust, this is safe to skip.\n\nğŸ“¦ Installs via: sudo snap install node --classic</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "âœ“ npm"
                            },
                            "title": "npm âœ“",
                            "icon": "âœ…",
                            "content": "Node package manager â€” installs JS dependencies and runs scripts.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Installed</div><div class=\"state-detail\">npm is available. Used by the control plane for: installing global tools (ESLint, Prettier), managing package.json dependencies, and running build scripts in JS/TS modules.\n\nThe Packages integration card uses npm for dependency auditing in Node.js projects.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "npm"
                            },
                            "content": "Node package manager â€” installs JS dependencies and runs scripts.",
                            "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš  Missing</div><div class=\"state-detail\">Without npm, JavaScript tooling can't be installed and package.json projects can't be managed. Usually installed alongside Node.js.\n\nğŸ“¦ Installs via: sudo apt-get install npm</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "âœ“ ruff"
                            },
                            "title": "ruff âœ“",
                            "icon": "âœ…",
                            "content": "Python linter and formatter â€” fast, Rust-powered, replaces flake8 + isort + black.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Installed</div><div class=\"state-detail\">Ruff is available. The control plane uses it in the Quality pipeline and audit scoring â€” it checks Python code for style violations, import ordering, and common mistakes.\n\nRuff is an order of magnitude faster than traditional Python linters. Its results feed into the ğŸ”§ Code Quality card on the dashboard.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "ruff"
                            },
                            "content": "Python linter and formatter â€” fast, Rust-powered, replaces flake8 + isort + black.",
                            "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš  Missing</div><div class=\"state-detail\">Without Ruff, the Code Quality card can't run lint checks on Python code. The audit scoring system treats this as a gap in your quality posture.\n\nIt's a pip install â€” no sudo needed, installs into your current virtualenv.\n\nğŸ“¦ Installs via: pip install ruff</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "âœ“ mypy"
                            },
                            "title": "mypy âœ“",
                            "icon": "âœ…",
                            "content": "Python static type checker â€” catches type errors before runtime.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Installed</div><div class=\"state-detail\">mypy is available. The control plane uses it in the Quality pipeline to verify type annotations across your Python codebase.\n\nType checking results feed into audit scoring. Projects with strict typing enabled score higher on the quality dimension.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "mypy"
                            },
                            "content": "Python static type checker â€” catches type errors before runtime.",
                            "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš  Missing</div><div class=\"state-detail\">Without mypy, the Quality pipeline skips type checking. If your Python code uses type annotations, installing mypy will improve your audit quality score.\n\nğŸ“¦ Installs via: pip install mypy</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "âœ“ pytest"
                            },
                            "title": "pytest âœ“",
                            "icon": "âœ…",
                            "content": "Python test runner â€” discovers and executes test suites.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Installed</div><div class=\"state-detail\">pytest is available. The control plane uses it in the Testing pipeline â€” running your test suite, collecting coverage data, and feeding results into the ğŸ§ª Testing card.\n\nTest results are a core input to audit scoring. Projects with passing tests and good coverage score significantly higher.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "pytest"
                            },
                            "content": "Python test runner â€” discovers and executes test suites.",
                            "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš  Missing</div><div class=\"state-detail\">Without pytest, the Testing card can't run your test suite or collect coverage. The audit scoring system will flag the testing dimension as uncovered.\n\nğŸ“¦ Installs via: pip install pytest</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "âœ“ pip-audit"
                            },
                            "title": "pip-audit âœ“",
                            "icon": "âœ…",
                            "content": "Python vulnerability scanner â€” checks installed packages against the PyPI advisory database.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Installed</div><div class=\"state-detail\">pip-audit is available. The control plane uses it in the Security pipeline to scan your Python dependencies for known CVEs.\n\nResults feed into the ğŸ” Security Posture card. It cross-references your installed packages against the PyPI advisory database and OSV.dev.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "pip-audit"
                            },
                            "content": "Python vulnerability scanner â€” checks installed packages against the PyPI advisory database.",
                            "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš  Missing</div><div class=\"state-detail\">Without pip-audit, the Security card can't check your Python dependencies for known vulnerabilities. This is one of the three security scanners the control plane uses.\n\nğŸ“¦ Installs via: pip install pip-audit</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "âœ“ bandit"
                            },
                            "title": "bandit âœ“",
                            "icon": "âœ…",
                            "content": "Python security linter â€” scans source code AST for common vulnerability patterns.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Installed</div><div class=\"state-detail\">Bandit is available. The control plane uses it in the Security pipeline to perform static analysis on your Python source code â€” looking for hardcoded passwords, insecure function calls, SQL injection patterns, and similar issues.\n\nUnlike pip-audit (which checks dependencies), Bandit scans your own code.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "bandit"
                            },
                            "content": "Python security linter â€” scans source code AST for common vulnerability patterns.",
                            "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš  Missing</div><div class=\"state-detail\">Without Bandit, the Security card can't scan your Python source code for vulnerability patterns. It complements pip-audit (which checks dependencies) by inspecting your actual code.\n\nğŸ“¦ Installs via: pip install bandit</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "âœ“ safety"
                            },
                            "title": "safety âœ“",
                            "icon": "âœ…",
                            "content": "Python dependency checker â€” cross-references packages against a known vulnerability database.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Installed</div><div class=\"state-detail\">Safety is available. It provides a second opinion to pip-audit by checking your Python dependencies against its own vulnerability database.\n\nThe control plane runs both pip-audit and Safety for comprehensive coverage â€” they use different data sources and catch different issues.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "safety"
                            },
                            "content": "Python dependency checker â€” cross-references packages against a known vulnerability database.",
                            "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš  Missing</div><div class=\"state-detail\">Without Safety, you lose one of the two dependency vulnerability scanners. pip-audit and Safety complement each other â€” they use different databases and catch different CVEs.\n\nğŸ“¦ Installs via: pip install safety</div></div>"
                        }
                    ]
                },
                "children": []
            },
            {
                "id": "file-detection",
                "title": "File Detection",
                "icon": "ğŸ“‹",
                "selector": "#wiz-int-files-section",
                "content": "{{filesDetected}} of {{filesTotal}} project files detected. These are the files and directories the control plane looks for to determine which integrations are relevant to your project.",
                "expanded": "Each pill represents a specific file or directory. Found files (â—) activate their corresponding integration by default â€” for example, a Dockerfile enables the Docker card, and a k8s/ directory enables Kubernetes.\n\nMissing files (â—‹) don't block anything â€” you can still enable integrations manually and the control plane will generate the missing files for you during setup.",
                "dynamic": true,
                "childTemplate": {
                    "selector": "#wiz-int-files-section > span",
                    "title": "{{name}}",
                    "content": "Project file or directory used for integration detection.",
                    "variants": [
                        {
                            "when": {
                                "textContains": "â— git repo"
                            },
                            "title": "git repo â—",
                            "content": "A .git directory exists â€” this project is under version control.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">â— Found</div><div class=\"state-detail\">The .git directory confirms this is a git repository. This is the foundation for Git, GitHub, and CI/CD integrations.\n\nThe control plane reads your remotes, branches, and commit history from this directory.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "â—‹ git repo"
                            },
                            "title": "git repo â—‹",
                            "content": "No .git directory found â€” this project is not yet under version control.",
                            "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">â—‹ Not found</div><div class=\"state-detail\">No git repository detected. Run `git init` to initialize one. Without it, the Git, GitHub, and CI/CD integrations cannot function.\n\nThe control plane will still let you configure integrations, but they won't be operational until a repository exists.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "â— dockerfile"
                            },
                            "title": "dockerfile â—",
                            "content": "A Dockerfile exists at the project root â€” Docker image builds are possible.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">â— Found</div><div class=\"state-detail\">Your project has a Dockerfile. The Docker integration card can build images, inspect layers, and integrate with your CI/CD pipeline for automated builds.\n\nThe control plane parses your Dockerfile to detect base images, exposed ports, and build stages.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "â—‹ dockerfile"
                            },
                            "title": "dockerfile â—‹",
                            "content": "No Dockerfile at the project root.",
                            "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â—‹ Not found</div><div class=\"state-detail\">No Dockerfile detected. The Docker integration can generate one for you based on your detected stack â€” including the right base image, dependencies, and port exposure.\n\nUse the âš™ï¸ Setup button on the Docker card to scaffold a Dockerfile.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "â— docker compose"
                            },
                            "title": "docker compose â—",
                            "content": "A docker-compose.yml exists â€” multi-service orchestration is configured.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">â— Found</div><div class=\"state-detail\">Your project has a compose file. The Docker integration parses it to enumerate services, detect ports, and provide per-service management from the dashboard.\n\nServices from your compose file appear in the Docker card with start/stop/restart controls.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "â—‹ docker compose"
                            },
                            "title": "docker compose â—‹",
                            "content": "No docker-compose.yml or docker-compose.yaml found.",
                            "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â—‹ Not found</div><div class=\"state-detail\">No compose file detected. If your project needs multiple services (API + database + cache), the Docker setup wizard can generate a compose file with detected stack defaults.\n\nSingle-container projects often don't need compose at all.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "â— k8s manifests"
                            },
                            "title": "k8s manifests â—",
                            "content": "A k8s/ or kubernetes/ directory exists â€” Kubernetes manifests are present.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">â— Found</div><div class=\"state-detail\">Kubernetes manifests detected. The K8s integration card can apply these to your cluster, inspect their status, and generate additional manifests through the K8s wizard.\n\nThe manifest wizard supports Deployments, Services, ConfigMaps, Secrets, PVCs, Ingress, and more.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "â—‹ k8s manifests"
                            },
                            "title": "k8s manifests â—‹",
                            "content": "No k8s/ or kubernetes/ directory found.",
                            "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â—‹ Not found</div><div class=\"state-detail\">No Kubernetes manifest directory detected. If you plan to deploy to K8s, the manifest wizard can generate a complete set of manifests based on your project's stack and requirements.\n\nEnable the Kubernetes integration to get started.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "â— terraform dir"
                            },
                            "title": "terraform dir â—",
                            "content": "A terraform/ directory or main.tf exists â€” infrastructure as code is configured.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">â— Found</div><div class=\"state-detail\">Terraform configuration detected. The Terraform integration card can inspect your providers, backend configuration, and state to give you infrastructure visibility from the dashboard.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "â—‹ terraform dir"
                            },
                            "title": "terraform dir â—‹",
                            "content": "No terraform/ directory or main.tf found.",
                            "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â—‹ Not found</div><div class=\"state-detail\">No Terraform configuration detected. The Terraform integration can scaffold a complete IaC setup â€” provider config, backend state, and resource templates â€” tailored to your cloud provider.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "â— github actions"
                            },
                            "title": "github actions â—",
                            "content": "GitHub Actions workflows exist in .github/workflows/.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">â— Found</div><div class=\"state-detail\">GitHub Actions workflows detected. The CI/CD integration card can list, enable, disable, and dispatch these workflows. It also detects which secrets and variables each workflow needs.\n\nThe control plane can generate additional workflows (cron-based pipelines, deployment workflows) through the CI/CD setup.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "â—‹ github actions"
                            },
                            "title": "github actions â—‹",
                            "content": "No .github/workflows/ directory found.",
                            "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â—‹ Not found</div><div class=\"state-detail\">No GitHub Actions workflows detected. The CI/CD integration can generate a pipeline workflow that runs your project's tests, security scans, and builds on push and on a schedule.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "â— pyproject"
                            },
                            "title": "pyproject â—",
                            "content": "pyproject.toml found â€” Python project metadata and dependencies are defined.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">â— Found</div><div class=\"state-detail\">Your project has a pyproject.toml. The control plane reads this for: dependency lists (used by security scanners), version metadata, build configuration, and tool settings (ruff, mypy, pytest).\n\nThis is the modern standard for Python project configuration.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "â—‹ pyproject"
                            },
                            "title": "pyproject â—‹",
                            "content": "No pyproject.toml found.",
                            "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â—‹ Not found</div><div class=\"state-detail\">No pyproject.toml detected. If this is a Python project, the control plane uses it for dependency scanning, tool configuration, and build metadata. Without it, setup.py or requirements.txt are used as fallbacks.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "â— package json"
                            },
                            "title": "package json â—",
                            "content": "package.json found â€” Node.js project metadata and dependencies are defined.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">â— Found</div><div class=\"state-detail\">Your project has a package.json. The control plane reads this for: dependency lists (npm audit), scripts, version metadata, and detected stack classification.\n\nThe Packages card uses this for npm dependency management and vulnerability scanning.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "â—‹ package json"
                            },
                            "title": "package json â—‹",
                            "content": "No package.json found.",
                            "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â—‹ Not found</div><div class=\"state-detail\">No package.json detected. If this isn't a Node.js project, this is expected and safe to ignore.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "â— pages config"
                            },
                            "title": "pages config â—",
                            "content": "project.yml found â€” Pages pipeline configuration is available.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">â— Found</div><div class=\"state-detail\">project.yml is present. The Pages integration uses it for site generation settings â€” docs source directories, Docusaurus configuration, and deployment targets.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "â—‹ pages config"
                            },
                            "title": "pages config â—‹",
                            "content": "No project.yml found.",
                            "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â—‹ Not found</div><div class=\"state-detail\">No project.yml detected. This file is generated by the Setup Wizard when you finish â€” it contains all your project configuration including module definitions, environment settings, and integration preferences.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "â— dns dir"
                            },
                            "title": "dns dir â—",
                            "content": "A dns/ directory exists â€” DNS configuration files are present.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">â— Found</div><div class=\"state-detail\">DNS configuration directory detected. The DNS & CDN integration card reads zone files and record definitions from this directory for domain management.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "â—‹ dns dir"
                            },
                            "title": "dns dir â—‹",
                            "content": "No dns/ directory found.",
                            "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â—‹ Not found</div><div class=\"state-detail\">No DNS directory detected. The DNS integration can generate one with record templates for your domains when you set it up.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "â— cdn dir"
                            },
                            "title": "cdn dir â—",
                            "content": "A cdn/ directory exists â€” CDN configuration is present.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">â— Found</div><div class=\"state-detail\">CDN configuration directory detected. The DNS & CDN integration uses this for edge caching rules, origin settings, and CDN deployment configuration.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "â—‹ cdn dir"
                            },
                            "title": "cdn dir â—‹",
                            "content": "No cdn/ directory found.",
                            "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â—‹ Not found</div><div class=\"state-detail\">No CDN directory detected. If you need CDN configuration for your static sites or APIs, the DNS & CDN integration can scaffold one during setup.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "â— cname file"
                            },
                            "title": "cname file â—",
                            "content": "A CNAME file exists â€” custom domain for GitHub Pages is configured.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">â— Found</div><div class=\"state-detail\">A CNAME file is present, pointing your GitHub Pages site to a custom domain. The Pages integration uses this for deployment URL resolution and DNS record validation.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "â—‹ cname file"
                            },
                            "title": "cname file â—‹",
                            "content": "No CNAME file found.",
                            "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â—‹ Not found</div><div class=\"state-detail\">No CNAME file detected. Without it, GitHub Pages uses the default github.io subdomain. If you want a custom domain, the Pages setup can create this file for you.</div></div>"
                        }
                    ]
                },
                "children": []
            },
            {
                "id": "integrations-section",
                "title": "Integrations",
                "icon": "ğŸ”Œ",
                "selector": "#wiz-int-section-integrations",
                "separator": true,
                "content": "These three integrations form the project's collaboration backbone â€” version control, remote hosting, and static site deployment.",
                "expanded": "Git, GitHub, and Pages work as a chain: Git provides the repository, GitHub connects it to a remote with CI/CD and secrets management, and Pages deploys your documentation or static site through that remote.\n\nEach card shows its current status and readiness. Enable or disable cards with the checkbox â€” disabled cards won't appear on the dashboard but can be re-enabled anytime.\n\nClick âš™ï¸ Setup on any card for inline configuration, or ğŸš€ Full Setup for the complete setup wizard with guided steps.",
                "children": [
                    {
                        "id": "git-card",
                        "title": "Git",
                        "icon": "ğŸ”€",
                        "selector": "#wiz-int-wrap-int-git",
                        "content": "Version control is the foundation of the control plane. Every integration â€” GitHub, CI/CD, Docker, K8s, Pages â€” depends on an initialized git repository with at least one remote.",
                        "expanded": "Git underpins the entire pipeline. The control plane uses it for commit tracking, remote detection, branch management, .gitignore analysis, and the sync pipeline that pushes secrets and configs to GitHub.\n\nThe checkbox enables or hides the Git card from the dashboard. Even disabled, git is still required by other integrations â€” GitHub reads your remotes, CI/CD triggers on push events, Docker builds embed commit SHAs in image labels, and the vault system from Step 3 relies on .gitignore to protect plaintext .env files.\n\nClick âš™ï¸ Setup to configure remotes, .gitignore, hooks, and initial commit in one pass.",
                        "variants": [
                            {
                                "when": {
                                    "textContains": "âœ… ready"
                                },
                                "content": "Your repository is initialized and connected â€” the foundation is healthy. Every downstream integration (GitHub, CI/CD, Docker, Pages) builds on this.",
                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Fully Configured</div><div class=\"state-detail\">The control plane can read your remotes, track branches, analyse .gitignore coverage, and manage commit hooks. This is the baseline that unlocks everything else.\n\nYour .gitignore protects the vault secrets from Step 3 â€” encrypted .env files, plaintext credentials, and auto-generated keys are all excluded from version control. Pre-commit hooks, if installed, enforce the lint and format tools detected in System Tools above before each commit reaches the repository.\n\nOpen âš™ï¸ Setup to fine-tune: add or remove remotes, regenerate .gitignore with stack-aware patterns, or wire pre-commit hooks into your toolchain. Use ğŸš€ Full Setup for the guided wizard with validation.</div></div>"
                            },
                            {
                                "when": {
                                    "textContains": "not configured"
                                },
                                "content": "Git is installed but this directory isn't a repository yet. Downstream integrations (GitHub, CI/CD) are blocked until you initialize one.",
                                "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš  No Repository</div><div class=\"state-detail\">The git binary is available but there's no .git/ directory in your project root. Without git init, the control plane can't detect remotes, branches, or .gitignore â€” and the GitHub and CI/CD cards below are stuck in an unconfigured state too.\n\nThis is the most actionable state â€” one setup pass fixes the entire chain. Click âš™ï¸ Setup to initialize the repository, choose a default branch, generate a stack-aware .gitignore, and optionally create an initial commit.\n\nAfter applying, hit ğŸ”„ Re-scan in the scan bar above. The GitHub card will update to reflect the new repository, CI/CD workflow generation becomes available, and the File Detection pills will show the git repo as found.</div></div>"
                            },
                            {
                                "when": {
                                    "textContains": "not installed"
                                },
                                "content": "Git is not installed on this system. This is the single most critical blocker â€” every integration depends on it, directly or transitively.",
                                "expanded": "<div class=\"assistant-state-card state-error\"><div class=\"state-label\">âŒ Critical â€” Not Installed</div><div class=\"state-detail\">Without git, the control plane cannot initialize a repository, detect project structure, sync configurations, or interact with any remote service. Every integration card below â€” GitHub, CI/CD, Docker, K8s, Terraform, Pages, DNS â€” depends on git either directly or through the repository it manages.\n\nThe vault system from Step 3 also needs a repository so that .gitignore can protect plaintext .env files from accidental commits. The chat sync feature uses git push/pull for message replication.\n\nInstall git first, then hit ğŸ”„ Re-scan in the scan bar above. All other integrations will unblock once the binary is on your PATH.\n\nğŸ“¦ Install: sudo apt-get install git</div></div>"
                            }
                        ],
                        "children": [
                            {
                                "id": "git-setup",
                                "title": "Setup Panel",
                                "icon": "âš™ï¸",
                                "selector": "#wiz-int-setup-int-git",
                                "content": "The Git setup panel configures your repository in one pass â€” initialization, remotes, .gitignore, hooks, and initial commit. Hit âœ… Apply to execute all changes in sequence.",
                                "expanded": "The status strip at the top shows what's already in place (âœ“ green) and what's missing (â—‹ gray). Each section below targets one aspect of git configuration.\n\nChanges are applied when you click âœ… Apply â€” nothing runs until then. The panel re-detects after applying, so all cards and pills update to reflect the new state.\n\nThis is the inline version. For a more guided experience with step-by-step validation, use ğŸš€ Full Setup instead.",
                                "children": [
                                    {
                                        "id": "git-status-strip",
                                        "title": "Status Strip",
                                        "icon": "ğŸ“Š",
                                        "selector": "#wiz-git-status-strip",
                                        "content": "At-a-glance health check â€” each pill tracks one aspect of your git configuration. Green (âœ“) means configured, gray (â—‹) means missing or not yet set up.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“Š Configuration Overview</div><div class=\"state-detail\">The status strip provides a quick visual summary of your repository's setup state. Each pill corresponds to a section below where you can configure the missing piece.\n\nThe strip updates after every Apply or re-scan. It reads live detection data from the backend â€” not cached state â€” so it always reflects the current reality on disk.\n\nHover any individual pill for details about that specific check and what to do if it's showing a failure state.</div></div>",
                                        "children": [
                                            {
                                                "id": "git-pill-binary",
                                                "title": "Git Binary",
                                                "icon": "ğŸ’»",
                                                "selector": "#wiz-git-pill-binary",
                                                "content": "Whether the git binary is installed and available on your system PATH.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ’» Git Installation</div><div class=\"state-detail\">This pill checks if the git executable is reachable. The version number shown is the installed version.\n\nGit is the foundation â€” every other pill, section, and the entire GitHub integration depends on it. If this shows âœ—, nothing else in this panel works.</div></div>",
                                                "variants": [
                                                    {
                                                        "when": {
                                                            "textContains": "âœ“ git"
                                                        },
                                                        "content": "Git is installed and available. The version number is detected from git --version.",
                                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Git Available</div><div class=\"state-detail\">The git binary was found on PATH and responded to version check. All git operations are unblocked.\n\nThe version shown is informational â€” the control plane works with any modern git version (2.x+).</div></div>"
                                                    },
                                                    {
                                                        "when": {
                                                            "textContains": "âœ— git"
                                                        },
                                                        "content": "Git is not installed â€” this blocks every integration in this panel.",
                                                        "expanded": "<div class=\"assistant-state-card state-error\"><div class=\"state-label\">âŒ Git Missing</div><div class=\"state-detail\">The git executable was not found on PATH. This blocks:\n\nâ€¢ Repository initialization\nâ€¢ Remote management\nâ€¢ .gitignore generation\nâ€¢ Hook installation\nâ€¢ Commit operations\nâ€¢ The entire GitHub integration\n\nInstall git first, then re-scan to refresh this panel.</div></div>"
                                                    }
                                                ],
                                                "children": []
                                            },
                                            {
                                                "id": "git-pill-repo",
                                                "title": "Repository",
                                                "icon": "ğŸ“",
                                                "selector": "#wiz-git-pill-repo",
                                                "content": "Whether a .git/ directory exists â€” indicates the project is a git repository.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“ Repository Status</div><div class=\"state-detail\">This pill checks for a .git/ directory in your project root. The branch name after the dot shows your current HEAD branch.\n\nInitialization creates the .git/ directory, which stores all version control metadata â€” commits, branches, refs, hooks, and configuration.</div></div>",
                                                "variants": [
                                                    {
                                                        "when": {
                                                            "textContains": "âœ“ repo"
                                                        },
                                                        "content": "Repository is initialized â€” the branch name shown is your current HEAD.",
                                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Repository Initialized</div><div class=\"state-detail\">A .git/ directory exists. The branch name after 'repo Â·' is your current HEAD â€” this is the active branch that commits will target.\n\nWith a repository in place, all other operations are unblocked: adding remotes, generating .gitignore, installing hooks, and making commits.</div></div>"
                                                    },
                                                    {
                                                        "when": {
                                                            "textContains": "â—‹ no repo"
                                                        },
                                                        "content": "No repository â€” git init will be run when you Apply.",
                                                        "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš  Not Initialized</div><div class=\"state-detail\">No .git/ directory found. The project is not under version control yet.\n\nWhen you hit âœ… Apply, the control plane runs git init to create the repository. The default branch name is set from the Default Branch field below.\n\nUntil initialized: no commits, no branches, no remotes, no hooks.</div></div>"
                                                    }
                                                ],
                                                "children": []
                                            },
                                            {
                                                "id": "git-pill-remotes",
                                                "title": "Remotes Count",
                                                "icon": "ğŸŒ",
                                                "selector": "#wiz-git-pill-remotes",
                                                "content": "How many remotes are configured â€” at least one (origin) is needed for push/pull and GitHub features.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸŒ Remote Count</div><div class=\"state-detail\">This pill counts all configured remotes (git remote -v). The number includes both origin and any additional remotes like upstream or deploy.\n\nThe GitHub integration reads the origin remote to determine your repository â€” no remotes means no GitHub features.</div></div>",
                                                "variants": [
                                                    {
                                                        "when": {
                                                            "textContains": "remote(s)"
                                                        },
                                                        "content": "At least one remote is configured â€” push/pull and GitHub integration are available.",
                                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Remotes Configured</div><div class=\"state-detail\">Your repository has one or more remotes. The origin remote is used by the GitHub integration to determine your repository slug for secrets sync, PR management, workflow dispatch, and Pages deployment.\n\nYou can manage remotes in the Remotes section below â€” add new ones or remove existing ones.</div></div>"
                                                    },
                                                    {
                                                        "when": {
                                                            "textContains": "â—‹ no remotes"
                                                        },
                                                        "content": "No remotes â€” push/pull and all GitHub features are blocked.",
                                                        "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš  No Remotes</div><div class=\"state-detail\">Without remotes, your repository is local-only. The control plane can't push code, sync secrets, dispatch CI/CD workflows, or deploy Pages.\n\nOpen the Remotes section below to add origin. If the GitHub CLI is authenticated, the URL may be pre-filled.</div></div>"
                                                    }
                                                ],
                                                "children": []
                                            },
                                            {
                                                "id": "git-pill-gitignore",
                                                "title": "Gitignore Status",
                                                "icon": "ğŸ“„",
                                                "selector": "#wiz-git-pill-gitignore",
                                                "content": "Whether .gitignore exists and what percentage of recommended patterns it covers.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“„ Coverage Check</div><div class=\"state-detail\">This pill shows two things: whether a .gitignore file exists, and if so, what percentage of recommended patterns (for your detected stacks) are present.\n\n100% means every recommended pattern is covered. Lower percentages mean gaps exist â€” potential for secrets or build artifacts to leak into version control.\n\nOpen the .gitignore section below for details on what's missing and to regenerate.</div></div>",
                                                "variants": [
                                                    {
                                                        "when": {
                                                            "textContains": "âœ“ .gitignore"
                                                        },
                                                        "content": "File exists â€” the percentage shows recommended pattern coverage for your stacks.",
                                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… .gitignore Present</div><div class=\"state-detail\">A .gitignore file exists in your project root. The percentage reflects how many recommended patterns for your detected stacks are included.\n\n100% means complete coverage. Below 100% means some recommended patterns are missing â€” check the .gitignore section below to see which ones and regenerate if needed.</div></div>"
                                                    },
                                                    {
                                                        "when": {
                                                            "textContains": "â—‹ no .gitignore"
                                                        },
                                                        "content": "No .gitignore file â€” secrets and build artifacts could be committed.",
                                                        "expanded": "<div class=\"assistant-state-card state-error\"><div class=\"state-label\">âŒ No .gitignore</div><div class=\"state-detail\">No .gitignore file was found. This is a security risk â€” without it, git add . would stage everything including .env files with secrets, build artifacts, and dependency directories.\n\nOpen the .gitignore section below and check 'Create .gitignore' to generate one based on your detected stacks.</div></div>"
                                                    }
                                                ],
                                                "children": []
                                            },
                                            {
                                                "id": "git-pill-hooks",
                                                "title": "Hooks Count",
                                                "icon": "ğŸª",
                                                "selector": "#wiz-git-pill-hooks",
                                                "content": "How many git hooks are installed â€” hooks automate quality checks before commits and pushes.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸª Hook Count</div><div class=\"state-detail\">This pill counts executable files in .git/hooks/ (excluding samples). Hooks are local scripts that git runs automatically at specific lifecycle events.\n\nThe most common hook is pre-commit â€” it runs checks before each commit. If the checks fail, the commit is blocked.\n\nIf lint or format tools are detected in your stack and no hooks exist, the Pre-commit Hook section below offers to install one.</div></div>",
                                                "variants": [
                                                    {
                                                        "when": {
                                                            "textContains": "hook(s)"
                                                        },
                                                        "content": "Hooks are installed â€” quality checks run automatically at git lifecycle events.",
                                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Hooks Active</div><div class=\"state-detail\">One or more git hooks are installed in .git/hooks/. These run automatically â€” typically before commits â€” to enforce code quality and catch issues early.\n\nThe hooks were either installed by the control plane or manually. You can inspect them at .git/hooks/ in your project root.</div></div>"
                                                    },
                                                    {
                                                        "when": {
                                                            "textContains": "â—‹ no hooks"
                                                        },
                                                        "content": "No hooks installed â€” commits go through unchecked.",
                                                        "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš  No Hooks</div><div class=\"state-detail\">No git hooks are installed. Commits are accepted without any automated checks.\n\nIf your stack has lint or format capabilities detected (shown in System Tools), the Pre-commit Hook section below can install a hook that runs those checks before every commit.\n\nHooks are a local first line of defense â€” the CI/CD pipeline provides the team-wide enforcement layer.</div></div>"
                                                    }
                                                ],
                                                "children": []
                                            }
                                        ]
                                    },
                                    {
                                        "id": "git-remotes",
                                        "title": "Remotes",
                                        "icon": "ğŸŒ",
                                        "selector": "#wiz-git-section-remotes",
                                        "content": "Remotes connect your local repository to its hosted counterpart. Adding origin is the first step to enabling push, pull, and the entire GitHub integration chain.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸŒ Remote Configuration</div><div class=\"state-detail\">The control plane reads your remotes to detect your GitHub repository, resolve the deployment target for Pages, and configure CI/CD workflow dispatch.\n\nNaming conventions:\nâ€¢ origin â€” your primary remote, usually your own GitHub repo\nâ€¢ upstream â€” the parent repository if you're working from a fork\n\nIf the GitHub CLI is authenticated, the remote URL is pre-filled from your gh repo info. The format should be https://github.com/owner/repo.git or git@github.com:owner/repo.git for SSH.\n\nThe GitHub integration card below reads the origin remote to determine which repository to target for secrets sync, PR management, and Actions dispatch. No remote = no GitHub features.</div></div>",
                                        "variants": [
                                            {
                                                "when": {
                                                    "textContains": "no remotes"
                                                },
                                                "content": "No remotes configured â€” push, pull, and GitHub integration are blocked until you add at least origin.",
                                                "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš  No Remotes</div><div class=\"state-detail\">Without a remote, your repository is local-only. The control plane can't push code, sync secrets to GitHub, dispatch workflows, or deploy Pages.\n\nAdd origin first â€” it's the primary remote that all GitHub features target. Type the remote name and URL below, then hit ï¼‹ Add.\n\nIf the GitHub CLI detected your repository, the URL is pre-filled. Otherwise, use the format: https://github.com/your-org/your-repo.git</div></div>"
                                            }
                                        ],
                                        "children": [
                                            {
                                                "id": "git-remote-name",
                                                "title": "Remote Name",
                                                "icon": "ğŸ·ï¸",
                                                "selector": "#wiz-git-remote-name",
                                                "content": "The remote name is a local alias for the hosted repository URL. It's how git references where to push and pull.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ·ï¸ Naming Convention</div><div class=\"state-detail\">Standard names and what they mean:\n\nâ€¢ origin â€” your primary repository. This is the default target for git push and git pull. The GitHub integration reads this remote to determine your repository slug.\nâ€¢ upstream â€” the parent repository you forked from. Used for syncing changes from the original project.\nâ€¢ deploy â€” some teams use a separate remote for deployment targets.\n\nIf this is your first remote, the placeholder suggests \"origin\" â€” that's almost always the right choice. The name is local to your machine and can be changed later with git remote rename.</div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "git-remote-url",
                                                "title": "Remote URL",
                                                "icon": "ğŸ”—",
                                                "selector": "#wiz-git-remote-url",
                                                "content": "The remote URL points to your hosted repository â€” this is where git push sends your code and where GitHub integration reads your project from.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ”— URL Format</div><div class=\"state-detail\">Two formats work:\n\nâ€¢ HTTPS: https://github.com/owner/repo.git\n  â€” Works out of the box, authenticates via git credential manager or token.\n\nâ€¢ SSH: git@github.com:owner/repo.git\n  â€” Requires SSH key setup. The control plane can detect SSH auth status and prompt for passphrase unlock when needed.\n\nIf the GitHub CLI (gh) is authenticated and detected your repository, this field is pre-filled with the HTTPS URL. You can switch to SSH if your workflow prefers it.\n\nThe URL you set here becomes the target for all GitHub operations â€” secrets sync, PR management, workflow dispatch, and Pages deployment.</div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "git-add-remote",
                                                "title": "Add Remote",
                                                "icon": "ï¼‹",
                                                "selector": "#wiz-git-add-remote-btn",
                                                "content": "Adds the remote immediately â€” this runs git remote add right now, not on Apply. The page re-detects after adding so all cards update.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ï¼‹ Instant Action</div><div class=\"state-detail\">Unlike other setup options that wait for âœ… Apply, adding a remote executes immediately via the /git/remote/add API endpoint. The reason: remotes affect detection results, so re-scanning after add gives accurate status for all other cards.\n\nAfter adding, the remote appears in the list above with a âœ— remove button. The GitHub card will update on the next re-scan to reflect the new remote.\n\nIf the name field is empty, it defaults to the placeholder value (\"origin\" for the first remote, \"upstream\" for additional ones).</div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "git-remotes-list",
                                                "title": "Configured Remotes",
                                                "icon": "ğŸ“‹",
                                                "selector": "#wiz-git-remotes-list",
                                                "content": "Your configured remotes â€” each row shows the name, URL, and a remove button. Removal is immediate and triggers re-detection.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“‹ Remote Registry</div><div class=\"state-detail\">Each row in this list is a configured git remote. The name (origin, upstream) is a local alias, the URL is the hosted repository endpoint.\n\nThe âœ— button removes a remote immediately (git remote remove) â€” this is irreversible. After removal, the page re-detects so all cards and pills update. If you remove origin, the GitHub integration will lose its target repository.\n\nRemotes are stored in .git/config and are local to your machine â€” they don't affect other developers working on the same repository.</div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "git-gh-hint",
                                                "title": "GitHub CLI Hint",
                                                "icon": "ğŸ™",
                                                "selector": "#wiz-git-gh-hint",
                                                "content": "The GitHub CLI detected your repository and pre-filled the remote URL. You can change it before adding.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ™ Auto-Detection</div><div class=\"state-detail\">The GitHub CLI (gh) command was found on your system and is authenticated. It identified a repository associated with this project directory.\n\nThe pre-filled URL uses the HTTPS format by default. You can change it to SSH (git@github.com:owner/repo.git) if your workflow uses SSH authentication.\n\nThis hint only appears when gh is installed, authenticated, and successfully resolved a repository slug for the current directory.</div></div>",
                                                "children": []
                                            }
                                        ]
                                    },
                                    {
                                        "id": "git-gitignore",
                                        "title": ".gitignore",
                                        "icon": "ğŸ“„",
                                        "selector": "#wiz-git-section-gitignore",
                                        "content": "The .gitignore controls what git tracks. Proper coverage prevents secrets, build artifacts, and environment files from being committed â€” this is the first line of defense for your vault.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“„ .gitignore Coverage</div><div class=\"state-detail\">The control plane analyses your .gitignore against a catalog of expected patterns for your detected stacks. Coverage percentage reflects how many recommended patterns are present.\n\nCritical patterns (always needed):\nâ€¢ .env, .env.* â€” vault secrets from Step 3\nâ€¢ .env.vault â€” encrypted vault files (extra protection layer)\n\nStack-specific patterns are added based on your detected modules â€” the generator reads your stack definitions to determine which build artifacts, dependency directories, and compiled output directories to exclude.\n\nThe generator produces a comprehensive .gitignore in one pass. It's safe to regenerate â€” the generated file includes all your existing custom patterns.</div></div>",
                                        "variants": [
                                            {
                                                "when": {
                                                    "textContains": "100%"
                                                },
                                                "content": "Your .gitignore covers all recommended patterns for your detected stacks. Secrets, build artifacts, and environment files are protected.",
                                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Full Coverage</div><div class=\"state-detail\">Every recommended pattern for your project's stacks is present in .gitignore. This means secrets from Step 3, build artifacts, and environment-specific files are all excluded from version control.\n\nYou can still open this section to regenerate if your stacks change â€” the generator always includes existing custom patterns alongside the recommended ones.</div></div>"
                                            },
                                            {
                                                "when": {
                                                    "textContains": "missing)"
                                                },
                                                "content": "No .gitignore file exists. Without it, secrets, build artifacts, and environment files could be committed to the repository.",
                                                "expanded": "<div class=\"assistant-state-card state-error\"><div class=\"state-label\">âŒ No .gitignore</div><div class=\"state-detail\">This is a security risk. Without .gitignore, git tracks everything â€” including plaintext .env files from Step 3, build artifacts, dependency directories, and IDE configuration.\n\nThe \"Create .gitignore\" checkbox generates a comprehensive file based on your detected stacks. It includes universal security patterns (blocking .env, credentials, keys) plus stack-specific patterns for build artifacts and dependency directories relevant to your stack.\n\nThis should be the first thing you fix â€” even before adding remotes. A .gitignore protects you from day one.</div></div>"
                                            },
                                            {
                                                "when": {
                                                    "textContains": "Missing"
                                                },
                                                "content": "Your .gitignore has gaps â€” some recommended patterns for your stacks are missing. Regenerating adds them without losing your custom entries.",
                                                "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš  Incomplete Coverage</div><div class=\"state-detail\">The analysis found patterns recommended for your detected stacks that aren't in your .gitignore. Missing patterns are shown as red pills â€” each represents a file type or directory that could leak into version control.\n\nCommon gaps include build output directories, dependency caches, compiled artifacts, IDE configs (.vscode/, .idea/), and OS files (.DS_Store).\n\nCheck the \"Regenerate .gitignore\" checkbox and hit âœ… Apply to fill the gaps. The generator preserves your existing custom patterns and adds the missing recommended ones on top.</div></div>"
                                            }
                                        ],
                                        "children": [
                                            {
                                                "id": "git-regen-gi",
                                                "title": "Regenerate .gitignore",
                                                "icon": "ğŸ”„",
                                                "selector": "#wiz-git-regen-gi",
                                                "content": "Regenerates your .gitignore with stack-aware patterns â€” fills gaps without removing your existing custom entries.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ”„ Stack-Aware Regeneration</div><div class=\"state-detail\">The generator reads your detected stacks (from Step 2 modules) and the security catalog to produce a comprehensive .gitignore.\n\nWhat it adds:\nâ€¢ Universal security patterns â€” .env, .env.*, credentials, private keys\nâ€¢ Stack-specific patterns â€” build artifacts, dependency directories, and compiled output relevant to your detected language and framework stacks\nâ€¢ IDE and OS patterns â€” .vscode/, .idea/, .DS_Store, Thumbs.db\n\nWhat it preserves:\nâ€¢ Any custom patterns you've added manually\nâ€¢ Comments and section headers in your existing file\n\nThis checkbox is pre-checked when the analysis detected gaps. Uncheck it if you want to manage .gitignore manually. The regeneration runs on âœ… Apply along with all other setup steps.</div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "git-create-gi",
                                                "title": "Create .gitignore",
                                                "icon": "ğŸ“",
                                                "selector": "#wiz-git-create-gi",
                                                "content": "Creates a new .gitignore from scratch â€” generated from your detected stacks with security-first defaults.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“ New File Generation</div><div class=\"state-detail\">This creates a brand-new .gitignore file in your project root. The generated file includes:\n\n1. Security patterns (always included):\n   â€¢ .env, .env.* â€” blocks vault secrets from Step 3\n   â€¢ *.pem, *.key â€” blocks private keys and certificates\n   â€¢ .env.vault â€” blocks encrypted vault archives\n\n2. Stack patterns (based on detected modules):\n   Build artifacts, dependency directories, and compiled output specific to your detected language and framework stacks.\n\n3. Common patterns:\n   â€¢ .DS_Store, Thumbs.db â€” OS artifacts\n   â€¢ .vscode/, .idea/ â€” IDE configs\n\nThis is the single most important file to create before your first commit. Without it, git add . would stage everything â€” including secrets.</div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "git-missing-patterns",
                                                "title": "Missing Patterns",
                                                "icon": "âš ï¸",
                                                "selector": "#wiz-git-missing-patterns",
                                                "content": "Each red pill is a pattern recommended for your detected stacks that's missing from .gitignore. Check 'Regenerate' and Apply to add them all.",
                                                "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš ï¸ Gap Analysis</div><div class=\"state-detail\">The control plane compares your .gitignore against a catalog of recommended patterns for each detected stack. Each red pill represents a pattern that should be present but isn't.\n\nPatterns are matched by your stack's language family and framework â€” the catalog knows which build outputs, dependency directories, and compiled artifacts each stack produces.\n\nChecking 'Regenerate .gitignore' and hitting âœ… Apply adds all missing patterns in one pass without removing your existing custom entries. Up to 5 are shown here â€” if there are more, the count is displayed.</div></div>",
                                                "children": []
                                            }
                                        ]
                                    },
                                    {
                                        "id": "git-hooks",
                                        "title": "Pre-commit Hook",
                                        "icon": "ğŸª",
                                        "selector": "#wiz-git-section-hooks",
                                        "content": "Pre-commit hooks run your lint and format tools automatically before each commit â€” catching issues before they reach the repository and enforcing code quality at the gate.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸª Automated Quality Gate</div><div class=\"state-detail\">This section appears when lint or format tools are detected in your stack but no pre-commit hook is installed yet. The hook runs automatically before every git commit â€” if the checks fail, the commit is blocked.\n\nThe commands wired into the hook come from your stack's capabilities, detected from the System Tools section above. The green pills below show which commands were detected and will be included in the hook script.\n\nThe hook is a simple shell script installed at .git/hooks/pre-commit. It runs each command in sequence and aborts the commit on any failure. This is the lightest quality gate â€” no CI required, runs locally, instant feedback.\n\nCheck the box and hit âœ… Apply to install it.</div></div>",
                                        "children": [
                                            {
                                                "id": "git-setup-hooks-check",
                                                "title": "Install Hook",
                                                "icon": "â˜‘ï¸",
                                                "selector": "#wiz-git-setup-hooks",
                                                "content": "Check this to install a pre-commit hook that runs your lint and format commands before every commit.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â˜‘ï¸ Hook Installation</div><div class=\"state-detail\">When checked, âœ… Apply creates a shell script at .git/hooks/pre-commit with the commands detected from your stack capabilities:\n\nFor each capability found in System Tools above, the hook runs the corresponding check command. If any check fails (non-zero exit), the commit is aborted and you see the error output.\n\nThe hook file is a standard git hook â€” you can edit it manually after installation. It's not versioned (lives in .git/hooks/ which is gitignored by default), so each developer needs to install it locally.\n\nFor team-wide enforcement, the CI/CD pipeline runs the same checks â€” the hook is just a fast local pre-check to catch issues before pushing.</div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "git-hook-commands",
                                                "title": "Detected Commands",
                                                "icon": "ğŸ”§",
                                                "selector": "#wiz-git-hook-commands",
                                                "content": "These are the check commands detected from your stack's capabilities. They'll be wired into the pre-commit hook script.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ”§ Stack Capabilities</div><div class=\"state-detail\">Each green pill represents a command detected from your stack definition's capabilities section. These commands are what the pre-commit hook will run before each commit.\n\nThe commands are not hardcoded â€” they come from your stack's YAML definition (discovered in Step 2). If your stack defines lint, format, or test capabilities, those commands appear here.\n\nThe hook runs each command in sequence. If any exits non-zero, the commit is blocked and the error output is shown.</div></div>",
                                                "children": [
                                                    {
                                                        "id": "git-hook-lint",
                                                        "title": "Lint Check",
                                                        "icon": "ğŸ”",
                                                        "selector": "#wiz-git-hook-lint",
                                                        "content": "The lint command from your stack's capabilities â€” runs static analysis to catch code issues before commit.",
                                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ” Static Analysis</div><div class=\"state-detail\">This is the lint command detected from your stack definition. Linting performs static analysis on your source code â€” catching bugs, style violations, and suspicious patterns without running the code.\n\nIn the pre-commit hook, this command runs in check mode (read-only). If it finds issues, the commit is blocked and you see the lint errors in your terminal.\n\nThe specific command shown here comes from your stack's 'lint' capability in its YAML definition.</div></div>",
                                                        "children": []
                                                    },
                                                    {
                                                        "id": "git-hook-format",
                                                        "title": "Format Check",
                                                        "icon": "âœ¨",
                                                        "selector": "#wiz-git-hook-format",
                                                        "content": "The format command from your stack's capabilities â€” checks code formatting consistency before commit.",
                                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">âœ¨ Formatting Verification</div><div class=\"state-detail\">This is the format command detected from your stack definition. Format checking verifies that your code follows consistent style rules â€” indentation, spacing, line length, and other formatting conventions.\n\nIn the pre-commit hook, this runs in check/verify mode â€” it reports formatting issues without modifying files. If unformatted code is found, the commit is blocked.\n\nThe specific command shown here comes from your stack's 'format' capability in its YAML definition.</div></div>",
                                                        "children": []
                                                    }
                                                ]
                                            }
                                        ]
                                    },
                                    {
                                        "id": "git-initial-commit",
                                        "title": "Initial Commit",
                                        "icon": "ğŸ’¾",
                                        "selector": "#wiz-git-section-commit",
                                        "content": "An initial commit anchors the repository â€” it's the baseline that all future changes are measured against and the first entry in your project's history.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ’¾ First Commit</div><div class=\"state-detail\">This section appears when the repository has no commits yet â€” either freshly initialized or never committed to. The initial commit typically includes your project.yml, .gitignore, and any existing source files.\n\nThe commit message defaults to \"Initial commit\" but you can customize it. The commit runs git add . followed by git commit -m after all other setup steps (remotes, .gitignore, hooks) have been applied â€” so the first commit captures a clean, properly configured state.\n\nAfter this commit, git log will show history, branch operations will work, and push to origin becomes possible.</div></div>",
                                        "children": [
                                            {
                                                "id": "git-init-commit-check",
                                                "title": "Create Commit",
                                                "icon": "â˜‘ï¸",
                                                "selector": "#wiz-git-init-commit",
                                                "content": "Check this to create an initial commit after all other setup steps complete â€” this anchors the repository with a clean starting state.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â˜‘ï¸ Initial Commit Toggle</div><div class=\"state-detail\">When checked, âœ… Apply runs git add . followed by git commit -m with your message after completing all other steps (.gitignore generation, hook installation, branch setup).\n\nThis ordering matters: the .gitignore is created BEFORE the commit, so the first commit already respects ignore rules. Secrets and build artifacts won't be staged.\n\nThe initial commit gives you:\nâ€¢ A baseline for git diff and git log\nâ€¢ A branch HEAD that enables push to remote\nâ€¢ A commit SHA that Docker builds can embed in image labels\n\nLeave unchecked if you want to review staged files before committing manually.</div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "git-commit-msg",
                                                "title": "Commit Message",
                                                "icon": "ğŸ’¬",
                                                "selector": "#wiz-git-commit-msg",
                                                "content": "The message for your initial commit â€” defaults to 'Initial commit' but you can describe what the first snapshot contains.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ’¬ First Message</div><div class=\"state-detail\">The commit message appears in git log and on GitHub's commit history. For initial commits, common patterns:\n\nâ€¢ \"Initial commit\" â€” the classic default\nâ€¢ \"Initial project setup with devops-control-plane\" â€” more descriptive\nâ€¢ \"chore: bootstrap project structure\" â€” conventional commits format\n\nThis message is passed directly to git commit -m. It only applies if the \"Create initial commit\" checkbox above is checked.\n\nAfter the initial commit, future commits should follow your team's commit message convention â€” conventional commits, gitmoji, or plain descriptive messages.</div></div>",
                                                "children": []
                                            }
                                        ]
                                    },
                                    {
                                        "id": "git-branch",
                                        "title": "Default Branch",
                                        "icon": "ğŸŒ¿",
                                        "selector": "#wiz-git-branch",
                                        "content": "The default branch is your main development line â€” it determines the target for pull requests, the base for CI/CD triggers, and the name git uses when initializing.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸŒ¿ Branch Configuration</div><div class=\"state-detail\">Most projects use \"main\" â€” GitHub has defaulted to this since 2020. Some older projects still use \"master\" and that works too.\n\nThe control plane uses this branch name in several places:\nâ€¢ CI/CD workflows trigger on push to this branch\nâ€¢ GitHub PR targets default to this branch\nâ€¢ Pages deployments reference this as the source branch\nâ€¢ The docker image tagging uses branch name as part of the version string\n\nChanging this after the initial setup is possible but requires renaming the branch (git branch -m old new) and updating any CI/CD workflow YAML that references the old name.\n\nIf you're starting fresh, stick with \"main\". If you have an existing repo, the current branch name is pre-filled.</div></div>",
                                        "children": []
                                    },
                                    {
                                        "id": "git-apply",
                                        "title": "Apply",
                                        "icon": "âœ…",
                                        "selector": "#wiz-apply-int-git",
                                        "content": "Executes all checked setup steps in sequence â€” .gitignore generation, hook installation, branch configuration, then initial commit if checked.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">âœ… Execution Order</div><div class=\"state-detail\">When you click Apply, the control plane runs each checked step in a specific order:\n\n1. git init (if no repository exists)\n2. Branch rename (if different from current)\n3. .gitignore generation or regeneration\n4. Pre-commit hook installation\n5. git add . + git commit (if initial commit is checked)\n\nThis ordering is intentional â€” .gitignore is created before the commit, so the first snapshot already excludes secrets and build artifacts.\n\nAfter all steps complete, the panel re-detects and all status pills and cards update to reflect the new state. If any step fails, the error is shown and remaining steps are skipped.</div></div>",
                                        "children": []
                                    },
                                    {
                                        "id": "git-cancel",
                                        "title": "Cancel",
                                        "icon": "âœ–",
                                        "selector": "#wiz-cancel-int-git",
                                        "content": "Closes the setup panel without applying any changes. Nothing is modified on disk.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">âœ– Discard Changes</div><div class=\"state-detail\">Clicking Cancel collapses the setup panel and discards any unsaved field values. No git operations are performed â€” no files are created, modified, or deleted.\n\nYou can reopen the panel at any time by clicking âš™ï¸ Setup again. Field values will be re-populated from the current detection state, not from your previous unsaved edits.</div></div>",
                                        "children": []
                                    }
                                ]
                            }
                        ]
                    },
                    {
                        "id": "gh-card",
                        "title": "GitHub",
                        "icon": "ğŸ™",
                        "selector": "#wiz-int-wrap-int-github",
                        "content": "GitHub integration connects your local project to GitHub's API â€” environment management, secrets sync, CODEOWNERS automation, and Actions dispatch all flow through the gh CLI.",
                        "variants": [
                            {
                                "when": {
                                    "textContains": "âœ… ready"
                                },
                                "content": "Authenticated as {{ghUser}} and linked to {{ghRepo}}. {{ghEnvAligned}} of {{ghEnvTotal}} environments aligned, {{ghWorkflows}} workflow(s) active. Open âš™ï¸ Setup to check what's left.",
                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Fully Connected</div><div class=\"state-detail\">The gh CLI is authenticated and linked to {{ghRepo}}. The control plane can manage deployment environments, push vault secrets from Step 3, write CODEOWNERS for automatic PR review, and query workflow status.\n\nYour integration health:\nâ€¢ {{ghEnvAligned}} of {{ghEnvTotal}} environments from Step 1 are on GitHub\nâ€¢ {{ghWorkflows}} Actions workflow(s) detected\nâ€¢ Repository is {{ghVis}}\n\nOpen âš™ï¸ Setup to drill into each dimension, or use ğŸš€ Full Setup for the guided wizard with repository creation and visibility management.</div></div>"
                            },
                            {
                                "when": {
                                    "textContains": "not configured"
                                },
                                "content": "The gh CLI is installed but not authenticated. Without a GitHub session, the control plane can't sync your {{envCount}} environments or push vault secrets.",
                                "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš  Not Authenticated</div><div class=\"state-detail\">The GitHub CLI binary is on your system but hasn't been linked to a GitHub account. This blocks:\n\nâ€¢ Creating your {{envCount}} environments on GitHub for CI/CD deployment gating\nâ€¢ Pushing vault secrets so Actions workflows can use them\nâ€¢ Writing CODEOWNERS for automatic PR review assignment\nâ€¢ Querying repository metadata and workflow status\n\nClick âš™ï¸ Setup â†’ ğŸ”‘ Authenticate to run the OAuth flow. After authenticating, hit ğŸ”„ Re-scan â€” the card will update with your account, repository link, and full integration status.</div></div>"
                            },
                            {
                                "when": {
                                    "textContains": "not installed"
                                },
                                "content": "The gh CLI isn't installed. Without it, your {{envCount}} environments, vault secrets, and CODEOWNERS have to be managed manually on github.com.",
                                "expanded": "<div class=\"assistant-state-card state-error\"><div class=\"state-label\">âŒ CLI Not Available</div><div class=\"state-detail\">The gh CLI is the bridge between your local project and GitHub's API. Without it, the control plane can't:\n\nâ€¢ Create deployment environments for your CI/CD workflows\nâ€¢ Push the vault secrets you configured in Step 3\nâ€¢ Write CODEOWNERS for automatic review assignment\nâ€¢ Query repository status, visibility, or workflow health\n\nYou'd have to do all of this manually through github.com.\n\nClick âš™ï¸ Setup â†’ ğŸ“¦ Install gh. After installation, authenticate and re-scan â€” everything else unlocks from there.\n\nğŸ“¦ Install: https://cli.github.com or brew install gh</div></div>"
                            }
                        ],
                        "children": [
                            {
                                "id": "gh-setup",
                                "title": "Setup Panel",
                                "icon": "âš™ï¸",
                                "selector": "#wiz-int-setup-int-github",
                                "content": "Your GitHub integration dashboard â€” authentication, repository link, environment alignment, CODEOWNERS, and secrets sync. What you see here depends on your gh CLI state.",
                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">âš™ï¸ GitHub Configuration</div><div class=\"state-detail\">This panel adapts to your current state:\n\nâ€¢ Not installed â†’ install prompt for the gh CLI binary\nâ€¢ Not authenticated â†’ OAuth login to link a GitHub account\nâ€¢ Authenticated â†’ full dashboard with {{ghEnvTotal}} environments, repository details, CODEOWNERS, and secrets sync\n\nEnvironments come from Step 1's project config. Secrets come from Step 3's vault. CODEOWNERS controls who reviews PRs. Everything here feeds into your CI/CD pipeline.\n\nFor the full guided experience with repository creation and visibility management, use ğŸš€ Full Setup instead.</div></div>",
                                "children": [
                                    {
                                        "id": "gh-status-strip",
                                        "title": "Status Strip",
                                        "icon": "ğŸ“Š",
                                        "selector": "#wiz-gh-status-strip",
                                        "content": "Integration health at a glance â€” {{ghEnvAligned}} of {{ghEnvTotal}} environments aligned, {{ghWorkflows}} workflow(s), repo is {{ghVis}}. Green pills are working, gray ones need attention.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“Š Integration Health</div><div class=\"state-detail\">Each pill is one dimension of your GitHub integration:\n\nâ€¢ Authentication â€” API access for all operations\nâ€¢ Account â€” the identity ({{ghUser}}) operations run under\nâ€¢ Repository â€” {{ghRepo}} is the target for CI/CD, Pages, and environments\nâ€¢ Visibility â€” {{ghVis}} controls who sees code, logs, and deployments\nâ€¢ Branch â€” {{ghBranch}} is the CI/CD trigger target and PR merge destination\nâ€¢ Environments â€” {{ghEnvAligned}} of {{ghEnvTotal}} aligned with Step 1\nâ€¢ CODEOWNERS â€” PR review automation status\nâ€¢ Workflows â€” {{ghWorkflows}} Actions pipeline(s) detected\n\nGray pills aren't always blockers â€” missing CODEOWNERS means manual review, not broken CI/CD. But missing environments will stall workflows that use deployment gates.</div></div>",
                                        "children": [
                                            {
                                                "id": "gh-pill-auth",
                                                "title": "Authentication",
                                                "icon": "ğŸ”‘",
                                                "selector": "#wiz-gh-pill-auth",
                                                "content": "You're authenticated â€” the control plane has API access to manage {{ghRepo}} on your behalf.",
                                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ“ Authenticated</div><div class=\"state-detail\">Your gh CLI session is active. The control plane can make API calls to GitHub as {{ghUser}} â€” creating environments, pushing secrets, writing CODEOWNERS, querying repository metadata.\n\nThe session persists until you explicitly log out or the OAuth token expires. If you see auth errors later, re-authenticate through the setup panel.</div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "gh-pill-user",
                                                "title": "Account",
                                                "icon": "ğŸ‘¤",
                                                "selector": "#wiz-gh-pill-user",
                                                "content": "Operating as {{ghUser}} â€” environment creation, secrets push, and CODEOWNERS writes all happen under this identity's permissions.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ‘¤ {{ghUser}}</div><div class=\"state-detail\">All GitHub operations happen under {{ghUser}}'s permissions. If {{ghRepo}} is owned by an organization, this account needs the right access level â€” environment creation and secrets management typically require admin or maintain role.\n\nIf operations fail with permission errors, use the ğŸ”“ Logout button in the user card below to switch to an account with the necessary access.</div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "gh-pill-repo",
                                                "title": "Repository",
                                                "icon": "ğŸ“¦",
                                                "selector": "#wiz-gh-pill-repo",
                                                "content": "Linked to {{ghRepo}} â€” your CI/CD workflows, Pages deployments, and environment scoping all reference this repository.",
                                                "variants": [
                                                    {
                                                        "when": {
                                                            "textContains": "no repo"
                                                        },
                                                        "content": "No repository linked. You need a git remote pointing to GitHub â€” set one up in the Git card's remotes section, or create a new repo through ğŸš€ Full Setup.",
                                                        "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">â—‹ No Repository Linked</div><div class=\"state-detail\">The gh CLI can't find a GitHub repository for this project. This means either:\n\nâ€¢ No git remote is configured (check the Git card above)\nâ€¢ The remote points to a non-GitHub host (GitLab, Bitbucket, etc.)\nâ€¢ The repository doesn't exist on GitHub yet\n\nWithout a linked repo, environments can't be created, secrets can't be pushed, and CODEOWNERS has nowhere to live.\n\nUse ğŸš€ Full Setup to create a new repository â€” it handles git remote add, initial push, and visibility settings in one flow.</div></div>"
                                                    }
                                                ],
                                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ“¦ {{ghRepo}}</div><div class=\"state-detail\">This is your project's home on GitHub. The slug is used by:\n\nâ€¢ CI/CD â€” Actions workflows trigger on push to this repository\nâ€¢ Pages â€” deployments publish to GitHub Pages under this repo\nâ€¢ Environments â€” deployment environments are scoped per-repository\nâ€¢ Secrets â€” vault keys pushed here are available in Actions\n\nThe ğŸ“¦ Repository section below has full details â€” visibility, default branch, description, and a direct link to GitHub.</div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "gh-pill-vis",
                                                "title": "Visibility",
                                                "icon": "ğŸ‘",
                                                "selector": "#wiz-gh-pill-vis",
                                                "content": "Your repo is {{ghVis}} â€” this affects who can see your code, Actions logs, and Pages deployments.",
                                                "variants": [
                                                    {
                                                        "when": {
                                                            "textContains": "private"
                                                        },
                                                        "content": "{{ghRepo}} is private â€” code, Actions logs, and Pages are restricted to collaborators only.",
                                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ”’ Private Repository</div><div class=\"state-detail\">Only collaborators with explicit access can see {{ghRepo}}:\n\nâ€¢ Source code is not publicly visible\nâ€¢ GitHub Actions logs are restricted to collaborators\nâ€¢ Pages deployments require authentication (Enterprise) or are disabled\nâ€¢ Fork PRs from outside collaborators are not possible\n\nThe vault system from Step 3 protects secrets from commits, but private visibility adds a second layer â€” even if something leaks into the repo, only collaborators see it.\n\nUse ğŸš€ Full Setup to change visibility â€” going public is irreversible for code that's already been seen.</div></div>"
                                                    },
                                                    {
                                                        "when": {
                                                            "textContains": "public"
                                                        },
                                                        "content": "{{ghRepo}} is public â€” your code, Actions logs, and Pages deployments are visible to everyone on the internet.",
                                                        "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">ğŸŒ Public Repository</div><div class=\"state-detail\">Anyone on the internet can see {{ghRepo}}:\n\nâ€¢ Source code is fully visible â€” no secrets should ever be committed\nâ€¢ GitHub Actions logs are public â€” workflow outputs are readable by anyone\nâ€¢ Pages deployments are accessible without authentication\nâ€¢ Anyone can fork and submit PRs (but fork PRs have limited secrets access)\n\nDouble-check your .gitignore coverage in the Git card â€” the vault's encrypted .env files and plaintext credentials must be excluded. Step 3's vault system handles this, but verify the Git card's .gitignore pill shows good coverage.</div></div>"
                                                    }
                                                ],
                                                "expanded": "",
                                                "children": []
                                            },
                                            {
                                                "id": "gh-pill-branch",
                                                "title": "Default Branch",
                                                "icon": "ğŸŒ¿",
                                                "selector": "#wiz-gh-pill-branch",
                                                "content": "Default branch is {{ghBranch}} â€” PRs merge here, Actions trigger on push here, Pages deploy from here.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸŒ¿ {{ghBranch}}</div><div class=\"state-detail\">{{ghBranch}} is where everything converges:\n\nâ€¢ PRs merge into {{ghBranch}}\nâ€¢ CI/CD workflows trigger on push to {{ghBranch}}\nâ€¢ Pages deployments source from {{ghBranch}}\n\nThis should match the branch in your CI/CD card's workflow YAML. If your workflow triggers on 'master' but GitHub's default is 'main', pushes won't fire the pipeline.\n\nUse ğŸš€ Full Setup to change the default branch on GitHub.</div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "gh-pill-envs",
                                                "title": "Environments",
                                                "icon": "ğŸŒ",
                                                "selector": "#wiz-gh-pill-envs",
                                                "content": "{{ghEnvAligned}} environment(s) exist on GitHub â€” CI/CD can target them for deployment gating and scoped secrets.",
                                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸŒ {{ghEnvAligned}} Deployment Environment(s)</div><div class=\"state-detail\">These GitHub deployment environments match your Step 1 project config. When a CI/CD workflow uses environment: in a job, GitHub gates the deployment â€” it can require approvals, set wait timers, and scope secrets.\n\nEnvironment-scoped secrets mean your production DB_PASSWORD is only visible to jobs targeting the production environment. Development jobs can't see it â€” that's the separation you built in Step 3.\n\nSee the âš™ï¸ Environments section below for the full alignment breakdown.</div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "gh-pill-envs-missing",
                                                "title": "Missing Environments",
                                                "icon": "âš ï¸",
                                                "selector": "#wiz-gh-pill-envs-missing",
                                                "content": "{{ghEnvMissing}} environment(s) from Step 1 don't exist on GitHub yet â€” CI/CD workflows targeting them will stall at the deployment gate.",
                                                "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš  {{ghEnvMissing}} Environment(s) Missing</div><div class=\"state-detail\">Your project defines {{ghEnvTotal}} environments in Step 1, but {{ghEnvMissing}} haven't been created on GitHub. If your CI/CD workflow uses environment: for those, GitHub can't deploy â€” the workflow stalls waiting for an environment that doesn't exist.\n\nScroll down to the âš™ï¸ Environments section â€” check the missing ones and click ğŸ†• Create. After creation, push scoped secrets through the ğŸ”’ Secrets section so each environment has its own credentials in Actions.</div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "gh-pill-codeowners",
                                                "title": "CODEOWNERS",
                                                "icon": "ğŸ“‹",
                                                "selector": "#wiz-gh-pill-codeowners",
                                                "content": "CODEOWNERS controls automatic PR review assignment â€” who gets notified when files in {{ghRepo}} are changed.",
                                                "variants": [
                                                    {
                                                        "when": {
                                                            "textContains": "CODEOWNERS âœ“"
                                                        },
                                                        "content": "CODEOWNERS is active on {{ghRepo}} â€” GitHub auto-assigns reviewers to PRs based on which files changed.",
                                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Review Automation Active</div><div class=\"state-detail\">Your CODEOWNERS file tells GitHub who should review changes to specific files in {{ghRepo}}. When a PR touches files matching a pattern, the listed owners are automatically added as reviewers.\n\nSee the ğŸ“‹ CODEOWNERS section below for the current rules. The most common pattern is * @owner which catches everything â€” add path-specific patterns for team members who own specific areas of the codebase.</div></div>"
                                                    },
                                                    {
                                                        "when": {
                                                            "textContains": "no CODEOWNERS"
                                                        },
                                                        "content": "No CODEOWNERS on {{ghRepo}} â€” every PR requires manual reviewer selection. Create one in the ğŸ“‹ section below.",
                                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â—‹ No Review Automation</div><div class=\"state-detail\">Without CODEOWNERS, every PR to {{ghRepo}} requires manual reviewer assignment. Works fine for solo projects, but as collaborators join, it's easy to miss adding the right reviewer for infrastructure, docs, or security-sensitive changes.\n\nScroll down to ğŸ“‹ CODEOWNERS to create one â€” the default template assigns {{ghUser}} to all files. Customize with path-specific rules for your team structure.</div></div>"
                                                    }
                                                ],
                                                "expanded": "",
                                                "children": []
                                            },
                                            {
                                                "id": "gh-pill-workflows",
                                                "title": "Workflows",
                                                "icon": "ğŸ”„",
                                                "selector": "#wiz-gh-pill-workflows",
                                                "content": "{{ghWorkflows}} Actions workflow(s) detected in {{ghRepo}} â€” these are your CI/CD pipelines, managed through the CI/CD card.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ”„ {{ghWorkflows}} Workflow(s)</div><div class=\"state-detail\">These are YAML workflow files in .github/workflows/ of {{ghRepo}}. Each one defines a CI/CD pipeline â€” what triggers it, what it builds, what it tests, where it deploys.\n\nWorkflows are configured through the CI/CD integration card. The GitHub card shows the count to confirm the connection is healthy â€” {{ghRepo}} has active pipelines and the gh CLI can query their status.\n\nIf the count seems wrong, hit ğŸ”„ Re-scan in the scan bar above.</div></div>",
                                                "children": []
                                            }
                                        ]
                                    },
                                    {
                                        "id": "gh-user-card",
                                        "title": "Account",
                                        "icon": "ğŸ‘¤",
                                        "selector": "#wiz-gh-user-card",
                                        "content": "Operating as {{ghUser}} â€” all GitHub API operations (environments, secrets, CODEOWNERS, visibility changes) happen under this identity.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ‘¤ {{ghUser}}</div><div class=\"state-detail\">All operations the control plane performs on {{ghRepo}} â€” creating deployment environments, pushing vault secrets, writing CODEOWNERS â€” happen under {{ghUser}}'s permissions.\n\nIf {{ghRepo}} belongs to an organization, {{ghUser}} needs admin or maintain role for environment creation and secrets management.\n\nThe ğŸ”“ Logout button disconnects this account. After logging out, re-scan to get a fresh login prompt. Use this to switch accounts if operations fail due to insufficient permissions.</div></div>",
                                        "children": []
                                    },
                                    {
                                        "id": "gh-repo",
                                        "title": "Repository",
                                        "icon": "ğŸ“¦",
                                        "selector": "#wiz-gh-section-repo",
                                        "content": "{{ghRepo}} is {{ghVis}}, default branch is {{ghBranch}}. This is the repository your CI/CD, Pages, and environment scoping all target.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“¦ {{ghRepo}}</div><div class=\"state-detail\">Your project's home on GitHub:\n\nâ€¢ Visibility â€” {{ghVis}}. Controls who sees code, Actions logs, and Pages deployments.\nâ€¢ Default branch â€” {{ghBranch}}. PRs merge here, Actions trigger here, Pages deploy from here.\nâ€¢ Fork status â€” fork repos have limited secrets access for outside PRs.\n\nThe Open â†— link goes directly to {{ghRepo}} on GitHub. Use ğŸš€ Full Setup to change visibility or the default branch.</div></div>",
                                        "variants": [
                                            {
                                                "when": {
                                                    "textContains": "ğŸ”’ private"
                                                },
                                                "content": "{{ghRepo}} is private, default branch is {{ghBranch}}. Code, Actions logs, and Pages are restricted to collaborators.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ”’ {{ghRepo}} Â· private</div><div class=\"state-detail\">Only collaborators with explicit access can see {{ghRepo}}:\n\nâ€¢ Source code is not publicly visible\nâ€¢ GitHub Actions logs are restricted to collaborators\nâ€¢ Pages deployments require Enterprise auth or are disabled\nâ€¢ Fork PRs from outside collaborators are blocked\n\nDefault branch is {{ghBranch}} â€” PRs merge there, CI/CD triggers on push there.\n\nThe vault from Step 3 protects secrets from commits. Private visibility adds a second layer â€” even if something leaks into the repo, only collaborators see it.\n\nUse ğŸš€ Full Setup to change visibility â€” going public is irreversible for code that's already been seen.</div></div>"
                                            },
                                            {
                                                "when": {
                                                    "textContains": "ğŸŒ public"
                                                },
                                                "content": "{{ghRepo}} is public, default branch is {{ghBranch}}. Code, Actions logs, and Pages are visible to everyone on the internet.",
                                                "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">ğŸŒ {{ghRepo}} Â· public</div><div class=\"state-detail\">Anyone on the internet can see {{ghRepo}}:\n\nâ€¢ Source code is fully visible â€” no secrets should ever be committed\nâ€¢ GitHub Actions logs are public â€” workflow outputs readable by anyone\nâ€¢ Pages deployments are accessible without authentication\nâ€¢ Anyone can fork and submit PRs (fork PRs have limited secrets access)\n\nDefault branch is {{ghBranch}} â€” PRs merge there, CI/CD triggers on push there.\n\nDouble-check .gitignore coverage in the Git card â€” the vault's encrypted .env files and plaintext credentials must be excluded. Step 3's vault handles this, but verify the Git card's .gitignore pill shows good coverage.</div></div>"
                                            }
                                        ],
                                        "children": []
                                    },
                                    {
                                        "id": "gh-envs",
                                        "title": "Environments",
                                        "icon": "âš™ï¸",
                                        "selector": "#wiz-gh-section-envs",
                                        "content": "All {{ghEnvTotal}} environments from Step 1 are on GitHub â€” CI/CD can target every one for deployment gating and scoped secrets.",
                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… {{ghEnvTotal}}/{{ghEnvTotal}} Aligned</div><div class=\"state-detail\">All {{ghEnvTotal}} environments you defined in Step 1 exist as deployment environments on {{ghRepo}}. CI/CD workflows can target every one of them.\n\nWhen a workflow uses environment: production in a job, GitHub gates the deployment â€” it can require approvals, set wait timers, and scope secrets so production credentials are only available to production jobs.\n\nEnvironment-scoped secrets from ğŸ”’ Secrets are properly separated â€” your production DB_PASSWORD is invisible to development jobs.\n\nâ­ marks your default environment from Step 1 â€” the one pre-selected when working with secrets and variables.</div></div>",
                                        "variants": [
                                            {
                                                "when": {
                                                    "textContains": "âœ— missing"
                                                },
                                                "content": "{{ghEnvAligned}} of {{ghEnvTotal}} aligned â€” {{ghEnvMissing}} environment(s) still need to be created on GitHub for CI/CD deployment gating.",
                                                "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš  {{ghEnvMissing}} of {{ghEnvTotal}} Missing</div><div class=\"state-detail\">{{ghEnvMissing}} of your {{ghEnvTotal}} environments from Step 1 don't exist on GitHub yet. CI/CD workflows that reference these with environment: will stall â€” GitHub can't deploy to an environment that doesn't exist.\n\nCheck the boxes next to the missing ones and click ğŸ†• Create. After creation, push scoped secrets through ğŸ”’ Secrets so each environment has its own credentials in Actions.\n\nThis takes seconds and is reversible â€” environments can be deleted from GitHub's repository settings.</div></div>"
                                            }
                                        ],
                                        "children": []
                                    },
                                    {
                                        "id": "gh-codeowners",
                                        "title": "CODEOWNERS",
                                        "icon": "ğŸ“‹",
                                        "selector": "#wiz-gh-section-codeowners",
                                        "content": "CODEOWNERS automates PR review assignment on {{ghRepo}} â€” GitHub reads this file to decide who reviews changes to which files.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“‹ Review Automation</div><div class=\"state-detail\">The CODEOWNERS file lives at .github/CODEOWNERS in {{ghRepo}} and tells GitHub who to assign as reviewers when a PR changes specific files.\n\nPattern format:\nâ€¢ * @owner â€” assigns the owner to ALL files (catch-all)\nâ€¢ /src/infra/ @platform-team â€” scopes to infrastructure\nâ€¢ *.md @docs-team â€” scopes to documentation\nâ€¢ /src/security/ @security @lead â€” multiple reviewers\n\nPatterns match top-to-bottom, last match wins. The catch-all should be first, with specific overrides below.\n\nThis file is committed to your repository â€” it's versioned and reviewable like any other code change.</div></div>",
                                        "variants": [
                                            {
                                                "when": {
                                                    "textContains": "(exists)"
                                                },
                                                "content": "CODEOWNERS is active on {{ghRepo}} â€” the preview below shows your current review assignment rules. Every PR gets automatic reviewer selection.",
                                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… CODEOWNERS Active</div><div class=\"state-detail\">The file is live in {{ghRepo}}. Every PR now gets automatic reviewer assignment based on the patterns defined. The preview below shows the current content.\n\nTo update rules, edit the file directly or use ğŸš€ Full Setup which provides an editor. Changes take effect on the next PR â€” existing open PRs don't retroactively get new reviewers.</div></div>"
                                            },
                                            {
                                                "when": {
                                                    "textContains": "(missing)"
                                                },
                                                "content": "No CODEOWNERS on {{ghRepo}} â€” every PR requires manual reviewer selection. Check the box below to create one with {{ghUser}} as the default owner.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“ Create CODEOWNERS</div><div class=\"state-detail\">Without CODEOWNERS, you manually select reviewers for every PR to {{ghRepo}}. The checkbox below generates a default file that assigns {{ghUser}} to all files.\n\nCustomize the template before applying:\nâ€¢ /docs/ @docs-team\nâ€¢ /src/infra/ @platform-team\nâ€¢ *.yml @devops-team\n\nThe file is written to .github/CODEOWNERS when you click âœ… Apply. It takes effect on the next PR created.</div></div>"
                                            }
                                        ],
                                        "children": []
                                    },
                                    {
                                        "id": "gh-secrets",
                                        "title": "Secrets",
                                        "icon": "ğŸ”’",
                                        "selector": "#wiz-gh-section-secrets",
                                        "content": "Your vault keys from Step 3 need to be on GitHub for Actions to use them. With {{envCount}} environments, each gets its own scoped secrets â€” production keys stay separate from development keys.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ”’ Vault â†’ GitHub Sync</div><div class=\"state-detail\">The secrets you configured in Step 3's vault are local to your machine. GitHub Actions can't access them until they're pushed to {{ghRepo}}.\n\nWith {{envCount}} environments, scoping works like this:\nâ€¢ Each environment gets its own GitHub environment secrets\nâ€¢ A production DB_PASSWORD is only visible to jobs using environment: production\nâ€¢ Development jobs see only development secrets â€” no cross-contamination\n\nThe 'Push now' checkbox triggers a sync of all vault keys when you âœ… Apply. For per-key control â€” choosing which to push, which to skip â€” use the ğŸ” Secrets tab on the dashboard or ğŸš€ Full Setup.\n\nSecrets pushed to GitHub are encrypted at rest and auto-masked in Actions logs.</div></div>",
                                        "children": []
                                    },
                                    {
                                        "id": "gh-apply",
                                        "title": "Apply",
                                        "icon": "âœ…",
                                        "selector": "#wiz-apply-int-github",
                                        "content": "Runs all checked actions: create {{ghEnvMissing}} missing environment(s), push vault secrets, write CODEOWNERS â€” in that order.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">âœ… Execution Order</div><div class=\"state-detail\">When you click Apply, the control plane runs each checked action against {{ghRepo}}:\n\n1. Create checked environments on GitHub (so deployment gates work)\n2. Push vault secrets (scoped per-environment if multi-env)\n3. Write CODEOWNERS (so PR review is automated)\n\nThis ordering matters â€” environments are created first so environment-scoped secrets land in the right targets.\n\nAfter all steps complete, re-detection runs and all status pills update. If any step fails, the error shows in a toast.\n\nFor repository creation, visibility changes, and branch management, use ğŸš€ Full Setup instead.</div></div>",
                                        "children": []
                                    },
                                    {
                                        "id": "gh-cancel",
                                        "title": "Cancel",
                                        "icon": "âœ–",
                                        "selector": "#wiz-cancel-int-github",
                                        "content": "Closes the setup panel without applying. No API calls to {{ghRepo}} â€” nothing changes on GitHub.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">âœ– Discard Changes</div><div class=\"state-detail\">Cancel collapses the panel and discards unsaved selections â€” environment checkboxes, CODEOWNERS content, secrets push toggle. No API calls are made to {{ghRepo}}.\n\nReopen anytime with âš™ï¸ Setup â€” checkbox states repopulate from the current detection state, not your previous unsaved selections.</div></div>",
                                        "children": []
                                    }
                                ]
                            }
                        ]
                    },
                    {
                        "id": "pages-card",
                        "title": "Pages",
                        "icon": "ğŸ“„",
                        "selector": "#wiz-int-wrap-int-pages",
                        "content": "Pages is your static site builder â€” documentation sites, landing pages, and content-driven sections built from your project's content folders and deployed through GitHub Pages or other targets.",
                        "variants": [
                            {
                                "when": {
                                    "textContains": "âœ… ready"
                                },
                                "content": "{{pagesSegments}} segment(s) configured and building. Deploy branch is {{pagesBranch}}, {{pagesBuildersAvail}} of {{pagesBuildersTotal}} builders available. Your static sites are operational.",
                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Pages Ready</div><div class=\"state-detail\">Your static site pipeline is healthy:\n\nâ€¢ {{pagesSegments}} segment(s) configured â€” each one is a buildable site section\nâ€¢ Deploy branch is {{pagesBranch}} â€” built output lands there for GitHub Pages\nâ€¢ {{pagesBuildersAvail}} of {{pagesBuildersTotal}} builders available\n\nSegments pull content from source directories, build through their assigned builder (Docusaurus, MkDocs, Hugo, plain HTML), and output to the deploy path.\n\nFull segment management â€” adding, editing, building, deploying â€” is in the Pages tab on the dashboard. This card gives you the overview and quick auto-init for new content folders.</div></div>"
                            },
                            {
                                "when": {
                                    "textContains": "âš ï¸ partial"
                                },
                                "content": "Pages is partially configured â€” {{pagesSegments}} segment(s) exist but the pipeline isn't fully operational. Check the sections below for what's missing.",
                                "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš  Partially Configured</div><div class=\"state-detail\">You have {{pagesSegments}} segment(s) defined but the Pages pipeline isn't fully ready. Common causes:\n\nâ€¢ A builder required by a segment isn't installed (check ğŸ”¨ Builders below)\nâ€¢ Content source directory is empty or missing\nâ€¢ Deploy branch isn't set for GitHub Pages\n\nOpen the sections below to see what needs attention. The Pages tab has full management â€” build logs, preview, and deploy controls.</div></div>"
                            },
                            {
                                "when": {
                                    "textContains": "not configured"
                                },
                                "content": "No Pages segments configured yet. If your project has content folders (docs/, content/), the auto-init below can create segments automatically.",
                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â—‹ Not Configured</div><div class=\"state-detail\">Pages isn't set up yet. This means no static sites are being built from your project.\n\nIf you have content folders â€” docs/, content/, site/ â€” they'll appear in the ğŸ“‚ Content Folders section with an auto-init option. The control plane detects the best builder for each folder (Docusaurus for docs with docusaurus.config.js, MkDocs for mkdocs.yml, etc.).\n\nYou can also create segments manually from the Pages tab, choosing any source directory and builder combination.\n\nPages deployment typically goes through GitHub Pages on branch {{pagesBranch}} â€” which links back to your GitHub card's repository configuration.</div></div>"
                            }
                        ],
                        "children": [
                            {
                                "id": "pages-setup",
                                "title": "Setup Panel",
                                "icon": "âš™ï¸",
                                "selector": "#wiz-int-setup-int-pages",
                                "content": "Your Pages dashboard â€” segments, content folders, available builders, and deployment configuration. What you see depends on what the detection scan found in your project.",
                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">âš™ï¸ Pages Configuration</div><div class=\"state-detail\">The Pages system works in segments â€” each one is an independent static site section:\n\nâ€¢ A segment has a source (content directory), a builder (Docusaurus, MkDocs, Hugo, plain), and an output path\nâ€¢ Multiple segments combine into one deployed site â€” docs + blog + landing page all coexist\nâ€¢ Each builder is auto-detected from your source structure (docusaurus.config.js â†’ Docusaurus, mkdocs.yml â†’ MkDocs)\n\nThe setup panel here shows what the detection scan found. For full management â€” adding segments, building, previewing, deploying â€” use the Pages tab on the dashboard.</div></div>",
                                "children": [
                                    {
                                        "id": "pages-status-strip",
                                        "title": "Status Strip",
                                        "icon": "ğŸ“Š",
                                        "selector": "#wiz-pages-status-strip",
                                        "content": "Pages health at a glance â€” {{pagesSegments}} segment(s), deploy branch {{pagesBranch}}, {{pagesBuildersAvail}} builders available.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“Š Pages Health</div><div class=\"state-detail\">Each pill is one dimension of your Pages setup:\n\nâ€¢ Status â€” overall pipeline health (ready, partial, not configured)\nâ€¢ Segments â€” {{pagesSegments}} buildable site section(s) defined\nâ€¢ .pages/ â€” the configuration directory exists in your project root\nâ€¢ Deploy branch â€” {{pagesBranch}} is where built output goes for GitHub Pages\nâ€¢ Content folders â€” detected directories that could become segments\n\nGreen status means all segments have valid sources, working builders, and a deploy target. Partial means something's incomplete â€” a missing builder or empty source.</div></div>",
                                        "children": [
                                            {
                                                "id": "pages-pill-status",
                                                "title": "Status",
                                                "icon": "ğŸ“‹",
                                                "selector": "#wiz-pages-pill-status",
                                                "content": "Overall Pages pipeline status â€” whether segments are configured and builders are operational.",
                                                "variants": [
                                                    {
                                                        "when": {
                                                            "textContains": "âœ… ready"
                                                        },
                                                        "content": "All {{pagesSegments}} segment(s) are healthy â€” sources exist, builders are available, output paths are configured.",
                                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Pipeline Ready</div><div class=\"state-detail\">Every configured segment has:\n\nâ€¢ A valid source directory with content\nâ€¢ An available builder installed on your system\nâ€¢ An output path for the built site\n\nYou can build and preview segments from the Pages tab. Deployment pushes built output to {{pagesBranch}} for GitHub Pages.</div></div>"
                                                    },
                                                    {
                                                        "when": {
                                                            "textContains": "âš ï¸ partial"
                                                        },
                                                        "content": "Some segments have issues â€” a builder might be missing or a source directory is empty. Check the sections below.",
                                                        "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš  Partially Ready</div><div class=\"state-detail\">At least one segment has a problem. Common issues:\n\nâ€¢ Builder not installed â€” check ğŸ”¨ Builders section\nâ€¢ Source directory empty or deleted since last scan\nâ€¢ Output path conflicts between segments\n\nHit ğŸ”„ Re-scan to refresh detection. The Pages tab shows per-segment build status with detailed error messages.</div></div>"
                                                    },
                                                    {
                                                        "when": {
                                                            "textContains": "not configured"
                                                        },
                                                        "content": "No segments exist yet. Content folders below can be auto-initialized, or create segments manually in the Pages tab.",
                                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â—‹ No Segments</div><div class=\"state-detail\">Pages has no configured segments. A segment is required before anything can be built or deployed.\n\nTwo paths to create one:\nâ€¢ Auto-init from detected content folders (ğŸ“‚ section below)\nâ€¢ Manual creation in the Pages tab â€” choose any directory + builder\n\nThe auto-init option examines each content folder's structure and picks the best builder automatically.</div></div>"
                                                    }
                                                ],
                                                "expanded": "",
                                                "children": []
                                            },
                                            {
                                                "id": "pages-pill-segments",
                                                "title": "Segments",
                                                "icon": "ğŸ“‘",
                                                "selector": "#wiz-pages-pill-segments",
                                                "content": "{{pagesSegments}} segment(s) â€” each one is an independent buildable site section with its own source directory and builder.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“‘ {{pagesSegments}} Segment(s)</div><div class=\"state-detail\">Each segment is a self-contained build unit:\n\nâ€¢ Has its own source directory (e.g., docs/, content/blog/)\nâ€¢ Uses a specific builder (Docusaurus, MkDocs, Hugo, plain HTML)\nâ€¢ Outputs to a path within the deployed site\n\nMultiple segments combine into one site â€” you can have docs at /docs, a blog at /blog, and a landing page at / all building independently.\n\nSee the ğŸ“‘ Segments section below for the full list with source â†’ output mappings and preview links.</div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "pages-pill-pagesdir",
                                                "title": ".pages/ Directory",
                                                "icon": "ğŸ“",
                                                "selector": "#wiz-pages-pill-pagesdir",
                                                "content": "The .pages/ directory holds Pages configuration â€” segment definitions, builder settings, and deploy metadata.",
                                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ“ .pages/ Exists</div><div class=\"state-detail\">Your project has a .pages/ directory at the root. This is where the Pages system stores:\n\nâ€¢ Segment definitions (which directories build into which site sections)\nâ€¢ Builder configuration and overrides\nâ€¢ Deploy metadata (branch, base URL, custom domain)\nâ€¢ Theme and plugin settings per builder\n\nThis directory is committed to your repository â€” your Pages configuration is versioned and reproducible across environments.</div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "pages-pill-branch",
                                                "title": "Deploy Branch",
                                                "icon": "ğŸŒ¿",
                                                "selector": "#wiz-pages-pill-branch",
                                                "content": "Built site output goes to {{pagesBranch}} â€” GitHub Pages serves from this branch automatically when configured on your repository.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸŒ¿ {{pagesBranch}}</div><div class=\"state-detail\">The deploy branch is where built static site output is committed. GitHub Pages reads from this branch to serve your site.\n\nThe flow:\n1. Build segments locally (or in CI/CD)\n2. Built output is committed to {{pagesBranch}}\n3. GitHub Pages picks it up and serves at your.domain.com or username.github.io/repo\n\nThis links back to your GitHub card â€” {{ghRepo}} needs GitHub Pages enabled in repository settings, pointing at {{pagesBranch}} as the source.\n\nThe CI/CD card's workflow can automate this: build on push to {{ghBranch}}, deploy output to {{pagesBranch}}.</div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "pages-pill-folders",
                                                "title": "Content Folders",
                                                "icon": "ğŸ“‚",
                                                "selector": "#wiz-pages-pill-folders",
                                                "content": "{{pagesFolders}} content folder(s) detected that could become segments â€” auto-init available if you want to build them into your site.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“‚ {{pagesFolders}} Content Folder(s)</div><div class=\"state-detail\">The detection scan found {{pagesFolders}} directories in your project that contain buildable content (markdown, HTML, RST) but don't have segments yet.\n\nEach folder is matched with the best builder:\nâ€¢ Has docusaurus.config.js â†’ Docusaurus\nâ€¢ Has mkdocs.yml â†’ MkDocs\nâ€¢ Contains .md files â†’ plain markdown (fallback)\n\nCheck the ğŸ“‚ Content Folders section below to auto-initialize segments from these. Apply creates the segment definitions â€” you can preview and build from the Pages tab afterward.</div></div>",
                                                "children": []
                                            }
                                        ]
                                    },
                                    {
                                        "id": "pages-segments",
                                        "title": "Segments",
                                        "icon": "ğŸ“‘",
                                        "selector": "#wiz-pages-section-segments",
                                        "content": "{{pagesSegments}} configured segment(s) â€” each row shows the segment name, builder, source â†’ output mapping, and a local preview link.",
                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ“‘ {{pagesSegments}} Active Segment(s)</div><div class=\"state-detail\">These segments are configured and buildable. Each row shows:\n\nâ€¢ Name â€” the segment identifier used in commands and the Pages tab\nâ€¢ Builder â€” which build tool processes the content (Docusaurus, MkDocs, etc.)\nâ€¢ Source â†’ Path â€” the content directory and where it appears in the deployed site\nâ€¢ ğŸ”— â€” opens a local preview of the built segment\n\nSegments build independently â€” changing docs doesn't rebuild blog. The Pages tab has build controls, logs, and full preview for each segment.\n\nDeployment pushes all segment outputs to {{pagesBranch}} as a combined site.</div></div>",
                                        "children": []
                                    },
                                    {
                                        "id": "pages-folders",
                                        "title": "Content Folders",
                                        "icon": "ğŸ“‚",
                                        "selector": "#wiz-pages-section-folders",
                                        "content": "Detected content directories that can become segments. âœ… means a segment already exists, â¬œ means auto-init is available.",
                                        "variants": [
                                            {
                                                "when": {
                                                    "textContains": "no segment"
                                                },
                                                "content": "{{pagesUninit}} content folder(s) don't have segments yet â€” check the auto-init box and Apply to create them automatically with the best matching builder.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“‚ {{pagesUninit}} Uninitialized</div><div class=\"state-detail\">{{pagesUninit}} content folder(s) were detected but don't have segments yet. Each one shows:\n\nâ€¢ The folder name and file count\nâ€¢ The best-matching builder (detected from config files and content type)\nâ€¢ A ğŸ’¡ suggestion if the detection has a specific recommendation\n\nThe auto-init checkbox at the bottom creates segments for all uninitialized folders using their detected builders. After init, you can build and preview from the Pages tab.\n\nThis is the fastest way to get your content building â€” one click creates properly configured segments.</div></div>"
                                            }
                                        ],
                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ“‚ All Folders Linked</div><div class=\"state-detail\">Every detected content folder has a corresponding segment. Your project's content directories are fully integrated into the Pages pipeline.\n\nEach folder's content is being built through its assigned builder whenever you trigger a build from the Pages tab or CI/CD workflow.</div></div>",
                                        "children": []
                                    },
                                    {
                                        "id": "pages-builders",
                                        "title": "Builders",
                                        "icon": "ğŸ”¨",
                                        "selector": "#wiz-pages-section-builders",
                                        "content": "{{pagesBuildersAvail}} of {{pagesBuildersTotal}} builders available on your system â€” these are the tools that compile content into static HTML.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ”¨ {{pagesBuildersAvail}}/{{pagesBuildersTotal}} Builders</div><div class=\"state-detail\">Builders are the engines that transform your content into static HTML. Each one handles a different source format:\n\nâ€¢ Docusaurus â€” React-based, MDX support, versioned docs, blog\nâ€¢ MkDocs â€” Python-based, Material theme, simpler configuration\nâ€¢ Hugo â€” Go-based, extremely fast builds, shortcodes\nâ€¢ Plain â€” copies HTML/CSS/JS directly, no compilation\n\nâœ… means the builder's CLI is installed and ready. â—‹ means it's known but not installed â€” segments using that builder can't build until you install it.\n\nThe system tools section at the top of this step shows CLI availability. Missing builders can be installed from there.</div></div>",
                                        "children": [
                                            {
                                                "id": "pages-builder-docusaurus",
                                                "title": "Docusaurus",
                                                "icon": "ğŸ¦–",
                                                "selector": "#wiz-pages-builder-docusaurus",
                                                "content": "Docusaurus â€” React-based documentation framework with MDX support. The most feature-rich builder for documentation sites.",
                                                "variants": [
                                                    {
                                                        "when": {
                                                            "textContains": "âœ…"
                                                        },
                                                        "content": "Docusaurus is installed and ready â€” Node.js and npx detected. The most powerful builder for documentation-heavy projects.",
                                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ¦– Docusaurus Â· ready</div><div class=\"state-detail\">Docusaurus is available and can build segments assigned to it.\n\nWhat it gives you:\nâ€¢ MDX â€” write React components directly in markdown\nâ€¢ Versioned docs â€” maintain docs across software versions\nâ€¢ Blog engine â€” built-in blog with RSS and pagination\nâ€¢ Search â€” Algolia-powered search out of the box\nâ€¢ i18n â€” built-in internationalization support\nâ€¢ Theme system â€” fully customizable React-based themes\n\nBest for: documentation sites, knowledge bases, multi-version API docs, developer portals.\n\nRequires: Node.js 18+ (detected via npx). Builds are slower than Hugo but the output is a full React SPA with client-side navigation.\n\nThis is the default builder when a content folder contains markdown and Node.js is available.</div></div>"
                                                    },
                                                    {
                                                        "when": {
                                                            "textContains": "â—‹"
                                                        },
                                                        "content": "Docusaurus requires Node.js 18+ (npx). Install Node.js to use this builder for MDX-enabled documentation sites.",
                                                        "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">ğŸ¦– Docusaurus Â· not available</div><div class=\"state-detail\">Docusaurus can't build because Node.js is missing.\n\nTo install:\nâ€¢ Node.js 18+ from https://nodejs.org\nâ€¢ Or via nvm: nvm install 18\n\nOnce Node.js is installed, npx handles Docusaurus initialization and builds automatically â€” no global install needed.\n\nAlternative: MkDocs uses Python instead of Node.js and is simpler to set up, though it has fewer features (no MDX, no React components).</div></div>"
                                                    }
                                                ],
                                                "expanded": "",
                                                "children": []
                                            },
                                            {
                                                "id": "pages-builder-mkdocs",
                                                "title": "MkDocs",
                                                "icon": "ğŸ“˜",
                                                "selector": "#wiz-pages-builder-mkdocs",
                                                "content": "MkDocs â€” Python-based documentation generator with Material theme support. Simpler than Docusaurus but very polished.",
                                                "variants": [
                                                    {
                                                        "when": {
                                                            "textContains": "âœ…"
                                                        },
                                                        "content": "MkDocs is installed and ready â€” Python and mkdocs CLI detected. Great for clean, Material-themed documentation.",
                                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ“˜ MkDocs Â· ready</div><div class=\"state-detail\">MkDocs is available and can build segments assigned to it.\n\nWhat it gives you:\nâ€¢ Material theme â€” polished, responsive design out of the box\nâ€¢ Navigation â€” automatic sidebar from directory structure\nâ€¢ Search â€” built-in lunr.js search, no external service needed\nâ€¢ Plugins â€” rich ecosystem (mermaid diagrams, code annotations, admonitions)\nâ€¢ Fast â€” Python-based but builds are quick for typical doc sizes\n\nBest for: project documentation, internal wikis, API reference sites, README-style docs.\n\nRequires: Python 3 with pip. Configuration lives in mkdocs.yml.\n\nMkDocs is the fallback when Node.js isn't available but Python is â€” it produces excellent results with less configuration than Docusaurus.</div></div>"
                                                    },
                                                    {
                                                        "when": {
                                                            "textContains": "â—‹"
                                                        },
                                                        "content": "MkDocs requires Python 3 and the mkdocs package. Install with: pip install mkdocs mkdocs-material",
                                                        "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">ğŸ“˜ MkDocs Â· not available</div><div class=\"state-detail\">MkDocs isn't installed. Python is likely available but the mkdocs package is missing.\n\nTo install:\nâ€¢ pip install mkdocs mkdocs-material\nâ€¢ Or in a venv: python -m pip install mkdocs mkdocs-material\n\nThe Material theme is strongly recommended â€” it provides the polished look and responsive layout. Without it, MkDocs uses a basic theme.\n\nAlternative: Docusaurus requires Node.js but is more feature-rich (MDX, versioned docs, React components).</div></div>"
                                                    }
                                                ],
                                                "expanded": "",
                                                "children": []
                                            },
                                            {
                                                "id": "pages-builder-hugo",
                                                "title": "Hugo",
                                                "icon": "âš¡",
                                                "selector": "#wiz-pages-builder-hugo",
                                                "content": "Hugo â€” Go-based static site generator. Single binary, no runtime dependencies, extremely fast builds.",
                                                "variants": [
                                                    {
                                                        "when": {
                                                            "textContains": "âœ…"
                                                        },
                                                        "content": "Hugo is installed and ready â€” the hugo binary is available. Fastest builder for large content sites.",
                                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âš¡ Hugo Â· ready</div><div class=\"state-detail\">Hugo is available and can build segments assigned to it.\n\nWhat it gives you:\nâ€¢ Speed â€” builds thousands of pages in milliseconds (Go compiled binary)\nâ€¢ Shortcodes â€” reusable content snippets without a framework\nâ€¢ Taxonomies â€” categories, tags, series out of the box\nâ€¢ Multilingual â€” built-in i18n with per-language content trees\nâ€¢ Themes â€” 300+ themes available, single-file configuration\n\nBest for: blogs, large content sites, multi-language sites, sites where build speed matters.\n\nRequires: hugo binary (no runtime dependencies). Single binary â€” no package manager, no node_modules, no virtual environments.\n\nHugo is the fastest builder by far but has less flexibility than Docusaurus for custom interactive components.</div></div>"
                                                    },
                                                    {
                                                        "when": {
                                                            "textContains": "â—‹"
                                                        },
                                                        "content": "Hugo requires the hugo binary. The control plane can download it to ~/.local/bin/ automatically.",
                                                        "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš¡ Hugo Â· not available</div><div class=\"state-detail\">The hugo binary isn't installed.\n\nTo install:\nâ€¢ The control plane can download it automatically (ğŸ”§ Install in the system tools section)\nâ€¢ Or manually: https://gohugo.io/installation/\nâ€¢ Homebrew: brew install hugo\nâ€¢ Snap: snap install hugo\n\nHugo is a single binary â€” no runtime dependencies. It downloads and runs immediately. No python, no node, no package manager needed.\n\nAlternative: Docusaurus or MkDocs if you already have Node.js or Python installed.</div></div>"
                                                    }
                                                ],
                                                "expanded": "",
                                                "children": []
                                            },
                                            {
                                                "id": "pages-builder-sphinx",
                                                "title": "Sphinx",
                                                "icon": "ğŸ“œ",
                                                "selector": "#wiz-pages-builder-sphinx",
                                                "content": "Sphinx â€” Python documentation generator. The standard for Python project docs, supports RST and Markdown via MyST.",
                                                "variants": [
                                                    {
                                                        "when": {
                                                            "textContains": "âœ…"
                                                        },
                                                        "content": "Sphinx is installed and ready â€” Python and sphinx-build detected. The standard choice for Python project documentation.",
                                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ“œ Sphinx Â· ready</div><div class=\"state-detail\">Sphinx is available and can build segments assigned to it.\n\nWhat it gives you:\nâ€¢ RST â€” reStructuredText, the most expressive plain-text markup\nâ€¢ Cross-referencing â€” automatic links between docs, API references, glossary terms\nâ€¢ API autodoc â€” generate docs directly from Python docstrings\nâ€¢ Extensions â€” hundreds of extensions (intersphinx, napoleon, todo, coverage)\nâ€¢ MyST â€” Markdown support via myst-parser (write markdown instead of RST)\n\nBest for: Python projects, API documentation, academic/technical writing, projects needing cross-references.\n\nRequires: Python 3 with sphinx. Configuration lives in conf.py.\n\nSphinx is the gold standard for Python projects â€” if your project is Python-heavy with docstrings, autodoc will save you hours of manual documentation.</div></div>"
                                                    },
                                                    {
                                                        "when": {
                                                            "textContains": "â—‹"
                                                        },
                                                        "content": "Sphinx requires Python 3 and the sphinx package. Install with: pip install sphinx myst-parser",
                                                        "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">ğŸ“œ Sphinx Â· not available</div><div class=\"state-detail\">Sphinx isn't installed.\n\nTo install:\nâ€¢ pip install sphinx myst-parser\nâ€¢ myst-parser enables Markdown alongside RST\nâ€¢ For the RTD theme: pip install sphinx-rtd-theme\n\nSphinx is most useful for Python projects with docstrings that need API reference generation. For pure markdown documentation, MkDocs or Docusaurus are simpler.\n\nAlternative: MkDocs for simpler markdown docs, Docusaurus for MDX and React.</div></div>"
                                                    }
                                                ],
                                                "expanded": "",
                                                "children": []
                                            },
                                            {
                                                "id": "pages-builder-raw",
                                                "title": "Static Files",
                                                "icon": "ğŸ“‹",
                                                "selector": "#wiz-pages-builder-raw",
                                                "content": "Static Files â€” copies HTML, CSS, and JS directly to the output. No build step, no dependencies. Always available.",
                                                "variants": [
                                                    {
                                                        "when": {
                                                            "textContains": "âœ…"
                                                        },
                                                        "content": "Static Files is always available â€” no build tools needed. Copies your files directly to the deployed site.",
                                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ“‹ Static Files Â· always available</div><div class=\"state-detail\">The raw/static builder is always ready â€” it requires no external tools.\n\nWhat it does:\nâ€¢ Copies files as-is from source to output directory\nâ€¢ No compilation, no transformation, no dependencies\nâ€¢ HTML, CSS, JS, images â€” anything goes\n\nBest for: pre-built sites, hand-crafted HTML, legacy content, assets that don't need processing.\n\nThis is the fallback builder when no specialized tool is available or when your content is already built HTML. It's also useful for embedding pre-existing sites as segments alongside Docusaurus or MkDocs segments.</div></div>"
                                                    }
                                                ],
                                                "expanded": "",
                                                "children": []
                                            },
                                            {
                                                "id": "pages-builder-custom",
                                                "title": "Custom Build",
                                                "icon": "ğŸ”§",
                                                "selector": "#wiz-pages-builder-custom",
                                                "content": "Custom Build â€” run any shell command as the build step. Full flexibility for non-standard toolchains. Always available.",
                                                "variants": [
                                                    {
                                                        "when": {
                                                            "textContains": "âœ…"
                                                        },
                                                        "content": "Custom Build is always available â€” define any build command for segments that don't fit standard builders.",
                                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ”§ Custom Build Â· always available</div><div class=\"state-detail\">The custom builder lets you define any shell command as your build step.\n\nUse cases:\nâ€¢ Gatsby, Astro, Next.js, Eleventy, or any other SSG\nâ€¢ Custom scripts that generate HTML from templates\nâ€¢ Compile-to-HTML workflows (Pandoc, LaTeX â†’ HTML)\nâ€¢ Chained builds that combine multiple tools\n\nConfiguration: set the build command, source directory, and output path in the segment config. The command runs from the project root.\n\nThis builder exists because the Pages system shouldn't limit you to the built-in options. If your tool can produce HTML output, it works as a custom builder.</div></div>"
                                                    }
                                                ],
                                                "expanded": "",
                                                "children": []
                                            }
                                        ]
                                    },
                                    {
                                        "id": "pages-deploy-info",
                                        "title": "Deploy Info",
                                        "icon": "ğŸš€",
                                        "selector": "#wiz-pages-deploy-info",
                                        "content": "Deploy branch is {{pagesBranch}} â€” built output goes here. GitHub Pages on {{ghRepo}} should be configured to serve from this branch.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸš€ Deployment Target</div><div class=\"state-detail\">Your Pages deployment configuration:\n\nâ€¢ Deploy branch â€” {{pagesBranch}}. Built segment output is committed here.\nâ€¢ GitHub Pages â€” {{ghRepo}} needs Pages enabled in repository settings, source set to {{pagesBranch}}.\n\nThe deployment flow:\n1. Build all segments (locally or in CI/CD)\n2. Commit built output to {{pagesBranch}}\n3. GitHub Pages serves the combined site\n\nBase URL matters if your repo is at github.io/repo-name â€” internal links need the prefix. The Pages tab has base URL configuration per segment.</div></div>",
                                        "children": []
                                    },
                                    {
                                        "id": "pages-apply",
                                        "title": "Apply",
                                        "icon": "âœ…",
                                        "selector": "#wiz-apply-int-pages",
                                        "content": "Auto-initializes {{pagesUninit}} segment(s) from uninitialized content folders using their best-matching builders.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">âœ… Auto-Initialize Segments</div><div class=\"state-detail\">Apply creates segment definitions for each checked content folder:\n\n1. Reads the content folder's structure and detected builder\n2. Creates a segment in .pages/ with the right configuration\n3. Sets the output path within the deployed site\n\nAfter initialization, segments are ready to build and preview from the Pages tab. No content is modified â€” only .pages/ segment definitions are created.\n\nThis is reversible â€” delete any segment from the Pages tab if the auto-detected configuration isn't right.</div></div>",
                                        "children": []
                                    },
                                    {
                                        "id": "pages-cancel",
                                        "title": "Cancel",
                                        "icon": "âœ–",
                                        "selector": "#wiz-cancel-int-pages",
                                        "content": "Closes the setup panel without creating any segments. No files are modified.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">âœ– Discard</div><div class=\"state-detail\">Cancel collapses the panel without creating segments or modifying any files. The auto-init checkbox state is discarded.\n\nReopen anytime with âš™ï¸ Setup â€” detection results repopulate from the current project state.</div></div>",
                                        "children": []
                                    }
                                ]
                            }
                        ]
                    }
                ]
            }
        ]
    }
]
[
    {
        "context": "wizard/welcome",
        "title": "Welcome to the Setup Wizard",
        "icon": "ğŸ§™",
        "content": "6 steps to shape your project. Everything starts here â€” your project's identity, where it lives, and how it's organized.\n\nTake your time. Nothing is saved until you hit Finish on the last step, so feel free to explore and come back.",
        "children": [
            {
                "id": "project-name",
                "title": "Project Name",
                "icon": "âœï¸",
                "selector": "#wiz-name",
                "content": "This is your project's identity â€” the name that follows it everywhere.",
                "expanded": "It shows up in Docker image tags, CI/CD pipeline names, Helm chart metadata, generated folder structures, and every config file the control plane produces.\n\nPick something lowercase, hyphen-separated â€” like my-api or data-pipeline. Spaces and special characters can cause issues in Docker tags and file paths downstream.\n\nğŸ’¡ Changing this later is possible but ripples through generated configs. Best to get it right now.",
                "children": []
            },
            {
                "id": "description",
                "title": "Description",
                "icon": "ğŸ“",
                "selector": "#wiz-desc",
                "content": "A short summary of what this project does â€” one or two sentences is perfect.",
                "expanded": "This text appears in your README header, package metadata (package.json, pyproject.toml), GitHub repository description, and Helm chart annotations.\n\nIt's not required, but it's the kind of thing you'll appreciate having when someone new looks at the project six months from now.\n\nğŸ’¡ Write it for a colleague who's never seen this repo before.",
                "children": []
            },
            {
                "id": "repository",
                "title": "Repository",
                "icon": "ğŸ”—",
                "selector": "#wiz-repo",
                "content": "Your Git remote â€” this connects the project to its home on GitHub, GitLab, or wherever it lives.",
                "expanded": "The control plane uses this for:\nâ€¢ CI/CD webhooks â€” triggering pipelines on push\nâ€¢ GitHub integration â€” PR management, secrets sync, Actions dispatch\nâ€¢ Docker registry paths â€” deriving container image names\nâ€¢ Generated configs â€” embedding the repo URL in Helm charts, Dockerfiles, and CI workflows\n\nFormat: github.com/owner/repo (without https://). If you're using GitHub, the control plane can often auto-detect this from your local git remote.",
                "children": []
            },
            {
                "id": "domains",
                "title": "Domains",
                "icon": "ğŸ·ï¸",
                "selector": "#wiz-domains",
                "separator": true,
                "content": "Domains are logical groupings for your codebase â€” not internet domains, more like folders of purpose.",
                "expanded": "When you add modules in Step 2, each one belongs to a domain. Think of it as organizing your project by responsibility:\n\nâ€¢ library â€” shared utilities, core business logic\nâ€¢ ops â€” DevOps tooling, scripts, CI/CD configs\nâ€¢ docs â€” documentation, guides, Docusaurus sites\nâ€¢ services â€” microservices, APIs, workers\n\nYou've got {{domainCount}} so far. You can always add more later â€” this just shapes how modules are categorized in the dashboard.",
                "dynamic": true,
                "childTemplate": {
                    "title": "{{name}}",
                    "content": "One of your project domains. Modules assigned to this domain will be grouped together in the dashboard and reports.",
                    "selector": "#wiz-domains > span"
                },
                "children": [
                    {
                        "id": "add-domain",
                        "title": "Add domainâ€¦",
                        "icon": "â•",
                        "selector": "#wiz-new-domain",
                        "content": "Type a name and press Enter or click + Add.",
                        "expanded": "Good domain names are short and describe a purpose, not a technology. Think library over python, or services over backend.\n\nğŸ’¡ You don't need to plan this perfectly. Domains can be added, renamed, or reorganized anytime.",
                        "children": []
                    }
                ]
            },
            {
                "id": "environments",
                "title": "Environments",
                "icon": "ğŸ“‹",
                "selector": "#wiz-envs",
                "separator": true,
                "content": "Environments scope your secrets and deployment variables. Your project configuration, integrations, and generated files are shared across all of them â€” what changes per environment are the credentials and endpoint values.",
                "expanded": "So your DB_HOST might be localhost:5432 in development but prod-db.internal in production. Same Dockerfile, same CI pipeline, different .env file per environment.\n\nEach environment gets its own encrypted .env file managed by the Vault in Step 3. The control plane keeps them separate â€” secrets from one environment never leak into another.\n\nYou've got {{envCount}} set up. Most projects need at least development and production. Add staging or preview if your workflow needs intermediate deployment targets.",
                "dynamic": true,
                "childTemplate": {
                    "title": "{{name}}",
                    "content": "The {{name}} environment â€” one of your deployment targets. It gets its own .env file with credentials and endpoint values scoped specifically to this context.",
                    "expanded": "When you define secrets and variables in Step 3, each environment has its own set of values. So your API keys, database URLs, and feature flags can differ between environments while sharing the same project config and generated files.\n\nğŸ’¡ Click the name or description to edit. Use Ã— to remove this environment.",
                    "selector": "#wiz-envs > div"
                },
                "children": [
                    {
                        "id": "add-env-name",
                        "title": "Environment name",
                        "icon": "â•",
                        "selector": "#wiz-new-env-name",
                        "content": "Add another deployment target â€” staging, qa, preview, or whatever your workflow needs.",
                        "expanded": "Keep it lowercase, no spaces. This name becomes part of your .env file path (.env.staging), GitHub deployment environment name, and CI/CD workflow target.\n\nEach new environment gets its own secret values in Step 3.\n\nğŸ’¡ Common patterns: development + production for simple projects. Add staging for a QA gate, or preview for PR-based ephemeral environments.",
                        "children": []
                    },
                    {
                        "id": "add-env-desc",
                        "title": "Environment description",
                        "icon": "ğŸ“",
                        "selector": "#wiz-new-env-desc",
                        "content": "A human-readable label â€” helps your team know what each environment is for at a glance.",
                        "expanded": "Examples: \"Local development and testing\", \"Pre-production staging\", \"Live customer-facing\".\n\nThis shows up in the dashboard environment selector and in the Vault management view. It's optional but makes life easier when you have 3+ environments.",
                        "children": []
                    }
                ]
            }
        ]
    },
    {
        "context": "wizard/modules",
        "title": "Modules",
        "icon": "ğŸ”",
        "content": "Modules are the building blocks of your project â€” each one maps to a directory in your codebase with its own stack and purpose.\n\nThe control plane uses them to decide what to generate: Dockerfiles, CI pipelines, linting configs, audit scans, and dashboard structure all flow from what you define here.",
        "children": [
            {
                "id": "auto-detect",
                "title": "Auto-Detect",
                "icon": "ğŸ”",
                "selector": "button[onclick='wizardDetect()']",
                "content": "Scans your project root for recognizable structures â€” pyproject.toml, package.json, docker-compose.yml, Makefile, docs folders â€” and creates module entries from what it finds.",
                "expanded": "Detection looks at file signatures:\nâ€¢ pyproject.toml or setup.py â†’ python-lib or python-cli\nâ€¢ app.py / wsgi.py â†’ python-flask\nâ€¢ package.json â†’ node\nâ€¢ docker-compose.yml â†’ docker-compose\nâ€¢ .md files in a docs/ folder â†’ markdown\n\nIt also reads descriptions from package metadata when available. Detection is non-destructive â€” it won't overwrite modules you've already added manually.\n\nğŸ’¡ If your project has an unusual structure, you can always add modules manually below.",
                "children": []
            },
            {
                "id": "modules-list",
                "title": "Module List",
                "icon": "ğŸ“¦",
                "selector": "#wizard-modules-list",
                "content": "Your configured modules â€” {{moduleCount}} so far. Each one represents a directory the control plane knows about and manages.",
                "expanded": "Every module gets its own treatment in the pipeline:\nâ€¢ Python modules get linting (ruff/flake8), type checking, and test runners\nâ€¢ Flask modules get Dockerfile generation, health check endpoints, and deployment configs\nâ€¢ Node modules get npm scripts, bundler configs, and dependency audits\nâ€¢ Docker-compose modules get service orchestration and K8s migration paths\nâ€¢ Markdown modules get Docusaurus site generation and content management\n\nThe control plane uses module paths to scope operations â€” when you run audit, lint, or generate configs, it targets the right directories.",
                "dynamic": true,
                "childTemplate": {
                    "title": "{{name}}",
                    "content": "The {{name}} module â€” managed by the control plane as part of your project structure.",
                    "expanded": "This module's stack determines what the control plane generates for it: Dockerfiles, CI workflows, linting configs, and audit targets. Its domain assignment controls how it's grouped in the dashboard.\n\nğŸ’¡ Use Ã— to remove this module if it was detected incorrectly or is no longer needed.",
                    "selector": "#wizard-modules-list > div"
                },
                "children": []
            },
            {
                "id": "add-module",
                "title": "Add Module",
                "icon": "â•",
                "selector": "#wiz-add-module",
                "separator": true,
                "content": "Manually define a module the auto-detector missed, or add one for a directory you're about to create. Pick a stack from the dropdown to tell the control plane what technology this module uses.",
                "expanded": "Three fields define a module:\nâ€¢ Name â€” appears in dashboard cards, CI pipeline names, and generated configs\nâ€¢ Path â€” directory relative to project root (e.g. src/core, services/api)\nâ€¢ Stack â€” the technology stack that drives everything the control plane generates\n\nAvailable stacks (47 total):\nğŸ python Â· python-lib Â· python-cli Â· python-flask Â· python-fastapi Â· python-django\nğŸ“¦ node Â· node-express Â· node-nextjs Â· node-react Â· node-lib Â· typescript Â· typescript-lib\nğŸ¹ go Â· go-gin Â· go-fiber Â· go-cli Â· go-lib\nğŸ¦€ rust Â· rust-actix Â· rust-axum Â· rust-cli Â· rust-lib\nâš™ï¸ c Â· cpp Â· âš¡ zig Â· ğŸ swift\nâ˜• java-maven Â· java-maven-spring Â· java-gradle Â· java-gradle-spring\nğŸ”· dotnet Â· dotnet-aspnet Â· dotnet-blazor\nğŸ’ ruby Â· ruby-rails Â· ruby-sinatra Â· ğŸ’§ elixir Â· elixir-phoenix\nğŸ˜ php Â· ğŸ“¡ protobuf\nğŸ³ docker-compose Â· â˜¸ï¸ kubernetes Â· âˆ helm Â· ğŸ—ï¸ terraform\nğŸ“ markdown Â· ğŸŒ static-site\n\nFlavored stacks inherit from their base and add framework-specific capabilities. Each is defined in stacks/<name>/stack.yml.",
                "children": [
                    {
                        "id": "mod-name",
                        "title": "Module Name",
                        "icon": "âœï¸",
                        "selector": "#wiz-mod-name",
                        "content": "A short, descriptive name for this module â€” like core, api, web, or docs.",
                        "expanded": "This name appears in:\nâ€¢ Dashboard module cards\nâ€¢ CI pipeline names (e.g. lint-core, test-api)\nâ€¢ Docker image tags when applicable\nâ€¢ Generated config references\n\nKeep it lowercase, hyphen-separated. It doesn't need to match the directory name, but it helps.",
                        "children": []
                    },
                    {
                        "id": "mod-path",
                        "title": "Module Path",
                        "icon": "ğŸ“‚",
                        "selector": "#wiz-mod-path",
                        "content": "The directory path relative to your project root â€” this is where the control plane looks for source files.",
                        "expanded": "Must point to an actual directory (or one you plan to create). The control plane uses this to:\nâ€¢ Scope linting and audit operations to the right files\nâ€¢ Generate Dockerfiles with correct COPY paths\nâ€¢ Set up CI workflows that only trigger on changes in this directory\nâ€¢ Resolve dependencies between modules\n\nExamples: src/core, src/ui/web, services/auth, docs",
                        "children": []
                    },
                    {
                        "id": "mod-stack",
                        "title": "Stack",
                        "icon": "ğŸ”§",
                        "selector": "#wiz-mod-stack",
                        "content": "A stack is a technology definition â€” it tells the control plane how to detect, build, lint, test, and deploy this module. Flavored stacks inherit capabilities from their base language.",
                        "expanded": "Each stack is defined in stacks/<name>/stack.yml. Flavored stacks declare a parent and inherit detection rules, requirements, and capabilities from their base â€” then add their own.\n\nğŸ Python\nâ€¢ python â€” Generic Python project\nâ€¢ python-lib â€” Library, no entry point (domain: library)\nâ€¢ python-cli â€” Click/argparse CLI tool (+run)\nâ€¢ python-flask â€” Flask web app (+serve)\nâ€¢ python-fastapi â€” FastAPI app (+serve via uvicorn)\nâ€¢ python-django â€” Django app (+serve, migrate, shell)\n\nğŸ“¦ JavaScript / TypeScript\nâ€¢ node â€” Node.js project\nâ€¢ node-express â€” Express.js server (+serve)\nâ€¢ node-nextjs â€” Next.js app (+dev, serve, build override)\nâ€¢ node-react â€” React SPA (+dev)\nâ€¢ node-lib â€” npm library (domain: library)\nâ€¢ typescript â€” TypeScript project\nâ€¢ typescript-lib â€” TS library (domain: library)\n\nğŸ¹ Go\nâ€¢ go â€” Go project (Go modules)\nâ€¢ go-gin â€” Gin web framework (+serve)\nâ€¢ go-fiber â€” Fiber web framework (+serve)\nâ€¢ go-cli â€” CLI tool (Cobra/urfave)\nâ€¢ go-lib â€” Library (domain: library)\n\nğŸ¦€ Rust\nâ€¢ rust â€” Rust project (Cargo)\nâ€¢ rust-actix â€” Actix-web service (+serve)\nâ€¢ rust-axum â€” Axum web service (+serve)\nâ€¢ rust-cli â€” CLI tool (clap)\nâ€¢ rust-lib â€” Library crate (domain: library)\n\nâš™ï¸ Systems\nâ€¢ c â€” C project (Makefile/CMake)\nâ€¢ cpp â€” C++ project (Makefile/CMake)\nâ€¢ zig â€” Zig project\nâ€¢ swift â€” Swift project (SPM)\n\nâ˜• JVM & .NET\nâ€¢ java-maven â€” Java (Maven build)\nâ€¢ java-maven-spring â€” Spring Boot + Maven (+serve)\nâ€¢ java-gradle â€” Java/Kotlin (Gradle build)\nâ€¢ java-gradle-spring â€” Spring Boot + Gradle (+serve)\nâ€¢ dotnet â€” .NET / C#\nâ€¢ dotnet-aspnet â€” ASP.NET web app (+serve)\nâ€¢ dotnet-blazor â€” Blazor app (+serve)\n\nğŸ’ Other Languages\nâ€¢ ruby â€” Ruby (Bundler)\nâ€¢ ruby-rails â€” Rails (+serve, migrate, console)\nâ€¢ ruby-sinatra â€” Sinatra (+serve)\nâ€¢ elixir â€” Elixir (Mix)\nâ€¢ elixir-phoenix â€” Phoenix (+serve, migrate, routes)\nâ€¢ php â€” PHP (Composer)\nâ€¢ protobuf â€” Protocol Buffers / gRPC\n\nğŸ³ Infrastructure\nâ€¢ docker-compose â€” Docker Compose orchestration\nâ€¢ kubernetes â€” Kubernetes manifests\nâ€¢ helm â€” Helm charts\nâ€¢ terraform â€” Terraform infrastructure\n\nğŸ“ Content\nâ€¢ markdown â€” Documentation (Docusaurus/MkDocs)\nâ€¢ static-site â€” Static site (HTML/CSS/JS)\n\nUse \"Custom\" to type an unlisted stack name â€” you can create its YAML later.",
                        "children": []
                    }
                ]
            }
        ]
    },
    {
        "context": "wizard/secrets",
        "title": "Secrets & Encryption",
        "icon": "ğŸ”",
        "content": "This step shows the state of your project's secrets infrastructure â€” one vault per environment, your GitHub connection, and the content encryption key.\n\nUnlike Step 1, some actions here take effect immediately when you click them. The + Create and ğŸ’¾ Save buttons write to disk right away â€” they don't wait for Finish.",
        "children": [
            {
                "id": "env-vault-status",
                "title": "Environment Vault Status",
                "icon": "ğŸŒ",
                "selector": "#wiz-env-vault-list",
                "separator": true,
                "content": "Each environment you defined in Step 1 gets its own encrypted vault file. In multi-environment mode, .env is a working copy of the active environment \u2014 when you switch environments, the control plane swaps the file automatically.",
                "expanded": "The file model:\n\u2022 .env \u2014 live working copy of whichever environment is active\n\u2022 .env.{name} \u2014 stored snapshot of each environment's secrets\n\u2022 .env.active \u2014 marker file recording which environment is selected\n\nWhen you activate production, the control plane saves .env \u2192 .env.development, then copies .env.production \u2192 .env. In single-env mode, there's just .env \u2014 no swapping.\n\n\ud83d\udca1 Vault files (.env.vault) are the encrypted versions. The .gitignore excludes plaintext .env files, and encryption adds the real protection.",
                "dynamic": true,
                "childTemplate": {
                    "title": "{{name}}",
                    "nameSelector": "code",
                    "content": "Vault file for the {{name}} environment.",
                    "expanded": "Checking status\u2026",
                    "selector": "#wiz-env-vault-list > div",
                    "variants": [
                        {
                            "when": {
                                "textContains": "unlocked",
                                "hasSelector": "[data-env-active]"
                            },
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">\ud83d\udd13 unlocked \u00b7 ACTIVE</div><div class=\"state-detail\">This is the active environment \u2014 .env is a live copy of this file right now. The vault is decrypted and ready for editing.\n\nAny changes you make in the \ud83d\udd10 Secrets tab modify this environment's .env directly. Remember to lock it when you're done.\n\nSwitching to another environment will save this file and swap in the new one.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "locked",
                                "hasSelector": "[data-env-active]"
                            },
                            "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">\ud83d\udd12 locked \u00b7 ACTIVE</div><div class=\"state-detail\">This is the active environment but the vault is locked \u2014 .env is encrypted on disk.\n\nUnlock it from the \ud83d\udd10 Secrets tab to view or edit secrets. The vault passphrase decrypts it on demand.\n\nSwitching to another environment will keep this vault locked and swap in the new one.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "missing",
                                "hasSelector": "[data-env-active]"
                            },
                            "expanded": "<div class=\"assistant-state-card state-error\"><div class=\"state-label\">\ud83d\udced missing \u00b7 ACTIVE</div><div class=\"state-detail\">This is the active environment but no .env file exists yet. Hit + Create to generate one \u2014 the file is written to disk immediately.\n\nThis is normal for new setups. Once created, you can add secrets through the \ud83d\udd10 Secrets tab.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "unlocked"
                            },
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">\ud83d\udd13 unlocked</div><div class=\"state-detail\">This vault is decrypted and ready. You can view and edit secrets through the \ud83d\udd10 Secrets tab on the dashboard.\n\nRemember to lock it when you're done \u2014 plaintext .env files should never be committed to git. The .gitignore already excludes them, but encryption is the real protection.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "locked"
                            },
                            "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">\ud83d\udd12 locked</div><div class=\"state-detail\">This vault is encrypted \u2014 its contents are safe on disk. This is the expected state when you're not actively editing credentials.\n\nTo read or edit secrets, unlock it from the \ud83d\udd10 Secrets tab. The vault passphrase decrypts it on demand.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "missing"
                            },
                            "expanded": "<div class=\"assistant-state-card state-error\"><div class=\"state-label\">\ud83d\udced missing</div><div class=\"state-detail\">This vault doesn't exist yet. Hit + Create to generate it \u2014 the file is written to disk immediately with an auto-generated encryption key.\n\nThis is normal for new environments. You can add secrets afterwards through the \ud83d\udd10 Secrets tab.</div></div>"
                        }
                    ]
                },
                "children": []
            },
            {
                "id": "gh-integration",
                "title": "GitHub Integration",
                "icon": "ğŸ”—",
                "selector": "#wiz-gh-integration",
                "separator": true,
                "content": "GITHUB_REPOSITORY connects your local vault to your GitHub remote â€” it's how the control plane knows where to sync secrets and dispatch workflows.",
                "expanded": "This value stays local to your .env file. It's never pushed to GitHub secrets â€” it's the bridge between your local credentials and your remote repository.\n\nWith this set, you get secrets sync to GitHub Actions, workflow dispatch, and PR management from the dashboard.",
                "variants": [
                    {
                        "when": {
                            "textContains": "configured"
                        },
                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… configured</div><div class=\"state-detail\">Your repository is set in .env. The control plane can push secrets, dispatch workflows, and manage PRs.\n\nThis value stays local â€” it's never pushed to GitHub. It's the link between your local vault and your remote repo.</div></div>"
                    },
                    {
                        "when": {
                            "textContains": "detected"
                        },
                        "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš ï¸ detected but not saved</div><div class=\"state-detail\">Your git remote was auto-detected but isn't persisted in .env yet. Click ğŸ’¾ Save to .env to keep it â€” this takes effect immediately.\n\nWithout it saved, GitHub integration features won't know where to target on next startup.</div></div>"
                    },
                    {
                        "when": {
                            "textContains": "could not detect"
                        },
                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â“ not detected</div><div class=\"state-detail\">No git remote found. You can set GITHUB_REPOSITORY manually in your .env file as owner/repo (e.g., my-org/my-project).\n\nThis is needed for secrets sync, GitHub Actions dispatch, and PR management.</div></div>"
                    }
                ],
                "children": [
                    {
                        "id": "gh-deploy-envs",
                        "title": "Deployment Environments",
                        "icon": "ğŸŒ",
                        "selector": "#wiz-gh-deploy-envs",
                        "content": "GitHub Deployment Environments scope secrets to specific environments like development and production. Each environment in your project should have a matching GitHub environment.",
                        "expanded": "Without matching GitHub environments, you can't push environment-scoped secrets. Dev typically uses repo-level secrets, but production needs its own environment for isolation.\n\nğŸ’¡ Hit ğŸš€ Create to provision missing environments on GitHub directly from the wizard.",
                        "dynamic": true,
                        "childTemplate": {
                            "title": "{{name}}",
                            "nameSelector": "code",
                            "content": "GitHub deployment environment.",
                            "selector": "#wiz-gh-deploy-list > div",
                            "variants": [
                                {
                                    "when": {
                                        "textContains": "exists"
                                    },
                                    "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… exists</div><div class=\"state-detail\">This environment is provisioned on GitHub. You can push scoped secrets to it from the \ud83d\udd10 Secrets tab and use environment-level protection rules in GitHub Actions.</div></div>"
                                },
                                {
                                    "when": {
                                        "textContains": "not found"
                                    },
                                    "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">\u26a0\ufe0f not found</div><div class=\"state-detail\">This environment doesn\u2019t exist on GitHub yet. Hit \ud83d\ude80 Create to provision it \u2014 this is required before you can push environment-scoped secrets.\n\nWithout it, secrets sync for this environment will fail.</div></div>"
                                }
                            ]
                        },
                        "children": []
                    }
                ]
            },
            {
                "id": "enc-key-status",
                "title": "Content Encryption Key",
                "icon": "ğŸ”‘",
                "selector": "#wiz-enc-key-status",
                "separator": true,
                "content": "CONTENT_VAULT_ENC_KEY is a general-purpose encryption key stored in your .env file. It enables on-demand encryption for any git-committed item â€” you toggle it per file or message, and the key does the rest.",
                "expanded": "This key protects multiple things across the control plane:\nâ€¢ Content files â€” media, documents, assets in the content vault\nâ€¢ Chat messages â€” encrypted at rest, decrypted on read\nâ€¢ Backup archives â€” encrypted snapshots of your project\nâ€¢ New vault seeding â€” auto-injected when creating environment vaults\n\nIt's separate from the vault passphrase that locks .env files. The vault passphrase protects secrets (API keys, database URLs). This key protects everything else you choose to encrypt.",
                "variants": [
                    {
                        "when": {
                            "textContains": "configured"
                        },
                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… configured</div><div class=\"state-detail\">Your encryption key is active. You can encrypt content files, chat messages, and backup archives on demand.\n\nThis key is auto-injected into new environment vaults when you create them. As long as your .env file is backed up, anything encrypted with this key is recoverable.</div></div>"
                    },
                    {
                        "when": {
                            "textContains": "not set"
                        },
                        "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš ï¸ not set</div><div class=\"state-detail\">No encryption key configured. Without it, you can't encrypt content files, chat messages, or backup archives.\n\nEnter your own key (at least 8 characters) or hit ğŸ² Generate for a strong random one. Either way, it's stored in .env â€” keep that file safe.\n\nâš ï¸ Losing this key means losing access to everything encrypted with it. There's no recovery mechanism.\n\nIf you don't need any of these encryption features, you can safely skip this.</div></div>"
                    }
                ],
                "children": []
            },
            {
                "id": "secrets-list",
                "title": "Detected Secret Files",
                "icon": "ğŸ“„",
                "selector": "#wiz-secrets-list",
                "separator": true,
                "content": "These are secret files found in your project \u2014 .env files, encrypted vaults, and related artifacts. This is a read-only snapshot of what\u2019s on disk right now.",
                "expanded": "In multi-environment mode, .env is a live copy of the active environment \u2014 it will match one of the .env.{name} files. The other .env.{name} files hold each environment's stored secrets.\n\nFor full vault management \u2014 locking, unlocking, adding keys, pushing secrets to GitHub \u2014 use the \ud83d\udd10 Secrets tab on the dashboard after you finish the wizard.\n\n\ud83d\udca1 Encrypted files are safe to commit (they\u2019re ciphertext). Plaintext files should be locked before pushing to git.",
                "dynamic": true,
                "childTemplate": {
                    "title": "{{name}}",
                    "nameSelector": "code",
                    "content": "A secret file in your project.",
                    "selector": "#wiz-detected-files > div",
                    "variants": [
                        {
                            "when": {
                                "textContains": "= .env."
                            },
                            "content": "This is the live working copy of the active environment.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">\ud83d\udd13 Active Copy</div><div class=\"state-detail\">In multi-environment mode, .env is automatically maintained as a copy of whichever environment is currently active.\n\nWhen you switch environments from the \ud83d\udd10 Secrets tab, the control plane saves this file back and copies the new environment into its place.\n\nYou don\u2019t edit .env directly for switching \u2014 use the Activate button in the Secrets tab.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": ".env.development"
                            },
                            "content": "Development environment secrets \u2014 used for local development and testing.",
                            "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">\ud83d\udea7 Development</div><div class=\"state-detail\">This file holds secrets for your development environment \u2014 typically local databases, test API keys, and debug configurations.\n\nIts contents are separate from production. When development is active, .env is a copy of this file.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": ".env.production"
                            },
                            "content": "Production environment secrets \u2014 used for released and deployed applications.",
                            "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">\ud83d\ude80 Production</div><div class=\"state-detail\">This file holds secrets for your production environment \u2014 live database credentials, real API keys, and deployment-specific configurations.\n\nHandle with extra care. When production is active, .env is a copy of this file. We suggest locking the vault when you move away \u2014 each environment can have its own passphrase for independent protection.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "Encrypted"
                            },
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">\ud83d\udd12 Encrypted</div><div class=\"state-detail\">Contents are safe on disk \u2014 this file can be committed to git without exposing secrets. To read or edit it, unlock through the \ud83d\udd10 Secrets tab.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "Plaintext"
                            },
                            "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">\ud83d\udd13 Plaintext</div><div class=\"state-detail\">Anyone with file access can read this file\u2019s contents. Use the \ud83d\udd10 Secrets tab to lock it when you\u2019re done editing \u2014 plaintext .env files should never be committed to git.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "Missing"
                            },
                            "expanded": "<div class=\"assistant-state-card state-error\"><div class=\"state-label\">\u274c Missing</div><div class=\"state-detail\">This file is expected but not found on disk. It may have been deleted or hasn\u2019t been created yet. Use + Create in the vault section above, or the \ud83d\udd10 Secrets tab.</div></div>"
                        }
                    ]
                },
                "children": []
            }
        ]
    },
    {
        "context": "wizard/content",
        "title": "Content Folders",
        "icon": "ğŸ“",
        "content": "Choose which folders appear in the ğŸ“ Content tab â€” your workspace for browsing, previewing, encrypting, and archiving project files.\n\nBelow the folders, you'll see the infrastructure directories that the control plane manages automatically. These track your chat history, audit traces, backups, and optimized large files â€” they're created on demand as you use the system.",
        "children": [
            {
                "id": "content-list",
                "title": "Project Folders",
                "icon": "ğŸ“‚",
                "selector": "#wiz-content-list",
                "separator": true,
                "content": "Select the folders you want to manage through the Content tab. Each selected folder becomes browsable with preview, encryption, download, and archive capabilities.",
                "expanded": "This controls the default folder tabs in the Content view. You can always browse any project directory using ğŸ—‚ Explore All â€” this selection just sets the defaults.\n\nğŸ’¡ Folders marked 'suggested' match common content folder patterns (docs, media, assets, etc). You don't have to include all of them â€” pick the ones that matter to your workflow.",
                "dynamic": true,
                "childTemplate": {
                    "title": "{{name}}",
                    "nameSelector": "div > div:first-child",
                    "content": "A project directory.",
                    "selector": "#wiz-content-list > label",
                    "variants": [
                        {
                            "when": {
                                "textContains": "Active",
                                "hasSelector": "[style*='suggested']"
                            },
                            "content": "This folder is selected and was auto-suggested as a common content folder.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Active Â· suggested</div><div class=\"state-detail\">This folder is included in the ğŸ“ Content tab. It matched a common content folder pattern and was pre-suggested.\n\nYou'll get full management capabilities: browsing, preview, upload, encryption, backup archives, and large file optimization.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "Active"
                            },
                            "content": "This folder is selected for content management.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Active</div><div class=\"state-detail\">This folder will appear as a tab in the ğŸ“ Content view. You can browse, upload, encrypt, download, and archive files inside it.\n\nUncheck it if you don't need to manage these files through the Content tab directly.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "suggested"
                            },
                            "content": "This looks like a good candidate for content management â€” it matches a common content folder pattern.",
                            "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ’¡ Suggested</div><div class=\"state-detail\">This directory name matches a common content folder pattern. Check it to include it in the Content tab â€” you'll get browsing, preview, encryption, and archive capabilities.\n\nSuggested doesn't mean required. If this folder isn't relevant to your workflow, leave it unchecked.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "â€”"
                            },
                            "content": "A project directory. Check the box to include it in the Content tab.",
                            "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">Not selected</div><div class=\"state-detail\">This folder exists in your project but isn't currently managed through the Content tab.\n\nCheck it if you want to browse, upload, encrypt, or archive files in this directory. Leave it unchecked if it's source code or configuration that doesn't need content management.</div></div>"
                        }
                    ]
                },
                "children": []
            },
            {
                "id": "content-infra",
                "title": "Content Infrastructure",
                "icon": "ğŸ—ï¸",
                "selector": "#wiz-content-infra",
                "separator": true,
                "content": "These directories are created and maintained by the control plane. They're gitignored and never need manual management â€” the system handles creation, population, and cleanup.",
                "expanded": "Think of them as internal storage layers:\n\nâ€¢ .ledger â€” shares data via git branches (chat threads, traces, audits)\nâ€¢ .state â€” local caches (preferences, scores, pending audits, run history)\nâ€¢ .backup â€” compressed archive snapshots from the Content tab\nâ€¢ .large â€” optimized oversized files, uploaded to release artifacts for sharing\nâ€¢ .pages â€” generated site builds from the Pages pipeline\n\nEach one is gitignored. The 'shared' badge on .ledger means it syncs with collaborators via git push/pull â€” everything else stays local to your machine.",
                "dynamic": true,
                "childTemplate": {
                    "title": "{{name}}",
                    "nameSelector": "code",
                    "content": "An infrastructure directory managed by the control plane.",
                    "selector": "#wiz-content-infra-list > div",
                    "variants": [
                        {
                            "when": {
                                "textContains": ".ledger"
                            },
                            "content": "Git worktree for shared project data â€” chat threads, trace snapshots, and saved audit records.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ“’ Ledger</div><div class=\"state-detail\">The ledger is a separate git branch checked out as a worktree at your project root. It stores:\n\nâ€¢ Chat threads and messages (from the ğŸ’¬ Chat tab)\nâ€¢ Execution traces (from traced operations)\nâ€¢ Saved audit snapshots (promoted from pending results)\n\nBadge: 'shared' means this data syncs with your remote repository via git push/pull. Collaborators get the same history.\n\nYou never interact with .ledger directly â€” the control plane handles all reads and writes through the ledger service.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": ".state"
                            },
                            "content": "Local cache â€” preferences, audit scores, pending audits, run history, and trace recordings.",
                            "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ’¾ Local State</div><div class=\"state-detail\">Machine-local storage for ephemeral and cached data:\n\nâ€¢ devops_prefs.json â€” your dashboard preferences\nâ€¢ devops_cache.json â€” cached scan results\nâ€¢ audit_activity.json â€” audit execution log\nâ€¢ audit_scores.json â€” audit score history\nâ€¢ pending_audits.json â€” audits awaiting review\nâ€¢ runs.jsonl â€” execution run history\nâ€¢ traces/ â€” local trace recordings before sharing\n\nNone of this leaves your machine. This directory is almost certainly present by now â€” the control plane creates it the first time any feature needs local persistence.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": ".backup"
                            },
                            "content": "Backup archives created from the Content tab's Archive view.",
                            "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ—„ï¸ Backups</div><div class=\"state-detail\">Compressed archive snapshots of folders you choose to protect. Created through the Archive view in the ğŸ“ Content tab.\n\nBackup archives can exist at any level â€” the root .backup holds project-wide archives, while individual content folders can have their own .backup subdirectories.\n\nFor off-machine protection, you can upload archives to GitHub release artifacts.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": ".large"
                            },
                            "content": "Optimized large files â€” gitignored, virtual in parent, uploadable to release artifacts.",
                            "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“¦ Large Files</div><div class=\"state-detail\">When files over 2 MB are uploaded through the Content tab, they're automatically moved to a .large subdirectory. The original filename appears virtually in the parent folder â€” you browse and manage them normally.\n\n.large is gitignored, so large files don't bloat your repository. For sharing, they can be uploaded to GitHub release artifacts (â˜ï¸ icon in the Content tab).\n\nThis directory can appear at any folder level â€” not just inside configured content folders. The content browser's Explore All mode can work with .large directories anywhere in the project.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": ".pages"
                            },
                            "content": "Generated site output from the Pages pipeline.",
                            "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸŒ Pages Output</div><div class=\"state-detail\">Build output from the Pages pipeline â€” your generated Docusaurus site, static assets, and deployment artifacts.\n\nThis directory is rebuilt on each deploy. It's not something you edit directly â€” changes flow from your source content through the Pages build process.\n\nğŸ’¡ If you see this without having used Pages yet, it was likely created by a previous build or site generation run.</div></div>"
                        }
                    ]
                },
                "children": []
            }
        ]
    }
]
[
    {
        "context": "wizard/welcome",
        "title": "Welcome to the Setup Wizard",
        "icon": "ğŸ§™",
        "content": "6 steps to shape your project. Everything starts here â€” your project's identity, where it lives, and how it's organized.\n\nTake your time. Nothing is saved until you hit Finish on the last step, so feel free to explore and come back.",
        "children": [
            {
                "id": "project-name",
                "title": "Project Name",
                "icon": "âœï¸",
                "selector": "#wiz-name",
                "content": "This is your project's identity â€” the name that follows it everywhere.",
                "expanded": "It shows up in Docker image tags, CI/CD pipeline names, Helm chart metadata, generated folder structures, and every config file the control plane produces.\n\nPick something lowercase, hyphen-separated â€” like my-api or data-pipeline. Spaces and special characters can cause issues in Docker tags and file paths downstream.\n\nğŸ’¡ Changing this later is possible but ripples through generated configs. Best to get it right now.",
                "children": []
            },
            {
                "id": "description",
                "title": "Description",
                "icon": "ğŸ“",
                "selector": "#wiz-desc",
                "content": "A short summary of what this project does â€” one or two sentences is perfect.",
                "expanded": "This text appears in your README header, package metadata (package.json, pyproject.toml), GitHub repository description, and Helm chart annotations.\n\nIt's not required, but it's the kind of thing you'll appreciate having when someone new looks at the project six months from now.\n\nğŸ’¡ Write it for a colleague who's never seen this repo before.",
                "children": []
            },
            {
                "id": "repository",
                "title": "Repository",
                "icon": "ğŸ”—",
                "selector": "#wiz-repo",
                "content": "Your Git remote â€” this connects the project to its home on GitHub, GitLab, or wherever it lives.",
                "expanded": "The control plane uses this for:\nâ€¢ CI/CD webhooks â€” triggering pipelines on push\nâ€¢ GitHub integration â€” PR management, secrets sync, Actions dispatch\nâ€¢ Docker registry paths â€” deriving container image names\nâ€¢ Generated configs â€” embedding the repo URL in Helm charts, Dockerfiles, and CI workflows\n\nFormat: github.com/owner/repo (without https://). If you're using GitHub, the control plane can often auto-detect this from your local git remote.",
                "children": []
            },
            {
                "id": "domains",
                "title": "Domains",
                "icon": "ğŸ·ï¸",
                "selector": "#wiz-domains",
                "separator": true,
                "content": "Domains are logical groupings for your codebase â€” not internet domains, more like folders of purpose.",
                "expanded": "When you add modules in Step 2, each one belongs to a domain. Think of it as organizing your project by responsibility:\n\nâ€¢ library â€” shared utilities, core business logic\nâ€¢ ops â€” DevOps tooling, scripts, CI/CD configs\nâ€¢ docs â€” documentation, guides, Docusaurus sites\nâ€¢ services â€” microservices, APIs, workers\n\nYou've got {{domainCount}} so far. You can always add more later â€” this just shapes how modules are categorized in the dashboard.",
                "dynamic": true,
                "childTemplate": {
                    "title": "{{name}}",
                    "content": "One of your project domains. Modules assigned to this domain will be grouped together in the dashboard and reports.",
                    "selector": "#wiz-domains > span"
                },
                "children": [
                    {
                        "id": "add-domain",
                        "title": "Add domainâ€¦",
                        "icon": "â•",
                        "selector": "#wiz-new-domain",
                        "content": "Type a name and press Enter or click + Add.",
                        "expanded": "Good domain names are short and describe a purpose, not a technology. Think library over python, or services over backend.\n\nğŸ’¡ You don't need to plan this perfectly. Domains can be added, renamed, or reorganized anytime.",
                        "children": []
                    }
                ]
            },
            {
                "id": "environments",
                "title": "Environments",
                "icon": "ğŸ“‹",
                "selector": "#wiz-envs",
                "separator": true,
                "content": "Environments scope your secrets and deployment variables. Your project configuration, integrations, and generated files are shared across all of them â€” what changes per environment are the credentials and endpoint values.",
                "expanded": "So your DB_HOST might be localhost:5432 in development but prod-db.internal in production. Same Dockerfile, same CI pipeline, different .env file per environment.\n\nEach environment gets its own encrypted .env file managed by the Vault in Step 3. The control plane keeps them separate â€” secrets from one environment never leak into another.\n\nYou've got {{envCount}} set up. Most projects need at least development and production. Add staging or preview if your workflow needs intermediate deployment targets.",
                "dynamic": true,
                "childTemplate": {
                    "title": "{{name}}",
                    "content": "The {{name}} environment â€” one of your deployment targets. It gets its own .env file with credentials and endpoint values scoped specifically to this context.",
                    "expanded": "When you define secrets and variables in Step 3, each environment has its own set of values. So your API keys, database URLs, and feature flags can differ between environments while sharing the same project config and generated files.\n\nğŸ’¡ Click the name or description to edit. Use Ã— to remove this environment.",
                    "selector": "#wiz-envs > div"
                },
                "children": [
                    {
                        "id": "add-env-name",
                        "title": "Environment name",
                        "icon": "â•",
                        "selector": "#wiz-new-env-name",
                        "content": "Add another deployment target â€” staging, qa, preview, or whatever your workflow needs.",
                        "expanded": "Keep it lowercase, no spaces. This name becomes part of your .env file path (.env.staging), GitHub deployment environment name, and CI/CD workflow target.\n\nEach new environment gets its own secret values in Step 3.\n\nğŸ’¡ Common patterns: development + production for simple projects. Add staging for a QA gate, or preview for PR-based ephemeral environments.",
                        "children": []
                    },
                    {
                        "id": "add-env-desc",
                        "title": "Environment description",
                        "icon": "ğŸ“",
                        "selector": "#wiz-new-env-desc",
                        "content": "A human-readable label â€” helps your team know what each environment is for at a glance.",
                        "expanded": "Examples: \"Local development and testing\", \"Pre-production staging\", \"Live customer-facing\".\n\nThis shows up in the dashboard environment selector and in the Vault management view. It's optional but makes life easier when you have 3+ environments.",
                        "children": []
                    }
                ]
            }
        ]
    },
    {
        "context": "wizard/modules",
        "title": "Modules",
        "icon": "ğŸ”",
        "content": "Modules are the building blocks of your project â€” each one maps to a directory in your codebase with its own stack and purpose.\n\nThe control plane uses them to decide what to generate: Dockerfiles, CI pipelines, linting configs, audit scans, and dashboard structure all flow from what you define here.",
        "children": [
            {
                "id": "auto-detect",
                "title": "Auto-Detect",
                "icon": "ğŸ”",
                "selector": "button[onclick='wizardDetect()']",
                "content": "Scans your project root for recognizable structures â€” pyproject.toml, package.json, docker-compose.yml, Makefile, docs folders â€” and creates module entries from what it finds.",
                "expanded": "Detection looks at file signatures:\nâ€¢ pyproject.toml or setup.py â†’ python-lib or python-cli\nâ€¢ app.py / wsgi.py â†’ python-flask\nâ€¢ package.json â†’ node\nâ€¢ docker-compose.yml â†’ docker-compose\nâ€¢ .md files in a docs/ folder â†’ markdown\n\nIt also reads descriptions from package metadata when available. Detection is non-destructive â€” it won't overwrite modules you've already added manually.\n\nğŸ’¡ If your project has an unusual structure, you can always add modules manually below.",
                "children": []
            },
            {
                "id": "modules-list",
                "title": "Module List",
                "icon": "ğŸ“¦",
                "selector": "#wizard-modules-list",
                "content": "Your configured modules â€” {{moduleCount}} so far. Each one represents a directory the control plane knows about and manages.",
                "expanded": "Every module gets its own treatment in the pipeline:\nâ€¢ Python modules get linting (ruff/flake8), type checking, and test runners\nâ€¢ Flask modules get Dockerfile generation, health check endpoints, and deployment configs\nâ€¢ Node modules get npm scripts, bundler configs, and dependency audits\nâ€¢ Docker-compose modules get service orchestration and K8s migration paths\nâ€¢ Markdown modules get Docusaurus site generation and content management\n\nThe control plane uses module paths to scope operations â€” when you run audit, lint, or generate configs, it targets the right directories.",
                "dynamic": true,
                "childTemplate": {
                    "title": "{{name}}",
                    "content": "The {{name}} module â€” managed by the control plane as part of your project structure.",
                    "expanded": "This module's stack determines what the control plane generates for it: Dockerfiles, CI workflows, linting configs, and audit targets. Its domain assignment controls how it's grouped in the dashboard.\n\nğŸ’¡ Use Ã— to remove this module if it was detected incorrectly or is no longer needed.",
                    "selector": "#wizard-modules-list > div"
                },
                "children": []
            },
            {
                "id": "add-module",
                "title": "Add Module",
                "icon": "â•",
                "selector": "#wiz-add-module",
                "separator": true,
                "content": "Manually define a module the auto-detector missed, or add one for a directory you're about to create. Pick a stack from the dropdown to tell the control plane what technology this module uses.",
                "expanded": "Three fields define a module:\nâ€¢ Name â€” appears in dashboard cards, CI pipeline names, and generated configs\nâ€¢ Path â€” directory relative to project root (e.g. src/core, services/api)\nâ€¢ Stack â€” the technology stack that drives everything the control plane generates\n\nAvailable stacks (47 total):\nğŸ python Â· python-lib Â· python-cli Â· python-flask Â· python-fastapi Â· python-django\nğŸ“¦ node Â· node-express Â· node-nextjs Â· node-react Â· node-lib Â· typescript Â· typescript-lib\nğŸ¹ go Â· go-gin Â· go-fiber Â· go-cli Â· go-lib\nğŸ¦€ rust Â· rust-actix Â· rust-axum Â· rust-cli Â· rust-lib\nâš™ï¸ c Â· cpp Â· âš¡ zig Â· ğŸ swift\nâ˜• java-maven Â· java-maven-spring Â· java-gradle Â· java-gradle-spring\nğŸ”· dotnet Â· dotnet-aspnet Â· dotnet-blazor\nğŸ’ ruby Â· ruby-rails Â· ruby-sinatra Â· ğŸ’§ elixir Â· elixir-phoenix\nğŸ˜ php Â· ğŸ“¡ protobuf\nğŸ³ docker-compose Â· â˜¸ï¸ kubernetes Â· âˆ helm Â· ğŸ—ï¸ terraform\nğŸ“ markdown Â· ğŸŒ static-site\n\nFlavored stacks inherit from their base and add framework-specific capabilities. Each is defined in stacks/<name>/stack.yml.",
                "children": [
                    {
                        "id": "mod-name",
                        "title": "Module Name",
                        "icon": "âœï¸",
                        "selector": "#wiz-mod-name",
                        "content": "A short, descriptive name for this module â€” like core, api, web, or docs.",
                        "expanded": "This name appears in:\nâ€¢ Dashboard module cards\nâ€¢ CI pipeline names (e.g. lint-core, test-api)\nâ€¢ Docker image tags when applicable\nâ€¢ Generated config references\n\nKeep it lowercase, hyphen-separated. It doesn't need to match the directory name, but it helps.",
                        "children": []
                    },
                    {
                        "id": "mod-path",
                        "title": "Module Path",
                        "icon": "ğŸ“‚",
                        "selector": "#wiz-mod-path",
                        "content": "The directory path relative to your project root â€” this is where the control plane looks for source files.",
                        "expanded": "Must point to an actual directory (or one you plan to create). The control plane uses this to:\nâ€¢ Scope linting and audit operations to the right files\nâ€¢ Generate Dockerfiles with correct COPY paths\nâ€¢ Set up CI workflows that only trigger on changes in this directory\nâ€¢ Resolve dependencies between modules\n\nExamples: src/core, src/ui/web, services/auth, docs",
                        "children": []
                    },
                    {
                        "id": "mod-stack",
                        "title": "Stack",
                        "icon": "ğŸ”§",
                        "selector": "#wiz-mod-stack",
                        "content": "A stack is a technology definition â€” it tells the control plane how to detect, build, lint, test, and deploy this module. Flavored stacks inherit capabilities from their base language.",
                        "expanded": "Each stack is defined in stacks/<name>/stack.yml. Flavored stacks declare a parent and inherit detection rules, requirements, and capabilities from their base â€” then add their own.\n\nğŸ Python\nâ€¢ python â€” Generic Python project\nâ€¢ python-lib â€” Library, no entry point (domain: library)\nâ€¢ python-cli â€” Click/argparse CLI tool (+run)\nâ€¢ python-flask â€” Flask web app (+serve)\nâ€¢ python-fastapi â€” FastAPI app (+serve via uvicorn)\nâ€¢ python-django â€” Django app (+serve, migrate, shell)\n\nğŸ“¦ JavaScript / TypeScript\nâ€¢ node â€” Node.js project\nâ€¢ node-express â€” Express.js server (+serve)\nâ€¢ node-nextjs â€” Next.js app (+dev, serve, build override)\nâ€¢ node-react â€” React SPA (+dev)\nâ€¢ node-lib â€” npm library (domain: library)\nâ€¢ typescript â€” TypeScript project\nâ€¢ typescript-lib â€” TS library (domain: library)\n\nğŸ¹ Go\nâ€¢ go â€” Go project (Go modules)\nâ€¢ go-gin â€” Gin web framework (+serve)\nâ€¢ go-fiber â€” Fiber web framework (+serve)\nâ€¢ go-cli â€” CLI tool (Cobra/urfave)\nâ€¢ go-lib â€” Library (domain: library)\n\nğŸ¦€ Rust\nâ€¢ rust â€” Rust project (Cargo)\nâ€¢ rust-actix â€” Actix-web service (+serve)\nâ€¢ rust-axum â€” Axum web service (+serve)\nâ€¢ rust-cli â€” CLI tool (clap)\nâ€¢ rust-lib â€” Library crate (domain: library)\n\nâš™ï¸ Systems\nâ€¢ c â€” C project (Makefile/CMake)\nâ€¢ cpp â€” C++ project (Makefile/CMake)\nâ€¢ zig â€” Zig project\nâ€¢ swift â€” Swift project (SPM)\n\nâ˜• JVM & .NET\nâ€¢ java-maven â€” Java (Maven build)\nâ€¢ java-maven-spring â€” Spring Boot + Maven (+serve)\nâ€¢ java-gradle â€” Java/Kotlin (Gradle build)\nâ€¢ java-gradle-spring â€” Spring Boot + Gradle (+serve)\nâ€¢ dotnet â€” .NET / C#\nâ€¢ dotnet-aspnet â€” ASP.NET web app (+serve)\nâ€¢ dotnet-blazor â€” Blazor app (+serve)\n\nğŸ’ Other Languages\nâ€¢ ruby â€” Ruby (Bundler)\nâ€¢ ruby-rails â€” Rails (+serve, migrate, console)\nâ€¢ ruby-sinatra â€” Sinatra (+serve)\nâ€¢ elixir â€” Elixir (Mix)\nâ€¢ elixir-phoenix â€” Phoenix (+serve, migrate, routes)\nâ€¢ php â€” PHP (Composer)\nâ€¢ protobuf â€” Protocol Buffers / gRPC\n\nğŸ³ Infrastructure\nâ€¢ docker-compose â€” Docker Compose orchestration\nâ€¢ kubernetes â€” Kubernetes manifests\nâ€¢ helm â€” Helm charts\nâ€¢ terraform â€” Terraform infrastructure\n\nğŸ“ Content\nâ€¢ markdown â€” Documentation (Docusaurus/MkDocs)\nâ€¢ static-site â€” Static site (HTML/CSS/JS)\n\nUse \"Custom\" to type an unlisted stack name â€” you can create its YAML later.",
                        "children": []
                    }
                ]
            }
        ]
    },
    {
        "context": "wizard/secrets",
        "title": "Secrets & Encryption",
        "icon": "ğŸ”",
        "content": "This step shows the state of your project's secrets infrastructure â€” one vault per environment, your GitHub connection, and the content encryption key.\n\nUnlike Step 1, some actions here take effect immediately when you click them. The + Create and ğŸ’¾ Save buttons write to disk right away â€” they don't wait for Finish.",
        "children": [
            {
                "id": "env-vault-status",
                "title": "Environment Vault Status",
                "icon": "ğŸŒ",
                "selector": "#wiz-env-vault-list",
                "separator": true,
                "content": "Each environment you defined in Step 1 gets its own encrypted vault file. In multi-environment mode, .env is a working copy of the active environment \u2014 when you switch environments, the control plane swaps the file automatically.",
                "expanded": "The file model:\n\u2022 .env \u2014 live working copy of whichever environment is active\n\u2022 .env.{name} \u2014 stored snapshot of each environment's secrets\n\u2022 .env.active \u2014 marker file recording which environment is selected\n\nWhen you activate production, the control plane saves .env \u2192 .env.development, then copies .env.production \u2192 .env. In single-env mode, there's just .env \u2014 no swapping.\n\n\ud83d\udca1 Vault files (.env.vault) are the encrypted versions. The .gitignore excludes plaintext .env files, and encryption adds the real protection.",
                "dynamic": true,
                "childTemplate": {
                    "title": "{{name}}",
                    "nameSelector": "code",
                    "content": "Vault file for the {{name}} environment.",
                    "expanded": "Checking status\u2026",
                    "selector": "#wiz-env-vault-list > div",
                    "variants": [
                        {
                            "when": {
                                "textContains": "unlocked",
                                "hasSelector": "[data-env-active]"
                            },
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">\ud83d\udd13 unlocked \u00b7 ACTIVE</div><div class=\"state-detail\">This is the active environment \u2014 .env is a live copy of this file right now. The vault is decrypted and ready for editing.\n\nAny changes you make in the \ud83d\udd10 Secrets tab modify this environment's .env directly. Remember to lock it when you're done.\n\nSwitching to another environment will save this file and swap in the new one.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "locked",
                                "hasSelector": "[data-env-active]"
                            },
                            "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">\ud83d\udd12 locked \u00b7 ACTIVE</div><div class=\"state-detail\">This is the active environment but the vault is locked \u2014 .env is encrypted on disk.\n\nUnlock it from the \ud83d\udd10 Secrets tab to view or edit secrets. The vault passphrase decrypts it on demand.\n\nSwitching to another environment will keep this vault locked and swap in the new one.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "missing",
                                "hasSelector": "[data-env-active]"
                            },
                            "expanded": "<div class=\"assistant-state-card state-error\"><div class=\"state-label\">\ud83d\udced missing \u00b7 ACTIVE</div><div class=\"state-detail\">This is the active environment but no .env file exists yet. Hit + Create to generate one \u2014 the file is written to disk immediately.\n\nThis is normal for new setups. Once created, you can add secrets through the \ud83d\udd10 Secrets tab.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "unlocked"
                            },
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">\ud83d\udd13 unlocked</div><div class=\"state-detail\">This vault is decrypted and ready. You can view and edit secrets through the \ud83d\udd10 Secrets tab on the dashboard.\n\nRemember to lock it when you're done \u2014 plaintext .env files should never be committed to git. The .gitignore already excludes them, but encryption is the real protection.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "locked"
                            },
                            "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">\ud83d\udd12 locked</div><div class=\"state-detail\">This vault is encrypted \u2014 its contents are safe on disk. This is the expected state when you're not actively editing credentials.\n\nTo read or edit secrets, unlock it from the \ud83d\udd10 Secrets tab. The vault passphrase decrypts it on demand.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "missing"
                            },
                            "expanded": "<div class=\"assistant-state-card state-error\"><div class=\"state-label\">\ud83d\udced missing</div><div class=\"state-detail\">This vault doesn't exist yet. Hit + Create to generate it \u2014 the file is written to disk immediately with an auto-generated encryption key.\n\nThis is normal for new environments. You can add secrets afterwards through the \ud83d\udd10 Secrets tab.</div></div>"
                        }
                    ]
                },
                "children": []
            },
            {
                "id": "gh-integration",
                "title": "GitHub Integration",
                "icon": "ğŸ”—",
                "selector": "#wiz-gh-integration",
                "separator": true,
                "content": "GITHUB_REPOSITORY connects your local vault to your GitHub remote â€” it's how the control plane knows where to sync secrets and dispatch workflows.",
                "expanded": "This value stays local to your .env file. It's never pushed to GitHub secrets â€” it's the bridge between your local credentials and your remote repository.\n\nWith this set, you get secrets sync to GitHub Actions, workflow dispatch, and PR management from the dashboard.",
                "variants": [
                    {
                        "when": {
                            "textContains": "configured"
                        },
                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… configured</div><div class=\"state-detail\">Your repository is set in .env. The control plane can push secrets, dispatch workflows, and manage PRs.\n\nThis value stays local â€” it's never pushed to GitHub. It's the link between your local vault and your remote repo.</div></div>"
                    },
                    {
                        "when": {
                            "textContains": "detected"
                        },
                        "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš ï¸ detected but not saved</div><div class=\"state-detail\">Your git remote was auto-detected but isn't persisted in .env yet. Click ğŸ’¾ Save to .env to keep it â€” this takes effect immediately.\n\nWithout it saved, GitHub integration features won't know where to target on next startup.</div></div>"
                    },
                    {
                        "when": {
                            "textContains": "could not detect"
                        },
                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â“ not detected</div><div class=\"state-detail\">No git remote found. You can set GITHUB_REPOSITORY manually in your .env file as owner/repo (e.g., my-org/my-project).\n\nThis is needed for secrets sync, GitHub Actions dispatch, and PR management.</div></div>"
                    }
                ],
                "children": [
                    {
                        "id": "gh-deploy-envs",
                        "title": "Deployment Environments",
                        "icon": "ğŸŒ",
                        "selector": "#wiz-gh-deploy-envs",
                        "content": "GitHub Deployment Environments scope secrets to specific environments like development and production. Each environment in your project should have a matching GitHub environment.",
                        "expanded": "Without matching GitHub environments, you can't push environment-scoped secrets. Dev typically uses repo-level secrets, but production needs its own environment for isolation.\n\nğŸ’¡ Hit ğŸš€ Create to provision missing environments on GitHub directly from the wizard.",
                        "dynamic": true,
                        "childTemplate": {
                            "title": "{{name}}",
                            "nameSelector": "code",
                            "content": "GitHub deployment environment.",
                            "selector": "#wiz-gh-deploy-list > div",
                            "variants": [
                                {
                                    "when": {
                                        "textContains": "exists"
                                    },
                                    "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… exists</div><div class=\"state-detail\">This environment is provisioned on GitHub. You can push scoped secrets to it from the \ud83d\udd10 Secrets tab and use environment-level protection rules in GitHub Actions.</div></div>"
                                },
                                {
                                    "when": {
                                        "textContains": "not found"
                                    },
                                    "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">\u26a0\ufe0f not found</div><div class=\"state-detail\">This environment doesn\u2019t exist on GitHub yet. Hit \ud83d\ude80 Create to provision it \u2014 this is required before you can push environment-scoped secrets.\n\nWithout it, secrets sync for this environment will fail.</div></div>"
                                }
                            ]
                        },
                        "children": []
                    }
                ]
            },
            {
                "id": "enc-key-status",
                "title": "Content Encryption Key",
                "icon": "ğŸ”‘",
                "selector": "#wiz-enc-key-status",
                "separator": true,
                "content": "CONTENT_VAULT_ENC_KEY is a general-purpose encryption key stored in your .env file. It enables on-demand encryption for any git-committed item â€” you toggle it per file or message, and the key does the rest.",
                "expanded": "This key protects multiple things across the control plane:\nâ€¢ Content files â€” media, documents, assets in the content vault\nâ€¢ Chat messages â€” encrypted at rest, decrypted on read\nâ€¢ Backup archives â€” encrypted snapshots of your project\nâ€¢ New vault seeding â€” auto-injected when creating environment vaults\n\nIt's separate from the vault passphrase that locks .env files. The vault passphrase protects secrets (API keys, database URLs). This key protects everything else you choose to encrypt.",
                "variants": [
                    {
                        "when": {
                            "textContains": "configured"
                        },
                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… configured</div><div class=\"state-detail\">Your encryption key is active. You can encrypt content files, chat messages, and backup archives on demand.\n\nThis key is auto-injected into new environment vaults when you create them. As long as your .env file is backed up, anything encrypted with this key is recoverable.</div></div>"
                    },
                    {
                        "when": {
                            "textContains": "not set"
                        },
                        "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš ï¸ not set</div><div class=\"state-detail\">No encryption key configured. Without it, you can't encrypt content files, chat messages, or backup archives.\n\nEnter your own key (at least 8 characters) or hit ğŸ² Generate for a strong random one. Either way, it's stored in .env â€” keep that file safe.\n\nâš ï¸ Losing this key means losing access to everything encrypted with it. There's no recovery mechanism.\n\nIf you don't need any of these encryption features, you can safely skip this.</div></div>"
                    }
                ],
                "children": []
            },
            {
                "id": "secrets-list",
                "title": "Detected Secret Files",
                "icon": "ğŸ“„",
                "selector": "#wiz-secrets-list",
                "separator": true,
                "content": "These are secret files found in your project \u2014 .env files, encrypted vaults, and related artifacts. This is a read-only snapshot of what\u2019s on disk right now.",
                "expanded": "In multi-environment mode, .env is a live copy of the active environment \u2014 it will match one of the .env.{name} files. The other .env.{name} files hold each environment's stored secrets.\n\nFor full vault management \u2014 locking, unlocking, adding keys, pushing secrets to GitHub \u2014 use the \ud83d\udd10 Secrets tab on the dashboard after you finish the wizard.\n\n\ud83d\udca1 Encrypted files are safe to commit (they\u2019re ciphertext). Plaintext files should be locked before pushing to git.",
                "dynamic": true,
                "childTemplate": {
                    "title": "{{name}}",
                    "nameSelector": "code",
                    "content": "A secret file in your project.",
                    "selector": "#wiz-detected-files > div",
                    "variants": [
                        {
                            "when": {
                                "textContains": "= .env."
                            },
                            "content": "This is the live working copy of the active environment.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">\ud83d\udd13 Active Copy</div><div class=\"state-detail\">In multi-environment mode, .env is automatically maintained as a copy of whichever environment is currently active.\n\nWhen you switch environments from the \ud83d\udd10 Secrets tab, the control plane saves this file back and copies the new environment into its place.\n\nYou don\u2019t edit .env directly for switching \u2014 use the Activate button in the Secrets tab.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": ".env.development"
                            },
                            "content": "Development environment secrets \u2014 used for local development and testing.",
                            "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">\ud83d\udea7 Development</div><div class=\"state-detail\">This file holds secrets for your development environment \u2014 typically local databases, test API keys, and debug configurations.\n\nIts contents are separate from production. When development is active, .env is a copy of this file.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": ".env.production"
                            },
                            "content": "Production environment secrets \u2014 used for released and deployed applications.",
                            "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">\ud83d\ude80 Production</div><div class=\"state-detail\">This file holds secrets for your production environment \u2014 live database credentials, real API keys, and deployment-specific configurations.\n\nHandle with extra care. When production is active, .env is a copy of this file. We suggest locking the vault when you move away \u2014 each environment can have its own passphrase for independent protection.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "Encrypted"
                            },
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">\ud83d\udd12 Encrypted</div><div class=\"state-detail\">Contents are safe on disk \u2014 this file can be committed to git without exposing secrets. To read or edit it, unlock through the \ud83d\udd10 Secrets tab.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "Plaintext"
                            },
                            "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">\ud83d\udd13 Plaintext</div><div class=\"state-detail\">Anyone with file access can read this file\u2019s contents. Use the \ud83d\udd10 Secrets tab to lock it when you\u2019re done editing \u2014 plaintext .env files should never be committed to git.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "Missing"
                            },
                            "expanded": "<div class=\"assistant-state-card state-error\"><div class=\"state-label\">\u274c Missing</div><div class=\"state-detail\">This file is expected but not found on disk. It may have been deleted or hasn\u2019t been created yet. Use + Create in the vault section above, or the \ud83d\udd10 Secrets tab.</div></div>"
                        }
                    ]
                },
                "children": []
            }
        ]
    },
    {
        "context": "wizard/content",
        "title": "Content Folders",
        "icon": "ğŸ“",
        "content": "Choose which folders appear in the ğŸ“ Content tab â€” your workspace for browsing, previewing, encrypting, and archiving project files.\n\nBelow the folders, you'll see the infrastructure directories that the control plane manages automatically. These track your chat history, audit traces, backups, and optimized large files â€” they're created on demand as you use the system.",
        "children": [
            {
                "id": "content-list",
                "title": "Project Folders",
                "icon": "ğŸ“‚",
                "selector": "#wiz-content-list",
                "separator": true,
                "content": "Select the folders you want to manage through the Content tab. Each selected folder becomes browsable with preview, encryption, download, and archive capabilities.",
                "expanded": "This controls the default folder tabs in the Content view. You can always browse any project directory using ğŸ—‚ Explore All â€” this selection just sets the defaults.\n\nğŸ’¡ Folders marked 'suggested' match common content folder patterns (docs, media, assets, etc). You don't have to include all of them â€” pick the ones that matter to your workflow.",
                "dynamic": true,
                "childTemplate": {
                    "title": "{{name}}",
                    "nameSelector": "div > div:first-child",
                    "content": "A project directory.",
                    "selector": "#wiz-content-list > label",
                    "variants": [
                        {
                            "when": {
                                "textContains": "Active",
                                "hasSelector": "[style*='suggested']"
                            },
                            "content": "This folder is selected and was auto-suggested as a common content folder.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Active Â· suggested</div><div class=\"state-detail\">This folder is included in the ğŸ“ Content tab. It matched a common content folder pattern and was pre-suggested.\n\nYou'll get full management capabilities: browsing, preview, upload, encryption, backup archives, and large file optimization.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "Active"
                            },
                            "content": "This folder is selected for content management.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Active</div><div class=\"state-detail\">This folder will appear as a tab in the ğŸ“ Content view. You can browse, upload, encrypt, download, and archive files inside it.\n\nUncheck it if you don't need to manage these files through the Content tab directly.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "suggested"
                            },
                            "content": "This looks like a good candidate for content management â€” it matches a common content folder pattern.",
                            "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ’¡ Suggested</div><div class=\"state-detail\">This directory name matches a common content folder pattern. Check it to include it in the Content tab â€” you'll get browsing, preview, encryption, and archive capabilities.\n\nSuggested doesn't mean required. If this folder isn't relevant to your workflow, leave it unchecked.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "â€”"
                            },
                            "content": "A project directory. Check the box to include it in the Content tab.",
                            "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">Not selected</div><div class=\"state-detail\">This folder exists in your project but isn't currently managed through the Content tab.\n\nCheck it if you want to browse, upload, encrypt, or archive files in this directory. Leave it unchecked if it's source code or configuration that doesn't need content management.</div></div>"
                        }
                    ]
                },
                "children": []
            },
            {
                "id": "content-infra",
                "title": "Content Infrastructure",
                "icon": "ğŸ—ï¸",
                "selector": "#wiz-content-infra",
                "separator": true,
                "content": "These directories are created and maintained by the control plane. They're gitignored and never need manual management â€” the system handles creation, population, and cleanup.",
                "expanded": "Think of them as internal storage layers:\n\nâ€¢ .ledger â€” shares data via git branches (chat threads, traces, audits)\nâ€¢ .state â€” local caches (preferences, scores, pending audits, run history)\nâ€¢ .backup â€” compressed archive snapshots from the Content tab\nâ€¢ .large â€” optimized oversized files, uploaded to release artifacts for sharing\nâ€¢ .pages â€” generated site builds from the Pages pipeline\n\nEach one is gitignored. The 'shared' badge on .ledger means it syncs with collaborators via git push/pull â€” everything else stays local to your machine.",
                "dynamic": true,
                "childTemplate": {
                    "title": "{{name}}",
                    "nameSelector": "code",
                    "content": "An infrastructure directory managed by the control plane.",
                    "selector": "#wiz-content-infra-list > div",
                    "variants": [
                        {
                            "when": {
                                "textContains": ".ledger"
                            },
                            "content": "Git worktree for shared project data â€” chat threads, trace snapshots, and saved audit records.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">ğŸ“’ Ledger</div><div class=\"state-detail\">The ledger is a separate git branch checked out as a worktree at your project root. It stores:\n\nâ€¢ Chat threads and messages (from the ğŸ’¬ Chat tab)\nâ€¢ Execution traces (from traced operations)\nâ€¢ Saved audit snapshots (promoted from pending results)\n\nBadge: 'shared' means this data syncs with your remote repository via git push/pull. Collaborators get the same history.\n\nYou never interact with .ledger directly â€” the control plane handles all reads and writes through the ledger service.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": ".state"
                            },
                            "content": "Local cache â€” preferences, audit scores, pending audits, run history, and trace recordings.",
                            "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ’¾ Local State</div><div class=\"state-detail\">Machine-local storage for ephemeral and cached data:\n\nâ€¢ devops_prefs.json â€” your dashboard preferences\nâ€¢ devops_cache.json â€” cached scan results\nâ€¢ audit_activity.json â€” audit execution log\nâ€¢ audit_scores.json â€” audit score history\nâ€¢ pending_audits.json â€” audits awaiting review\nâ€¢ runs.jsonl â€” execution run history\nâ€¢ traces/ â€” local trace recordings before sharing\n\nNone of this leaves your machine. This directory is almost certainly present by now â€” the control plane creates it the first time any feature needs local persistence.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": ".backup"
                            },
                            "content": "Backup archives created from the Content tab's Archive view.",
                            "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ—„ï¸ Backups</div><div class=\"state-detail\">Compressed archive snapshots of folders you choose to protect. Created through the Archive view in the ğŸ“ Content tab.\n\nBackup archives can exist at any level â€” the root .backup holds project-wide archives, while individual content folders can have their own .backup subdirectories.\n\nFor off-machine protection, you can upload archives to GitHub release artifacts.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": ".large"
                            },
                            "content": "Optimized large files â€” gitignored, virtual in parent, uploadable to release artifacts.",
                            "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“¦ Large Files</div><div class=\"state-detail\">When files over 2 MB are uploaded through the Content tab, they're automatically moved to a .large subdirectory. The original filename appears virtually in the parent folder â€” you browse and manage them normally.\n\n.large is gitignored, so large files don't bloat your repository. For sharing, they can be uploaded to GitHub release artifacts (â˜ï¸ icon in the Content tab).\n\nThis directory can appear at any folder level â€” not just inside configured content folders. The content browser's Explore All mode can work with .large directories anywhere in the project.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": ".pages"
                            },
                            "content": "Generated site output from the Pages pipeline.",
                            "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸŒ Pages Output</div><div class=\"state-detail\">Build output from the Pages pipeline â€” your generated Docusaurus site, static assets, and deployment artifacts.\n\nThis directory is rebuilt on each deploy. It's not something you edit directly â€” changes flow from your source content through the Pages build process.\n\nğŸ’¡ If you see this without having used Pages yet, it was likely created by a previous build or site generation run.</div></div>"
                        }
                    ]
                },
                "children": []
            }
        ]
    },
    {
        "context": "wizard/integrations",
        "title": "Integrations & DevOps",
        "icon": "ğŸ”Œ",
        "content": "This step detects your environment and lets you choose which integrations are active. {{toolsInstalled}} of {{toolsTotal}} tools are available, {{filesDetected}} project files detected, and {{integrationCount}} integration cards are ready to configure.\n\nEach integration you enable here becomes a card on the dashboard â€” giving you one-click access to its setup, status, and operations.",
        "children": [
            {
                "id": "scan-bar",
                "title": "Scan Status",
                "icon": "ğŸ”",
                "selector": "#wiz-int-scan-bar",
                "content": "The control plane scans your project root and system PATH to detect available tools, project files, and integration readiness.",
                "expanded": "Results are cached in-memory and in your browser's session storage so you don't wait on every step change. The age shown is how long ago the last scan completed.\n\nHit ğŸ”„ Re-scan to force a fresh detection â€” useful after installing a tool or adding a Dockerfile.",
                "variants": [
                    {
                        "when": {
                            "textContains": "rescan recommended"
                        },
                        "content": "Files on disk have changed since the last scan â€” the detection results may be stale.",
                        "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš¡ Stale</div><div class=\"state-detail\">The staleness watcher detected file changes in your project since the last scan. This means new or modified Dockerfiles, manifests, config files, or tool installations may not be reflected in the current detection.\n\nHit ğŸ”„ Re-scan to refresh. The scan is fast (< 2 seconds) and updates everything: tool availability, file detection, stack defaults, and integration status.</div></div>"
                    },
                    {
                        "when": {
                            "textContains": "fresh"
                        },
                        "content": "The scan is recent and up to date â€” detection results reflect the current state of your project.",
                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ“ Fresh</div><div class=\"state-detail\">Scan completed less than 30 seconds ago. All tool checks, file detection, and integration status reflect the current state of your project.\n\nYou can still force a re-scan anytime if you've made changes since landing on this step.</div></div>"
                    }
                ],
                "children": []
            },
            {
                "id": "system-tools",
                "title": "System Tools",
                "icon": "ğŸ”§",
                "selector": "#wiz-int-tools-section",
                "content": "{{toolsInstalled}} of {{toolsTotal}} development tools are available on your system. These are the CLI binaries the control plane calls to perform real work â€” building images, running tests, scanning for vulnerabilities, deploying to clusters.",
                "expanded": "Tools marked âœ— are missing from your PATH. You can install them directly from here â€” pip-based tools install into your current virtualenv, while system tools need sudo.\n\nEvery tool here maps to a specific pipeline in the control plane. Missing tools don't block setup, but they'll limit what the corresponding integration cards can do.",
                "dynamic": true,
                "childTemplate": {
                    "selector": "[id^='wiz-int-tool-']",
                    "nameSelector": "code",
                    "title": "{{name}}",
                    "content": "Development tool used by the control plane.",
                    "variants": [
                        {
                            "when": {
                                "textContains": "âœ“ git"
                            },
                            "title": "git âœ“",
                            "icon": "âœ…",
                            "content": "Version control â€” the foundation everything else depends on.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Installed</div><div class=\"state-detail\">Git is the bedrock of the control plane. Every integration below â€” GitHub, CI/CD, Docker, K8s â€” assumes a git repository exists.\n\nThe control plane uses git for: commit tracking, remote detection, branch awareness, .gitignore analysis, and the entire sync pipeline that pushes secrets and configs to GitHub.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "git"
                            },
                            "content": "Version control â€” the foundation everything else depends on.",
                            "expanded": "<div class=\"assistant-state-card state-error\"><div class=\"state-label\">âŒ Missing â€” Critical</div><div class=\"state-detail\">Git is not installed. This blocks nearly every integration â€” GitHub, CI/CD, Docker builds, and K8s deployments all assume a git repository.\n\nInstall it now. Without git, the control plane cannot detect your project structure or sync configurations.\n\nğŸ“¦ Installs via: sudo apt-get install git</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "âœ“ gh"
                            },
                            "title": "gh âœ“",
                            "icon": "âœ…",
                            "content": "GitHub CLI â€” manages PRs, secrets, Actions, and environments from the terminal.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Installed</div><div class=\"state-detail\">The GitHub CLI is how the control plane interacts with your GitHub repository without needing API tokens or REST calls.\n\nUsed for: pushing secrets (gh secret set), syncing variables (gh variable set), dispatching workflows, creating deployment environments, and managing pull requests â€” all from the dashboard.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "gh"
                            },
                            "content": "GitHub CLI â€” manages PRs, secrets, Actions, and environments from the terminal.",
                            "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš  Missing</div><div class=\"state-detail\">Without the GitHub CLI, you can't sync secrets to GitHub, dispatch workflows, or manage deployment environments from the control plane.\n\nThe control plane exclusively uses `gh` for all GitHub operations â€” no raw REST API calls. Install it to unlock the full GitHub integration.\n\nğŸ“¦ Installs via: sudo snap install gh</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "âœ“ docker-compose"
                            },
                            "title": "docker-compose âœ“",
                            "icon": "âœ…",
                            "content": "Multi-service orchestration â€” manages docker-compose.yml stacks.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Installed</div><div class=\"state-detail\">Docker Compose is available. The control plane uses it to parse your compose files, enumerate services, manage stack lifecycle (up/down/restart), and generate compose configurations with detected stack defaults.\n\nYour compose services will appear in the Docker integration card with per-service controls.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "docker-compose"
                            },
                            "content": "Multi-service orchestration â€” manages docker-compose.yml stacks.",
                            "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš  Missing</div><div class=\"state-detail\">Docker Compose orchestrates multi-container applications from a single YAML file. Without it, the control plane can't manage your compose stacks, start/stop services, or generate compose configurations.\n\nIf you only run single containers, this is optional. For multi-service setups (API + database + cache), it's essential.\n\nğŸ“¦ Installs via: sudo apt-get install docker-compose-v2</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "âœ“ docker"
                            },
                            "title": "docker âœ“",
                            "icon": "âœ…",
                            "content": "Container runtime â€” builds images, runs containers, talks to the Docker daemon.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Installed</div><div class=\"state-detail\">Docker is available. The control plane uses it for: building container images from your Dockerfile, running docker compose stacks, inspecting the daemon for running containers, and producing deployment artifacts.\n\nThe Docker integration card on the dashboard gives you image management, compose orchestration, and Dockerfile generation â€” all powered by this binary.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "docker"
                            },
                            "content": "Container runtime â€” builds images, runs containers, talks to the Docker daemon.",
                            "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš  Missing</div><div class=\"state-detail\">Docker is not installed. Without it, the control plane can't build container images, run compose stacks, or produce deployment artifacts.\n\nThe Docker integration card will still appear but will be limited to configuration â€” no builds or daemon interaction until Docker is available.\n\nğŸ“¦ Installs via: sudo apt-get install docker.io</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "âœ“ kubectl"
                            },
                            "title": "kubectl âœ“",
                            "icon": "âœ…",
                            "content": "Kubernetes CLI â€” talks to clusters, applies manifests, inspects workloads.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Installed</div><div class=\"state-detail\">kubectl is available and the control plane can interact with Kubernetes clusters. Used for: applying manifests, inspecting pods/services/deployments, checking cluster connectivity, and the K8s manifest wizard.\n\nThe Kubernetes integration card uses kubectl for all cluster operations. Make sure your kubeconfig points to the right cluster.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "kubectl"
                            },
                            "content": "Kubernetes CLI â€” talks to clusters, applies manifests, inspects workloads.",
                            "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš  Missing</div><div class=\"state-detail\">Without kubectl, the control plane can't communicate with Kubernetes clusters. The K8s integration card will be limited to manifest generation â€” no live cluster operations.\n\nIf you're not deploying to Kubernetes, this is safe to skip.\n\nğŸ“¦ Installs via: sudo snap install kubectl --classic</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "âœ“ terraform"
                            },
                            "title": "terraform âœ“",
                            "icon": "âœ…",
                            "content": "Infrastructure as Code â€” provisions cloud resources from declarative configs.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Installed</div><div class=\"state-detail\">Terraform is available. The control plane uses it for: scaffolding provider configurations, generating backend state configs, planning infrastructure changes, and integrating with the Terraform card on the dashboard.\n\nThe Terraform integration detects your providers, backend, and existing state to give you a clear picture of your infrastructure posture.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "terraform"
                            },
                            "content": "Infrastructure as Code â€” provisions cloud resources from declarative configs.",
                            "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš  Missing</div><div class=\"state-detail\">Without Terraform, the control plane can't scaffold IaC configs or inspect your infrastructure state. The Terraform card will be hidden by default unless you have a terraform/ directory.\n\nIf you manage infrastructure through other means (CloudFormation, Pulumi, manual), this is safe to skip.\n\nğŸ“¦ Installs via: sudo snap install terraform --classic</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "âœ“ helm"
                            },
                            "title": "helm âœ“",
                            "icon": "âœ…",
                            "content": "Kubernetes package manager â€” manages charts, releases, and values files.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Installed</div><div class=\"state-detail\">Helm is available. The control plane uses it alongside kubectl for: listing releases, inspecting chart values, and generating Helm-based deployment configurations in the K8s manifest wizard.\n\nHelm charts provide a higher-level abstraction over raw K8s manifests â€” especially useful for complex applications with many resources.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "helm"
                            },
                            "content": "Kubernetes package manager â€” manages charts, releases, and values files.",
                            "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš  Missing</div><div class=\"state-detail\">Without Helm, the control plane can still work with raw K8s manifests via kubectl. Helm adds chart management and release tracking on top.\n\nIf you deploy with raw YAML manifests, Helm is optional. If your project uses Helm charts, install it.\n\nğŸ“¦ Installs via: curl script (sudo required)</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "âœ“ node"
                            },
                            "title": "node âœ“",
                            "icon": "âœ…",
                            "content": "Node.js runtime â€” required for npm, npx, and JavaScript-based tooling.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Installed</div><div class=\"state-detail\">Node.js is available. The control plane uses it indirectly through npm/npx for: JavaScript linting (ESLint), formatting (Prettier), and the Pages pipeline (Docusaurus builds).\n\nIf your project includes JavaScript or TypeScript modules, Node.js enables their full toolchain integration.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "node"
                            },
                            "content": "Node.js runtime â€” required for npm, npx, and JavaScript-based tooling.",
                            "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš  Missing</div><div class=\"state-detail\">Without Node.js, JavaScript-based tools (ESLint, Prettier) and the Pages pipeline (Docusaurus) won't work. If your project is pure Python/Go/Rust, this is safe to skip.\n\nğŸ“¦ Installs via: sudo snap install node --classic</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "âœ“ npm"
                            },
                            "title": "npm âœ“",
                            "icon": "âœ…",
                            "content": "Node package manager â€” installs JS dependencies and runs scripts.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Installed</div><div class=\"state-detail\">npm is available. Used by the control plane for: installing global tools (ESLint, Prettier), managing package.json dependencies, and running build scripts in JS/TS modules.\n\nThe Packages integration card uses npm for dependency auditing in Node.js projects.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "npm"
                            },
                            "content": "Node package manager â€” installs JS dependencies and runs scripts.",
                            "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš  Missing</div><div class=\"state-detail\">Without npm, JavaScript tooling can't be installed and package.json projects can't be managed. Usually installed alongside Node.js.\n\nğŸ“¦ Installs via: sudo apt-get install npm</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "âœ“ ruff"
                            },
                            "title": "ruff âœ“",
                            "icon": "âœ…",
                            "content": "Python linter and formatter â€” fast, Rust-powered, replaces flake8 + isort + black.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Installed</div><div class=\"state-detail\">Ruff is available. The control plane uses it in the Quality pipeline and audit scoring â€” it checks Python code for style violations, import ordering, and common mistakes.\n\nRuff is an order of magnitude faster than traditional Python linters. Its results feed into the ğŸ”§ Code Quality card on the dashboard.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "ruff"
                            },
                            "content": "Python linter and formatter â€” fast, Rust-powered, replaces flake8 + isort + black.",
                            "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš  Missing</div><div class=\"state-detail\">Without Ruff, the Code Quality card can't run lint checks on Python code. The audit scoring system treats this as a gap in your quality posture.\n\nIt's a pip install â€” no sudo needed, installs into your current virtualenv.\n\nğŸ“¦ Installs via: pip install ruff</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "âœ“ mypy"
                            },
                            "title": "mypy âœ“",
                            "icon": "âœ…",
                            "content": "Python static type checker â€” catches type errors before runtime.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Installed</div><div class=\"state-detail\">mypy is available. The control plane uses it in the Quality pipeline to verify type annotations across your Python codebase.\n\nType checking results feed into audit scoring. Projects with strict typing enabled score higher on the quality dimension.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "mypy"
                            },
                            "content": "Python static type checker â€” catches type errors before runtime.",
                            "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš  Missing</div><div class=\"state-detail\">Without mypy, the Quality pipeline skips type checking. If your Python code uses type annotations, installing mypy will improve your audit quality score.\n\nğŸ“¦ Installs via: pip install mypy</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "âœ“ pytest"
                            },
                            "title": "pytest âœ“",
                            "icon": "âœ…",
                            "content": "Python test runner â€” discovers and executes test suites.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Installed</div><div class=\"state-detail\">pytest is available. The control plane uses it in the Testing pipeline â€” running your test suite, collecting coverage data, and feeding results into the ğŸ§ª Testing card.\n\nTest results are a core input to audit scoring. Projects with passing tests and good coverage score significantly higher.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "pytest"
                            },
                            "content": "Python test runner â€” discovers and executes test suites.",
                            "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš  Missing</div><div class=\"state-detail\">Without pytest, the Testing card can't run your test suite or collect coverage. The audit scoring system will flag the testing dimension as uncovered.\n\nğŸ“¦ Installs via: pip install pytest</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "âœ“ pip-audit"
                            },
                            "title": "pip-audit âœ“",
                            "icon": "âœ…",
                            "content": "Python vulnerability scanner â€” checks installed packages against the PyPI advisory database.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Installed</div><div class=\"state-detail\">pip-audit is available. The control plane uses it in the Security pipeline to scan your Python dependencies for known CVEs.\n\nResults feed into the ğŸ” Security Posture card. It cross-references your installed packages against the PyPI advisory database and OSV.dev.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "pip-audit"
                            },
                            "content": "Python vulnerability scanner â€” checks installed packages against the PyPI advisory database.",
                            "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš  Missing</div><div class=\"state-detail\">Without pip-audit, the Security card can't check your Python dependencies for known vulnerabilities. This is one of the three security scanners the control plane uses.\n\nğŸ“¦ Installs via: pip install pip-audit</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "âœ“ bandit"
                            },
                            "title": "bandit âœ“",
                            "icon": "âœ…",
                            "content": "Python security linter â€” scans source code AST for common vulnerability patterns.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Installed</div><div class=\"state-detail\">Bandit is available. The control plane uses it in the Security pipeline to perform static analysis on your Python source code â€” looking for hardcoded passwords, insecure function calls, SQL injection patterns, and similar issues.\n\nUnlike pip-audit (which checks dependencies), Bandit scans your own code.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "bandit"
                            },
                            "content": "Python security linter â€” scans source code AST for common vulnerability patterns.",
                            "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš  Missing</div><div class=\"state-detail\">Without Bandit, the Security card can't scan your Python source code for vulnerability patterns. It complements pip-audit (which checks dependencies) by inspecting your actual code.\n\nğŸ“¦ Installs via: pip install bandit</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "âœ“ safety"
                            },
                            "title": "safety âœ“",
                            "icon": "âœ…",
                            "content": "Python dependency checker â€” cross-references packages against a known vulnerability database.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Installed</div><div class=\"state-detail\">Safety is available. It provides a second opinion to pip-audit by checking your Python dependencies against its own vulnerability database.\n\nThe control plane runs both pip-audit and Safety for comprehensive coverage â€” they use different data sources and catch different issues.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "safety"
                            },
                            "content": "Python dependency checker â€” cross-references packages against a known vulnerability database.",
                            "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš  Missing</div><div class=\"state-detail\">Without Safety, you lose one of the two dependency vulnerability scanners. pip-audit and Safety complement each other â€” they use different databases and catch different CVEs.\n\nğŸ“¦ Installs via: pip install safety</div></div>"
                        }
                    ]
                },
                "children": []
            },
            {
                "id": "file-detection",
                "title": "File Detection",
                "icon": "ğŸ“‹",
                "selector": "#wiz-int-files-section",
                "content": "{{filesDetected}} of {{filesTotal}} project files detected. These are the files and directories the control plane looks for to determine which integrations are relevant to your project.",
                "expanded": "Each pill represents a specific file or directory. Found files (â—) activate their corresponding integration by default â€” for example, a Dockerfile enables the Docker card, and a k8s/ directory enables Kubernetes.\n\nMissing files (â—‹) don't block anything â€” you can still enable integrations manually and the control plane will generate the missing files for you during setup.",
                "dynamic": true,
                "childTemplate": {
                    "selector": "#wiz-int-files-section > span",
                    "title": "{{name}}",
                    "content": "Project file or directory used for integration detection.",
                    "variants": [
                        {
                            "when": {
                                "textContains": "â— git repo"
                            },
                            "title": "git repo â—",
                            "content": "A .git directory exists â€” this project is under version control.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">â— Found</div><div class=\"state-detail\">The .git directory confirms this is a git repository. This is the foundation for Git, GitHub, and CI/CD integrations.\n\nThe control plane reads your remotes, branches, and commit history from this directory.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "â—‹ git repo"
                            },
                            "title": "git repo â—‹",
                            "content": "No .git directory found â€” this project is not yet under version control.",
                            "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">â—‹ Not found</div><div class=\"state-detail\">No git repository detected. Run `git init` to initialize one. Without it, the Git, GitHub, and CI/CD integrations cannot function.\n\nThe control plane will still let you configure integrations, but they won't be operational until a repository exists.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "â— dockerfile"
                            },
                            "title": "dockerfile â—",
                            "content": "A Dockerfile exists at the project root â€” Docker image builds are possible.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">â— Found</div><div class=\"state-detail\">Your project has a Dockerfile. The Docker integration card can build images, inspect layers, and integrate with your CI/CD pipeline for automated builds.\n\nThe control plane parses your Dockerfile to detect base images, exposed ports, and build stages.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "â—‹ dockerfile"
                            },
                            "title": "dockerfile â—‹",
                            "content": "No Dockerfile at the project root.",
                            "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â—‹ Not found</div><div class=\"state-detail\">No Dockerfile detected. The Docker integration can generate one for you based on your detected stack â€” including the right base image, dependencies, and port exposure.\n\nUse the âš™ï¸ Setup button on the Docker card to scaffold a Dockerfile.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "â— docker compose"
                            },
                            "title": "docker compose â—",
                            "content": "A docker-compose.yml exists â€” multi-service orchestration is configured.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">â— Found</div><div class=\"state-detail\">Your project has a compose file. The Docker integration parses it to enumerate services, detect ports, and provide per-service management from the dashboard.\n\nServices from your compose file appear in the Docker card with start/stop/restart controls.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "â—‹ docker compose"
                            },
                            "title": "docker compose â—‹",
                            "content": "No docker-compose.yml or docker-compose.yaml found.",
                            "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â—‹ Not found</div><div class=\"state-detail\">No compose file detected. If your project needs multiple services (API + database + cache), the Docker setup wizard can generate a compose file with detected stack defaults.\n\nSingle-container projects often don't need compose at all.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "â— k8s manifests"
                            },
                            "title": "k8s manifests â—",
                            "content": "A k8s/ or kubernetes/ directory exists â€” Kubernetes manifests are present.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">â— Found</div><div class=\"state-detail\">Kubernetes manifests detected. The K8s integration card can apply these to your cluster, inspect their status, and generate additional manifests through the K8s wizard.\n\nThe manifest wizard supports Deployments, Services, ConfigMaps, Secrets, PVCs, Ingress, and more.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "â—‹ k8s manifests"
                            },
                            "title": "k8s manifests â—‹",
                            "content": "No k8s/ or kubernetes/ directory found.",
                            "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â—‹ Not found</div><div class=\"state-detail\">No Kubernetes manifest directory detected. If you plan to deploy to K8s, the manifest wizard can generate a complete set of manifests based on your project's stack and requirements.\n\nEnable the Kubernetes integration to get started.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "â— terraform dir"
                            },
                            "title": "terraform dir â—",
                            "content": "A terraform/ directory or main.tf exists â€” infrastructure as code is configured.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">â— Found</div><div class=\"state-detail\">Terraform configuration detected. The Terraform integration card can inspect your providers, backend configuration, and state to give you infrastructure visibility from the dashboard.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "â—‹ terraform dir"
                            },
                            "title": "terraform dir â—‹",
                            "content": "No terraform/ directory or main.tf found.",
                            "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â—‹ Not found</div><div class=\"state-detail\">No Terraform configuration detected. The Terraform integration can scaffold a complete IaC setup â€” provider config, backend state, and resource templates â€” tailored to your cloud provider.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "â— github actions"
                            },
                            "title": "github actions â—",
                            "content": "GitHub Actions workflows exist in .github/workflows/.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">â— Found</div><div class=\"state-detail\">GitHub Actions workflows detected. The CI/CD integration card can list, enable, disable, and dispatch these workflows. It also detects which secrets and variables each workflow needs.\n\nThe control plane can generate additional workflows (cron-based pipelines, deployment workflows) through the CI/CD setup.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "â—‹ github actions"
                            },
                            "title": "github actions â—‹",
                            "content": "No .github/workflows/ directory found.",
                            "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â—‹ Not found</div><div class=\"state-detail\">No GitHub Actions workflows detected. The CI/CD integration can generate a pipeline workflow that runs your project's tests, security scans, and builds on push and on a schedule.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "â— pyproject"
                            },
                            "title": "pyproject â—",
                            "content": "pyproject.toml found â€” Python project metadata and dependencies are defined.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">â— Found</div><div class=\"state-detail\">Your project has a pyproject.toml. The control plane reads this for: dependency lists (used by security scanners), version metadata, build configuration, and tool settings (ruff, mypy, pytest).\n\nThis is the modern standard for Python project configuration.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "â—‹ pyproject"
                            },
                            "title": "pyproject â—‹",
                            "content": "No pyproject.toml found.",
                            "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â—‹ Not found</div><div class=\"state-detail\">No pyproject.toml detected. If this is a Python project, the control plane uses it for dependency scanning, tool configuration, and build metadata. Without it, setup.py or requirements.txt are used as fallbacks.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "â— package json"
                            },
                            "title": "package json â—",
                            "content": "package.json found â€” Node.js project metadata and dependencies are defined.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">â— Found</div><div class=\"state-detail\">Your project has a package.json. The control plane reads this for: dependency lists (npm audit), scripts, version metadata, and detected stack classification.\n\nThe Packages card uses this for npm dependency management and vulnerability scanning.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "â—‹ package json"
                            },
                            "title": "package json â—‹",
                            "content": "No package.json found.",
                            "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â—‹ Not found</div><div class=\"state-detail\">No package.json detected. If this isn't a Node.js project, this is expected and safe to ignore.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "â— pages config"
                            },
                            "title": "pages config â—",
                            "content": "project.yml found â€” Pages pipeline configuration is available.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">â— Found</div><div class=\"state-detail\">project.yml is present. The Pages integration uses it for site generation settings â€” docs source directories, Docusaurus configuration, and deployment targets.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "â—‹ pages config"
                            },
                            "title": "pages config â—‹",
                            "content": "No project.yml found.",
                            "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â—‹ Not found</div><div class=\"state-detail\">No project.yml detected. This file is generated by the Setup Wizard when you finish â€” it contains all your project configuration including module definitions, environment settings, and integration preferences.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "â— dns dir"
                            },
                            "title": "dns dir â—",
                            "content": "A dns/ directory exists â€” DNS configuration files are present.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">â— Found</div><div class=\"state-detail\">DNS configuration directory detected. The DNS & CDN integration card reads zone files and record definitions from this directory for domain management.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "â—‹ dns dir"
                            },
                            "title": "dns dir â—‹",
                            "content": "No dns/ directory found.",
                            "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â—‹ Not found</div><div class=\"state-detail\">No DNS directory detected. The DNS integration can generate one with record templates for your domains when you set it up.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "â— cdn dir"
                            },
                            "title": "cdn dir â—",
                            "content": "A cdn/ directory exists â€” CDN configuration is present.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">â— Found</div><div class=\"state-detail\">CDN configuration directory detected. The DNS & CDN integration uses this for edge caching rules, origin settings, and CDN deployment configuration.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "â—‹ cdn dir"
                            },
                            "title": "cdn dir â—‹",
                            "content": "No cdn/ directory found.",
                            "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â—‹ Not found</div><div class=\"state-detail\">No CDN directory detected. If you need CDN configuration for your static sites or APIs, the DNS & CDN integration can scaffold one during setup.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "â— cname file"
                            },
                            "title": "cname file â—",
                            "content": "A CNAME file exists â€” custom domain for GitHub Pages is configured.",
                            "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">â— Found</div><div class=\"state-detail\">A CNAME file is present, pointing your GitHub Pages site to a custom domain. The Pages integration uses this for deployment URL resolution and DNS record validation.</div></div>"
                        },
                        {
                            "when": {
                                "textContains": "â—‹ cname file"
                            },
                            "title": "cname file â—‹",
                            "content": "No CNAME file found.",
                            "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â—‹ Not found</div><div class=\"state-detail\">No CNAME file detected. Without it, GitHub Pages uses the default github.io subdomain. If you want a custom domain, the Pages setup can create this file for you.</div></div>"
                        }
                    ]
                },
                "children": []
            },
            {
                "id": "integrations-section",
                "title": "Integrations",
                "icon": "ğŸ”Œ",
                "selector": "#wiz-int-section-integrations",
                "separator": true,
                "content": "These three integrations form the project's collaboration backbone â€” version control, remote hosting, and static site deployment.",
                "expanded": "Git, GitHub, and Pages work as a chain: Git provides the repository, GitHub connects it to a remote with CI/CD and secrets management, and Pages deploys your documentation or static site through that remote.\n\nEach card shows its current status and readiness. Enable or disable cards with the checkbox â€” disabled cards won't appear on the dashboard but can be re-enabled anytime.\n\nClick âš™ï¸ Setup on any card for inline configuration, or ğŸš€ Full Setup for the complete setup wizard with guided steps.",
                "children": [
                    {
                        "id": "git-card",
                        "title": "Git",
                        "icon": "ğŸ”€",
                        "selector": "#wiz-int-wrap-int-git",
                        "content": "Version control is the foundation of the control plane. Every integration â€” GitHub, CI/CD, Docker, K8s, Pages â€” depends on an initialized git repository with at least one remote.",
                        "expanded": "Git underpins the entire pipeline. The control plane uses it for commit tracking, remote detection, branch management, .gitignore analysis, and the sync pipeline that pushes secrets and configs to GitHub.\n\nThe checkbox enables or hides the Git card from the dashboard. Even disabled, git is still required by other integrations â€” GitHub reads your remotes, CI/CD triggers on push events, Docker builds embed commit SHAs in image labels, and the vault system from Step 3 relies on .gitignore to protect plaintext .env files.\n\nClick âš™ï¸ Setup to configure remotes, .gitignore, hooks, and initial commit in one pass.",
                        "variants": [
                            {
                                "when": {
                                    "textContains": "âœ… ready"
                                },
                                "content": "Your repository is initialized and connected â€” the foundation is healthy. Every downstream integration (GitHub, CI/CD, Docker, Pages) builds on this.",
                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Fully Configured</div><div class=\"state-detail\">The control plane can read your remotes, track branches, analyse .gitignore coverage, and manage commit hooks. This is the baseline that unlocks everything else.\n\nYour .gitignore protects the vault secrets from Step 3 â€” encrypted .env files, plaintext credentials, and auto-generated keys are all excluded from version control. Pre-commit hooks, if installed, enforce the lint and format tools detected in System Tools above before each commit reaches the repository.\n\nOpen âš™ï¸ Setup to fine-tune: add or remove remotes, regenerate .gitignore with stack-aware patterns, or wire pre-commit hooks into your toolchain. Use ğŸš€ Full Setup for the guided wizard with validation.</div></div>"
                            },
                            {
                                "when": {
                                    "textContains": "not configured"
                                },
                                "content": "Git is installed but this directory isn't a repository yet. Downstream integrations (GitHub, CI/CD) are blocked until you initialize one.",
                                "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš  No Repository</div><div class=\"state-detail\">The git binary is available but there's no .git/ directory in your project root. Without git init, the control plane can't detect remotes, branches, or .gitignore â€” and the GitHub and CI/CD cards below are stuck in an unconfigured state too.\n\nThis is the most actionable state â€” one setup pass fixes the entire chain. Click âš™ï¸ Setup to initialize the repository, choose a default branch, generate a stack-aware .gitignore, and optionally create an initial commit.\n\nAfter applying, hit ğŸ”„ Re-scan in the scan bar above. The GitHub card will update to reflect the new repository, CI/CD workflow generation becomes available, and the File Detection pills will show the git repo as found.</div></div>"
                            },
                            {
                                "when": {
                                    "textContains": "not installed"
                                },
                                "content": "Git is not installed on this system. This is the single most critical blocker â€” every integration depends on it, directly or transitively.",
                                "expanded": "<div class=\"assistant-state-card state-error\"><div class=\"state-label\">âŒ Critical â€” Not Installed</div><div class=\"state-detail\">Without git, the control plane cannot initialize a repository, detect project structure, sync configurations, or interact with any remote service. Every integration card below â€” GitHub, CI/CD, Docker, K8s, Terraform, Pages, DNS â€” depends on git either directly or through the repository it manages.\n\nThe vault system from Step 3 also needs a repository so that .gitignore can protect plaintext .env files from accidental commits. The chat sync feature uses git push/pull for message replication.\n\nInstall git first, then hit ğŸ”„ Re-scan in the scan bar above. All other integrations will unblock once the binary is on your PATH.\n\nğŸ“¦ Install: sudo apt-get install git</div></div>"
                            }
                        ],
                        "children": [
                            {
                                "id": "git-setup",
                                "title": "Setup Panel",
                                "icon": "âš™ï¸",
                                "selector": "#wiz-int-setup-int-git",
                                "content": "The Git setup panel configures your repository in one pass â€” initialization, remotes, .gitignore, hooks, and initial commit. Hit âœ… Apply to execute all changes in sequence.",
                                "expanded": "The status strip at the top shows what's already in place (âœ“ green) and what's missing (â—‹ gray). Each section below targets one aspect of git configuration.\n\nChanges are applied when you click âœ… Apply â€” nothing runs until then. The panel re-detects after applying, so all cards and pills update to reflect the new state.\n\nThis is the inline version. For a more guided experience with step-by-step validation, use ğŸš€ Full Setup instead.",
                                "children": [
                                    {
                                        "id": "git-status-strip",
                                        "title": "Status Strip",
                                        "icon": "ğŸ“Š",
                                        "selector": "#wiz-git-status-strip",
                                        "content": "At-a-glance health check â€” each pill tracks one aspect of your git configuration. Green (âœ“) means configured, gray (â—‹) means missing or not yet set up.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“Š Configuration Overview</div><div class=\"state-detail\">The status strip provides a quick visual summary of your repository's setup state. Each pill corresponds to a section below where you can configure the missing piece.\n\nThe strip updates after every Apply or re-scan. It reads live detection data from the backend â€” not cached state â€” so it always reflects the current reality on disk.\n\nHover any individual pill for details about that specific check and what to do if it's showing a failure state.</div></div>",
                                        "children": [
                                            {
                                                "id": "git-pill-binary",
                                                "title": "Git Binary",
                                                "icon": "ğŸ’»",
                                                "selector": "#wiz-git-pill-binary",
                                                "content": "Whether the git binary is installed and available on your system PATH.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ’» Git Installation</div><div class=\"state-detail\">This pill checks if the git executable is reachable. The version number shown is the installed version.\n\nGit is the foundation â€” every other pill, section, and the entire GitHub integration depends on it. If this shows âœ—, nothing else in this panel works.</div></div>",
                                                "variants": [
                                                    {
                                                        "when": {
                                                            "textContains": "âœ“ git"
                                                        },
                                                        "content": "Git is installed and available. The version number is detected from git --version.",
                                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Git Available</div><div class=\"state-detail\">The git binary was found on PATH and responded to version check. All git operations are unblocked.\n\nThe version shown is informational â€” the control plane works with any modern git version (2.x+).</div></div>"
                                                    },
                                                    {
                                                        "when": {
                                                            "textContains": "âœ— git"
                                                        },
                                                        "content": "Git is not installed â€” this blocks every integration in this panel.",
                                                        "expanded": "<div class=\"assistant-state-card state-error\"><div class=\"state-label\">âŒ Git Missing</div><div class=\"state-detail\">The git executable was not found on PATH. This blocks:\n\nâ€¢ Repository initialization\nâ€¢ Remote management\nâ€¢ .gitignore generation\nâ€¢ Hook installation\nâ€¢ Commit operations\nâ€¢ The entire GitHub integration\n\nInstall git first, then re-scan to refresh this panel.</div></div>"
                                                    }
                                                ],
                                                "children": []
                                            },
                                            {
                                                "id": "git-pill-repo",
                                                "title": "Repository",
                                                "icon": "ğŸ“",
                                                "selector": "#wiz-git-pill-repo",
                                                "content": "Whether a .git/ directory exists â€” indicates the project is a git repository.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“ Repository Status</div><div class=\"state-detail\">This pill checks for a .git/ directory in your project root. The branch name after the dot shows your current HEAD branch.\n\nInitialization creates the .git/ directory, which stores all version control metadata â€” commits, branches, refs, hooks, and configuration.</div></div>",
                                                "variants": [
                                                    {
                                                        "when": {
                                                            "textContains": "âœ“ repo"
                                                        },
                                                        "content": "Repository is initialized â€” the branch name shown is your current HEAD.",
                                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Repository Initialized</div><div class=\"state-detail\">A .git/ directory exists. The branch name after 'repo Â·' is your current HEAD â€” this is the active branch that commits will target.\n\nWith a repository in place, all other operations are unblocked: adding remotes, generating .gitignore, installing hooks, and making commits.</div></div>"
                                                    },
                                                    {
                                                        "when": {
                                                            "textContains": "â—‹ no repo"
                                                        },
                                                        "content": "No repository â€” git init will be run when you Apply.",
                                                        "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš  Not Initialized</div><div class=\"state-detail\">No .git/ directory found. The project is not under version control yet.\n\nWhen you hit âœ… Apply, the control plane runs git init to create the repository. The default branch name is set from the Default Branch field below.\n\nUntil initialized: no commits, no branches, no remotes, no hooks.</div></div>"
                                                    }
                                                ],
                                                "children": []
                                            },
                                            {
                                                "id": "git-pill-remotes",
                                                "title": "Remotes Count",
                                                "icon": "ğŸŒ",
                                                "selector": "#wiz-git-pill-remotes",
                                                "content": "How many remotes are configured â€” at least one (origin) is needed for push/pull and GitHub features.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸŒ Remote Count</div><div class=\"state-detail\">This pill counts all configured remotes (git remote -v). The number includes both origin and any additional remotes like upstream or deploy.\n\nThe GitHub integration reads the origin remote to determine your repository â€” no remotes means no GitHub features.</div></div>",
                                                "variants": [
                                                    {
                                                        "when": {
                                                            "textContains": "remote(s)"
                                                        },
                                                        "content": "At least one remote is configured â€” push/pull and GitHub integration are available.",
                                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Remotes Configured</div><div class=\"state-detail\">Your repository has one or more remotes. The origin remote is used by the GitHub integration to determine your repository slug for secrets sync, PR management, workflow dispatch, and Pages deployment.\n\nYou can manage remotes in the Remotes section below â€” add new ones or remove existing ones.</div></div>"
                                                    },
                                                    {
                                                        "when": {
                                                            "textContains": "â—‹ no remotes"
                                                        },
                                                        "content": "No remotes â€” push/pull and all GitHub features are blocked.",
                                                        "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš  No Remotes</div><div class=\"state-detail\">Without remotes, your repository is local-only. The control plane can't push code, sync secrets, dispatch CI/CD workflows, or deploy Pages.\n\nOpen the Remotes section below to add origin. If the GitHub CLI is authenticated, the URL may be pre-filled.</div></div>"
                                                    }
                                                ],
                                                "children": []
                                            },
                                            {
                                                "id": "git-pill-gitignore",
                                                "title": "Gitignore Status",
                                                "icon": "ğŸ“„",
                                                "selector": "#wiz-git-pill-gitignore",
                                                "content": "Whether .gitignore exists and what percentage of recommended patterns it covers.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“„ Coverage Check</div><div class=\"state-detail\">This pill shows two things: whether a .gitignore file exists, and if so, what percentage of recommended patterns (for your detected stacks) are present.\n\n100% means every recommended pattern is covered. Lower percentages mean gaps exist â€” potential for secrets or build artifacts to leak into version control.\n\nOpen the .gitignore section below for details on what's missing and to regenerate.</div></div>",
                                                "variants": [
                                                    {
                                                        "when": {
                                                            "textContains": "âœ“ .gitignore"
                                                        },
                                                        "content": "File exists â€” the percentage shows recommended pattern coverage for your stacks.",
                                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… .gitignore Present</div><div class=\"state-detail\">A .gitignore file exists in your project root. The percentage reflects how many recommended patterns for your detected stacks are included.\n\n100% means complete coverage. Below 100% means some recommended patterns are missing â€” check the .gitignore section below to see which ones and regenerate if needed.</div></div>"
                                                    },
                                                    {
                                                        "when": {
                                                            "textContains": "â—‹ no .gitignore"
                                                        },
                                                        "content": "No .gitignore file â€” secrets and build artifacts could be committed.",
                                                        "expanded": "<div class=\"assistant-state-card state-error\"><div class=\"state-label\">âŒ No .gitignore</div><div class=\"state-detail\">No .gitignore file was found. This is a security risk â€” without it, git add . would stage everything including .env files with secrets, build artifacts, and dependency directories.\n\nOpen the .gitignore section below and check 'Create .gitignore' to generate one based on your detected stacks.</div></div>"
                                                    }
                                                ],
                                                "children": []
                                            },
                                            {
                                                "id": "git-pill-hooks",
                                                "title": "Hooks Count",
                                                "icon": "ğŸª",
                                                "selector": "#wiz-git-pill-hooks",
                                                "content": "How many git hooks are installed â€” hooks automate quality checks before commits and pushes.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸª Hook Count</div><div class=\"state-detail\">This pill counts executable files in .git/hooks/ (excluding samples). Hooks are local scripts that git runs automatically at specific lifecycle events.\n\nThe most common hook is pre-commit â€” it runs checks before each commit. If the checks fail, the commit is blocked.\n\nIf lint or format tools are detected in your stack and no hooks exist, the Pre-commit Hook section below offers to install one.</div></div>",
                                                "variants": [
                                                    {
                                                        "when": {
                                                            "textContains": "hook(s)"
                                                        },
                                                        "content": "Hooks are installed â€” quality checks run automatically at git lifecycle events.",
                                                        "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Hooks Active</div><div class=\"state-detail\">One or more git hooks are installed in .git/hooks/. These run automatically â€” typically before commits â€” to enforce code quality and catch issues early.\n\nThe hooks were either installed by the control plane or manually. You can inspect them at .git/hooks/ in your project root.</div></div>"
                                                    },
                                                    {
                                                        "when": {
                                                            "textContains": "â—‹ no hooks"
                                                        },
                                                        "content": "No hooks installed â€” commits go through unchecked.",
                                                        "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš  No Hooks</div><div class=\"state-detail\">No git hooks are installed. Commits are accepted without any automated checks.\n\nIf your stack has lint or format capabilities detected (shown in System Tools), the Pre-commit Hook section below can install a hook that runs those checks before every commit.\n\nHooks are a local first line of defense â€” the CI/CD pipeline provides the team-wide enforcement layer.</div></div>"
                                                    }
                                                ],
                                                "children": []
                                            }
                                        ]
                                    },
                                    {
                                        "id": "git-remotes",
                                        "title": "Remotes",
                                        "icon": "ğŸŒ",
                                        "selector": "#wiz-git-section-remotes",
                                        "content": "Remotes connect your local repository to its hosted counterpart. Adding origin is the first step to enabling push, pull, and the entire GitHub integration chain.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸŒ Remote Configuration</div><div class=\"state-detail\">The control plane reads your remotes to detect your GitHub repository, resolve the deployment target for Pages, and configure CI/CD workflow dispatch.\n\nNaming conventions:\nâ€¢ origin â€” your primary remote, usually your own GitHub repo\nâ€¢ upstream â€” the parent repository if you're working from a fork\n\nIf the GitHub CLI is authenticated, the remote URL is pre-filled from your gh repo info. The format should be https://github.com/owner/repo.git or git@github.com:owner/repo.git for SSH.\n\nThe GitHub integration card below reads the origin remote to determine which repository to target for secrets sync, PR management, and Actions dispatch. No remote = no GitHub features.</div></div>",
                                        "variants": [
                                            {
                                                "when": {
                                                    "textContains": "no remotes"
                                                },
                                                "content": "No remotes configured â€” push, pull, and GitHub integration are blocked until you add at least origin.",
                                                "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš  No Remotes</div><div class=\"state-detail\">Without a remote, your repository is local-only. The control plane can't push code, sync secrets to GitHub, dispatch workflows, or deploy Pages.\n\nAdd origin first â€” it's the primary remote that all GitHub features target. Type the remote name and URL below, then hit ï¼‹ Add.\n\nIf the GitHub CLI detected your repository, the URL is pre-filled. Otherwise, use the format: https://github.com/your-org/your-repo.git</div></div>"
                                            }
                                        ],
                                        "children": [
                                            {
                                                "id": "git-remote-name",
                                                "title": "Remote Name",
                                                "icon": "ğŸ·ï¸",
                                                "selector": "#wiz-git-remote-name",
                                                "content": "The remote name is a local alias for the hosted repository URL. It's how git references where to push and pull.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ·ï¸ Naming Convention</div><div class=\"state-detail\">Standard names and what they mean:\n\nâ€¢ origin â€” your primary repository. This is the default target for git push and git pull. The GitHub integration reads this remote to determine your repository slug.\nâ€¢ upstream â€” the parent repository you forked from. Used for syncing changes from the original project.\nâ€¢ deploy â€” some teams use a separate remote for deployment targets.\n\nIf this is your first remote, the placeholder suggests \"origin\" â€” that's almost always the right choice. The name is local to your machine and can be changed later with git remote rename.</div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "git-remote-url",
                                                "title": "Remote URL",
                                                "icon": "ğŸ”—",
                                                "selector": "#wiz-git-remote-url",
                                                "content": "The remote URL points to your hosted repository â€” this is where git push sends your code and where GitHub integration reads your project from.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ”— URL Format</div><div class=\"state-detail\">Two formats work:\n\nâ€¢ HTTPS: https://github.com/owner/repo.git\n  â€” Works out of the box, authenticates via git credential manager or token.\n\nâ€¢ SSH: git@github.com:owner/repo.git\n  â€” Requires SSH key setup. The control plane can detect SSH auth status and prompt for passphrase unlock when needed.\n\nIf the GitHub CLI (gh) is authenticated and detected your repository, this field is pre-filled with the HTTPS URL. You can switch to SSH if your workflow prefers it.\n\nThe URL you set here becomes the target for all GitHub operations â€” secrets sync, PR management, workflow dispatch, and Pages deployment.</div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "git-add-remote",
                                                "title": "Add Remote",
                                                "icon": "ï¼‹",
                                                "selector": "#wiz-git-add-remote-btn",
                                                "content": "Adds the remote immediately â€” this runs git remote add right now, not on Apply. The page re-detects after adding so all cards update.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ï¼‹ Instant Action</div><div class=\"state-detail\">Unlike other setup options that wait for âœ… Apply, adding a remote executes immediately via the /git/remote/add API endpoint. The reason: remotes affect detection results, so re-scanning after add gives accurate status for all other cards.\n\nAfter adding, the remote appears in the list above with a âœ— remove button. The GitHub card will update on the next re-scan to reflect the new remote.\n\nIf the name field is empty, it defaults to the placeholder value (\"origin\" for the first remote, \"upstream\" for additional ones).</div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "git-remotes-list",
                                                "title": "Configured Remotes",
                                                "icon": "ğŸ“‹",
                                                "selector": "#wiz-git-remotes-list",
                                                "content": "Your configured remotes â€” each row shows the name, URL, and a remove button. Removal is immediate and triggers re-detection.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“‹ Remote Registry</div><div class=\"state-detail\">Each row in this list is a configured git remote. The name (origin, upstream) is a local alias, the URL is the hosted repository endpoint.\n\nThe âœ— button removes a remote immediately (git remote remove) â€” this is irreversible. After removal, the page re-detects so all cards and pills update. If you remove origin, the GitHub integration will lose its target repository.\n\nRemotes are stored in .git/config and are local to your machine â€” they don't affect other developers working on the same repository.</div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "git-gh-hint",
                                                "title": "GitHub CLI Hint",
                                                "icon": "ğŸ™",
                                                "selector": "#wiz-git-gh-hint",
                                                "content": "The GitHub CLI detected your repository and pre-filled the remote URL. You can change it before adding.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ™ Auto-Detection</div><div class=\"state-detail\">The GitHub CLI (gh) command was found on your system and is authenticated. It identified a repository associated with this project directory.\n\nThe pre-filled URL uses the HTTPS format by default. You can change it to SSH (git@github.com:owner/repo.git) if your workflow uses SSH authentication.\n\nThis hint only appears when gh is installed, authenticated, and successfully resolved a repository slug for the current directory.</div></div>",
                                                "children": []
                                            }
                                        ]
                                    },
                                    {
                                        "id": "git-gitignore",
                                        "title": ".gitignore",
                                        "icon": "ğŸ“„",
                                        "selector": "#wiz-git-section-gitignore",
                                        "content": "The .gitignore controls what git tracks. Proper coverage prevents secrets, build artifacts, and environment files from being committed â€” this is the first line of defense for your vault.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“„ .gitignore Coverage</div><div class=\"state-detail\">The control plane analyses your .gitignore against a catalog of expected patterns for your detected stacks. Coverage percentage reflects how many recommended patterns are present.\n\nCritical patterns (always needed):\nâ€¢ .env, .env.* â€” vault secrets from Step 3\nâ€¢ .env.vault â€” encrypted vault files (extra protection layer)\n\nStack-specific patterns are added based on your detected modules â€” the generator reads your stack definitions to determine which build artifacts, dependency directories, and compiled output directories to exclude.\n\nThe generator produces a comprehensive .gitignore in one pass. It's safe to regenerate â€” the generated file includes all your existing custom patterns.</div></div>",
                                        "variants": [
                                            {
                                                "when": {
                                                    "textContains": "100%"
                                                },
                                                "content": "Your .gitignore covers all recommended patterns for your detected stacks. Secrets, build artifacts, and environment files are protected.",
                                                "expanded": "<div class=\"assistant-state-card state-success\"><div class=\"state-label\">âœ… Full Coverage</div><div class=\"state-detail\">Every recommended pattern for your project's stacks is present in .gitignore. This means secrets from Step 3, build artifacts, and environment-specific files are all excluded from version control.\n\nYou can still open this section to regenerate if your stacks change â€” the generator always includes existing custom patterns alongside the recommended ones.</div></div>"
                                            },
                                            {
                                                "when": {
                                                    "textContains": "missing)"
                                                },
                                                "content": "No .gitignore file exists. Without it, secrets, build artifacts, and environment files could be committed to the repository.",
                                                "expanded": "<div class=\"assistant-state-card state-error\"><div class=\"state-label\">âŒ No .gitignore</div><div class=\"state-detail\">This is a security risk. Without .gitignore, git tracks everything â€” including plaintext .env files from Step 3, build artifacts, dependency directories, and IDE configuration.\n\nThe \"Create .gitignore\" checkbox generates a comprehensive file based on your detected stacks. It includes universal security patterns (blocking .env, credentials, keys) plus stack-specific patterns for build artifacts and dependency directories relevant to your stack.\n\nThis should be the first thing you fix â€” even before adding remotes. A .gitignore protects you from day one.</div></div>"
                                            },
                                            {
                                                "when": {
                                                    "textContains": "Missing"
                                                },
                                                "content": "Your .gitignore has gaps â€” some recommended patterns for your stacks are missing. Regenerating adds them without losing your custom entries.",
                                                "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš  Incomplete Coverage</div><div class=\"state-detail\">The analysis found patterns recommended for your detected stacks that aren't in your .gitignore. Missing patterns are shown as red pills â€” each represents a file type or directory that could leak into version control.\n\nCommon gaps include build output directories, dependency caches, compiled artifacts, IDE configs (.vscode/, .idea/), and OS files (.DS_Store).\n\nCheck the \"Regenerate .gitignore\" checkbox and hit âœ… Apply to fill the gaps. The generator preserves your existing custom patterns and adds the missing recommended ones on top.</div></div>"
                                            }
                                        ],
                                        "children": [
                                            {
                                                "id": "git-regen-gi",
                                                "title": "Regenerate .gitignore",
                                                "icon": "ğŸ”„",
                                                "selector": "#wiz-git-regen-gi",
                                                "content": "Regenerates your .gitignore with stack-aware patterns â€” fills gaps without removing your existing custom entries.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ”„ Stack-Aware Regeneration</div><div class=\"state-detail\">The generator reads your detected stacks (from Step 2 modules) and the security catalog to produce a comprehensive .gitignore.\n\nWhat it adds:\nâ€¢ Universal security patterns â€” .env, .env.*, credentials, private keys\nâ€¢ Stack-specific patterns â€” build artifacts, dependency directories, and compiled output relevant to your detected language and framework stacks\nâ€¢ IDE and OS patterns â€” .vscode/, .idea/, .DS_Store, Thumbs.db\n\nWhat it preserves:\nâ€¢ Any custom patterns you've added manually\nâ€¢ Comments and section headers in your existing file\n\nThis checkbox is pre-checked when the analysis detected gaps. Uncheck it if you want to manage .gitignore manually. The regeneration runs on âœ… Apply along with all other setup steps.</div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "git-create-gi",
                                                "title": "Create .gitignore",
                                                "icon": "ğŸ“",
                                                "selector": "#wiz-git-create-gi",
                                                "content": "Creates a new .gitignore from scratch â€” generated from your detected stacks with security-first defaults.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ“ New File Generation</div><div class=\"state-detail\">This creates a brand-new .gitignore file in your project root. The generated file includes:\n\n1. Security patterns (always included):\n   â€¢ .env, .env.* â€” blocks vault secrets from Step 3\n   â€¢ *.pem, *.key â€” blocks private keys and certificates\n   â€¢ .env.vault â€” blocks encrypted vault archives\n\n2. Stack patterns (based on detected modules):\n   Build artifacts, dependency directories, and compiled output specific to your detected language and framework stacks.\n\n3. Common patterns:\n   â€¢ .DS_Store, Thumbs.db â€” OS artifacts\n   â€¢ .vscode/, .idea/ â€” IDE configs\n\nThis is the single most important file to create before your first commit. Without it, git add . would stage everything â€” including secrets.</div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "git-missing-patterns",
                                                "title": "Missing Patterns",
                                                "icon": "âš ï¸",
                                                "selector": "#wiz-git-missing-patterns",
                                                "content": "Each red pill is a pattern recommended for your detected stacks that's missing from .gitignore. Check 'Regenerate' and Apply to add them all.",
                                                "expanded": "<div class=\"assistant-state-card state-warning\"><div class=\"state-label\">âš ï¸ Gap Analysis</div><div class=\"state-detail\">The control plane compares your .gitignore against a catalog of recommended patterns for each detected stack. Each red pill represents a pattern that should be present but isn't.\n\nPatterns are matched by your stack's language family and framework â€” the catalog knows which build outputs, dependency directories, and compiled artifacts each stack produces.\n\nChecking 'Regenerate .gitignore' and hitting âœ… Apply adds all missing patterns in one pass without removing your existing custom entries. Up to 5 are shown here â€” if there are more, the count is displayed.</div></div>",
                                                "children": []
                                            }
                                        ]
                                    },
                                    {
                                        "id": "git-hooks",
                                        "title": "Pre-commit Hook",
                                        "icon": "ğŸª",
                                        "selector": "#wiz-git-section-hooks",
                                        "content": "Pre-commit hooks run your lint and format tools automatically before each commit â€” catching issues before they reach the repository and enforcing code quality at the gate.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸª Automated Quality Gate</div><div class=\"state-detail\">This section appears when lint or format tools are detected in your stack but no pre-commit hook is installed yet. The hook runs automatically before every git commit â€” if the checks fail, the commit is blocked.\n\nThe commands wired into the hook come from your stack's capabilities, detected from the System Tools section above. The green pills below show which commands were detected and will be included in the hook script.\n\nThe hook is a simple shell script installed at .git/hooks/pre-commit. It runs each command in sequence and aborts the commit on any failure. This is the lightest quality gate â€” no CI required, runs locally, instant feedback.\n\nCheck the box and hit âœ… Apply to install it.</div></div>",
                                        "children": [
                                            {
                                                "id": "git-setup-hooks-check",
                                                "title": "Install Hook",
                                                "icon": "â˜‘ï¸",
                                                "selector": "#wiz-git-setup-hooks",
                                                "content": "Check this to install a pre-commit hook that runs your lint and format commands before every commit.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â˜‘ï¸ Hook Installation</div><div class=\"state-detail\">When checked, âœ… Apply creates a shell script at .git/hooks/pre-commit with the commands detected from your stack capabilities:\n\nFor each capability found in System Tools above, the hook runs the corresponding check command. If any check fails (non-zero exit), the commit is aborted and you see the error output.\n\nThe hook file is a standard git hook â€” you can edit it manually after installation. It's not versioned (lives in .git/hooks/ which is gitignored by default), so each developer needs to install it locally.\n\nFor team-wide enforcement, the CI/CD pipeline runs the same checks â€” the hook is just a fast local pre-check to catch issues before pushing.</div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "git-hook-commands",
                                                "title": "Detected Commands",
                                                "icon": "ğŸ”§",
                                                "selector": "#wiz-git-hook-commands",
                                                "content": "These are the check commands detected from your stack's capabilities. They'll be wired into the pre-commit hook script.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ”§ Stack Capabilities</div><div class=\"state-detail\">Each green pill represents a command detected from your stack definition's capabilities section. These commands are what the pre-commit hook will run before each commit.\n\nThe commands are not hardcoded â€” they come from your stack's YAML definition (discovered in Step 2). If your stack defines lint, format, or test capabilities, those commands appear here.\n\nThe hook runs each command in sequence. If any exits non-zero, the commit is blocked and the error output is shown.</div></div>",
                                                "children": [
                                                    {
                                                        "id": "git-hook-lint",
                                                        "title": "Lint Check",
                                                        "icon": "ğŸ”",
                                                        "selector": "#wiz-git-hook-lint",
                                                        "content": "The lint command from your stack's capabilities â€” runs static analysis to catch code issues before commit.",
                                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ” Static Analysis</div><div class=\"state-detail\">This is the lint command detected from your stack definition. Linting performs static analysis on your source code â€” catching bugs, style violations, and suspicious patterns without running the code.\n\nIn the pre-commit hook, this command runs in check mode (read-only). If it finds issues, the commit is blocked and you see the lint errors in your terminal.\n\nThe specific command shown here comes from your stack's 'lint' capability in its YAML definition.</div></div>",
                                                        "children": []
                                                    },
                                                    {
                                                        "id": "git-hook-format",
                                                        "title": "Format Check",
                                                        "icon": "âœ¨",
                                                        "selector": "#wiz-git-hook-format",
                                                        "content": "The format command from your stack's capabilities â€” checks code formatting consistency before commit.",
                                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">âœ¨ Formatting Verification</div><div class=\"state-detail\">This is the format command detected from your stack definition. Format checking verifies that your code follows consistent style rules â€” indentation, spacing, line length, and other formatting conventions.\n\nIn the pre-commit hook, this runs in check/verify mode â€” it reports formatting issues without modifying files. If unformatted code is found, the commit is blocked.\n\nThe specific command shown here comes from your stack's 'format' capability in its YAML definition.</div></div>",
                                                        "children": []
                                                    }
                                                ]
                                            }
                                        ]
                                    },
                                    {
                                        "id": "git-initial-commit",
                                        "title": "Initial Commit",
                                        "icon": "ğŸ’¾",
                                        "selector": "#wiz-git-section-commit",
                                        "content": "An initial commit anchors the repository â€” it's the baseline that all future changes are measured against and the first entry in your project's history.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ’¾ First Commit</div><div class=\"state-detail\">This section appears when the repository has no commits yet â€” either freshly initialized or never committed to. The initial commit typically includes your project.yml, .gitignore, and any existing source files.\n\nThe commit message defaults to \"Initial commit\" but you can customize it. The commit runs git add . followed by git commit -m after all other setup steps (remotes, .gitignore, hooks) have been applied â€” so the first commit captures a clean, properly configured state.\n\nAfter this commit, git log will show history, branch operations will work, and push to origin becomes possible.</div></div>",
                                        "children": [
                                            {
                                                "id": "git-init-commit-check",
                                                "title": "Create Commit",
                                                "icon": "â˜‘ï¸",
                                                "selector": "#wiz-git-init-commit",
                                                "content": "Check this to create an initial commit after all other setup steps complete â€” this anchors the repository with a clean starting state.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">â˜‘ï¸ Initial Commit Toggle</div><div class=\"state-detail\">When checked, âœ… Apply runs git add . followed by git commit -m with your message after completing all other steps (.gitignore generation, hook installation, branch setup).\n\nThis ordering matters: the .gitignore is created BEFORE the commit, so the first commit already respects ignore rules. Secrets and build artifacts won't be staged.\n\nThe initial commit gives you:\nâ€¢ A baseline for git diff and git log\nâ€¢ A branch HEAD that enables push to remote\nâ€¢ A commit SHA that Docker builds can embed in image labels\n\nLeave unchecked if you want to review staged files before committing manually.</div></div>",
                                                "children": []
                                            },
                                            {
                                                "id": "git-commit-msg",
                                                "title": "Commit Message",
                                                "icon": "ğŸ’¬",
                                                "selector": "#wiz-git-commit-msg",
                                                "content": "The message for your initial commit â€” defaults to 'Initial commit' but you can describe what the first snapshot contains.",
                                                "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸ’¬ First Message</div><div class=\"state-detail\">The commit message appears in git log and on GitHub's commit history. For initial commits, common patterns:\n\nâ€¢ \"Initial commit\" â€” the classic default\nâ€¢ \"Initial project setup with devops-control-plane\" â€” more descriptive\nâ€¢ \"chore: bootstrap project structure\" â€” conventional commits format\n\nThis message is passed directly to git commit -m. It only applies if the \"Create initial commit\" checkbox above is checked.\n\nAfter the initial commit, future commits should follow your team's commit message convention â€” conventional commits, gitmoji, or plain descriptive messages.</div></div>",
                                                "children": []
                                            }
                                        ]
                                    },
                                    {
                                        "id": "git-branch",
                                        "title": "Default Branch",
                                        "icon": "ğŸŒ¿",
                                        "selector": "#wiz-git-branch",
                                        "content": "The default branch is your main development line â€” it determines the target for pull requests, the base for CI/CD triggers, and the name git uses when initializing.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">ğŸŒ¿ Branch Configuration</div><div class=\"state-detail\">Most projects use \"main\" â€” GitHub has defaulted to this since 2020. Some older projects still use \"master\" and that works too.\n\nThe control plane uses this branch name in several places:\nâ€¢ CI/CD workflows trigger on push to this branch\nâ€¢ GitHub PR targets default to this branch\nâ€¢ Pages deployments reference this as the source branch\nâ€¢ The docker image tagging uses branch name as part of the version string\n\nChanging this after the initial setup is possible but requires renaming the branch (git branch -m old new) and updating any CI/CD workflow YAML that references the old name.\n\nIf you're starting fresh, stick with \"main\". If you have an existing repo, the current branch name is pre-filled.</div></div>",
                                        "children": []
                                    },
                                    {
                                        "id": "git-apply",
                                        "title": "Apply",
                                        "icon": "âœ…",
                                        "selector": "#wiz-apply-int-git",
                                        "content": "Executes all checked setup steps in sequence â€” .gitignore generation, hook installation, branch configuration, then initial commit if checked.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">âœ… Execution Order</div><div class=\"state-detail\">When you click Apply, the control plane runs each checked step in a specific order:\n\n1. git init (if no repository exists)\n2. Branch rename (if different from current)\n3. .gitignore generation or regeneration\n4. Pre-commit hook installation\n5. git add . + git commit (if initial commit is checked)\n\nThis ordering is intentional â€” .gitignore is created before the commit, so the first snapshot already excludes secrets and build artifacts.\n\nAfter all steps complete, the panel re-detects and all status pills and cards update to reflect the new state. If any step fails, the error is shown and remaining steps are skipped.</div></div>",
                                        "children": []
                                    },
                                    {
                                        "id": "git-cancel",
                                        "title": "Cancel",
                                        "icon": "âœ–",
                                        "selector": "#wiz-cancel-int-git",
                                        "content": "Closes the setup panel without applying any changes. Nothing is modified on disk.",
                                        "expanded": "<div class=\"assistant-state-card state-info\"><div class=\"state-label\">âœ– Discard Changes</div><div class=\"state-detail\">Clicking Cancel collapses the setup panel and discards any unsaved field values. No git operations are performed â€” no files are created, modified, or deleted.\n\nYou can reopen the panel at any time by clicking âš™ï¸ Setup again. Field values will be re-populated from the current detection state, not from your previous unsaved edits.</div></div>",
                                        "children": []
                                    }
                                ]
                            }
                        ]
                    }
                ]
            }
        ]
    }
]
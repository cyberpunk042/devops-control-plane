[
    {
        "context": "wizard/welcome",
        "title": "Welcome to the Setup Wizard",
        "icon": "ğŸ§™",
        "content": "6 steps to shape your project. Everything starts here â€” your project's identity, where it lives, and how it's organized.\n\nTake your time. Nothing is saved until you hit Finish on the last step, so feel free to explore and come back.",
        "children": [
            {
                "id": "project-name",
                "title": "Project Name",
                "icon": "âœï¸",
                "selector": "#wiz-name",
                "content": "This is your project's identity â€” the name that follows it everywhere.",
                "expanded": "It shows up in Docker image tags, CI/CD pipeline names, Helm chart metadata, generated folder structures, and every config file the control plane produces.\n\nPick something lowercase, hyphen-separated â€” like my-api or data-pipeline. Spaces and special characters can cause issues in Docker tags and file paths downstream.\n\nğŸ’¡ Changing this later is possible but ripples through generated configs. Best to get it right now.",
                "children": []
            },
            {
                "id": "description",
                "title": "Description",
                "icon": "ğŸ“",
                "selector": "#wiz-desc",
                "content": "A short summary of what this project does â€” one or two sentences is perfect.",
                "expanded": "This text appears in your README header, package metadata (package.json, pyproject.toml), GitHub repository description, and Helm chart annotations.\n\nIt's not required, but it's the kind of thing you'll appreciate having when someone new looks at the project six months from now.\n\nğŸ’¡ Write it for a colleague who's never seen this repo before.",
                "children": []
            },
            {
                "id": "repository",
                "title": "Repository",
                "icon": "ğŸ”—",
                "selector": "#wiz-repo",
                "content": "Your Git remote â€” this connects the project to its home on GitHub, GitLab, or wherever it lives.",
                "expanded": "The control plane uses this for:\nâ€¢ CI/CD webhooks â€” triggering pipelines on push\nâ€¢ GitHub integration â€” PR management, secrets sync, Actions dispatch\nâ€¢ Docker registry paths â€” deriving container image names\nâ€¢ Generated configs â€” embedding the repo URL in Helm charts, Dockerfiles, and CI workflows\n\nFormat: github.com/owner/repo (without https://). If you're using GitHub, the control plane can often auto-detect this from your local git remote.",
                "children": []
            },
            {
                "id": "domains",
                "title": "Domains",
                "icon": "ğŸ·ï¸",
                "selector": "#wiz-domains",
                "separator": true,
                "content": "Domains are logical groupings for your codebase â€” not internet domains, more like folders of purpose.",
                "expanded": "When you add modules in Step 2, each one belongs to a domain. Think of it as organizing your project by responsibility:\n\nâ€¢ library â€” shared utilities, core business logic\nâ€¢ ops â€” DevOps tooling, scripts, CI/CD configs\nâ€¢ docs â€” documentation, guides, Docusaurus sites\nâ€¢ services â€” microservices, APIs, workers\n\nYou've got {{domainCount}} so far. You can always add more later â€” this just shapes how modules are categorized in the dashboard.",
                "dynamic": true,
                "childTemplate": {
                    "title": "{{name}}",
                    "content": "One of your project domains. Modules assigned to this domain will be grouped together in the dashboard and reports.",
                    "selector": "#wiz-domains > span"
                },
                "children": [
                    {
                        "id": "add-domain",
                        "title": "Add domainâ€¦",
                        "icon": "â•",
                        "selector": "#wiz-new-domain",
                        "content": "Type a name and press Enter or click + Add.",
                        "expanded": "Good domain names are short and describe a purpose, not a technology. Think library over python, or services over backend.\n\nğŸ’¡ You don't need to plan this perfectly. Domains can be added, renamed, or reorganized anytime.",
                        "children": []
                    }
                ]
            },
            {
                "id": "environments",
                "title": "Environments",
                "icon": "ğŸ“‹",
                "selector": "#wiz-envs",
                "separator": true,
                "content": "Environments scope your secrets and deployment variables. Your project configuration, integrations, and generated files are shared across all of them â€” what changes per environment are the credentials and endpoint values.",
                "expanded": "So your DB_HOST might be localhost:5432 in development but prod-db.internal in production. Same Dockerfile, same CI pipeline, different .env file per environment.\n\nEach environment gets its own encrypted .env file managed by the Vault in Step 3. The control plane keeps them separate â€” secrets from one environment never leak into another.\n\nYou've got {{envCount}} set up. Most projects need at least development and production. Add staging or preview if your workflow needs intermediate deployment targets.",
                "dynamic": true,
                "childTemplate": {
                    "title": "{{name}}",
                    "content": "The {{name}} environment â€” one of your deployment targets. It gets its own .env file with credentials and endpoint values scoped specifically to this context.",
                    "expanded": "When you define secrets and variables in Step 3, each environment has its own set of values. So your API keys, database URLs, and feature flags can differ between environments while sharing the same project config and generated files.\n\nğŸ’¡ Click the name or description to edit. Use Ã— to remove this environment.",
                    "selector": "#wiz-envs > div"
                },
                "children": [
                    {
                        "id": "add-env-name",
                        "title": "Environment name",
                        "icon": "â•",
                        "selector": "#wiz-new-env-name",
                        "content": "Add another deployment target â€” staging, qa, preview, or whatever your workflow needs.",
                        "expanded": "Keep it lowercase, no spaces. This name becomes part of your .env file path (.env.staging), GitHub deployment environment name, and CI/CD workflow target.\n\nEach new environment gets its own secret values in Step 3.\n\nğŸ’¡ Common patterns: development + production for simple projects. Add staging for a QA gate, or preview for PR-based ephemeral environments.",
                        "children": []
                    },
                    {
                        "id": "add-env-desc",
                        "title": "Environment description",
                        "icon": "ğŸ“",
                        "selector": "#wiz-new-env-desc",
                        "content": "A human-readable label â€” helps your team know what each environment is for at a glance.",
                        "expanded": "Examples: \"Local development and testing\", \"Pre-production staging\", \"Live customer-facing\".\n\nThis shows up in the dashboard environment selector and in the Vault management view. It's optional but makes life easier when you have 3+ environments.",
                        "children": []
                    }
                ]
            }
        ]
    },
    {
        "context": "wizard/modules",
        "title": "Modules",
        "icon": "ğŸ”",
        "content": "Modules are the building blocks of your project â€” each one maps to a directory in your codebase with its own stack and purpose.\n\nThe control plane uses them to decide what to generate: Dockerfiles, CI pipelines, linting configs, audit scans, and dashboard structure all flow from what you define here.",
        "children": [
            {
                "id": "auto-detect",
                "title": "Auto-Detect",
                "icon": "ğŸ”",
                "selector": "button[onclick='wizardDetect()']",
                "content": "Scans your project root for recognizable structures â€” pyproject.toml, package.json, docker-compose.yml, Makefile, docs folders â€” and creates module entries from what it finds.",
                "expanded": "Detection looks at file signatures:\nâ€¢ pyproject.toml or setup.py â†’ python-lib or python-cli\nâ€¢ app.py / wsgi.py â†’ python-flask\nâ€¢ package.json â†’ node\nâ€¢ docker-compose.yml â†’ docker-compose\nâ€¢ .md files in a docs/ folder â†’ markdown\n\nIt also reads descriptions from package metadata when available. Detection is non-destructive â€” it won't overwrite modules you've already added manually.\n\nğŸ’¡ If your project has an unusual structure, you can always add modules manually below.",
                "children": []
            },
            {
                "id": "modules-list",
                "title": "Module List",
                "icon": "ğŸ“¦",
                "selector": "#wizard-modules-list",
                "content": "Your configured modules â€” {{moduleCount}} so far. Each one represents a directory the control plane knows about and manages.",
                "expanded": "Every module gets its own treatment in the pipeline:\nâ€¢ Python modules get linting (ruff/flake8), type checking, and test runners\nâ€¢ Flask modules get Dockerfile generation, health check endpoints, and deployment configs\nâ€¢ Node modules get npm scripts, bundler configs, and dependency audits\nâ€¢ Docker-compose modules get service orchestration and K8s migration paths\nâ€¢ Markdown modules get Docusaurus site generation and content management\n\nThe control plane uses module paths to scope operations â€” when you run audit, lint, or generate configs, it targets the right directories.",
                "dynamic": true,
                "childTemplate": {
                    "title": "{{name}}",
                    "content": "The {{name}} module â€” managed by the control plane as part of your project structure.",
                    "expanded": "This module's stack determines what the control plane generates for it: Dockerfiles, CI workflows, linting configs, and audit targets. Its domain assignment controls how it's grouped in the dashboard.\n\nğŸ’¡ Use Ã— to remove this module if it was detected incorrectly or is no longer needed.",
                    "selector": "#wizard-modules-list > div"
                },
                "children": []
            },
            {
                "id": "add-module",
                "title": "Add Module",
                "icon": "â•",
                "selector": "#wiz-add-module",
                "separator": true,
                "content": "Manually define a module the auto-detector missed, or add one for a directory you're about to create. Pick a stack from the dropdown to tell the control plane what technology this module uses.",
                "expanded": "Three fields define a module:\nâ€¢ Name â€” appears in dashboard cards, CI pipeline names, and generated configs\nâ€¢ Path â€” directory relative to project root (e.g. src/core, services/api)\nâ€¢ Stack â€” the technology stack that drives everything the control plane generates\n\nAvailable stacks:\nğŸ python Â· python-lib Â· python-cli Â· python-flask\nğŸ“¦ node Â· typescript\nğŸ¦€ rust Â· go Â· c Â· cpp Â· zig Â· swift\nâ˜• java-maven Â· java-gradle Â· dotnet\nğŸ’ ruby Â· elixir Â· protobuf\nğŸ³ docker-compose Â· kubernetes Â· helm Â· terraform\nğŸ“„ static-site Â· markdown\n\nEach stack is a YAML file in stacks/<name>/stack.yml that encodes detection rules, required tools, and available automations. Pick the one that matches your module's technology, or use \"Custom\" for unlisted stacks.",
                "children": [
                    {
                        "id": "mod-name",
                        "title": "Module Name",
                        "icon": "âœï¸",
                        "selector": "#wiz-mod-name",
                        "content": "A short, descriptive name for this module â€” like core, api, web, or docs.",
                        "expanded": "This name appears in:\nâ€¢ Dashboard module cards\nâ€¢ CI pipeline names (e.g. lint-core, test-api)\nâ€¢ Docker image tags when applicable\nâ€¢ Generated config references\n\nKeep it lowercase, hyphen-separated. It doesn't need to match the directory name, but it helps.",
                        "children": []
                    },
                    {
                        "id": "mod-path",
                        "title": "Module Path",
                        "icon": "ğŸ“‚",
                        "selector": "#wiz-mod-path",
                        "content": "The directory path relative to your project root â€” this is where the control plane looks for source files.",
                        "expanded": "Must point to an actual directory (or one you plan to create). The control plane uses this to:\nâ€¢ Scope linting and audit operations to the right files\nâ€¢ Generate Dockerfiles with correct COPY paths\nâ€¢ Set up CI workflows that only trigger on changes in this directory\nâ€¢ Resolve dependencies between modules\n\nExamples: src/core, src/ui/web, services/auth, docs",
                        "children": []
                    },
                    {
                        "id": "mod-stack",
                        "title": "Stack",
                        "icon": "ğŸ”§",
                        "selector": "#wiz-mod-stack",
                        "content": "A stack is a technology definition â€” it tells the control plane how to detect, build, lint, test, and deploy this module.",
                        "expanded": "Each stack is defined in stacks/<name>/stack.yml with detection rules, required tools, and capabilities.\n\nğŸ Python\nâ€¢ python â€” Python project (generic)\nâ€¢ python-lib â€” Python library (no entry point)\nâ€¢ python-cli â€” Click-based CLI tool\nâ€¢ python-flask â€” Flask web application\n\nğŸ“¦ JavaScript\nâ€¢ node â€” Node.js project\nâ€¢ typescript â€” TypeScript project\n\nğŸ¦€ Systems\nâ€¢ rust â€” Rust project (Cargo)\nâ€¢ go â€” Go project (Go modules)\nâ€¢ c â€” C project (Makefile/CMake)\nâ€¢ cpp â€” C++ project (Makefile/CMake)\nâ€¢ zig â€” Zig project\nâ€¢ swift â€” Swift project (SPM)\n\nâ˜• JVM & .NET\nâ€¢ java-maven â€” Java project (Maven)\nâ€¢ java-gradle â€” Java project (Gradle)\nâ€¢ dotnet â€” .NET project\n\nğŸ’ Other Languages\nâ€¢ ruby â€” Ruby project (Bundler)\nâ€¢ elixir â€” Elixir project (Mix)\nâ€¢ protobuf â€” Protocol Buffers\n\nğŸ³ Infrastructure\nâ€¢ docker-compose â€” Docker Compose orchestration\nâ€¢ kubernetes â€” Kubernetes manifests\nâ€¢ helm â€” Helm charts\nâ€¢ terraform â€” Terraform configs\n\nğŸ“„ Content\nâ€¢ static-site â€” Static site generator\nâ€¢ markdown â€” Documentation (Docusaurus)\n\nUse \"Custom\" if your stack isn't listed â€” you can define its YAML later.",
                        "children": []
                    }
                ]
            }
        ]
    }
]
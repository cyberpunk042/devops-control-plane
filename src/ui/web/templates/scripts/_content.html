<script>
    // â”€â”€ Content Vault tab logic â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    let contentCurrentMode = 'docs';
    let contentFolders = [];
    let contentCurrentPath = '';
    let contentLoaded = false;
    let encKeyConfigured = false;
    let _contentCategoryFilters = {};  // mode â†’ { category: bool }
    let _contentLastRenderData = null; // cached for filter re-render
    let _contentMediaShowAll = false;  // recursive media listing

    // Category â†’ mode mapping (encrypted files show in all modes)
    const CATEGORY_MODES = {
        docs: ['document', 'code', 'script', 'config', 'data', 'other', 'encrypted'],
        media: ['image', 'video', 'audio', 'encrypted'],
        archive: ['document', 'code', 'script', 'config', 'data', 'other', 'encrypted', 'image', 'video', 'audio', 'archive'],
    };

    const CATEGORY_ICONS = {
        image: 'ğŸ–¼ï¸',
        video: 'ğŸ¬',
        audio: 'ğŸµ',
        document: 'ğŸ“„',
        code: 'ğŸ’»',
        script: 'âš¡',
        config: 'âš™ï¸',
        data: 'ğŸ“Š',
        archive: 'ğŸ“¦',
        encrypted: 'ğŸ”',
        other: 'ğŸ“',
    };

    const CATEGORY_COLORS = {
        image: '#4ade80',
        video: '#818cf8',
        audio: '#f472b6',
        document: '#60a5fa',
        code: '#c084fc',
        script: '#fb923c',
        config: '#2dd4bf',
        data: '#fbbf24',
        archive: '#a78bfa',
        encrypted: '#f87171',
        other: '#94a3b8',
    };



    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  Init / Load
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    async function loadContentTab(subParts) {
        if (contentLoaded) {
            // If sub-navigation is requested but tab is already loaded, apply it
            if (subParts && subParts.length > 0) {
                contentApplySubNav(subParts);
            }
            return;
        }
        const browser = document.getElementById('content-browser');
        browser.innerHTML = '<p class="empty-state"><span class="spinner"></span> Detecting foldersâ€¦</p>';

        try {
            // Check enc key status in parallel with folder detection
            const [data, keyStatus] = await Promise.all([
                api('/content/folders'),
                api('/content/enc-key-status').catch(() => ({ configured: false })),
            ]);

            encKeyConfigured = keyStatus.configured;
            contentFolders = data.folders || [];

            if (contentFolders.length === 0) {
                renderContentEmpty(data.suggestions || []);
            } else {
                renderContentFolderBar();

                // Restore navigation from hash sub-parts or default to first folder
                if (subParts && subParts.length > 0) {
                    contentApplySubNav(subParts);
                } else {
                    contentLoadFolder(contentFolders[0].path);
                }
            }
            contentLoaded = true;
        } catch (e) {
            browser.innerHTML = `<p class="empty-state" style="color:var(--error)">âŒ ${esc(e.message)}</p>`;
        }
    }


    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  Empty State
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    function renderContentEmpty(suggestions) {
        const folderBar = document.getElementById('content-folder-bar');
        folderBar.style.display = 'none';

        const browser = document.getElementById('content-browser');

        let quickButtons = '';
        for (const name of suggestions.slice(0, 3)) {
            quickButtons += `
                <button class="btn btn-primary btn-sm" onclick="contentCreateFolder('${esc(name)}')"
                        style="min-width:100px">
                    ğŸ“ Create <code>${esc(name)}/</code>
                </button>`;
        }

        browser.innerHTML = `
            <div class="empty-state" style="padding:3rem 1rem">
                <span style="font-size:3rem;display:block;margin-bottom:1rem">ğŸ“‚</span>
                <h3 style="margin-bottom:0.75rem;color:var(--text-primary)">No content folders detected</h3>
                <p style="color:var(--text-secondary);margin-bottom:1.5rem;max-width:400px;line-height:1.6">
                    Create a content folder to start managing documents, media, and encrypted files.
                </p>
                <div style="display:flex;gap:0.75rem;justify-content:center;flex-wrap:wrap">
                    ${quickButtons}
                </div>
                <p style="color:var(--text-muted);margin-top:1.5rem;font-size:0.8rem">
                    Or create any of: <code>${suggestions.join('</code>, <code>')}</code>
                </p>
            </div>`;
    }


    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  Folder Bar & Selection
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    function renderContentFolderBar() {
        const bar = document.getElementById('content-folder-bar');
        bar.style.display = 'block';

        const select = document.getElementById('content-folder-select');
        select.innerHTML = contentFolders.map(f =>
            `<option value="${esc(f.path)}">${esc(f.name)} (${f.file_count} files)</option>`
        ).join('');
    }

    async function contentToggleExploreAll(enabled) {
        const select = document.getElementById('content-folder-select');
        if (!enabled) {
            // Revert to configured folders only
            renderContentFolderBar();
            // Re-select first configured folder if current isn't in the list
            let found = false;
            for (const opt of select.options) {
                if (contentCurrentPath && contentCurrentPath.startsWith(opt.value)) {
                    select.value = opt.value;
                    found = true;
                    break;
                }
            }
            if (!found && contentFolders.length > 0) {
                select.value = contentFolders[0].path;
                contentLoadFolder(contentFolders[0].path);
            }
            return;
        }

        // Fetch all project folders
        try {
            const data = await api('/content/all-folders');
            const allFolders = data.folders || [];
            const configuredPaths = new Set(contentFolders.map(f => f.path));

            // Build options: configured first (with file counts), then additional
            let html = '';
            for (const f of contentFolders) {
                html += `<option value="${esc(f.path)}">${esc(f.name)} (${f.file_count} files)</option>`;
            }
            const extras = allFolders.filter(f => !configuredPaths.has(f.path));
            if (extras.length > 0) {
                html += '<option disabled>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</option>';
                for (const f of extras) {
                    html += `<option value="${esc(f.path)}">ğŸ—‚ ${esc(f.name)}</option>`;
                }
            }
            select.innerHTML = html;

            // Keep current selection
            if (contentCurrentPath) {
                for (const opt of select.options) {
                    if (contentCurrentPath.startsWith(opt.value)) {
                        select.value = opt.value;
                        break;
                    }
                }
            }
        } catch (e) {
            toast(`Failed to load folders: ${e.message}`, 'error');
        }
    }

    async function contentLoadFolder(folderPath) {
        contentCurrentPath = folderPath;
        // Clear file preview state so hash reverts to folder format
        previewCurrentPath = '';
        previewCurrentName = '';
        contentUpdateHash();
        const browser = document.getElementById('content-browser');
        browser.innerHTML = '<p style="text-align:center;padding:2rem"><span class="spinner"></span></p>';

        // Sync the folder selector â€” add temporary option if path is outside configured folders
        const sel = document.getElementById('content-folder-select');
        if (sel) {
            const rootFolder = folderPath.split('/')[0];
            let matched = false;
            for (const opt of sel.options) {
                if (folderPath.startsWith(opt.value)) {
                    sel.value = opt.value;
                    matched = true;
                    break;
                }
            }
            if (!matched && rootFolder) {
                // Add a temporary option for out-of-context navigation
                const tempOpt = document.createElement('option');
                tempOpt.value = rootFolder;
                tempOpt.textContent = `ğŸ”— ${rootFolder}`;
                tempOpt.dataset.temporary = 'true';
                sel.appendChild(tempOpt);
                sel.value = rootFolder;
            }
        }

        try {
            let listUrl = `/content/list?path=${encodeURIComponent(folderPath)}`;
            if (_contentMediaShowAll && contentCurrentMode === 'media') {
                listUrl += '&recursive=true';
            }
            const data = await api(listUrl);
            renderContentFiles(data, folderPath);
        } catch (e) {
            browser.innerHTML = `<p class="empty-state" style="color:var(--error)">âŒ ${esc(e.message)}</p>`;
        }
    }

    function contentSwitchMode(mode) {
        // Clean up archive modals & polls before switching away
        if (contentCurrentMode === 'archive' && mode !== 'archive') {
            _archiveCleanup();
        }

        contentCurrentMode = mode;
        document.querySelectorAll('.content-modes .content-mode').forEach(b => b.classList.remove('active'));
        const btn = document.querySelector(`.content-modes .content-mode[data-mode="${mode}"]`);
        if (btn) btn.classList.add('active');

        // Show/hide upload button based on mode
        const uploadBtn = document.getElementById('content-upload-btn');
        if (uploadBtn) uploadBtn.style.display = (mode === 'media') ? '' : 'none';

        contentUpdateHash();

        if (mode === 'archive') {
            // Archive mode: own panel with folder context selector
            document.getElementById('content-folder-bar').style.display = 'none';
            document.getElementById('content-breadcrumb').style.display = 'none';
            renderArchivePanel();
        } else {
            // Show folder bar again
            if (contentFolders.length > 0) {
                document.getElementById('content-folder-bar').style.display = '';
            }
            document.getElementById('content-breadcrumb').style.display = '';

            // Clear the browser immediately to remove any stale archive HTML
            const browser = document.getElementById('content-browser');
            browser.innerHTML = '<p style="text-align:center;padding:2rem"><span class="spinner"></span></p>';

            // Load folder â€” use current path if valid, otherwise first available folder
            if (contentCurrentPath) {
                contentLoadFolder(contentCurrentPath);
            } else if (contentFolders.length > 0) {
                contentLoadFolder(contentFolders[0].path);
            }
        }
    }

    function _archiveCleanup() {
        // Close all archive modals
        const modalIds = ['bk-wipe-modal', 'bk-restore-modal', 'bk-release-modal',
            'bk-delete-modal', 'bk-crypto-modal', 'bk-rename-modal'];
        for (const id of modalIds) {
            const m = document.getElementById(id);
            if (m) m.style.display = 'none';
        }
        // Stop upload poll if running
        if (_releasePollTimer) {
            clearInterval(_releasePollTimer);
            _releasePollTimer = null;
        }
    }

    // â”€â”€ Navigation state in URL hash â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Format: #content/MODE/FOLDER_OR_FILE_PATH[@viewmode]
    // Examples:
    //   #content/docs/docs                     â†’ folder listing
    //   #content/docs/docs/readme.md@preview    â†’ file in rendered mode
    //   #content/docs/docs/readme.md@raw        â†’ file in raw mode
    //   #content/docs/docs/readme.md@edit       â†’ file in edit mode
    //   #content/archive/backups                â†’ archive with folder context

    function contentUpdateHash() {
        if (contentCurrentMode === 'archive') {
            const parts = ['content', 'archive'];
            if (_archiveSelectedFolder) parts.push(_archiveSelectedFolder);
            history.replaceState(null, '', `#${parts.join('/')}`);
            return;
        }
        // If previewing a file, encode file path + view mode
        if (previewCurrentPath) {
            let viewMode = 'preview';
            if (previewEditMode) viewMode = 'edit';
            else if (previewRawMode) viewMode = 'raw';
            const parts = ['content', contentCurrentMode, previewCurrentPath + '@' + viewMode];
            history.replaceState(null, '', `#${parts.join('/')}`);
            return;
        }
        if (!contentCurrentPath) return;
        const parts = ['content', contentCurrentMode, contentCurrentPath];
        history.replaceState(null, '', `#${parts.join('/')}`);
    }

    function contentApplySubNav(subParts) {
        // subParts = [mode, ...rest]
        if (subParts.length >= 1) {
            const mode = subParts[0];
            if (['docs', 'media', 'archive'].includes(mode)) {
                contentCurrentMode = mode;
                document.querySelectorAll('.content-modes .content-mode').forEach(b => b.classList.remove('active'));
                const btn = document.querySelector(`.content-modes .content-mode[data-mode="${mode}"]`);
                if (btn) btn.classList.add('active');
                const uploadBtn = document.getElementById('content-upload-btn');
                if (uploadBtn) uploadBtn.style.display = (mode === 'media') ? '' : 'none';
            }
        }
        // Archive mode: own panel â€” read folder from hash
        if (contentCurrentMode === 'archive') {
            document.getElementById('content-folder-bar').style.display = 'none';
            document.getElementById('content-breadcrumb').style.display = 'none';
            if (subParts.length >= 2) {
                _archiveSelectedFolder = subParts.slice(1).join('/');
            }
            renderArchivePanel();
            return;
        }
        if (subParts.length >= 2) {
            const rawPath = subParts.slice(1).join('/');
            // Check for @viewmode suffix indicating a file preview
            const atIdx = rawPath.lastIndexOf('@');
            if (atIdx > 0) {
                const filePath = rawPath.substring(0, atIdx);
                const viewMode = rawPath.substring(atIdx + 1);
                // Set the folder context from the file path (first segment)
                const folderRoot = filePath.split('/')[0];
                contentCurrentPath = folderRoot;
                // Set view mode state before opening preview
                if (viewMode === 'edit') {
                    previewEditMode = true;
                    previewRawMode = false;
                } else if (viewMode === 'raw') {
                    previewEditMode = false;
                    previewRawMode = true;
                } else {
                    previewEditMode = false;
                    previewRawMode = false;
                }
                // Sync folder bar
                renderContentFolderBar();
                const sel = document.getElementById('content-folder-select');
                if (sel) {
                    for (const opt of sel.options) {
                        if (filePath.startsWith(opt.value)) { sel.value = opt.value; break; }
                    }
                }
                document.getElementById('content-folder-bar').style.display = '';
                // Determine if encrypted
                if (filePath.endsWith('.enc')) {
                    contentPreviewEncrypted(filePath, filePath.split('/').pop());
                } else {
                    contentPreviewFile(filePath, filePath.split('/').pop());
                }
                return;
            }
            contentLoadFolder(rawPath);
        } else if (contentFolders.length > 0) {
            contentLoadFolder(contentFolders[0].path);
        }
    }

    async function contentRefresh() {
        contentLoaded = false;
        await loadContentTab();
    }


    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  Archive Panel (Backup & Restore)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    let _archiveUploadedPath = null;
    let _archiveSelectedFolder = '';
    let _archiveTreeData = [];
    let _archiveFolders = [];       // loaded from /backup/folders
    const _archiveTypeIcons = { document: 'ğŸ“', code: 'ğŸ’»', script: 'âš¡', config: 'âš™ï¸', data: 'ğŸ“Š', image: 'ğŸ–¼ï¸', video: 'ğŸ¬', audio: 'ğŸµ', archive: 'ğŸ“¦', encrypted: 'ğŸ”', other: 'ğŸ“„' };

    async function renderArchivePanel() {
        const browser = document.getElementById('content-browser');
        browser.innerHTML = '<div style="padding:2rem;text-align:center"><span class="spinner"></span> Loading archiveâ€¦</div>';

        // Load recursive folder tree from backend
        let folderTree = [];
        try {
            const data = await api('/backup/folder-tree');
            folderTree = data.tree || [];
        } catch (e) {
            browser.innerHTML = `<p class="empty-state" style="color:var(--error)">âŒ ${esc(e.message)}</p>`;
            return;
        }

        // Flatten tree to get all folder paths for validation
        function _flattenPaths(nodes) {
            let paths = [];
            for (const n of nodes) {
                paths.push(n.path);
                if (n.children) paths = paths.concat(_flattenPaths(n.children));
            }
            return paths;
        }
        const allFolderPaths = _flattenPaths(folderTree);

        // Sync from docs/media folder if no archive folder explicitly selected
        if (!_archiveSelectedFolder && contentCurrentPath) {
            const rootFolder = contentCurrentPath.split('/')[0];
            if (rootFolder && allFolderPaths.includes(rootFolder)) {
                _archiveSelectedFolder = rootFolder;
            }
        }

        if (!_archiveSelectedFolder && folderTree.length) {
            _archiveSelectedFolder = folderTree[0].path;
        }

        // Render folder tree HTML
        function _renderFolderTree(nodes, depth) {
            let h = '';
            for (const n of nodes) {
                const indent = depth * 1.2;
                const isSel = n.path === _archiveSelectedFolder;
                const bkIcon = n.has_backup ? ' ğŸ’¾' : '';
                const filesBadge = n.files > 0 ? ` <span style="color:var(--text-muted);font-size:0.75rem">(${n.files})</span>` : '';
                const selCls = isSel ? 'bk-folder-active' : '';
                const hasKids = n.children && n.children.length > 0;
                // Auto-expand if selected folder is inside this subtree
                const selPath = _archiveSelectedFolder || '';
                const shouldExpand = isSel || selPath.startsWith(n.path + '/');

                h += `<div style="padding-left:${indent}rem" data-folder-wrap="${esc(n.path)}">`;
                h += `<div style="display:flex;align-items:center;gap:0.3rem;padding:1px 0">`;
                if (hasKids) {
                    h += `<span class="bk-tree-toggle" style="font-size:0.65rem;cursor:pointer;display:inline-block;width:12px;text-align:center" onclick="this.textContent=this.textContent==='â–¶'?'â–¼':'â–¶';this.parentElement.nextElementSibling.style.display=this.textContent==='â–¶'?'none':'block'">${shouldExpand ? 'â–¼' : 'â–¶'}</span>`;
                } else {
                    h += `<span style="width:12px"></span>`;
                }
                h += `<span class="bk-folder-item ${selCls}" data-path="${esc(n.path)}" onclick="archiveSwitchFolder('${esc(n.path)}')" style="cursor:pointer;padding:1px 6px;border-radius:4px;transition:background 0.15s">ğŸ“ ${esc(n.name)}${filesBadge}${bkIcon}</span>`;
                h += `</div>`;
                if (hasKids) {
                    h += `<div style="display:${shouldExpand ? 'block' : 'none'}">`;
                    h += _renderFolderTree(n.children, depth + 1);
                    h += `</div>`;
                }
                h += `</div>`;
            }
            return h;
        }

        const folderTreeHtml = _renderFolderTree(folderTree, 0);

        // Project root entry at the top
        const rootSel = _archiveSelectedFolder === '.' ? 'bk-folder-active' : '';
        const rootHasBackup = folderTree.some(n => n.has_backup); // approximate
        const rootEntry = `<div style="margin-bottom:0.25rem">
            <span class="bk-folder-item ${rootSel}" data-path="." onclick="archiveSwitchFolder('.')" style="cursor:pointer;padding:1px 6px;border-radius:4px;transition:background 0.15s;font-weight:600">
                ğŸ“¦ Project Root
            </span>
        </div>`;

        browser.innerHTML = `
            <div style="max-width:740px;margin:0 auto">

                <!-- Folder tree context -->
                <div style="background:var(--bg-card);border:1px solid var(--border-subtle);border-radius:12px;padding:1rem 1.25rem;margin-bottom:1.25rem">
                    <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:0.5rem">
                        <div style="font-weight:700;font-size:0.95rem">ğŸ“‚ Folder context</div>
                        <span id="bk-folder-selected" style="font-size:0.85rem;font-weight:600;color:var(--accent-primary)">${esc(_archiveSelectedFolder || 'â€”')}</span>
                    </div>
                    <div id="bk-folder-tree" style="max-height:220px;overflow-y:auto;font-size:0.84rem;line-height:1.5;border:1px solid var(--border-subtle);border-radius:8px;padding:0.4rem;background:var(--bg-tertiary)">
                        ${rootEntry}
                        ${folderTreeHtml}
                    </div>
                </div>

                <!-- Backups (AT THE TOP) -->
                <div style="background:var(--bg-card);border:1px solid var(--border-subtle);border-radius:12px;padding:1.5rem;margin-bottom:1.25rem">
                    <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:0.75rem">
                        <div style="font-weight:700;font-size:1rem">ğŸ—„ï¸ Backups</div>
                        <button class="btn btn-secondary btn-sm" onclick="archiveLoadList()" title="Refresh">ğŸ”„</button>
                    </div>
                    <div id="bk-local-list" style="font-size:0.85rem;color:var(--text-secondary);max-height:500px;overflow-y:auto">
                        <span class="spinner"></span> Loadingâ€¦
                    </div>
                </div>

                <!-- Export / Wipe -->
                <div style="background:var(--bg-card);border:1px solid var(--border-subtle);border-radius:12px;padding:1.5rem;margin-bottom:1.25rem">
                    <div style="font-weight:700;font-size:1rem;margin-bottom:0.75rem">ğŸ“¦ Select items to backup</div>

                    <!-- Gitignore exclusion toggle -->
                    <div style="margin-bottom:0.75rem">
                        <label style="display:flex;align-items:center;gap:0.4rem;cursor:pointer;font-size:0.85rem;color:var(--text-secondary)" title="Exclude files matched by .gitignore (node_modules, dist, build, etc.)">
                            <input type="checkbox" id="bk-opt-gitignore" checked onchange="archiveRefreshTree()"
                                style="width:16px;height:16px;accent-color:var(--accent-primary)"> ğŸš« Respect <code>.gitignore</code> exclusions
                        </label>
                    </div>

                    <div id="bk-type-filters" style="display:flex;gap:0.75rem;margin-bottom:1rem;flex-wrap:wrap">
                        <!-- dynamically populated by archiveRefreshTree -->
                    </div>

                    <div style="display:flex;align-items:center;gap:0.75rem;margin-bottom:0.75rem">
                        <button class="btn btn-secondary btn-sm" onclick="archiveSelectAll(true)" style="font-size:0.75rem;padding:0.2rem 0.6rem">â˜‘ All</button>
                        <button class="btn btn-secondary btn-sm" onclick="archiveSelectAll(false)" style="font-size:0.75rem;padding:0.2rem 0.6rem">â˜ None</button>
                        <span id="bk-selection-count" style="font-size:0.8rem;color:var(--text-muted);margin-left:auto"></span>
                    </div>

                    <div id="bk-file-tree" style="max-height:350px;overflow-y:auto;border:1px solid var(--border-subtle);border-radius:8px;padding:0.5rem;background:var(--bg-tertiary);font-size:0.84rem;line-height:1.3">
                        <span class="spinner"></span> Loadingâ€¦
                    </div>

                    <!-- Encryption Options -->
                    <div style="display:flex;gap:1.25rem;margin-top:1rem;flex-wrap:wrap">
                        <label style="display:flex;align-items:center;gap:0.4rem;cursor:pointer;font-size:0.85rem;color:var(--text-secondary)" title="Decrypt .enc files into plaintext form inside the archive">
                            <input type="checkbox" id="bk-opt-decrypt" style="width:16px;height:16px;accent-color:var(--accent-primary)"> ğŸ”“ Decrypt .enc in archive
                        </label>
                        <label style="display:flex;align-items:center;gap:0.4rem;cursor:pointer;font-size:0.85rem;color:var(--text-secondary)" title="Encrypt the entire .tar.gz archive with your vault key">
                            <input type="checkbox" id="bk-opt-encrypt-archive" style="width:16px;height:16px;accent-color:var(--accent-primary)"> ğŸ”’ Encrypt archive
                        </label>
                    </div>

                    <div style="display:flex;gap:0.5rem;margin-top:0.75rem;align-items:center;flex-wrap:wrap">
                        <label style="font-size:0.85rem;color:var(--text-secondary);font-weight:600;white-space:nowrap">ğŸ“ Backup name:</label>
                        <input type="text" id="bk-custom-name"
                               style="flex:1;min-width:200px;font-size:0.85rem;padding:0.35rem 0.6rem;border:1px solid var(--border-subtle);border-radius:6px;background:var(--bg-tertiary);color:var(--text-primary);font-family:monospace"
                               value="">
                        <button class="btn btn-secondary btn-sm" style="font-size:0.7rem;padding:0.2rem 0.5rem" onclick="_archiveRefreshName()" title="Generate a new name">â†º</button>
                    </div>

                    <div style="display:flex;gap:0.5rem;margin-top:1rem;flex-wrap:wrap;justify-content:flex-end">
                        <button class="btn btn-primary btn-sm" id="bk-export-btn" onclick="archiveDoExport()" style="min-width:150px">
                            ğŸ“¥ Backup selected
                        </button>
                        <button class="btn btn-secondary btn-sm" id="bk-wipe-btn" onclick="archiveShowWipeModal()" style="min-width:150px;color:var(--error)">
                            ğŸ—‘ï¸ Wipe selected
                        </button>
                    </div>
                    <div id="bk-action-status" style="display:none;margin-top:0.75rem;padding:0.75rem;background:var(--bg-tertiary);border-radius:8px;font-size:0.85rem;line-height:1.6"></div>
                </div>

                <!-- Upload -->
                <div style="background:var(--bg-card);border:1px solid var(--border-subtle);border-radius:12px;padding:1.5rem">
                    <div style="font-weight:700;font-size:1rem;margin-bottom:0.75rem">ğŸ“¤ Upload archive</div>
                    <p style="color:var(--text-secondary);font-size:0.85rem;margin-bottom:1rem;line-height:1.6">
                        Upload a <code>.tar.gz</code> or <code>.tar.gz.enc</code> archive into this folder's <code>.backup/</code>.
                    </p>
                    <div style="display:flex;gap:0.75rem;align-items:center;flex-wrap:wrap">
                        <label class="btn btn-secondary btn-sm" style="cursor:pointer;min-width:130px;text-align:center">
                            ğŸ“ Choose fileâ€¦
                            <input type="file" id="bk-import-file" accept=".tar.gz,.gz,.enc"
                                   style="display:none" onchange="archivePreviewUpload(this)">
                        </label>
                        <span id="bk-import-filename" style="font-size:0.85rem;color:var(--text-muted)">No file selected</span>
                    </div>
                    <div id="bk-import-preview" style="display:none;margin-top:1rem;padding:0.85rem;background:var(--bg-tertiary);border:1px solid var(--border-subtle);border-radius:8px;font-size:0.85rem;line-height:1.8"></div>
                </div>

            </div>

            <!-- Wipe Modal -->
            <div id="bk-wipe-modal" style="display:none;position:fixed;inset:0;z-index:9999;background:rgba(0,0,0,0.6);backdrop-filter:blur(4px);align-items:center;justify-content:center">
                <div style="background:var(--bg-card);border:1px solid var(--border-subtle);border-radius:16px;padding:2rem;max-width:480px;width:90%;box-shadow:0 20px 60px rgba(0,0,0,0.4)">
                    <div style="font-size:1.5rem;margin-bottom:0.5rem">âš ï¸ Factory Reset</div>
                    <div id="bk-wipe-modal-info" style="color:var(--text-secondary);font-size:0.9rem;line-height:1.6;margin-bottom:1.25rem"></div>
                    <label style="display:flex;align-items:center;gap:0.5rem;cursor:pointer;font-size:0.85rem;margin-bottom:1.25rem;color:var(--text-secondary)">
                        <input type="checkbox" id="bk-wipe-backup-cb" checked style="width:16px;height:16px;accent-color:var(--accent-primary)"> ğŸ’¾ Create backup before wiping (recommended)
                    </label>
                    <div style="display:flex;gap:0.5rem;justify-content:flex-end">
                        <button class="btn btn-secondary" onclick="document.getElementById('bk-wipe-modal').style.display='none'">Cancel</button>
                        <button class="btn btn-primary" id="bk-wipe-confirm-btn" onclick="archiveDoWipe()" style="background:var(--error);border-color:var(--error)">ğŸ—‘ï¸ Wipe files</button>
                    </div>
                </div>
            </div>

            <!-- Restore Modal -->
            <div id="bk-restore-modal" style="display:none;position:fixed;inset:0;z-index:9999;background:rgba(0,0,0,0.6);backdrop-filter:blur(4px);align-items:center;justify-content:center">
                <div style="background:var(--bg-card);border:1px solid var(--border-subtle);border-radius:16px;padding:2rem;max-width:560px;width:92%;box-shadow:0 20px 60px rgba(0,0,0,0.4)">
                    <div style="font-size:1.3rem;margin-bottom:0.5rem">â™»ï¸ Restore from backup</div>
                    <div id="bk-restore-modal-info" style="color:var(--text-secondary);font-size:0.85rem;margin-bottom:0.75rem"></div>
                    <div id="bk-restore-modal-files" style="max-height:300px;overflow-y:auto;border:1px solid var(--border-subtle);border-radius:8px;padding:0.5rem;background:var(--bg-tertiary);font-size:0.84rem;margin-bottom:1rem">
                        <span class="spinner"></span> Loadingâ€¦
                    </div>
                    <div style="display:flex;align-items:center;gap:0.5rem;margin-bottom:0.75rem">
                        <button class="btn btn-secondary btn-sm" onclick="document.querySelectorAll('#bk-restore-modal-files .bk-rmod-cb').forEach(c=>c.checked=true)" style="font-size:0.75rem">â˜‘ All</button>
                        <button class="btn btn-secondary btn-sm" onclick="document.querySelectorAll('#bk-restore-modal-files .bk-rmod-cb').forEach(c=>c.checked=false)" style="font-size:0.75rem">â˜ None</button>
                        <span id="bk-restore-modal-count" style="font-size:0.8rem;color:var(--text-muted);margin-left:auto"></span>
                    </div>
                    <div id="bk-restore-modal-enc-opts" style="display:none;margin-bottom:1rem;padding:0.6rem 0.75rem;background:var(--bg-tertiary);border:1px solid var(--border-subtle);border-radius:8px">
                        <div style="font-size:0.85rem;font-weight:600;color:var(--text-secondary);margin-bottom:0.4rem">ğŸ” Encryption options <span id="bk-restore-enc-count" style="font-weight:400;color:var(--text-muted)"></span></div>
                        <label style="display:flex;align-items:center;gap:0.5rem;cursor:pointer;font-size:0.84rem;color:var(--text-secondary);margin-bottom:0.3rem">
                            <input type="checkbox" id="bk-restore-decrypt-cb" style="width:15px;height:15px;accent-color:var(--accent-primary)"> ğŸ”“ Decrypt .enc files during restore (restore as plain text)
                        </label>
                        <label style="display:flex;align-items:center;gap:0.5rem;cursor:pointer;font-size:0.84rem;color:var(--text-secondary)">
                            <input type="checkbox" id="bk-restore-encrypt-cb" style="width:15px;height:15px;accent-color:var(--accent-primary)"> ğŸ”’ Encrypt plain files during restore (restore as .enc)
                        </label>
                    </div>

                    <!-- Wipe before restore (hard restore) -->
                    <div style="margin-bottom:1rem;padding:0.6rem 0.75rem;background:rgba(var(--error-rgb,239,68,68),0.08);border:1px solid rgba(var(--error-rgb,239,68,68),0.25);border-radius:8px">
                        <label style="display:flex;align-items:center;gap:0.5rem;cursor:pointer;font-size:0.84rem;color:var(--text-secondary)">
                            <input type="checkbox" id="bk-restore-wipe-cb" onchange="_restoreWipeChanged()"
                                style="width:15px;height:15px;accent-color:var(--error)">
                            ğŸ§¹ <strong>Wipe folder before restore</strong> (hard restore)
                        </label>
                        <div style="font-size:0.75rem;color:var(--text-muted);margin-top:0.25rem;margin-left:1.75rem">
                            Deletes all existing files in the target folder before restoring from backup.
                        </div>
                        <div id="bk-restore-wipe-confirm" style="display:none;margin-top:0.5rem;margin-left:1.75rem">
                            <div style="font-size:0.8rem;color:var(--error);font-weight:600;margin-bottom:0.3rem">
                                âš ï¸ Type <code>CONFIRM</code> to proceed with wipe:
                            </div>
                            <input type="text" id="bk-restore-wipe-confirm-input" placeholder="Type CONFIRM"
                                style="width:160px;font-size:0.85rem;padding:0.3rem 0.5rem;border:1px solid var(--error);border-radius:6px;background:var(--bg-tertiary);color:var(--text-primary);font-family:monospace">
                        </div>
                    </div>

                    <div id="bk-restore-modal-status" style="display:none;margin-bottom:0.75rem;padding:0.5rem;background:var(--bg-tertiary);border-radius:8px;font-size:0.85rem"></div>
                    <div style="display:flex;gap:0.5rem;justify-content:flex-end">
                        <button class="btn btn-secondary" onclick="document.getElementById('bk-restore-modal').style.display='none'">Cancel</button>
                        <button class="btn btn-primary" id="bk-restore-confirm-btn" onclick="archiveDoRestoreFromModal()">â™»ï¸ Restore selected</button>
                    </div>
                </div>
            </div>

            <!-- Upload to Release Modal -->
            <div id="bk-release-modal" style="display:none;position:fixed;inset:0;z-index:9999;background:rgba(0,0,0,0.6);backdrop-filter:blur(4px);align-items:center;justify-content:center">
                <div style="background:var(--bg-card);border:1px solid var(--border-subtle);border-radius:16px;padding:2rem;max-width:480px;width:90%;box-shadow:0 20px 60px rgba(0,0,0,0.4)">
                    <div style="font-size:1.3rem;margin-bottom:0.5rem">ğŸš€ Upload to GitHub Release</div>
                    <div id="bk-release-modal-info" style="color:var(--text-secondary);font-size:0.9rem;line-height:1.6;margin-bottom:1rem"></div>
                    <div id="bk-release-modal-progress" style="display:none;margin-bottom:1rem">
                        <div style="display:flex;align-items:center;gap:0.75rem;margin-bottom:0.5rem">
                            <span class="spinner"></span>
                            <span id="bk-release-modal-status-text" style="font-size:0.85rem">Uploadingâ€¦</span>
                        </div>
                        <div style="height:6px;background:var(--bg-tertiary);border-radius:3px;overflow:hidden">
                            <div id="bk-release-modal-bar" style="height:100%;background:var(--accent-primary);width:0%;transition:width 0.3s"></div>
                        </div>
                    </div>
                    <div id="bk-release-modal-result" style="display:none;padding:0.75rem;background:var(--bg-tertiary);border-radius:8px;font-size:0.85rem;margin-bottom:1rem"></div>
                    <div style="display:flex;gap:0.5rem;justify-content:flex-end">
                        <button class="btn btn-secondary" id="bk-release-close-btn" onclick="document.getElementById('bk-release-modal').style.display='none'">Close</button>
                        <button class="btn btn-primary" id="bk-release-confirm-btn" onclick="archiveDoUploadRelease()">ğŸš€ Upload</button>
                    </div>
                </div>
            </div>

            <!-- Delete Backup Modal -->
            <div id="bk-delete-modal" style="display:none;position:fixed;inset:0;z-index:9999;background:rgba(0,0,0,0.6);backdrop-filter:blur(4px);align-items:center;justify-content:center">
                <div style="background:var(--bg-card);border:1px solid var(--border-subtle);border-radius:16px;padding:2rem;max-width:480px;width:90%;box-shadow:0 20px 60px rgba(0,0,0,0.4)">
                    <div style="font-size:1.3rem;margin-bottom:0.5rem">ğŸ—‘ï¸ Delete Backup</div>
                    <div id="bk-delete-modal-info" style="color:var(--text-secondary);font-size:0.9rem;line-height:1.6;margin-bottom:1rem"></div>
                    <div id="bk-delete-modal-release-opt" style="display:none;margin-bottom:1rem">
                        <label style="display:flex;align-items:center;gap:0.5rem;cursor:pointer;font-size:0.85rem;color:var(--text-secondary)">
                            <input type="checkbox" id="bk-delete-release-cb" checked style="width:16px;height:16px;accent-color:var(--accent-primary)"> ğŸš€ Also delete the GitHub Release artifact
                        </label>
                    </div>
                    <div id="bk-delete-modal-status" style="display:none;margin-bottom:0.75rem;padding:0.5rem;background:var(--bg-tertiary);border-radius:8px;font-size:0.85rem"></div>
                    <div style="display:flex;gap:0.5rem;justify-content:flex-end">
                        <button class="btn btn-secondary" onclick="document.getElementById('bk-delete-modal').style.display='none'">Cancel</button>
                        <button class="btn btn-primary" id="bk-delete-confirm-btn" onclick="archiveDoDeleteConfirm()" style="background:var(--error);border-color:var(--error)">ğŸ—‘ï¸ Delete</button>
                    </div>
                </div>
            </div>

            <!-- Encrypt / Decrypt Modal -->
            <div id="bk-crypto-modal" style="display:none;position:fixed;inset:0;z-index:9999;background:rgba(0,0,0,0.6);backdrop-filter:blur(4px);align-items:center;justify-content:center">
                <div style="background:var(--bg-card);border:1px solid var(--border-subtle);border-radius:16px;padding:2rem;max-width:480px;width:90%;box-shadow:0 20px 60px rgba(0,0,0,0.4)">
                    <div id="bk-crypto-modal-title" style="font-size:1.3rem;margin-bottom:0.5rem">ğŸ” Encrypt Backup</div>
                    <div id="bk-crypto-modal-info" style="color:var(--text-secondary);font-size:0.9rem;line-height:1.6;margin-bottom:1rem"></div>
                    <div id="bk-crypto-modal-status" style="display:none;margin-bottom:0.75rem;padding:0.5rem;background:var(--bg-tertiary);border-radius:8px;font-size:0.85rem"></div>
                    <div id="bk-crypto-modal-release-warn" style="display:none;margin-bottom:1rem;padding:0.5rem;background:var(--bg-tertiary);border:1px solid var(--border-subtle);border-radius:8px;font-size:0.85rem;color:var(--text-secondary)">
                        âš ï¸ This backup has a release artifact. After this operation, the old artifact will be stale.
                        <label style="display:flex;align-items:center;gap:0.5rem;cursor:pointer;margin-top:0.5rem;font-size:0.85rem">
                            <input type="checkbox" id="bk-crypto-update-artifact-cb" style="width:16px;height:16px;accent-color:var(--accent-primary)"> ğŸš€ Delete old artifact & upload new version
                        </label>
                    </div>
                    <div style="display:flex;gap:0.5rem;justify-content:flex-end">
                        <button class="btn btn-secondary" id="bk-crypto-close-btn" onclick="document.getElementById('bk-crypto-modal').style.display='none'">Cancel</button>
                        <button class="btn btn-primary" id="bk-crypto-confirm-btn" onclick="archiveDoCryptoConfirm()">ğŸ” Confirm</button>
                    </div>
                </div>
            </div>

            <!-- Rename Modal -->
            <div id="bk-rename-modal" style="display:none;position:fixed;inset:0;z-index:9999;background:rgba(0,0,0,0.6);backdrop-filter:blur(4px);align-items:center;justify-content:center">
                <div style="background:var(--bg-card);border:1px solid var(--border-subtle);border-radius:16px;padding:2rem;max-width:480px;width:90%;box-shadow:0 20px 60px rgba(0,0,0,0.4)">
                    <div style="font-size:1.3rem;margin-bottom:0.5rem">âœï¸ Rename Backup</div>
                    <div id="bk-rename-modal-info" style="color:var(--text-secondary);font-size:0.85rem;line-height:1.6;margin-bottom:0.75rem"></div>
                    <div style="margin-bottom:1rem">
                        <label style="font-size:0.85rem;color:var(--text-secondary);font-weight:600;display:block;margin-bottom:0.4rem">New filename:</label>
                        <input type="text" id="bk-rename-input" onkeydown="if(event.key==='Enter'){archiveDoRenameConfirm();}"
                               style="width:100%;font-size:0.85rem;padding:0.4rem 0.6rem;border:1px solid var(--border-subtle);border-radius:6px;background:var(--bg-tertiary);color:var(--text-primary);font-family:monospace;box-sizing:border-box">
                        <div style="font-size:0.75rem;color:var(--text-muted);margin-top:0.3rem">Extension (.tar.gz / .tar.gz.enc) will be auto-added if missing</div>
                    </div>
                    <div id="bk-rename-modal-release-warn" style="display:none;margin-bottom:1rem;padding:0.5rem;background:var(--bg-tertiary);border:1px solid var(--border-subtle);border-radius:8px;font-size:0.85rem;color:var(--text-secondary)">
                        âš ï¸ This backup has a release artifact. After renaming, the old artifact name will be stale.
                        <label style="display:flex;align-items:center;gap:0.5rem;cursor:pointer;margin-top:0.5rem;font-size:0.85rem">
                            <input type="checkbox" id="bk-rename-update-artifact-cb" style="width:16px;height:16px;accent-color:var(--accent-primary)"> ğŸš€ Delete old artifact & upload renamed file
                        </label>
                    </div>
                    <div id="bk-rename-modal-status" style="display:none;margin-bottom:0.75rem;padding:0.5rem;background:var(--bg-tertiary);border-radius:8px;font-size:0.85rem"></div>
                    <div style="display:flex;gap:0.5rem;justify-content:flex-end">
                        <button class="btn btn-secondary" onclick="document.getElementById('bk-rename-modal').style.display='none'">Cancel</button>
                        <button class="btn btn-primary" id="bk-rename-confirm-btn" onclick="archiveDoRenameConfirm()">âœï¸ Rename</button>
                    </div>
                </div>
            </div>`;

        archiveRefreshTree();
        archiveLoadList();
        _archiveRefreshName();
    }


    // â”€â”€ Name generation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    function _archiveRefreshName() {
        const now = new Date();
        const pad = (n, w = 2) => String(n).padStart(w, '0');
        const ts = `${now.getFullYear()}${pad(now.getMonth() + 1)}${pad(now.getDate())}T${pad(now.getHours())}${pad(now.getMinutes())}${pad(now.getSeconds())}`;
        const name = `backup_${ts}`;
        const el = document.getElementById('bk-custom-name');
        if (el) el.value = name;
    }


    // â”€â”€ Folder switch â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    function archiveSwitchFolder(folder) {
        _archiveSelectedFolder = folder;
        _archiveBkTypeState = null;  // re-discover types for new folder

        // Update URL hash
        contentUpdateHash();

        // Update folder tree highlighting in-place (no re-render)
        document.querySelectorAll('.bk-folder-item').forEach(el => {
            el.classList.toggle('bk-folder-active', el.dataset.path === folder);
        });

        // Update the selected label
        const selLabel = document.getElementById('bk-folder-selected');
        if (selLabel) selLabel.textContent = folder;

        // Refresh only backup list + file tree
        archiveRefreshTree();
        archiveLoadList();
    }


    // â”€â”€ Tree loading â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    let _archiveBkTypeState = null;  // { type: bool } â€” null until discovered

    const _BK_TYPE_ICONS = {
        document: 'ğŸ“', code: 'ğŸ’»', script: 'âš¡', config: 'âš™ï¸', data: 'ğŸ“Š',
        image: 'ğŸ–¼ï¸', video: 'ğŸ¬', audio: 'ğŸµ', archive: 'ğŸ“¦', encrypted: 'ğŸ”', other: 'ğŸ“„',
    };
    const _BK_TYPE_ORDER = ['document', 'code', 'script', 'config', 'data', 'image', 'video', 'audio', 'archive', 'encrypted', 'other'];

    function _archiveBuildTypeFilters(counts) {
        const container = document.getElementById('bk-type-filters');
        if (!container) return;
        let html = '';
        for (const cat of _BK_TYPE_ORDER) {
            const count = counts[cat] || 0;
            if (count === 0) continue; // don't show types with no files
            const icon = _BK_TYPE_ICONS[cat] || 'ğŸ“„';
            const checked = (_archiveBkTypeState === null || _archiveBkTypeState[cat] !== false) ? 'checked' : '';
            html += `<label style="display:flex;align-items:center;gap:0.4rem;cursor:pointer;font-size:0.85rem">
                <input type="checkbox" data-bk-type="${cat}" ${checked} onchange="archiveFilterByTypes()"
                    style="width:16px;height:16px;accent-color:var(--accent-primary)"> ${icon} ${cat} <span style="font-size:0.72rem;color:var(--text-muted)">(${count})</span>
            </label>`;
        }
        container.innerHTML = html;
    }

    function archiveFilterByTypes() {
        // Read checkbox states
        const checkboxes = document.querySelectorAll('#bk-type-filters input[data-bk-type]');
        _archiveBkTypeState = {};
        checkboxes.forEach(cb => { _archiveBkTypeState[cb.dataset.bkType] = cb.checked; });
        archiveRefreshTree();
    }

    async function archiveRefreshTree() {
        const treeEl = document.getElementById('bk-file-tree');
        if (!treeEl) return;
        treeEl.innerHTML = '<span class="spinner"></span> Loadingâ€¦';

        // Collect selected types from checkboxes
        const types = [];
        if (_archiveBkTypeState === null) {
            // First load â€” fetch all, then build checkboxes from discovery
            types.push(..._BK_TYPE_ORDER);
        } else {
            for (const [t, on] of Object.entries(_archiveBkTypeState)) {
                if (on) types.push(t);
            }
        }

        if (!types.length) {
            treeEl.innerHTML = '<em style="color:var(--text-muted)">Select at least one type above.</em>';
            _archiveTreeData = [];
            archiveUpdateCount();
            return;
        }

        try {
            const respectGitignore = document.getElementById('bk-opt-gitignore')?.checked ?? true;
            const gitParam = respectGitignore ? '&gitignore=true' : '';
            const data = await api(`/backup/tree?path=${encodeURIComponent(_archiveSelectedFolder)}&types=${types.join(',')}${gitParam}`);
            _archiveTreeData = data.tree || [];
            const counts = data.counts || {};

            // Build / refresh dynamic type filter checkboxes
            if (_archiveBkTypeState === null) {
                // Discovery pass: build checkboxes, initialize state
                _archiveBuildTypeFilters(counts);
                _archiveBkTypeState = {};
                for (const cat of _BK_TYPE_ORDER) {
                    if ((counts[cat] || 0) > 0) _archiveBkTypeState[cat] = true;
                }
            }

            const infoEl = document.getElementById('bk-folder-info');
            if (infoEl) {
                const total = Object.values(counts).reduce((a, b) => a + b, 0);
                const parts = [];
                for (const [k, v] of Object.entries(counts)) {
                    if (v > 0) parts.push(`${v} ${k}`);
                }
                infoEl.textContent = total > 0 ? `${total} items (${parts.join(', ')})` : 'empty';
            }

            if (!_archiveTreeData.length) {
                treeEl.innerHTML = '<em style="color:var(--text-muted)">No matching files in this folder.</em>';
                return;
            }

            treeEl.innerHTML = archiveRenderTreeNodes(_archiveTreeData, 0);
            archiveUpdateCount();
        } catch (e) {
            treeEl.innerHTML = `<span style="color:var(--error)">âŒ ${esc(e.message)}</span>`;
        }
    }


    // â”€â”€ Tree rendering â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    function archiveRenderTreeNodes(nodes, depth) {
        let html = '';
        for (const node of nodes) {
            const indent = depth * 1.2;
            const pathAttr = esc(node.path);

            if (node.type === 'directory') {
                const count = node.count || 0;
                html += `<div style="padding-left:${indent}rem">`;
                html += `<div style="display:flex;align-items:center;gap:0.4rem;padding:3px 0;cursor:pointer" onclick="archiveToggleDir(this)">`;
                html += `<input type="checkbox" class="bk-tree-cb bk-tree-dir" data-path="${pathAttr}" data-dir="1"
                            onchange="archiveDirCheck(this)" onclick="event.stopPropagation()"
                            style="width:15px;height:15px;accent-color:var(--accent-primary);flex-shrink:0" checked>`;
                html += `<span class="bk-tree-arrow" style="font-size:0.7rem;transition:transform 0.15s;display:inline-block">â–¶</span>`;
                html += `<span style="font-weight:600">ğŸ“ ${esc(node.name)}</span>`;
                html += `<span style="color:var(--text-muted);font-size:0.75rem;margin-left:0.3rem">(${count})</span>`;
                html += `</div>`;
                html += `<div class="bk-tree-children" style="display:none">`;
                html += archiveRenderTreeNodes(node.children || [], depth + 1);
                html += `</div></div>`;
            } else {
                const icon = _archiveTypeIcons[node.type] || 'ğŸ“„';
                const sizeStr = node.size < 1024 ? `${node.size} B`
                    : node.size < 1048576 ? `${(node.size / 1024).toFixed(1)} KB`
                        : `${(node.size / 1048576).toFixed(1)} MB`;
                html += `<div style="display:flex;align-items:center;gap:0.4rem;padding:2px 0;padding-left:${indent}rem">`;
                html += `<input type="checkbox" class="bk-tree-cb bk-tree-file" data-path="${pathAttr}"
                            onchange="archiveUpdateCount()" style="width:15px;height:15px;accent-color:var(--accent-primary);flex-shrink:0" checked>`;
                html += `<span>${icon} ${esc(node.name)}</span>`;
                html += `<span style="color:var(--text-muted);font-size:0.75rem;margin-left:auto">${sizeStr}</span>`;
                html += `</div>`;
            }
        }
        return html;
    }


    // â”€â”€ Tree interactions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    function archiveToggleDir(rowEl) {
        const children = rowEl.nextElementSibling;
        const arrow = rowEl.querySelector('.bk-tree-arrow');
        if (children) {
            const open = children.style.display !== 'none';
            children.style.display = open ? 'none' : 'block';
            if (arrow) arrow.style.transform = open ? '' : 'rotate(90deg)';
        }
    }

    function archiveDirCheck(cb) {
        const checked = cb.checked;
        const children = cb.closest('div[style]').nextElementSibling;
        if (children) {
            children.querySelectorAll('.bk-tree-cb').forEach(c => { c.checked = checked; });
        }
        archiveUpdateCount();
    }

    function archiveSelectAll(state) {
        document.querySelectorAll('.bk-tree-cb').forEach(c => { c.checked = state; });
        archiveUpdateCount();
    }

    function archiveUpdateCount() {
        const files = document.querySelectorAll('.bk-tree-file:checked');
        const el = document.getElementById('bk-selection-count');
        if (el) el.textContent = `${files.length} file(s) selected`;
    }

    function archiveGetSelectedPaths() {
        const paths = [];
        document.querySelectorAll('.bk-tree-file:checked').forEach(cb => {
            paths.push(cb.dataset.path);
        });
        return paths;
    }


    // â”€â”€ Export (backup) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    async function archiveDoExport() {
        const paths = archiveGetSelectedPaths();
        if (!paths.length) { toast('No files selected', 'error'); return; }

        const decryptEnc = document.getElementById('bk-opt-decrypt')?.checked || false;
        const encryptArchive = document.getElementById('bk-opt-encrypt-archive')?.checked || false;
        const customName = document.getElementById('bk-custom-name')?.value?.trim() || '';

        const btn = document.getElementById('bk-export-btn');
        const status = document.getElementById('bk-action-status');
        btn.disabled = true;
        btn.textContent = 'â³ Backing upâ€¦';
        status.style.display = 'block';
        status.innerHTML = '<span class="spinner"></span> Creating archiveâ€¦';

        try {
            const result = await api('/backup/export', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    target_folder: _archiveSelectedFolder,
                    paths: paths,
                    label: 'admin_export',
                    decrypt_enc: decryptEnc,
                    encrypt_archive: encryptArchive,
                    custom_name: customName,
                }),
            });

            if (result.error) {
                status.innerHTML = `<span style="color:var(--error)">âŒ ${esc(result.error)}</span>`;
            } else {
                const sizeKB = (result.size_bytes / 1024).toFixed(1);
                const stats = result.manifest?.stats || {};
                const encLabel = result.encrypted ? ' ğŸ”’ encrypted' : '';
                status.innerHTML = `
                    âœ… <strong>${esc(result.filename)}</strong> (${sizeKB} KB)${encLabel} â€” ${stats.total_files || 0} files<br>
                    Saved to <code>${esc(result.backup_folder)}/</code><br>
                    <a href="/api/backup/download/${esc(result.full_path)}" class="btn btn-primary btn-sm" style="margin-top:0.5rem;display:inline-block" download>
                        ğŸ’¾ Download
                    </a>`;
                toast('Backup created!', 'success');
                archiveLoadList();
                _archiveRefreshName(); // fresh name for next backup
            }
        } catch (e) {
            status.innerHTML = `<span style="color:var(--error)">âŒ ${esc(e.message)}</span>`;
        } finally {
            btn.disabled = false;
            btn.textContent = 'ğŸ“¥ Backup selected';
        }
    }


    // â”€â”€ Wipe modal â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    function archiveShowWipeModal() {
        const paths = archiveGetSelectedPaths();
        if (!paths.length) { toast('No files selected', 'error'); return; }

        const modal = document.getElementById('bk-wipe-modal');
        const info = document.getElementById('bk-wipe-modal-info');

        // Build expandable file list
        const limit = 30;
        const showing = paths.slice(0, limit);
        let fileList = showing.map(p => `<div style="padding:1px 0;font-size:0.8rem;font-family:monospace;white-space:nowrap;overflow:hidden;text-overflow:ellipsis">â€¢ ${esc(p)}</div>`).join('');
        if (paths.length > limit) {
            fileList += `<div style="padding:1px 0;font-size:0.8rem;color:var(--text-muted)">â€¦ and ${paths.length - limit} more</div>`;
        }

        info.innerHTML = `You are about to delete <strong>${paths.length} file(s)</strong> from <code>${esc(_archiveSelectedFolder)}/</code>.<br><br>This action <strong>cannot be undone</strong> without a backup.`
            + `<details style="margin-top:0.75rem;cursor:pointer">`
            + `<summary style="font-size:0.85rem;color:var(--text-secondary);user-select:none">ğŸ“‹ Show ${paths.length} file(s) to be wiped</summary>`
            + `<div style="max-height:200px;overflow-y:auto;margin-top:0.4rem;padding:0.4rem;background:var(--bg-tertiary);border-radius:6px;border:1px solid var(--border-subtle)">${fileList}</div>`
            + `</details>`;

        // Extra warning + CONFIRM for root-level wipe
        if (_archiveSelectedFolder === '.') {
            info.innerHTML += `<div style="margin-top:0.75rem;padding:0.5rem 0.75rem;background:rgba(var(--error-rgb,239,68,68),0.1);border:1px solid rgba(var(--error-rgb,239,68,68),0.3);border-radius:8px">
                <div style="font-size:0.85rem;color:var(--error);font-weight:700;margin-bottom:0.3rem">âš ï¸ PROJECT ROOT WIPE</div>
                <div style="font-size:0.8rem;color:var(--text-secondary);margin-bottom:0.5rem">This will delete files at the project root level. Type <code>CONFIRM</code> to proceed:</div>
                <input type="text" id="bk-wipe-confirm-input" placeholder="Type CONFIRM"
                    style="width:160px;font-size:0.85rem;padding:0.3rem 0.5rem;border:1px solid var(--error);border-radius:6px;background:var(--bg-tertiary);color:var(--text-primary);font-family:monospace">
            </div>`;
        }

        modal.style.display = 'flex';
    }

    async function archiveDoWipe() {
        const paths = archiveGetSelectedPaths();
        if (!paths.length) { toast('No files selected', 'error'); return; }

        // Require CONFIRM for project root wipe
        if (_archiveSelectedFolder === '.') {
            const confirmInput = document.getElementById('bk-wipe-confirm-input');
            if (!confirmInput || confirmInput.value.trim() !== 'CONFIRM') {
                toast('Type CONFIRM to wipe the project root', 'error');
                return;
            }
        }

        const createBackup = document.getElementById('bk-wipe-backup-cb')?.checked ?? true;
        const modal = document.getElementById('bk-wipe-modal');
        modal.style.display = 'none';

        const status = document.getElementById('bk-action-status');
        status.style.display = 'block';
        status.innerHTML = '<span class="spinner"></span> ' + (createBackup ? 'Backing up then deletingâ€¦' : 'Deletingâ€¦');

        try {
            const result = await api('/backup/wipe', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    target_folder: _archiveSelectedFolder,
                    paths: paths,
                    create_backup: createBackup,
                }),
            });

            if (result.error) {
                status.innerHTML = `<span style="color:var(--error)">âŒ ${esc(result.error)}</span>`;
            } else {
                let msg = `âœ… Wiped ${result.deleted.length} file(s)`;
                if (result.backup) {
                    msg += `<br>ğŸ’¾ Backup: <code>${esc(result.backup.full_path)}</code> (${(result.backup.size_bytes / 1024).toFixed(1)} KB)`;
                }
                if (result.errors?.length) {
                    msg += `<br><span style="color:var(--warning)">âš ï¸ ${result.errors.length} error(s)</span>`;
                }
                status.innerHTML = msg;
                toast('Wipe complete!', 'success');
                archiveRefreshTree();
                archiveLoadList();
                contentLoaded = false;
            }
        } catch (e) {
            status.innerHTML = `<span style="color:var(--error)">âŒ ${esc(e.message)}</span>`;
        }
    }


    // â”€â”€ Upload + preview â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    async function archivePreviewUpload(input) {
        const file = input.files[0];
        if (!file) return;

        document.getElementById('bk-import-filename').textContent = file.name;
        const preview = document.getElementById('bk-import-preview');
        preview.style.display = 'block';
        preview.innerHTML = '<span class="spinner"></span> Uploading & validatingâ€¦';
        _archiveUploadedPath = null;

        try {
            const formData = new FormData();
            formData.append('file', file);
            formData.append('target_folder', _archiveSelectedFolder);

            const resp = await fetch('/api/backup/upload', { method: 'POST', body: formData });
            const data = await resp.json();

            if (!data.success) {
                preview.innerHTML = `<span style="color:var(--error)">âŒ ${data.error}</span>`;
                return;
            }

            _archiveUploadedPath = data.full_path;
            const sizeKB = (data.size_bytes / 1024).toFixed(1);
            const encLabel = data.encrypted ? ' ğŸ”’ encrypted' : '';

            let html = `<strong>ğŸ“¦ ${esc(data.filename)}</strong> (${sizeKB} KB)${encLabel}<br>`;
            html += `Uploaded to <code>${esc(data.folder)}/.backup/</code>`;

            if (data.manifest) {
                const m = data.manifest;
                const stats = m.stats || {};
                html += `<br>Files: ${stats.total_files || (m.files || []).length || '?'}`;
                if (m.created_at) html += ` Â· Created: ${new Date(m.created_at).toLocaleString()}`;
            }

            preview.innerHTML = html;
            toast('Archive uploaded!', 'success');
            archiveLoadList();
        } catch (e) {
            preview.innerHTML = `<span style="color:var(--error)">âŒ ${e.message}</span>`;
        }
    }


    // â”€â”€ Restore modal â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    let _restoreModalPath = '';

    async function archiveDoRestoreFrom(backupPath) {
        if (!backupPath) return;
        _restoreModalPath = backupPath;

        const modal = document.getElementById('bk-restore-modal');
        const info = document.getElementById('bk-restore-modal-info');
        const filesEl = document.getElementById('bk-restore-modal-files');
        const statusEl = document.getElementById('bk-restore-modal-status');
        const countEl = document.getElementById('bk-restore-modal-count');
        const encOpts = document.getElementById('bk-restore-modal-enc-opts');
        const encCount = document.getElementById('bk-restore-enc-count');

        statusEl.style.display = 'none';
        encOpts.style.display = 'none';
        info.innerHTML = `Backup: <code>${esc(backupPath)}</code>`;

        // Show if archive itself is encrypted
        const isEncArchive = backupPath.endsWith('.enc');
        if (isEncArchive) {
            info.innerHTML += ` <span style="color:var(--accent-primary);font-size:0.8rem">ğŸ” encrypted archive</span>`;
        }

        filesEl.innerHTML = '<span class="spinner"></span> Loading filesâ€¦';
        // Reset checkboxes
        const decCb = document.getElementById('bk-restore-decrypt-cb');
        const encCb = document.getElementById('bk-restore-encrypt-cb');
        if (decCb) decCb.checked = false;
        if (encCb) encCb.checked = false;
        // Reset wipe option
        const wipeCb = document.getElementById('bk-restore-wipe-cb');
        const wipeConfirm = document.getElementById('bk-restore-wipe-confirm');
        const wipeInput = document.getElementById('bk-restore-wipe-confirm-input');
        if (wipeCb) wipeCb.checked = false;
        if (wipeConfirm) wipeConfirm.style.display = 'none';
        if (wipeInput) wipeInput.value = '';
        modal.style.display = 'flex';

        try {
            const data = await api(`/backup/preview?path=${encodeURIComponent(backupPath)}`);
            const files = data.files || [];
            if (!files.length) {
                filesEl.innerHTML = '<em style="color:var(--text-muted)">Archive is empty.</em>';
                return;
            }

            let html = '';
            let encFileCount = 0;
            let plainFileCount = 0;
            for (const f of files) {
                const isEnc = f.path.endsWith('.enc');
                if (isEnc) encFileCount++;
                else plainFileCount++;
                const icon = isEnc ? 'ğŸ”' : (_archiveTypeIcons[f.type] || 'ğŸ“„');
                const sizeStr = f.size < 1024 ? `${f.size} B`
                    : f.size < 1048576 ? `${(f.size / 1024).toFixed(1)} KB`
                        : `${(f.size / 1048576).toFixed(1)} MB`;
                html += `<div style="display:flex;align-items:center;gap:0.4rem;padding:2px 0">`;
                html += `<input type="checkbox" class="bk-rmod-cb" data-path="${esc(f.path)}" checked style="width:14px;height:14px;accent-color:var(--accent-primary);flex-shrink:0">`;
                html += `<span>${icon} ${esc(f.path)}</span>`;
                html += `<span style="color:var(--text-muted);font-size:0.75rem;margin-left:auto">${sizeStr}</span>`;
                html += `</div>`;
            }
            filesEl.innerHTML = html;
            countEl.textContent = `${files.length} file(s)`;

            // Show encryption options if there are any enc or plain files
            if (encFileCount > 0 || plainFileCount > 0) {
                encOpts.style.display = 'block';
                const parts = [];
                if (encFileCount > 0) parts.push(`${encFileCount} encrypted`);
                if (plainFileCount > 0) parts.push(`${plainFileCount} plain`);
                encCount.textContent = `â€” ${parts.join(', ')}`;
            }
        } catch (e) {
            filesEl.innerHTML = `<span style="color:var(--error)">âŒ ${esc(e.message)}</span>`;
        }
    }

    async function archiveDoRestoreFromModal() {
        const cbs = document.querySelectorAll('#bk-restore-modal-files .bk-rmod-cb:checked');
        const paths = Array.from(cbs).map(c => c.dataset.path);
        if (!paths.length) { toast('No files selected', 'error'); return; }

        const btn = document.getElementById('bk-restore-confirm-btn');
        const statusEl = document.getElementById('bk-restore-modal-status');
        btn.disabled = true;
        btn.textContent = 'â³ Restoringâ€¦';
        statusEl.style.display = 'block';
        statusEl.innerHTML = '<span class="spinner"></span> Restoring filesâ€¦';

        const wipeFirst = document.getElementById('bk-restore-wipe-cb')?.checked || false;

        // If wiping the project root, require CONFIRM
        if (wipeFirst && _archiveSelectedFolder === '.') {
            const confirmInput = document.getElementById('bk-restore-wipe-confirm-input');
            if (!confirmInput || confirmInput.value.trim() !== 'CONFIRM') {
                statusEl.innerHTML = '<span style="color:var(--error)">âŒ You must type CONFIRM to wipe the project root</span>';
                btn.disabled = false;
                btn.textContent = 'â™»ï¸ Restore selected';
                return;
            }
        }

        try {
            const result = await api('/backup/restore', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    backup_path: _restoreModalPath,
                    paths: paths,
                    decrypt_restored: document.getElementById('bk-restore-decrypt-cb')?.checked || false,
                    encrypt_restored: document.getElementById('bk-restore-encrypt-cb')?.checked || false,
                    wipe_first: wipeFirst,
                    target_folder: _archiveSelectedFolder,
                }),
            });

            if (result.success) {
                let msg = `âœ… Restored <strong>${result.restored.length}</strong> file(s)`;
                if (result.wiped_count) {
                    msg += ` â€” <span style="color:var(--text-muted)">${result.wiped_count} file(s) wiped before restore</span>`;
                }
                statusEl.innerHTML = msg;
                toast(`Restored ${result.restored.length} file(s)`, 'success');
                archiveRefreshTree();
                contentLoaded = false;
                setTimeout(() => { document.getElementById('bk-restore-modal').style.display = 'none'; }, 1500);
            } else {
                statusEl.innerHTML = `<span style="color:var(--error)">âŒ ${esc(result.error)}</span>`;
            }
        } catch (e) {
            statusEl.innerHTML = `<span style="color:var(--error)">âŒ ${esc(e.message)}</span>`;
        } finally {
            btn.disabled = false;
            btn.textContent = 'â™»ï¸ Restore selected';
        }
    }

    function _restoreWipeChanged() {
        const checked = document.getElementById('bk-restore-wipe-cb')?.checked;
        const confirmDiv = document.getElementById('bk-restore-wipe-confirm');
        const confirmInput = document.getElementById('bk-restore-wipe-confirm-input');
        const btn = document.getElementById('bk-restore-confirm-btn');

        if (checked) {
            // Always show CONFIRM for wipe operations (especially dangerous for root)
            confirmDiv.style.display = 'block';
            confirmInput.value = '';
            btn.style.background = 'var(--error)';
            btn.style.borderColor = 'var(--error)';
            btn.textContent = 'ğŸ§¹ Wipe & Restore';
        } else {
            confirmDiv.style.display = 'none';
            btn.style.background = '';
            btn.style.borderColor = '';
            btn.textContent = 'â™»ï¸ Restore selected';
        }
    }


    // â”€â”€ Delete backup (modal) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    let _deleteBackupPath = '';
    let _deleteHasRelease = false;

    function archiveDeleteBackup(backupPath, hasRelease) {
        _deleteBackupPath = backupPath;
        _deleteHasRelease = hasRelease;

        const modal = document.getElementById('bk-delete-modal');
        const info = document.getElementById('bk-delete-modal-info');
        const releaseOpt = document.getElementById('bk-delete-modal-release-opt');
        const status = document.getElementById('bk-delete-modal-status');
        const confirmBtn = document.getElementById('bk-delete-confirm-btn');

        info.innerHTML = `Are you sure you want to permanently delete this backup?<br><br><code style="font-size:0.82rem;word-break:break-all">${esc(backupPath)}</code><br><br>This action <strong>cannot be undone</strong>.`;
        releaseOpt.style.display = hasRelease ? 'block' : 'none';
        status.style.display = 'none';
        confirmBtn.disabled = false;
        confirmBtn.textContent = 'ğŸ—‘ï¸ Delete';
        modal.style.display = 'flex';
    }

    async function archiveDoDeleteConfirm() {
        const modal = document.getElementById('bk-delete-modal');
        const status = document.getElementById('bk-delete-modal-status');
        const confirmBtn = document.getElementById('bk-delete-confirm-btn');
        const deleteRelease = _deleteHasRelease && (document.getElementById('bk-delete-release-cb')?.checked ?? false);

        confirmBtn.disabled = true;
        confirmBtn.textContent = 'â³ Deletingâ€¦';
        status.style.display = 'block';
        status.innerHTML = '<span class="spinner"></span> Deletingâ€¦';

        try {
            // Delete release artifact first if requested
            if (deleteRelease) {
                status.innerHTML = '<span class="spinner"></span> Removing release artifactâ€¦';
                await api('/backup/delete-release', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ backup_path: _deleteBackupPath }),
                });
            }

            status.innerHTML = '<span class="spinner"></span> Deleting local backupâ€¦';
            const result = await api('/backup/delete', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ backup_path: _deleteBackupPath }),
            });

            if (result.success) {
                modal.style.display = 'none';
                toast('Backup deleted' + (deleteRelease ? ' (+ release artifact)' : ''), 'success');
                archiveLoadList();
            } else {
                status.innerHTML = `<span style="color:var(--error)">âŒ ${esc(result.error || 'Delete failed')}</span>`;
                confirmBtn.disabled = false;
                confirmBtn.textContent = 'ğŸ—‘ï¸ Delete';
            }
        } catch (e) {
            status.innerHTML = `<span style="color:var(--error)">âŒ ${esc(e.message)}</span>`;
            confirmBtn.disabled = false;
            confirmBtn.textContent = 'ğŸ—‘ï¸ Delete';
        }
    }


    // â”€â”€ Encrypt / Decrypt (modal) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    let _cryptoBackupPath = '';
    let _cryptoShouldEncrypt = true;
    let _cryptoHasRelease = false;
    let _cryptoNewPath = '';  // stored after success for artifact update

    function archiveToggleCrypto(backupPath, shouldEncrypt, hasRelease) {
        _cryptoBackupPath = backupPath;
        _cryptoShouldEncrypt = shouldEncrypt;
        _cryptoHasRelease = hasRelease;
        _cryptoNewPath = '';

        const action = shouldEncrypt ? 'Encrypt' : 'Decrypt';
        const modal = document.getElementById('bk-crypto-modal');
        const title = document.getElementById('bk-crypto-modal-title');
        const info = document.getElementById('bk-crypto-modal-info');
        const status = document.getElementById('bk-crypto-modal-status');
        const confirmBtn = document.getElementById('bk-crypto-confirm-btn');
        const closeBtn = document.getElementById('bk-crypto-close-btn');

        title.textContent = `ğŸ” ${action} Backup`;

        let html = `${action} this backup?<br><br><code style="font-size:0.82rem;word-break:break-all">${esc(backupPath)}</code>`;
        info.innerHTML = html;

        // Show/hide release artifact checkbox
        const releaseWarn = document.getElementById('bk-crypto-modal-release-warn');
        const artifactCb = document.getElementById('bk-crypto-update-artifact-cb');
        releaseWarn.style.display = hasRelease ? 'block' : 'none';
        if (artifactCb) artifactCb.checked = false;

        status.style.display = 'none';
        confirmBtn.style.display = '';
        confirmBtn.disabled = false;
        confirmBtn.textContent = `ğŸ” ${action}`;
        closeBtn.textContent = 'Cancel';
        modal.style.display = 'flex';
    }

    async function archiveDoCryptoConfirm() {
        const action = _cryptoShouldEncrypt ? 'Encrypt' : 'Decrypt';
        const status = document.getElementById('bk-crypto-modal-status');
        const confirmBtn = document.getElementById('bk-crypto-confirm-btn');
        const closeBtn = document.getElementById('bk-crypto-close-btn');

        confirmBtn.disabled = true;
        confirmBtn.textContent = `â³ ${action}ingâ€¦`;
        status.style.display = 'block';
        status.innerHTML = `<span class="spinner"></span> ${action}ing backupâ€¦`;

        try {
            const endpoint = _cryptoShouldEncrypt ? '/backup/encrypt' : '/backup/decrypt';
            const result = await api(endpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ backup_path: _cryptoBackupPath }),
            });

            if (result.success) {
                _cryptoNewPath = result.full_path;
                const sizeKB = (result.size_bytes / 1024).toFixed(1);
                status.innerHTML = `âœ… ${action}ed â†’ <strong>${esc(result.filename)}</strong> (${sizeKB} KB)`;
                confirmBtn.style.display = 'none';
                closeBtn.textContent = 'Done';

                // Auto-handle artifact update if checkbox was checked
                const updateArtifact = document.getElementById('bk-crypto-update-artifact-cb')?.checked;
                if (_cryptoHasRelease && updateArtifact) {
                    status.innerHTML += '<br><span class="spinner" style="width:12px;height:12px"></span> Deleting old release artifactâ€¦';
                    try {
                        await api('/backup/delete-release', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ backup_path: _cryptoBackupPath }),
                        });
                    } catch (_) { /* old artifact may already be gone */ }

                    document.getElementById('bk-crypto-modal').style.display = 'none';
                    archiveLoadList();
                    // Open the upload modal for the new file
                    archiveUploadToRelease(_cryptoNewPath);
                } else {
                    archiveLoadList();
                }
            } else {
                status.innerHTML = `<span style="color:var(--error)">âŒ ${esc(result.error || action + ' failed')}</span>`;
                confirmBtn.disabled = false;
                confirmBtn.textContent = `ğŸ” ${action}`;
            }
        } catch (e) {
            status.innerHTML = `<span style="color:var(--error)">âŒ ${esc(e.message)}</span>`;
            confirmBtn.disabled = false;
            confirmBtn.textContent = `ğŸ” ${action}`;
        }
    }



    // â”€â”€ Rename backup (modal) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    let _renameBackupPath = '';
    let _renameHasRelease = false;

    function archiveRenameBackup(backupPath, currentName, hasRelease) {
        _renameBackupPath = backupPath;
        _renameHasRelease = hasRelease;

        const modal = document.getElementById('bk-rename-modal');
        const info = document.getElementById('bk-rename-modal-info');
        const input = document.getElementById('bk-rename-input');
        const releaseWarn = document.getElementById('bk-rename-modal-release-warn');
        const status = document.getElementById('bk-rename-modal-status');
        const confirmBtn = document.getElementById('bk-rename-confirm-btn');

        info.innerHTML = `Current name: <code style="font-size:0.82rem">${esc(currentName)}</code>`;
        input.value = currentName.replace(/\.tar\.gz(\.enc)?$/, '');
        releaseWarn.style.display = hasRelease ? 'block' : 'none';
        if (hasRelease) {
            document.getElementById('bk-rename-update-artifact-cb').checked = false;
        }
        status.style.display = 'none';
        confirmBtn.disabled = false;
        confirmBtn.textContent = 'âœï¸ Rename';
        modal.style.display = 'flex';

        // Focus & select text
        setTimeout(() => { input.focus(); input.select(); }, 100);
    }

    async function archiveDoRenameConfirm() {
        const modal = document.getElementById('bk-rename-modal');
        const input = document.getElementById('bk-rename-input');
        const status = document.getElementById('bk-rename-modal-status');
        const confirmBtn = document.getElementById('bk-rename-confirm-btn');
        const newName = input.value.trim();
        const updateArtifact = _renameHasRelease && (document.getElementById('bk-rename-update-artifact-cb')?.checked ?? false);

        if (!newName) { toast('Enter a name', 'error'); return; }

        confirmBtn.disabled = true;
        confirmBtn.textContent = 'â³ Renamingâ€¦';
        status.style.display = 'block';
        status.innerHTML = '<span class="spinner"></span> Renamingâ€¦';

        try {
            const result = await api('/backup/rename', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ backup_path: _renameBackupPath, new_name: newName }),
            });

            if (result.success) {
                if (updateArtifact) {
                    status.innerHTML = '<span class="spinner"></span> Deleting old release artifactâ€¦';
                    // Use the NEW path â€” rename already moved the .release.json metadata
                    await api('/backup/delete-release', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ backup_path: result.full_path }),
                    }).catch(() => { });

                    modal.style.display = 'none';
                    archiveLoadList();
                    // Open upload modal for renamed file
                    archiveUploadToRelease(result.full_path);
                } else {
                    modal.style.display = 'none';
                    toast(`Renamed â†’ ${result.filename}`, 'success');
                    archiveLoadList();
                }
            } else {
                status.innerHTML = `<span style="color:var(--error)">âŒ ${esc(result.error || 'Rename failed')}</span>`;
                confirmBtn.disabled = false;
                confirmBtn.textContent = 'âœï¸ Rename';
            }
        } catch (e) {
            status.innerHTML = `<span style="color:var(--error)">âŒ ${esc(e.message)}</span>`;
            confirmBtn.disabled = false;
            confirmBtn.textContent = 'âœï¸ Rename';
        }
    }


    // â”€â”€ Mark as special (git-tracked) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    async function archiveMarkSpecial(backupPath, isTracked) {
        // This one is simple enough to keep as a quick action with a toast
        const action = isTracked ? 'Remove from' : 'Add to';
        try {
            const result = await api('/backup/mark-special', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ backup_path: backupPath, unmark: isTracked }),
            });
            if (result.success) {
                toast(result.message, 'success');
                archiveLoadList();
            } else {
                toast(result.error || 'Failed', 'error');
            }
        } catch (e) {
            toast(e.message, 'error');
        }
    }


    // â”€â”€ Delete release artifact â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    function archiveDeleteRelease(backupPath) {
        // Re-use the delete modal in release-only mode
        _deleteBackupPath = backupPath;
        _deleteHasRelease = true;

        const modal = document.getElementById('bk-delete-modal');
        const info = document.getElementById('bk-delete-modal-info');
        const releaseOpt = document.getElementById('bk-delete-modal-release-opt');
        const status = document.getElementById('bk-delete-modal-status');
        const confirmBtn = document.getElementById('bk-delete-confirm-btn');

        info.innerHTML = `Delete the <strong>GitHub Release artifact</strong> for this backup?<br><br><code style="font-size:0.82rem;word-break:break-all">${esc(backupPath)}</code><br><br>The local backup file will <strong>not</strong> be deleted.`;
        releaseOpt.style.display = 'none'; // no checkbox needed â€” this IS the release delete
        status.style.display = 'none';
        confirmBtn.disabled = false;
        confirmBtn.textContent = 'ğŸš€ğŸ—‘ï¸ Delete artifact';

        // Override the confirm to only delete the release
        confirmBtn.onclick = async function () {
            confirmBtn.disabled = true;
            confirmBtn.textContent = 'â³ Deletingâ€¦';
            status.style.display = 'block';
            status.innerHTML = '<span class="spinner"></span> Removing release artifactâ€¦';
            try {
                const result = await api('/backup/delete-release', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ backup_path: backupPath }),
                });
                if (result.success) {
                    modal.style.display = 'none';
                    toast(result.message, 'success');
                    archiveLoadList();
                } else {
                    status.innerHTML = `<span style="color:var(--error)">âŒ ${esc(result.error)}</span>`;
                    confirmBtn.disabled = false;
                    confirmBtn.textContent = 'ğŸš€ğŸ—‘ï¸ Delete artifact';
                }
            } catch (e) {
                status.innerHTML = `<span style="color:var(--error)">âŒ ${esc(e.message)}</span>`;
                confirmBtn.disabled = false;
                confirmBtn.textContent = 'ğŸš€ğŸ—‘ï¸ Delete artifact';
            }
            // Restore original handler
            confirmBtn.onclick = archiveDoDeleteConfirm;
        };

        modal.style.display = 'flex';
    }


    // â”€â”€ Upload to Release (modal) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    let _releaseBackupPath = '';
    let _releaseFileId = '';
    let _releasePollTimer = null;

    function archiveUploadToRelease(backupPath) {
        _releaseBackupPath = backupPath;

        const modal = document.getElementById('bk-release-modal');
        const info = document.getElementById('bk-release-modal-info');
        const progress = document.getElementById('bk-release-modal-progress');
        const result = document.getElementById('bk-release-modal-result');
        const confirmBtn = document.getElementById('bk-release-confirm-btn');
        const closeBtn = document.getElementById('bk-release-close-btn');

        const filename = backupPath.split('/').pop();
        info.innerHTML = `Push <strong>${esc(filename)}</strong> to a GitHub Release as a downloadable artifact.<br><br>Path: <code>${esc(backupPath)}</code>`;
        progress.style.display = 'none';
        result.style.display = 'none';
        confirmBtn.style.display = '';
        confirmBtn.disabled = false;
        confirmBtn.textContent = 'ğŸš€ Upload';
        modal.style.display = 'flex';
    }

    async function archiveDoUploadRelease() {
        const confirmBtn = document.getElementById('bk-release-confirm-btn');
        const progress = document.getElementById('bk-release-modal-progress');
        const statusText = document.getElementById('bk-release-modal-status-text');
        const bar = document.getElementById('bk-release-modal-bar');
        const result = document.getElementById('bk-release-modal-result');

        confirmBtn.disabled = true;
        confirmBtn.textContent = 'â³ Startingâ€¦';
        progress.style.display = 'block';
        result.style.display = 'none';
        bar.style.width = '0%';
        statusText.textContent = 'Starting uploadâ€¦';

        try {
            const data = await api('/backup/upload-release', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ backup_path: _releaseBackupPath }),
            });

            if (!data.success) {
                progress.style.display = 'none';
                result.style.display = 'block';
                result.innerHTML = `<span style="color:var(--error)">âŒ ${esc(data.error)}</span>`;
                confirmBtn.disabled = false;
                confirmBtn.textContent = 'ğŸš€ Upload';
                return;
            }

            _releaseFileId = data.file_id;
            confirmBtn.style.display = 'none';
            bar.style.width = '10%';
            statusText.textContent = 'Upload in progressâ€¦';

            // Start polling for status
            _releasePollTimer = setInterval(() => _pollReleaseStatus(), 2000);
        } catch (e) {
            progress.style.display = 'none';
            result.style.display = 'block';
            result.innerHTML = `<span style="color:var(--error)">âŒ ${esc(e.message)}</span>`;
            confirmBtn.disabled = false;
            confirmBtn.textContent = 'ğŸš€ Upload';
        }
    }

    async function _pollReleaseStatus() {
        const statusText = document.getElementById('bk-release-modal-status-text');
        const bar = document.getElementById('bk-release-modal-bar');
        const progress = document.getElementById('bk-release-modal-progress');
        const result = document.getElementById('bk-release-modal-result');

        try {
            const data = await api(`/content/release-status/${_releaseFileId}`);
            const st = data.status || 'unknown';

            if (st === 'uploading' || st === 'pending') {
                const pct = data.progress_pct || 0;
                bar.style.width = `${Math.min(pct, 95)}%`;
                statusText.textContent = data.message || `Uploadingâ€¦ ${pct}%`;
            } else if (st === 'done' || st === 'complete') {
                clearInterval(_releasePollTimer);
                _releasePollTimer = null;
                bar.style.width = '100%';
                statusText.textContent = 'Complete!';

                setTimeout(() => {
                    progress.style.display = 'none';
                    result.style.display = 'block';
                    let html = `âœ… <strong>Upload complete!</strong>`;
                    if (data.url) html += `<br><a href="${esc(data.url)}" target="_blank" style="color:var(--accent-primary)">View release â†’</a>`;
                    if (data.download_url) html += `<br><a href="${esc(data.download_url)}" target="_blank" style="color:var(--accent-primary)">Download link â†’</a>`;
                    result.innerHTML = html;
                }, 500);
                toast('Release upload done!', 'success');
                // Refresh list so the release badge appears immediately
                archiveLoadList();
            } else if (st === 'error' || st === 'failed') {
                clearInterval(_releasePollTimer);
                _releasePollTimer = null;
                progress.style.display = 'none';
                result.style.display = 'block';
                result.innerHTML = `<span style="color:var(--error)">âŒ ${esc(data.error || 'Upload failed')}</span>`;
                // Refresh list to sync state
                archiveLoadList();
            }
            // else keep polling
        } catch (e) {
            // Network error; keep trying
        }
    }


    // â”€â”€ List local .backup/ archives â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    async function archiveLoadList() {
        const container = document.getElementById('bk-local-list');
        if (!container) return;

        try {
            const data = await api(`/backup/list?path=${encodeURIComponent(_archiveSelectedFolder)}`);

            if (!data.backups || !data.backups.length) {
                container.innerHTML = '<em style="color:var(--text-muted)">No backups yet. Use "Backup selected" below to create one.</em>';
                return;
            }

            let html = '';
            for (const b of data.backups) {
                const sizeKB = (b.size_bytes / 1024).toFixed(1);
                const m = b.manifest || {};
                const stats = m.stats || {};
                const trigger = m.trigger || '';
                const created = m.created_at ? new Date(m.created_at).toLocaleString() : (m.manifest?.created_at ? new Date(m.manifest.created_at).toLocaleString() : '?');
                const fileCount = stats.total_files || (m.files || []).length || '?';
                const bkId = esc(b.full_path).replace(/[^a-zA-Z0-9]/g, '_');
                const hasRelease = !!b.release;
                const escapedPath = esc(b.full_path).replace(/'/g, "\\'");

                // Status badges
                let badges = '';
                if (b.encrypted) badges += ' ğŸ”’';
                if (b.git_tracked) badges += ' <span title="Git-tracked (special)" style="font-size:0.72rem;background:#8b5cf6;color:#fff;padding:1px 5px;border-radius:3px">â­ Git</span>';
                if (b.release) {
                    const rStatus = b.release.status || 'unknown';
                    if (rStatus === 'done') badges += ' <span title="Uploaded to GitHub Release" style="font-size:0.72rem;background:#22c55e;color:#fff;padding:1px 5px;border-radius:3px">ğŸŸ¢ Release</span>';
                    else if (rStatus === 'uploading') badges += ' <span title="Upload in progress" style="font-size:0.72rem;background:#eab308;color:#000;padding:1px 5px;border-radius:3px">ğŸŸ¡ Uploading</span>';
                    else badges += ' <span title="Release status: ' + rStatus + '" style="font-size:0.72rem;background:var(--text-muted);color:#fff;padding:1px 5px;border-radius:3px">âšª ' + rStatus + '</span>';
                }

                html += `<div style="padding:0.6rem 0;border-bottom:1px solid var(--border-subtle)">`;
                html += `<div style="display:flex;justify-content:space-between;align-items:flex-start;gap:0.5rem">`;
                html += `<div style="min-width:0;flex:1">`;
                html += `<strong style="color:var(--text-primary)">ğŸ“¦ ${esc(b.filename)}</strong>`;
                html += ` <span style="color:var(--text-muted);font-size:0.8rem">(${sizeKB} KB)</span>`;
                html += `${badges}<br>`;
                html += `<span style="font-size:0.8rem;color:var(--text-muted)">${fileCount} files`;
                if (trigger) html += ` Â· ${esc(trigger)}`;
                html += ` Â· ${created}</span>`;
                html += `</div>`;

                // Action buttons
                html += `<div style="display:flex;flex-direction:column;gap:3px;flex-shrink:0">`;
                // Row 1: core actions
                html += `<div style="display:flex;gap:3px">`;
                html += `<button class="btn btn-primary btn-sm" style="font-size:0.75rem;padding:0.2rem 0.45rem" title="Restore (modal)" onclick="archiveDoRestoreFrom('${escapedPath}')">â™»ï¸</button>`;
                html += `<button class="btn btn-secondary btn-sm" style="font-size:0.75rem;padding:0.2rem 0.45rem" title="Browse contents" onclick="archiveBrowseBackup('${escapedPath}', '${bkId}')">ğŸ“‚</button>`;
                html += `<a href="/api/backup/download/${esc(b.full_path)}" class="btn btn-secondary btn-sm" style="font-size:0.75rem;padding:0.2rem 0.45rem" title="Download" download>ğŸ’¾</a>`;
                html += `<button class="btn btn-secondary btn-sm" style="font-size:0.75rem;padding:0.2rem 0.45rem" title="Rename" onclick="archiveRenameBackup('${escapedPath}', '${esc(b.filename)}', ${hasRelease})">âœï¸</button>`;
                html += `<button class="btn btn-secondary btn-sm" style="font-size:0.75rem;padding:0.2rem 0.45rem;color:var(--error)" title="Delete backup" onclick="archiveDeleteBackup('${escapedPath}', ${hasRelease})">ğŸ—‘ï¸</button>`;
                html += `</div>`;
                // Row 2: crypto + release + git
                html += `<div style="display:flex;gap:3px">`;
                if (b.encrypted) {
                    html += `<button class="btn btn-secondary btn-sm" style="font-size:0.75rem;padding:0.2rem 0.45rem" title="Decrypt backup" onclick="archiveToggleCrypto('${escapedPath}', false, ${hasRelease})">ğŸ”“</button>`;
                } else {
                    html += `<button class="btn btn-secondary btn-sm" style="font-size:0.75rem;padding:0.2rem 0.45rem" title="Encrypt backup" onclick="archiveToggleCrypto('${escapedPath}', true, ${hasRelease})">ğŸ”’</button>`;
                }
                html += `<button class="btn btn-secondary btn-sm" style="font-size:0.75rem;padding:0.2rem 0.45rem" title="Upload to GitHub Release" onclick="archiveUploadToRelease('${escapedPath}')">ğŸš€</button>`;
                if (b.release) {
                    html += `<button class="btn btn-secondary btn-sm" style="font-size:0.75rem;padding:0.2rem 0.45rem;color:var(--error)" title="Delete release artifact" onclick="archiveDeleteRelease('${escapedPath}')">ğŸš€ğŸ—‘ï¸</button>`;
                }
                html += `<button class="btn btn-secondary btn-sm" style="font-size:0.75rem;padding:0.2rem 0.45rem" title="${b.git_tracked ? 'Remove from git tracking' : 'Add to git (force, â‰¤25MB)'}" onclick="archiveMarkSpecial('${escapedPath}', ${!!b.git_tracked})">${b.git_tracked ? 'â­' : 'â˜†'}</button>`;
                html += `</div>`;
                html += `</div></div>`;

                html += `<div id="bk-browse-${bkId}" style="display:none;margin-top:0.5rem;padding:0.75rem;background:var(--bg-tertiary);border:1px solid var(--border-subtle);border-radius:8px"></div>`;
                html += `</div>`;
            }

            container.innerHTML = html;
        } catch (e) {
            container.innerHTML = `<span style="color:var(--error)">Error: ${esc(e.message)}</span>`;
        }
    }


    // â”€â”€ Browse backup contents (selective restore) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    async function archiveBrowseBackup(backupPath, bkId) {
        const panel = document.getElementById('bk-browse-' + bkId);
        if (!panel) return;

        if (panel.style.display !== 'none') {
            panel.style.display = 'none';
            return;
        }

        panel.style.display = 'block';
        panel.innerHTML = '<span class="spinner"></span> Loading archive contentsâ€¦';

        try {
            const data = await api(`/backup/preview?path=${encodeURIComponent(backupPath)}`);
            const files = data.files || [];

            if (!files.length) {
                panel.innerHTML = '<em style="color:var(--text-muted)">No files in this archive.</em>';
                return;
            }

            let html = '<div style="margin-bottom:0.5rem;display:flex;align-items:center;gap:0.75rem">';
            html += `<button class="btn btn-secondary btn-sm" onclick="document.querySelectorAll('#bk-browse-${bkId} .bk-restore-cb').forEach(c=>c.checked=true)" style="font-size:0.75rem;padding:0.2rem 0.5rem">â˜‘ All</button>`;
            html += `<button class="btn btn-secondary btn-sm" onclick="document.querySelectorAll('#bk-browse-${bkId} .bk-restore-cb').forEach(c=>c.checked=false)" style="font-size:0.75rem;padding:0.2rem 0.5rem">â˜ None</button>`;
            html += `<span style="font-size:0.8rem;color:var(--text-muted);margin-left:auto">${files.length} file(s)</span>`;
            html += '</div>';

            html += '<div style="max-height:250px;overflow-y:auto;font-size:0.82rem;line-height:1.5">';
            for (const f of files) {
                const icon = _archiveTypeIcons[f.type] || 'ğŸ“„';
                const sizeStr = f.size < 1024 ? `${f.size} B`
                    : f.size < 1048576 ? `${(f.size / 1024).toFixed(1)} KB`
                        : `${(f.size / 1048576).toFixed(1)} MB`;
                html += `<div style="display:flex;align-items:center;gap:0.4rem;padding:2px 0">`;
                html += `<input type="checkbox" class="bk-restore-cb" data-path="${esc(f.path)}" checked style="width:14px;height:14px;accent-color:var(--accent-primary);flex-shrink:0">`;
                html += `<span>${icon} ${esc(f.path)}</span>`;
                html += `<span style="color:var(--text-muted);font-size:0.75rem;margin-left:auto">${sizeStr}</span>`;
                html += `</div>`;
            }
            html += '</div>';

            html += '<div style="display:flex;gap:0.5rem;margin-top:0.75rem;justify-content:flex-end">';
            html += `<button class="btn btn-primary btn-sm" onclick="archiveDoSelectiveRestore('${esc(backupPath)}', '${bkId}')" style="min-width:140px">â™»ï¸ Restore selected</button>`;
            html += `<button class="btn btn-secondary btn-sm" onclick="archiveDoImportFrom('${esc(backupPath)}')" style="min-width:140px">ğŸ“¤ Import (additive)</button>`;
            html += '</div>';

            panel.innerHTML = html;
        } catch (e) {
            panel.innerHTML = `<span style="color:var(--error)">âŒ ${esc(e.message)}</span>`;
        }
    }


    async function archiveDoSelectiveRestore(backupPath, bkId) {
        const panel = document.getElementById('bk-browse-' + bkId);
        const cbs = panel ? panel.querySelectorAll('.bk-restore-cb:checked') : [];
        const paths = Array.from(cbs).map(cb => cb.dataset.path);

        if (!paths.length) { toast('No files selected', 'error'); return; }
        if (!confirm(`âš ï¸ Restore ${paths.length} file(s) from backup?\n\nThis will OVERWRITE existing files.\n\nProceed?`)) return;

        try {
            const result = await api('/backup/restore', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ backup_path: backupPath, paths: paths }),
            });

            if (result.success) {
                toast(`Restored ${result.restored.length} file(s)`, 'success');
                archiveRefreshTree();
                contentLoaded = false;
            } else {
                toast(result.error || 'Restore failed', 'error');
            }
        } catch (e) {
            toast(e.message, 'error');
        }
    }


    async function archiveDoImportFrom(backupPath) {
        if (!confirm('ğŸ“¤ Import files?\n\nNew files will be added.\nExisting files will NOT be overwritten.\n\nProceed?')) return;

        try {
            const result = await api('/backup/import', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ backup_path: backupPath }),
            });

            if (result.success) {
                toast(`Imported ${result.imported.length} file(s), skipped ${result.skipped.length}`, 'success');
                archiveRefreshTree();
                contentLoaded = false;
            } else {
                toast(result.error || 'Import failed', 'error');
            }
        } catch (e) {
            toast(e.message, 'error');
        }
    }



    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  File Browser
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    function contentToggleCategoryFilter(category) {
        if (!_contentCategoryFilters[contentCurrentMode]) {
            _contentCategoryFilters[contentCurrentMode] = {};
        }
        const mf = _contentCategoryFilters[contentCurrentMode];
        mf[category] = mf[category] === false ? true : false;

        // Re-render from cached data
        if (_contentLastRenderData) {
            renderContentFiles(_contentLastRenderData.data, _contentLastRenderData.folderPath);
        }
    }

    function contentToggleMediaShowAll(checked) {
        _contentMediaShowAll = checked;
        // Reload current folder with/without recursive flag
        contentLoadFolder(contentCurrentPath);
    }

    function _matchesGlob(name, query) {
        // If query contains *, treat as glob pattern
        if (query.includes('*')) {
            // Convert glob to regex: escape regex chars except *, then replace * with .*
            const escaped = query.replace(/[.+^${}()|[\]\\]/g, '\\$&').replace(/\*/g, '.*');
            try {
                return new RegExp('^' + escaped + '$', 'i').test(name);
            } catch (_) {
                return name.includes(query);
            }
        }
        // Plain substring match
        return name.includes(query);
    }

    // â”€â”€ Recursive search cache and helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let _searchRecursiveCache = { path: '', files: [] };
    let _searchDebounceTimer = null;

    function contentFilterListByName(query) {
        const q = query.toLowerCase().trim();
        const recursive = document.getElementById('content-list-search-recursive')?.checked ?? true;

        if (!recursive || !q) {
            // Remove any injected search results
            const injected = document.getElementById('content-search-results-overlay');
            if (injected) injected.remove();
            // Show original list
            const origList = document.querySelector('.content-file-list');
            if (origList) origList.style.display = '';
            // Simple DOM filter
            const rows = document.querySelectorAll('.content-file-list .content-file-row[data-name]');
            rows.forEach(row => {
                const name = row.dataset.name || '';
                row.style.display = (!q || _matchesGlob(name, q)) ? '' : 'none';
            });
            return;
        }

        // Recursive search with debounce
        clearTimeout(_searchDebounceTimer);
        _searchDebounceTimer = setTimeout(() => _doRecursiveListSearch(q), 250);
    }

    async function _doRecursiveListSearch(q) {
        // Fetch recursive data (cached per path)
        if (_searchRecursiveCache.path !== contentCurrentPath) {
            try {
                const data = await api(`/content/list?path=${encodeURIComponent(contentCurrentPath)}&recursive=true`);
                _searchRecursiveCache = { path: contentCurrentPath, files: (data.files || []).filter(f => !f.is_dir) };
            } catch (e) { return; }
        }

        const allowedCats = CATEGORY_MODES[contentCurrentMode] || [];
        const matches = _searchRecursiveCache.files.filter(f =>
            allowedCats.includes(f.category) && _matchesGlob(f.name.toLowerCase(), q)
        );

        // Hide original list, show results overlay
        const origList = document.querySelector('.content-file-list');
        if (origList) origList.style.display = 'none';

        let overlay = document.getElementById('content-search-results-overlay');
        if (!overlay) {
            overlay = document.createElement('div');
            overlay.id = 'content-search-results-overlay';
            overlay.style.cssText = 'border:1px solid var(--border-subtle);border-radius:8px;background:var(--bg-tertiary);padding:0.5rem;max-height:400px;overflow-y:auto';
            origList?.parentElement?.appendChild(overlay);
        }

        if (!matches.length) {
            overlay.innerHTML = '<div style="padding:0.5rem;color:var(--text-muted);font-size:0.85rem">No matching files found in subfolders</div>';
            return;
        }

        let html = `<div style="font-size:0.75rem;color:var(--text-muted);margin-bottom:0.3rem">${matches.length} result(s) across all subfolders</div>`;
        for (const f of matches.slice(0, 100)) {
            const icon = f.encrypted ? 'ğŸ”' : (CATEGORY_ICONS[f.category] || 'ğŸ“„');
            const relPath = f.path.replace(contentCurrentPath + '/', '');
            const dir = relPath.includes('/') ? relPath.substring(0, relPath.lastIndexOf('/')) + '/' : '';
            html += `<div class="content-file-row" style="cursor:pointer;padding:0.25rem 0.4rem;border-radius:4px"
                onclick="contentPreviewFile('${esc(f.path)}', '${esc(f.name)}', '${esc(f.mime_type || '')}', ${f.encrypted || false})">
                <div class="content-file-icon">${icon}</div>
                <div class="content-file-info">
                    <div class="content-file-name">${dir ? '<span style="color:var(--text-muted);font-size:0.75rem">' + esc(dir) + '</span>' : ''}${esc(f.name)}</div>
                </div>
                <div class="content-file-size">${formatFileSize(f.size || 0)}</div>
            </div>`;
        }
        if (matches.length > 100) {
            html += `<div style="padding:0.3rem;color:var(--text-muted);font-size:0.8rem">â€¦ and ${matches.length - 100} more</div>`;
        }
        overlay.innerHTML = html;
    }

    function contentFilterMediaByName(query) {
        const q = query.toLowerCase().trim();
        const recursive = document.getElementById('content-media-search-recursive')?.checked ?? true;

        if (!recursive || !q) {
            // Remove any injected search results
            const injected = document.getElementById('media-search-results-overlay');
            if (injected) injected.remove();
            // Show original gallery
            const origGrid = document.querySelector('.media-gallery-grid');
            if (origGrid) origGrid.style.display = '';
            // Simple DOM filter
            const items = document.querySelectorAll('.media-gallery-grid .media-gallery-item[data-name]');
            items.forEach(item => {
                const name = item.dataset.name || '';
                item.style.display = (!q || _matchesGlob(name, q)) ? '' : 'none';
            });
            return;
        }

        // Recursive search with debounce
        clearTimeout(_searchDebounceTimer);
        _searchDebounceTimer = setTimeout(() => _doRecursiveMediaSearch(q), 250);
    }

    async function _doRecursiveMediaSearch(q) {
        // Fetch recursive data (cached per path)
        if (_searchRecursiveCache.path !== contentCurrentPath) {
            try {
                const data = await api(`/content/list?path=${encodeURIComponent(contentCurrentPath)}&recursive=true`);
                _searchRecursiveCache = { path: contentCurrentPath, files: (data.files || []).filter(f => !f.is_dir) };
            } catch (e) { return; }
        }

        const mediaCats = CATEGORY_MODES['media'] || [];
        const matches = _searchRecursiveCache.files.filter(f =>
            mediaCats.includes(f.category) && _matchesGlob(f.name.toLowerCase(), q)
        );

        // Hide original grid, show results overlay
        const origGrid = document.querySelector('.media-gallery-grid');
        if (origGrid) origGrid.style.display = 'none';

        let overlay = document.getElementById('media-search-results-overlay');
        if (!overlay) {
            overlay = document.createElement('div');
            overlay.id = 'media-search-results-overlay';
            overlay.className = 'media-gallery-grid';
            overlay.style.cssText = 'margin-top:0.5rem';
            origGrid?.parentElement?.appendChild(overlay);
        }

        if (!matches.length) {
            overlay.innerHTML = '<div style="padding:1rem;color:var(--text-muted);font-size:0.85rem;text-align:center">No matching files found in subfolders</div>';
            return;
        }

        let html = `<div style="grid-column:1/-1;font-size:0.75rem;color:var(--text-muted);margin-bottom:0.2rem">${matches.length} result(s) across all subfolders</div>`;
        for (const f of matches.slice(0, 60)) {
            const isImage = (f.mime_type || '').startsWith('image/') && !f.encrypted;
            const icon = f.encrypted ? 'ğŸ”' : (CATEGORY_ICONS[f.category] || 'ğŸ“');
            const thumbSrc = isImage ? `/api/content/download?path=${encodeURIComponent(f.path)}` : '';
            const relPath = f.path.replace(contentCurrentPath + '/', '');

            html += `<div class="media-gallery-item" data-name="${f.name.toLowerCase()}"
                onclick="contentPreviewFile('${esc(f.path)}', '${esc(f.name)}', '${esc(f.mime_type || '')}', ${f.encrypted || false})"
                style="cursor:pointer">`;
            if (thumbSrc) {
                html += `<div class="media-gallery-thumb" style="background-image:url('${thumbSrc}')"></div>`;
            } else {
                html += `<div class="media-gallery-thumb" style="display:flex;align-items:center;justify-content:center;font-size:2rem;background:var(--bg-tertiary)">${icon}</div>`;
            }
            html += `<div class="media-gallery-label" title="${esc(relPath)}">${esc(f.name)}</div>`;
            html += `</div>`;
        }
        overlay.innerHTML = html;
    }

    function renderContentFiles(data, folderPath) {
        _contentLastRenderData = { data, folderPath };
        const browser = document.getElementById('content-browser');
        const summary = document.getElementById('content-summary');
        const breadcrumb = document.getElementById('content-breadcrumb');
        const files = data.files || [];

        // Summary
        if (summary && data.summary) {
            const s = data.summary;
            summary.textContent = `${s.file_count} files Â· ${s.total_size_human}${s.encrypted_count ? ` Â· ${s.encrypted_count} encrypted` : ''}`;
        }

        // Breadcrumb
        const parts = folderPath.split('/');
        if (breadcrumb) {
            breadcrumb.style.display = parts.length > 1 ? 'block' : 'none';
            let crumbs = '';
            let accumulated = '';
            for (let i = 0; i < parts.length; i++) {
                accumulated += (i > 0 ? '/' : '') + parts[i];
                const isLast = i === parts.length - 1;
                if (isLast) {
                    crumbs += `<span style="color:var(--text-primary);font-weight:600">${esc(parts[i])}</span>`;
                } else {
                    const p = accumulated;
                    crumbs += `<a href="#" onclick="event.preventDefault();contentLoadFolder('${esc(p)}')" style="color:var(--primary)">${esc(parts[i])}</a>`;
                    crumbs += ' <span style="color:var(--text-muted)">â€º</span> ';
                }
            }
            breadcrumb.innerHTML = 'ğŸ“‚ ' + crumbs;
        }

        // Filter by mode
        const allowedCategories = CATEGORY_MODES[contentCurrentMode] || [];
        const filtered = files.filter(f => {
            if (f.is_dir) return true; // always show dirs
            return allowedCategories.includes(f.category);
        });

        // Detect categories present in filtered files and build filter bar
        const categoryCounts = {};
        for (const f of filtered) {
            if (f.is_dir) continue;
            const cat = f.category || 'other';
            categoryCounts[cat] = (categoryCounts[cat] || 0) + 1;
        }
        const detectedCategories = Object.keys(categoryCounts).sort((a, b) => {
            const order = ['document', 'code', 'script', 'config', 'data', 'image', 'video', 'audio', 'archive', 'encrypted', 'other'];
            return order.indexOf(a) - order.indexOf(b);
        });

        // Initialize filter state for current mode if needed
        if (!_contentCategoryFilters[contentCurrentMode]) {
            _contentCategoryFilters[contentCurrentMode] = {};
        }
        const modeFilters = _contentCategoryFilters[contentCurrentMode];
        for (const cat of detectedCategories) {
            if (modeFilters[cat] === undefined) modeFilters[cat] = true; // default ON
        }

        let filterBarHtml = '';
        if (detectedCategories.length > 0) {
            filterBarHtml = '<div id="content-category-filters" style="display:flex;flex-wrap:wrap;gap:0.35rem;margin-bottom:0.75rem;align-items:center">';
            filterBarHtml += '<span style="font-size:0.75rem;color:var(--text-muted);margin-right:0.25rem">Filter:</span>';
            for (const cat of detectedCategories) {
                const color = CATEGORY_COLORS[cat] || '#94a3b8';
                const icon = CATEGORY_ICONS[cat] || 'ğŸ“';
                const isOn = modeFilters[cat] !== false;
                const opacity = isOn ? '1' : '0.35';
                filterBarHtml += `<button class="content-cat-filter-pill" data-cat="${cat}"
                    onclick="contentToggleCategoryFilter('${cat}')"
                    style="display:inline-flex;align-items:center;gap:0.25rem;padding:0.2rem 0.55rem;border-radius:12px;
                           border:1px solid ${color}40;background:${isOn ? color + '18' : 'transparent'};
                           color:${color};font-size:0.75rem;font-weight:500;cursor:pointer;
                           opacity:${opacity};transition:all 0.15s"
                    title="${cat}">${icon} ${cat} <span style="opacity:0.6;font-size:0.7rem">${categoryCounts[cat]}</span></button>`;
            }
            filterBarHtml += '</div>';
        }

        // Apply category filters to filtered list
        const visibleFiles = filtered.filter(f => {
            if (f.is_dir) return true;
            const cat = f.category || 'other';
            return modeFilters[cat] !== false;
        });

        // â”€â”€ Always render upload zone for media mode (before empty-state checks)
        // This ensures contentShowUpload() can always find it in the DOM
        const uploadZoneHtml = (contentCurrentMode === 'media') ? `
            <div id="content-upload-zone" style="display:none;margin-bottom:1rem">
                <div id="content-dropzone" class="content-dropzone" onclick="document.getElementById('content-upload-input').click()">
                    <div style="font-size:2.5rem;margin-bottom:0.5rem;opacity:0.4">ğŸ“¤</div>
                    <p style="font-size:0.9rem;margin-bottom:0.3rem">Drop files here, or click to upload</p>
                    <p style="font-size:0.75rem;color:var(--text-muted)">Images, Videos, Audio, Documents â€” up to 500 MB</p>
                    <input type="file" id="content-upload-input" style="display:none" multiple
                        accept="image/*,video/*,audio/*,application/pdf,text/*,.json,.xml,.csv,.md,.zip,.gz,.tar,.7z,.mkv,.webm,.mov,.avi,.mp3,.mp4,.wav,.flac,.ogg"
                        onchange="contentUploadFiles(event)">
                </div>
                <label style="display:flex;align-items:center;gap:0.5rem;margin-top:0.5rem;font-size:0.8rem;color:var(--text-muted);cursor:pointer">
                    <input type="checkbox" id="content-upload-encrypt-cb"> ğŸ”’ Encrypt after upload
                </label>
                <div id="content-upload-progress" class="content-upload-progress" style="display:none">
                    <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:0.5rem">
                        <div style="font-size:0.85rem;font-weight:500" id="content-upload-label">ğŸ“¤ Uploading...</div>
                        <button onclick="contentCancelUpload()" id="content-upload-cancel-btn"
                            style="background:none;border:1px solid var(--border);border-radius:6px;padding:2px 10px;
                            font-size:0.75rem;color:var(--text-muted);cursor:pointer;transition:all 0.2s"
                            onmouseover="this.style.borderColor='#ef4444';this.style.color='#ef4444'"
                            onmouseout="this.style.borderColor='var(--border)';this.style.color='var(--text-muted)'"
                            >âœ• Cancel</button>
                    </div>
                    <div class="content-upload-progress-bar-track">
                        <div class="content-upload-progress-bar" id="content-upload-bar"></div>
                    </div>
                    <div style="display:flex;justify-content:space-between;font-size:0.75rem;color:var(--text-muted)">
                        <span id="content-upload-detail">0%</span>
                        <span id="content-upload-eta"></span>
                    </div>
                </div>
            </div>` : '';

        // Build the media "Include subfolders" toggle (needs to survive empty-state renders)
        const mediaShowAllHtml = (contentCurrentMode === 'media') ? `<div style="display:flex;align-items:center;gap:0.5rem;margin-bottom:0.5rem">
            <label style="display:inline-flex;align-items:center;gap:0.35rem;font-size:0.78rem;color:var(--text-secondary);cursor:pointer;user-select:none">
                <input type="checkbox" id="content-media-show-all-cb" ${_contentMediaShowAll ? 'checked' : ''}
                    onchange="contentToggleMediaShowAll(this.checked)"
                    style="cursor:pointer">
                ğŸ“‚ Include subfolders
            </label>
            ${_contentMediaShowAll ? '<span style="font-size:0.72rem;color:var(--accent-primary)">âœ“ showing all</span>' : ''}
        </div>` : '';

        // Build search bar HTML for empty-state renders (so recursive subfolder search still works)
        const _searchBarSnippet = contentCurrentMode === 'media'
            ? `<div style="margin-bottom:0.5rem;display:flex;gap:0.5rem;align-items:center">
                <input type="text" id="content-media-search" placeholder="ğŸ” Search mediaâ€¦ (supports * wildcards)"
                    oninput="contentFilterMediaByName(this.value)"
                    style="flex:1;font-size:0.82rem;padding:0.35rem 0.6rem;border:1px solid var(--border-subtle);border-radius:8px;background:var(--bg-tertiary);color:var(--text-primary);box-sizing:border-box">
                <label style="display:flex;align-items:center;gap:0.3rem;cursor:pointer;font-size:0.75rem;color:var(--text-muted);white-space:nowrap" title="Search in all subfolders recursively">
                    <input type="checkbox" id="content-media-search-recursive" checked
                        onchange="contentFilterMediaByName(document.getElementById('content-media-search')?.value||'')"
                        style="width:13px;height:13px;accent-color:var(--accent-primary)"> ğŸ“‚ Subfolders
                </label>
            </div>`
            : (contentCurrentMode === 'docs'
                ? `<div style="margin-bottom:0.5rem;display:flex;gap:0.5rem;align-items:center">
                    <input type="text" id="content-list-search" placeholder="ğŸ” Filter filesâ€¦ (supports * wildcards)"
                        oninput="contentFilterListByName(this.value)"
                        style="flex:1;font-size:0.82rem;padding:0.35rem 0.6rem;border:1px solid var(--border-subtle);border-radius:8px;background:var(--bg-tertiary);color:var(--text-primary);box-sizing:border-box">
                    <label style="display:flex;align-items:center;gap:0.3rem;cursor:pointer;font-size:0.75rem;color:var(--text-muted);white-space:nowrap" title="Search in all subfolders recursively">
                        <input type="checkbox" id="content-list-search-recursive" checked
                            onchange="contentFilterListByName(document.getElementById('content-list-search')?.value||'')"
                            style="width:13px;height:13px;accent-color:var(--accent-primary)"> ğŸ“‚ Subfolders
                    </label>
                </div>`
                : '');

        if (filtered.length === 0 && files.length === 0) {
            browser.innerHTML = uploadZoneHtml + mediaShowAllHtml + _searchBarSnippet + `
                <div class="empty-state" style="padding:2rem">
                    <span style="font-size:2rem;display:block;margin-bottom:0.5rem">ğŸ“­</span>
                    <p>This folder is empty.</p>
                    ${contentCurrentMode === 'media' ? `<button class="btn btn-primary btn-sm" onclick="contentShowUpload()" style="margin-top:0.75rem">ğŸ“¤ Upload a file</button>` : ''}
                </div>`;
            if (contentCurrentMode === 'media') contentInitDragDrop();
            return;
        }

        if (filtered.length === 0) {
            const modeLabel = { docs: 'documents', media: 'media files', archive: 'archives' }[contentCurrentMode];
            browser.innerHTML = uploadZoneHtml + mediaShowAllHtml + _searchBarSnippet + `
                <div class="empty-state" style="padding:2rem">
                    <span style="font-size:2rem;display:block;margin-bottom:0.5rem">ğŸ”</span>
                    <p>No ${modeLabel} in this folder.</p>
                    <p style="font-size:0.8rem;color:var(--text-muted);margin-top:0.5rem">
                        ${files.length} file(s) found in other categories.
                    </p>
                    ${contentCurrentMode === 'media' ? `<button class="btn btn-primary btn-sm" onclick="contentShowUpload()" style="margin-top:0.75rem">ğŸ“¤ Upload a file</button>` : ''}
                </div>`;
            if (contentCurrentMode === 'media') contentInitDragDrop();
            return;
        }

        // Directories first
        const dirs = visibleFiles.filter(f => f.is_dir);
        const regularFiles = visibleFiles.filter(f => !f.is_dir);

        // â”€â”€ Media mode: gallery grid â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        if (contentCurrentMode === 'media') {
            let html = uploadZoneHtml + mediaShowAllHtml + filterBarHtml;

            // Directory cards â€” always show for navigation
            for (const d of dirs) {
                html += `
                    <div class="content-file-row" onclick="contentLoadFolder('${esc(d.path)}')" style="cursor:pointer">
                        <div class="content-file-icon" style="font-size:1.3rem">ğŸ“</div>
                        <div class="content-file-info">
                            <div class="content-file-name" translate="no">${esc(d.name)}/</div>
                            <div class="content-file-meta">${d.file_count} file(s)</div>
                        </div>
                        <div class="content-file-size">${formatFileSize(d.size || 0)}</div>
                    </div>`;
            }

            // Search bar for media â€” always show (recursive search works across subfolders)
            html += `<div style="margin-bottom:0.5rem;display:flex;gap:0.5rem;align-items:center">
                <input type="text" id="content-media-search" placeholder="ğŸ” Search mediaâ€¦ (supports * wildcards)"
                    oninput="contentFilterMediaByName(this.value)"
                    style="flex:1;font-size:0.82rem;padding:0.35rem 0.6rem;border:1px solid var(--border-subtle);border-radius:8px;background:var(--bg-tertiary);color:var(--text-primary);box-sizing:border-box">
                <label style="display:flex;align-items:center;gap:0.3rem;cursor:pointer;font-size:0.75rem;color:var(--text-muted);white-space:nowrap" title="Search in all subfolders recursively">
                    <input type="checkbox" id="content-media-search-recursive" checked
                        onchange="contentFilterMediaByName(document.getElementById('content-media-search')?.value||'')"
                        style="width:13px;height:13px;accent-color:var(--accent-primary)"> ğŸ“‚ Subfolders
                </label>
            </div>`;

            // Gallery grid for files
            html += '<div class="media-gallery-grid" style="margin-top:0.5rem">';
            for (const f of regularFiles) {
                const isImage = (f.mime_type || '').startsWith('image/') && !f.encrypted;
                const isVideo = (f.mime_type || '').startsWith('video/');
                const isAudio = (f.mime_type || '').startsWith('audio/');
                const icon = f.encrypted ? 'ğŸ”' : (CATEGORY_ICONS[f.category] || 'ğŸ“');
                const thumbSrc = isImage ? `/api/content/download?path=${encodeURIComponent(f.path)}` : '';

                const clickFn = f.encrypted
                    ? `contentPreviewEncrypted('${esc(f.path)}', '${esc(f.name)}')`
                    : `contentPreviewFile('${esc(f.path)}', '${esc(f.name)}', ${!!f.has_release})`;

                html += `
                    <div class="media-gallery-item" data-name="${f.name.toLowerCase()}" onclick="${clickFn}" title="${esc(f.name)}\n${f.mime_type || ''} Â· ${formatFileSize(f.size)}">
                        <div class="media-gallery-thumb">
                            ${isImage
                        ? `<img src="${thumbSrc}" alt="${esc(f.name)}" loading="lazy"
                                    onerror="this.style.display='none';this.nextElementSibling.style.display='flex'">
                                   <div style="display:none;align-items:center;justify-content:center;width:100%;height:100%;font-size:1.5rem;opacity:0.4">ğŸ–¼ï¸</div>`
                        : `<div style="display:flex;align-items:center;justify-content:center;width:100%;height:100%;font-size:1.8rem;opacity:0.5">${isVideo ? 'ğŸ¬' : isAudio ? 'ğŸµ' : icon}</div>`
                    }
                        </div>
                        <div class="media-gallery-label" translate="no">
                            <span class="media-gallery-name">${esc(f.name)}</span>
                            <span class="media-gallery-meta">
                                ${f.subfolder ? `<span style="color:var(--text-muted);font-size:0.65rem">ğŸ“‚ ${esc(f.subfolder)}</span>` : ''}
                                <span>${formatFileSize(f.size)}</span>
                                ${f.encrypted ? '<span style="color:#f87171">ğŸ”’</span>' : ''}
                                ${f.has_release ? '<span style="color:#60a5fa" title="Backed up to GitHub Release">â˜ï¸</span>' : ''}
                            </span>
                        </div>
                    </div>`;
            }
            html += '</div>';
            browser.innerHTML = html;

            // Init drag & drop on the dropzone
            contentInitDragDrop();
            return;
        }

        // â”€â”€ Default: list view â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        const totalItems = dirs.length + regularFiles.length;
        const searchBarHtml = totalItems > 0 ? `<div style="margin-bottom:0.5rem;display:flex;gap:0.5rem;align-items:center">
            <input type="text" id="content-list-search" placeholder="ğŸ” Filter filesâ€¦ (supports * wildcards)"
                oninput="contentFilterListByName(this.value)"
                style="flex:1;font-size:0.82rem;padding:0.35rem 0.6rem;border:1px solid var(--border-subtle);border-radius:8px;background:var(--bg-tertiary);color:var(--text-primary);box-sizing:border-box">
            <label style="display:flex;align-items:center;gap:0.3rem;cursor:pointer;font-size:0.75rem;color:var(--text-muted);white-space:nowrap" title="Search in all subfolders recursively">
                <input type="checkbox" id="content-list-search-recursive" checked
                    onchange="contentFilterListByName(document.getElementById('content-list-search')?.value||'')"
                    style="width:13px;height:13px;accent-color:var(--accent-primary)"> ğŸ“‚ Subfolders
            </label>
        </div>` : '';
        let html = filterBarHtml + searchBarHtml + '<div class="content-file-list">';

        for (const d of dirs) {
            html += `
                <div class="content-file-row" data-name="${d.name.toLowerCase()}" onclick="contentLoadFolder('${esc(d.path)}')" style="cursor:pointer">
                    <div class="content-file-icon" style="font-size:1.3rem">ğŸ“</div>
                    <div class="content-file-info">
                        <div class="content-file-name" translate="no">${esc(d.name)}/</div>
                        <div class="content-file-meta">${d.file_count} file(s)</div>
                    </div>
                    <div class="content-file-size">${formatFileSize(d.size || 0)}</div>
                </div>`;
        }

        for (const f of regularFiles) {
            const icon = f.encrypted ? 'ğŸ”' : (CATEGORY_ICONS[f.category] || 'ğŸ“');
            const catColor = CATEGORY_COLORS[f.category] || '#94a3b8';
            const encOriginal = f.covault_meta ? f.covault_meta.filename : '';
            const clickFn = f.encrypted
                ? `contentPreviewEncrypted('${esc(f.path)}', '${esc(f.name)}')`
                : `contentPreviewFile('${esc(f.path)}', '${esc(f.name)}', ${!!f.has_release})`;
            const escapedPath = esc(f.path).replace(/'/g, "\\'");
            const escapedName = esc(f.name).replace(/'/g, "\\'");

            html += `
                <div class="content-file-row" data-name="${f.name.toLowerCase()}" data-file-path="${esc(f.path)}" onclick="${clickFn}" style="cursor:pointer">
                    <div class="content-file-icon" style="font-size:1.3rem">${icon}</div>
                    <div class="content-file-info">
                        <div class="content-file-name" translate="no">${esc(f.name)}</div>
                        <div class="content-file-meta">
                            <span class="content-cat-badge" style="background:${catColor}20;color:${catColor};border:1px solid ${catColor}40">
                                ${f.encrypted ? 'encrypted' : f.category}
                            </span>
                            ${encOriginal ? `<span style="color:var(--text-muted)">â† ${esc(encOriginal)}</span>` : ''}
                            <span style="color:var(--text-muted)">${f.mime_type || ''}</span>
                        </div>
                    </div>
                    <div class="content-file-actions">
                        <button class="btn btn-secondary btn-sm" onclick="event.stopPropagation();contentRenameFile('${escapedPath}', '${escapedName}')" title="Rename">âœï¸</button>
                        <button class="btn btn-secondary btn-sm" onclick="event.stopPropagation();contentMoveFile('${escapedPath}', '${escapedName}')" title="Move">ğŸ“‚</button>
                        <button class="btn btn-secondary btn-sm" onclick="event.stopPropagation();${clickFn}" title="Preview">ğŸ‘ï¸</button>
                        ${f.encrypted
                    ? `<button class="btn btn-secondary btn-sm" onclick="event.stopPropagation();contentDecryptFile('${esc(f.path)}', ${!!f.has_release})" title="Decrypt to disk">ğŸ”“</button>`
                    : `<button class="btn btn-secondary btn-sm" onclick="event.stopPropagation();contentEncryptFile('${esc(f.path)}', ${!!f.has_release})" title="Encrypt">ğŸ”’</button>`
                }
                        ${!f.encrypted
                    ? `<a class="btn btn-secondary btn-sm" href="/api/content/download?path=${encodeURIComponent(f.path)}" title="Download" target="_blank" onclick="event.stopPropagation()">â¬‡ï¸</a>`
                    : ''
                }
                        <button class="btn btn-secondary btn-sm" onclick="event.stopPropagation();contentDeleteFile('${esc(f.path)}', '${esc(f.name)}', false, ${!!f.has_release})" title="Delete" style="color:var(--error)">ğŸ—‘ï¸</button>
                    </div>
                    <div class="content-file-size">${formatFileSize(f.size)}</div>
                </div>`;
        }

        html += '</div>';
        browser.innerHTML = html;
    }


    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  Actions
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    async function contentCreateFolder(name) {
        try {
            await api('/content/create-folder', {
                method: 'POST',
                body: JSON.stringify({ name }),
            });
            toast(`Created folder: ${name}/`, 'success');
            contentLoaded = false;
            await loadContentTab();
        } catch (e) {
            toast(`Failed: ${e.message}`, 'error');
        }
    }

    let _ctEncryptPath = '';

    function contentEncryptFile(path, hasRelease) {
        _ctEncryptPath = path || previewCurrentPath;
        // Check if enc key is configured
        if (!encKeyConfigured) {
            contentEncKeySetup();
            return;
        }

        const modal = document.getElementById('ct-encrypt-modal');
        const info = document.getElementById('ct-encrypt-modal-info');
        const status = document.getElementById('ct-encrypt-modal-status');
        const confirmBtn = document.getElementById('ct-encrypt-confirm-btn');
        const releaseWarn = document.getElementById('ct-encrypt-modal-release-warn');

        info.innerHTML = `File: <code style="font-size:0.82rem">${esc(_ctEncryptPath)}</code>`;
        status.style.display = 'none';
        if (releaseWarn) releaseWarn.style.display = hasRelease ? 'block' : 'none';
        confirmBtn.disabled = false;
        confirmBtn.textContent = 'ğŸ”’ Encrypt';
        modal.style.display = 'flex';
    }

    async function contentDoEncryptConfirm() {
        const modal = document.getElementById('ct-encrypt-modal');
        const status = document.getElementById('ct-encrypt-modal-status');
        const confirmBtn = document.getElementById('ct-encrypt-confirm-btn');

        confirmBtn.disabled = true;
        confirmBtn.textContent = 'â³ Encryptingâ€¦';
        status.style.display = 'block';
        status.innerHTML = '<span class="spinner"></span> Encryptingâ€¦';

        try {
            const result = await api('/content/encrypt', {
                method: 'POST',
                body: JSON.stringify({ path: _ctEncryptPath, delete_original: true }),
            });

            if (result.error) {
                status.innerHTML = `<span style="color:var(--error)">âŒ ${esc(result.error)}</span>`;
                confirmBtn.disabled = false;
                confirmBtn.textContent = 'ğŸ”’ Encrypt';
                return;
            }

            modal.style.display = 'none';
            toast('Encrypted successfully!', 'success');
            contentLoaded = false;
            const newPath = result.output;
            const newName = newPath.split('/').pop();
            setTimeout(() => contentPreviewEncrypted(newPath, newName), 300);
        } catch (e) {
            status.innerHTML = `<span style="color:var(--error)">âŒ ${esc(e.message)}</span>`;
            confirmBtn.disabled = false;
            confirmBtn.textContent = 'ğŸ”’ Encrypt';
        }
    }

    let _ctDecryptPath = '';

    function contentDecryptFile(path, hasRelease) {
        _ctDecryptPath = path || previewCurrentPath;

        const modal = document.getElementById('ct-decrypt-modal');
        const info = document.getElementById('ct-decrypt-modal-info');
        const status = document.getElementById('ct-decrypt-modal-status');
        const confirmBtn = document.getElementById('ct-decrypt-confirm-btn');
        const releaseWarn = document.getElementById('ct-decrypt-modal-release-warn');

        info.innerHTML = `File: <code style="font-size:0.82rem">${esc(_ctDecryptPath)}</code>`;
        status.style.display = 'none';
        if (releaseWarn) releaseWarn.style.display = hasRelease ? 'block' : 'none';
        confirmBtn.disabled = false;
        confirmBtn.textContent = 'ğŸ”“ Decrypt';
        modal.style.display = 'flex';
    }

    async function contentDoDecryptConfirm() {
        const modal = document.getElementById('ct-decrypt-modal');
        const status = document.getElementById('ct-decrypt-modal-status');
        const confirmBtn = document.getElementById('ct-decrypt-confirm-btn');

        confirmBtn.disabled = true;
        confirmBtn.textContent = 'â³ Decryptingâ€¦';
        status.style.display = 'block';
        status.innerHTML = '<span class="spinner"></span> Decryptingâ€¦';

        try {
            const result = await api('/content/decrypt', {
                method: 'POST',
                body: JSON.stringify({ path: _ctDecryptPath, delete_encrypted: true }),
            });

            if (result.error) {
                status.innerHTML = `<span style="color:var(--error)">âŒ ${esc(result.error)}</span>`;
                confirmBtn.disabled = false;
                confirmBtn.textContent = 'ğŸ”“ Decrypt';
                return;
            }

            modal.style.display = 'none';
            toast('Decrypted successfully!', 'success');
            contentLoaded = false;
            const newPath = result.output;
            const newName = newPath.split('/').pop();
            setTimeout(() => contentPreviewFile(newPath, newName), 300);
        } catch (e) {
            status.innerHTML = `<span style="color:var(--error)">âŒ ${esc(e.message)}</span>`;
            confirmBtn.disabled = false;
            confirmBtn.textContent = 'ğŸ”“ Decrypt';
        }
    }

    let _ctDeletePath = '';
    let _ctDeleteName = '';
    let _ctDeleteFromPreview = false;

    function contentDeleteFile(path, name, fromPreview, hasRelease) {
        _ctDeletePath = path || previewCurrentPath;
        _ctDeleteName = name || previewCurrentName;
        _ctDeleteFromPreview = !!fromPreview;

        const modal = document.getElementById('ct-delete-modal');
        const info = document.getElementById('ct-delete-modal-info');
        const status = document.getElementById('ct-delete-modal-status');
        const confirmBtn = document.getElementById('ct-delete-confirm-btn');
        const releaseWarn = document.getElementById('ct-delete-modal-release-warn');

        info.innerHTML = `File: <code style="font-size:0.82rem">${esc(_ctDeleteName)}</code>`;
        status.style.display = 'none';
        if (releaseWarn) releaseWarn.style.display = hasRelease ? 'block' : 'none';
        confirmBtn.disabled = false;
        confirmBtn.textContent = 'ğŸ—‘ï¸ Delete';
        modal.style.display = 'flex';
    }

    async function contentDoDeleteConfirm() {
        const modal = document.getElementById('ct-delete-modal');
        const status = document.getElementById('ct-delete-modal-status');
        const confirmBtn = document.getElementById('ct-delete-confirm-btn');
        const releaseWarn = document.getElementById('ct-delete-modal-release-warn');
        const releaseCheckbox = document.getElementById('ct-delete-also-release');
        const alsoDeleteRelease = releaseWarn && releaseWarn.style.display !== 'none'
            && releaseCheckbox && releaseCheckbox.checked;

        confirmBtn.disabled = true;
        confirmBtn.textContent = 'â³ Deletingâ€¦';
        status.style.display = 'block';
        status.innerHTML = '<span class="spinner"></span> Deletingâ€¦';

        try {
            if (alsoDeleteRelease) {
                status.innerHTML = '<span class="spinner"></span> Removing release artifactâ€¦';
                await api('/backup/delete-release', {
                    method: 'POST',
                    body: JSON.stringify({ path: _ctDeletePath }),
                });
            }

            status.innerHTML = '<span class="spinner"></span> Deleting fileâ€¦';
            await api('/content/delete', {
                method: 'POST',
                body: JSON.stringify({ path: _ctDeletePath }),
            });
            modal.style.display = 'none';
            toast(`Deleted: ${_ctDeleteName}`, 'success');

            if (_ctDeleteFromPreview) {
                contentClosePreview();
            } else {
                await contentLoadFolder(contentCurrentPath);
            }
        } catch (e) {
            status.innerHTML = `<span style="color:var(--error)">âŒ ${esc(e.message)}</span>`;
            confirmBtn.disabled = false;
            confirmBtn.textContent = 'ğŸ—‘ï¸ Delete';
        }
    }

    async function contentDeleteRelease(path, name) {
        if (!confirm(`Remove the GitHub Release artifact for "${name}"?\n\nThis only removes the remote artifact â€” the local file stays.`)) {
            return;
        }
        try {
            toast('Removing release artifactâ€¦', 'success');
            await api('/backup/delete-release', {
                method: 'POST',
                body: JSON.stringify({ path }),
            });
            toast('Release artifact removed', 'success');
            await contentLoadFolder(contentCurrentPath);
        } catch (e) {
            toast(`Failed: ${e.message}`, 'error');
        }
    }

    async function contentUploadToRelease(path) {
        try {
            toast('Uploading to releaseâ€¦', 'success');
            const result = await api('/backup/upload-release', {
                method: 'POST',
                body: JSON.stringify({ path }),
            });
            toast(result.message || 'Upload started', 'success');
            setTimeout(() => contentLoadFolder(contentCurrentPath), 1500);
        } catch (e) {
            toast(`Upload failed: ${e.message}`, 'error');
        }
    }
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  File Preview + Edit
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    let previewRawMode = true;    // true = raw text, false = rendered markdown
    let previewEditMode = false;  // true = editing
    let previewOrigContent = '';  // snapshot for discard
    let previewCurrentPath = '';
    let previewCurrentName = '';
    let previewCurrentHasRelease = false;
    let previewIsText = false;

    /**
     * Attach delegated click handlers for anchor links and doc links
     * in the rendered markdown preview.
     */
    function _attachPreviewLinkHandlers(container) {
        container.addEventListener('click', (e) => {
            const anchor = e.target.closest('a[data-anchor]');
            if (anchor) {
                e.preventDefault();
                const targetId = anchor.dataset.anchor;
                const el = document.getElementById(targetId);
                if (el) {
                    el.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
                return;
            }
            const docLink = e.target.closest('a[data-doclink]');
            if (docLink) {
                e.preventDefault();
                let href = docLink.dataset.doclink;
                // Strip anchor part from href (file.md#section â†’ file.md)
                const hashIdx = href.indexOf('#');
                if (hashIdx >= 0) href = href.substring(0, hashIdx);
                if (!href) return; // was just "#" with no file

                // Resolve relative path against current file's directory
                const currentDir = previewCurrentPath.split('/').slice(0, -1).join('/');
                let resolved = href;
                if (href.startsWith('./')) {
                    resolved = currentDir ? currentDir + '/' + href.substring(2) : href.substring(2);
                } else if (href.startsWith('../')) {
                    const parts = currentDir.split('/');
                    let rel = href;
                    while (rel.startsWith('../') && parts.length > 0) {
                        parts.pop();
                        rel = rel.substring(3);
                    }
                    resolved = parts.length ? parts.join('/') + '/' + rel : rel;
                } else if (!href.includes('/')) {
                    // bare filename like "other.md" â€” same directory
                    resolved = currentDir ? currentDir + '/' + href : href;
                }

                const fileName = resolved.split('/').pop();
                // Update folder context so "Back" returns to the right folder
                const fileDir = resolved.split('/').slice(0, -1).join('/');
                if (fileDir && fileDir !== contentCurrentPath) {
                    contentCurrentPath = fileDir;
                }
                if (resolved.endsWith('.enc')) {
                    contentPreviewEncrypted(resolved, fileName);
                } else {
                    contentPreviewFile(resolved, fileName);
                }
                return;
            }
        });
    }

    async function contentPreviewFile(path, name, hasRelease) {
        // Only reset edit mode if opening a different file
        if (path !== previewCurrentPath) {
            previewEditMode = false;
        }
        previewCurrentPath = path;
        previewCurrentName = name;
        previewCurrentHasRelease = !!hasRelease;
        contentUpdateHash();

        const browser = document.getElementById('content-browser');

        browser.innerHTML = `
            <div class="content-preview-panel">
                <div class="content-preview-header">
                    <button class="btn btn-secondary btn-sm" onclick="contentClosePreview()" title="Back to files">â† Back</button>
                    <span class="content-preview-title" id="content-preview-filename" translate="no">${esc(name)}</span>
                    <button class="btn btn-secondary btn-sm" onclick="contentRenameFile()" title="Rename" style="font-size:0.7rem;padding:0.15rem 0.4rem">âœï¸</button>
                    <div id="content-preview-toggle" style="display:none;gap:4px"></div>
                    <div style="flex:1"></div>
                    <div id="content-preview-actions" style="display:flex;gap:4px;align-items:center">
                        ${hasRelease ? '<span style="font-size:0.75rem;color:#60a5fa;background:rgba(96,165,250,0.12);border:1px solid rgba(96,165,250,0.3);border-radius:6px;padding:0.1rem 0.45rem" title="Backed up to GitHub Release">â˜ï¸ release</span>' : ''}
                        ${hasRelease ? '<button class="btn btn-secondary btn-sm" onclick="contentDeleteRelease(previewCurrentPath, previewCurrentName)" title="Delete release artifact" style="color:#f59e0b">â˜ï¸âœ•</button>' : ''}
                        ${!hasRelease ? '<button class="btn btn-secondary btn-sm" id="content-btn-upload-release" onclick="contentUploadToRelease(previewCurrentPath)" title="Upload to Release" style="color:#60a5fa">â¬†ï¸ Release</button>' : ''}
                        <button class="btn btn-secondary btn-sm" onclick="contentEncryptFromPreview()" title="Encrypt">ğŸ”’ Encrypt</button>
                        <button class="btn btn-secondary btn-sm" id="content-btn-move" onclick="contentMoveFile()" title="Move toâ€¦">ğŸ“‚ Move</button>
                        <button class="btn btn-secondary btn-sm" onclick="contentDeleteFromPreview()" title="Delete" style="color:var(--error)">ğŸ—‘ï¸ Delete</button>
                    </div>
                </div>
                <div id="content-preview-body" class="content-preview-body" translate="no">
                    <p class="empty-state"><span class="spinner"></span> Loading previewâ€¦</p>
                </div>
                <div id="content-preview-edit-bar" style="display:none;padding-top:var(--space-sm);border-top:1px solid var(--border-subtle);gap:0.5rem;justify-content:flex-end">
                </div>
            </div>`;

        try {
            const data = await api(`/content/preview?path=${encodeURIComponent(path)}`);

            // Update release status from API (authoritative source)
            if (data.has_release && !previewCurrentHasRelease) {
                previewCurrentHasRelease = true;
                const actions = document.getElementById('content-preview-actions');
                if (actions) {
                    // Remove upload button, add badge + delete button
                    const uploadBtn = document.getElementById('content-btn-upload-release');
                    if (uploadBtn) uploadBtn.remove();
                    if (!actions.querySelector('[data-release-badge]')) {
                        actions.insertAdjacentHTML('afterbegin',
                            '<button class="btn btn-secondary btn-sm" onclick="contentDeleteRelease(previewCurrentPath, previewCurrentName)" title="Delete release artifact" style="color:#f59e0b" data-release-badge>â˜ï¸âœ•</button>' +
                            '<span style="font-size:0.75rem;color:#60a5fa;background:rgba(96,165,250,0.12);border:1px solid rgba(96,165,250,0.3);border-radius:6px;padding:0.1rem 0.45rem" title="Backed up to GitHub Release" data-release-badge>â˜ï¸ release</span>'
                        );
                    }
                }
            } else if (!data.has_release) {
                previewCurrentHasRelease = false;
            }

            const body = document.getElementById('content-preview-body');
            const toggle = document.getElementById('content-preview-toggle');
            const editBar = document.getElementById('content-preview-edit-bar');
            previewIsText = (data.type === 'text' || data.type === 'markdown');

            if (data.type === 'image') {
                body.innerHTML = `<div style="text-align:center;padding:1rem">
                    <img src="${data.url}" alt="${esc(name)}" style="max-width:100%;max-height:70vh;border-radius:var(--radius-sm)">
                </div>`;

            } else if (data.type === 'video') {
                // Video player with fallback + optimize option
                const canPlayNatively = ['video/mp4', 'video/webm'].includes(data.mime);
                body.innerHTML = `
                    <div style="text-align:center;padding:1rem">
                        <video id="content-video-player" controls ${!canPlayNatively ? 'style="display:none"' : ''}
                            style="max-width:100%;max-height:55vh;border-radius:var(--radius-sm);background:#000">
                            <source src="${data.url}">
                        </video>
                        <div id="content-video-fallback" style="${canPlayNatively ? 'display:none;' : ''}padding:1.5rem">
                            <div style="font-size:2.5rem;margin-bottom:0.5rem;opacity:0.5">ğŸ¬</div>
                            <p style="font-size:0.85rem;color:var(--text-secondary);margin-bottom:0.75rem">
                                ${canPlayNatively ? 'Cannot play this video.' : `<strong>${esc(name)}</strong> (${data.mime}) can't play in browser.`}
                            </p>
                            <a href="${data.url}" download="${esc(name)}" class="btn btn-secondary btn-sm">
                                â¬‡ï¸ Download (${formatFileSize(data.size)})
                            </a>
                        </div>
                        <div style="margin-top:1rem;padding:0.75rem;background:var(--bg-inset);border-radius:var(--radius-sm);border:1px solid var(--border-subtle)">
                            <div style="display:flex;align-items:center;gap:0.5rem;justify-content:center;flex-wrap:wrap">
                                <span style="font-size:0.8rem;color:var(--text-secondary)">
                                    ${formatFileSize(data.size)} Â· ${data.mime}
                                </span>
                                <a href="${data.url}" download="${esc(name)}" class="btn btn-secondary btn-sm">â¬‡ï¸ Download</a>
                            </div>
                        </div>
                    </div>`;
                // If browser can't decode, show download fallback
                if (canPlayNatively) {
                    const videoEl = document.getElementById('content-video-player');
                    if (videoEl) {
                        videoEl.addEventListener('error', () => {
                            videoEl.style.display = 'none';
                            const fb = document.getElementById('content-video-fallback');
                            if (fb) fb.style.display = 'block';
                        }, true);
                    }
                }

            } else if (data.type === 'audio') {
                // Audio player
                body.innerHTML = `
                    <div style="text-align:center;width:100%;padding:2rem">
                        <div style="font-size:3rem;margin-bottom:1rem;opacity:0.4">ğŸµ</div>
                        <p style="font-size:0.9rem;color:var(--text-secondary);margin-bottom:1rem">${esc(name)}</p>
                        <audio controls style="width:100%;max-width:450px">
                            <source src="${data.url}" type="${data.mime}">
                        </audio>
                        <div style="margin-top:1rem">
                            <a href="${data.url}" download="${esc(name)}" class="btn btn-secondary btn-sm">â¬‡ï¸ Download (${formatFileSize(data.size)})</a>
                        </div>
                    </div>`;

            } else if (data.type === 'markdown' || data.type === 'text') {
                previewOrigContent = data.content;

                // Build toggle buttons
                toggle.style.display = 'flex';
                let toggleHtml = '';
                if (data.type === 'markdown') {
                    toggleHtml += `
                        <button class="btn btn-sm ${previewRawMode && !previewEditMode ? 'btn-primary' : 'btn-secondary'}" onclick="contentSetPreviewMode('raw')">Raw</button>
                        <button class="btn btn-sm ${!previewRawMode && !previewEditMode ? 'btn-primary' : 'btn-secondary'}" onclick="contentSetPreviewMode('preview')">Preview</button>`;
                }
                toggleHtml += `<button class="btn btn-sm ${previewEditMode ? 'btn-primary' : 'btn-secondary'}" onclick="contentSetPreviewMode('edit')">âœï¸ Edit</button>`;
                toggle.innerHTML = toggleHtml;

                if (previewEditMode) {
                    body.innerHTML = `<textarea id="content-editor" class="content-editor" spellcheck="false">${esc(data.content)}</textarea>`;
                    editBar.style.display = 'flex';
                    editBar.innerHTML = `
                        <button class="btn btn-secondary btn-sm" onclick="contentDiscardEdit()">â†©ï¸ Discard</button>
                        <button class="btn btn-primary btn-sm" onclick="contentSaveEdit()">ğŸ’¾ Save</button>`;
                } else if (data.type === 'markdown' && !previewRawMode) {
                    body.innerHTML = `<div class="content-preview-rendered notranslate" translate="no"><div style="display:flex;justify-content:flex-end;margin-bottom:0.5rem"><button class="btn btn-secondary btn-sm" style="font-size:0.7rem;padding:0.15rem 0.5rem" onclick="contentToggleTranslate(this)">ğŸŒ Translate</button></div>${renderMarkdown(data.content)}</div>`;
                    _attachPreviewLinkHandlers(body);
                    editBar.style.display = 'none';
                } else {
                    body.innerHTML = `<pre class="content-preview-code notranslate" translate="no"><code>${esc(data.content)}</code></pre>`;
                    editBar.style.display = 'none';
                }

                if (data.truncated) {
                    body.innerHTML += `<p style="color:var(--warning);font-size:0.8rem;padding:0.5rem">âš ï¸ File truncated (showing first 512 KB of ${formatFileSize(data.size)})</p>`;
                }

            } else if (data.type === 'binary') {
                body.innerHTML = `<div class="empty-state" style="padding:2rem">
                    <span style="font-size:2rem">ğŸ“¦</span>
                    <p>Binary file â€” cannot preview</p>
                    <p style="font-size:0.8rem;color:var(--text-muted)">${data.mime || 'unknown type'}</p>
                    <a class="btn btn-primary btn-sm" href="/api/content/download?path=${encodeURIComponent(path)}&download=1" style="margin-top:0.75rem">â¬‡ï¸ Download</a>
                </div>`;
            }
        } catch (e) {
            document.getElementById('content-preview-body').innerHTML =
                `<p class="empty-state" style="color:var(--error)">âŒ ${esc(e.message)}</p>`;
        }
    }

    function contentSetPreviewMode(mode) {
        if (mode === 'edit') {
            previewEditMode = true;
        } else {
            previewEditMode = false;
            previewRawMode = (mode === 'raw');
        }
        contentPreviewFile(previewCurrentPath, previewCurrentName);
        contentUpdateHash();
    }


    // â”€â”€ Encrypted file preview â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    let encPreviewKey = '';  // key used for this preview session
    let encPreviewContent = '';  // decrypted text content (for edit)

    async function contentPreviewEncrypted(path, name, overrideKey) {
        previewCurrentPath = path;
        previewCurrentName = name;
        if (overrideKey) encPreviewKey = overrideKey;
        contentUpdateHash();

        const browser = document.getElementById('content-browser');

        browser.innerHTML = `
            <div class="content-preview-panel">
                <div class="content-preview-header">
                    <button class="btn btn-secondary btn-sm" onclick="contentClosePreview()">â† Back</button>
                    <span class="content-preview-title" id="content-preview-filename" translate="no">ğŸ” ${esc(name)}</span>
                    <button class="btn btn-secondary btn-sm" onclick="contentRenameFile()" title="Rename" style="font-size:0.7rem;padding:0.15rem 0.4rem">âœï¸</button>
                    <div id="content-preview-toggle" style="display:none;gap:4px"></div>
                    <div style="flex:1"></div>
                    <div id="content-preview-actions" style="display:flex;gap:4px">
                        <button class="btn btn-secondary btn-sm" onclick="contentDecryptFile('${esc(path)}')" title="Decrypt to disk">ğŸ”“ Decrypt</button>
                        <button class="btn btn-secondary btn-sm" onclick="contentMoveFile()" title="Move toâ€¦">ğŸ“‚ Move</button>
                        <button class="btn btn-secondary btn-sm" onclick="contentDeleteFromPreview()" title="Delete" style="color:var(--error)">ğŸ—‘ï¸ Delete</button>
                    </div>
                </div>
                <div id="content-preview-body" class="content-preview-body" translate="no">
                    <p class="empty-state"><span class="spinner"></span> Decrypting for previewâ€¦</p>
                </div>
                <div id="content-preview-edit-bar" style="display:none;padding-top:var(--space-sm);border-top:1px solid var(--border-subtle);gap:0.5rem;justify-content:flex-end">
                </div>
            </div>`;

        try {
            const payload = { path };
            const keyToUse = overrideKey || encPreviewKey || '';
            if (keyToUse) payload.key = keyToUse;

            const resp = await fetch('/api/content/preview-encrypted', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload),
            });
            const data = await resp.json();

            const body = document.getElementById('content-preview-body');
            const toggle = document.getElementById('content-preview-toggle');
            const editBar = document.getElementById('content-preview-edit-bar');

            if (!resp.ok) {
                if (data.wrong_key || data.needs_key) {
                    body.innerHTML = `
                        <div style="padding:2rem;text-align:center">
                            <span style="font-size:2rem;display:block;margin-bottom:1rem">ğŸ”‘</span>
                            <p style="color:var(--text-secondary);margin-bottom:1rem">
                                ${data.needs_key
                            ? 'No encryption key configured.'
                            : 'The configured key does not match this file.'}
                            </p>
                            <p style="color:var(--text-muted);font-size:0.85rem;margin-bottom:1.5rem">
                                Enter the key that was used to encrypt this file:
                            </p>
                            <div style="display:flex;gap:0.5rem;justify-content:center;max-width:500px;margin:0 auto">
                                <input type="password" id="enc-preview-key" placeholder="Decryption keyâ€¦"
                                       style="flex:1;font-family:monospace"
                                       onkeydown="if(event.key==='Enter')contentTryEncPreviewKey('${esc(path)}','${esc(name)}')">
                                <button class="btn btn-primary btn-sm"
                                        onclick="contentTryEncPreviewKey('${esc(path)}','${esc(name)}')">
                                    ğŸ”“ Unlock
                                </button>
                            </div>
                        </div>`;
                    return;
                }
                throw new Error(data.error || 'Preview failed');
            }

            // Successfully decrypted
            const originalLabel = data.original_name ? ` (${esc(data.original_name)})` : '';
            previewIsText = (data.type === 'text' || data.type === 'markdown');

            if (data.type === 'image') {
                body.innerHTML = `<div style="text-align:center;padding:1rem">
                    <p style="color:var(--text-muted);font-size:0.8rem;margin-bottom:0.5rem">ğŸ”“ Decrypted preview${originalLabel}</p>
                    <img src="${data.url}" alt="${esc(name)}" style="max-width:100%;max-height:70vh;border-radius:var(--radius-sm)">
                </div>`;

            } else if (data.type === 'video') {
                body.innerHTML = `
                    <div style="text-align:center;padding:1rem">
                        <p style="color:var(--text-muted);font-size:0.8rem;margin-bottom:0.5rem">ğŸ”“ Decrypted preview${originalLabel} Â· ${formatFileSize(data.size)}</p>
                        <video id="content-video-player" controls
                            style="max-width:100%;max-height:65vh;border-radius:var(--radius-sm);background:#000">
                            <source src="${data.url}">
                        </video>
                    </div>`;

            } else if (data.type === 'audio') {
                body.innerHTML = `
                    <div style="text-align:center;width:100%;padding:2rem">
                        <div style="font-size:3rem;margin-bottom:1rem;opacity:0.4">ğŸµ</div>
                        <p style="color:var(--text-muted);font-size:0.8rem;margin-bottom:0.5rem">ğŸ”“ Decrypted preview${originalLabel}</p>
                        <p style="font-size:0.9rem;color:var(--text-secondary);margin-bottom:1rem">${esc(name)}</p>
                        <audio controls style="width:100%;max-width:450px">
                            <source src="${data.url}" type="${data.mime}">
                        </audio>
                    </div>`;

            } else if (data.type === 'markdown' || data.type === 'text') {
                encPreviewContent = data.content;

                // Show toggles
                toggle.style.display = 'flex';
                let toggleHtml = '';
                if (data.type === 'markdown') {
                    toggleHtml += `
                        <button class="btn btn-sm ${previewRawMode && !previewEditMode ? 'btn-primary' : 'btn-secondary'}" onclick="contentSetEncPreviewMode('raw')">Raw</button>
                        <button class="btn btn-sm ${!previewRawMode && !previewEditMode ? 'btn-primary' : 'btn-secondary'}" onclick="contentSetEncPreviewMode('preview')">Preview</button>`;
                }
                toggleHtml += `<button class="btn btn-sm ${previewEditMode ? 'btn-primary' : 'btn-secondary'}" onclick="contentSetEncPreviewMode('edit')">âœï¸ Edit</button>`;
                toggle.innerHTML = toggleHtml;

                if (previewEditMode) {
                    body.innerHTML = `<textarea id="content-editor" class="content-editor" spellcheck="false">${esc(data.content)}</textarea>`;
                    editBar.style.display = 'flex';
                    editBar.innerHTML = `
                        <button class="btn btn-secondary btn-sm" onclick="contentDiscardEncEdit()">â†©ï¸ Discard</button>
                        <button class="btn btn-primary btn-sm" onclick="contentSaveEncEdit()">ğŸ’¾ Save</button>`;
                } else if (data.type === 'markdown' && !previewRawMode) {
                    body.innerHTML = `
                        <p style="color:var(--text-muted);font-size:0.8rem;padding:0.5rem 1rem;border-bottom:1px solid var(--border-subtle)">
                            ğŸ”“ Decrypted${originalLabel} Â· ${formatFileSize(data.size)} Â· ${data.line_count} lines
                        </p>
                        <div class="content-preview-rendered notranslate" translate="no"><div style="display:flex;justify-content:flex-end;margin-bottom:0.5rem"><button class="btn btn-secondary btn-sm" style="font-size:0.7rem;padding:0.15rem 0.5rem" onclick="contentToggleTranslate(this)">ğŸŒ Translate</button></div>${renderMarkdown(data.content)}</div>`;
                    _attachPreviewLinkHandlers(body);
                    editBar.style.display = 'none';
                } else {
                    body.innerHTML = `
                        <p style="color:var(--text-muted);font-size:0.8rem;padding:0.5rem 1rem;border-bottom:1px solid var(--border-subtle)">
                            ğŸ”“ Decrypted${originalLabel} Â· ${formatFileSize(data.size)} Â· ${data.line_count} lines
                        </p>
                        <pre class="content-preview-code notranslate" translate="no"><code>${esc(data.content)}</code></pre>`;
                    editBar.style.display = 'none';
                }

                if (data.truncated) {
                    body.innerHTML += `<p style="color:var(--warning);font-size:0.8rem;padding:0.5rem">âš ï¸ Truncated (first 512 KB of ${formatFileSize(data.size)})</p>`;
                }

            } else if (data.type === 'binary') {
                body.innerHTML = `<div class="empty-state" style="padding:2rem">
                    <span style="font-size:2rem">ğŸ“¦</span>
                    <p>ğŸ”“ Decrypted${originalLabel}</p>
                    <p style="font-size:0.8rem;color:var(--text-muted)">${data.mime || 'unknown type'} Â· ${formatFileSize(data.size)}</p>
                    <p style="font-size:0.8rem;color:var(--text-muted)">Binary content â€” use Decrypt to write to disk</p>
                </div>`;
            }

        } catch (e) {
            const body = document.getElementById('content-preview-body');
            if (body) body.innerHTML = `<p class="empty-state" style="color:var(--error)">âŒ ${esc(e.message)}</p>`;
        }
    }

    function contentSetEncPreviewMode(mode) {
        if (mode === 'edit') {
            previewEditMode = true;
        } else {
            previewEditMode = false;
            previewRawMode = (mode === 'raw');
        }
        contentPreviewEncrypted(previewCurrentPath, previewCurrentName);
    }

    function contentDiscardEncEdit() {
        previewEditMode = false;
        contentPreviewEncrypted(previewCurrentPath, previewCurrentName);
    }

    async function contentSaveEncEdit() {
        const editor = document.getElementById('content-editor');
        if (!editor) return;

        try {
            await api('/content/save-encrypted', {
                method: 'POST',
                body: JSON.stringify({
                    path: previewCurrentPath,
                    content: editor.value,
                    key: encPreviewKey || undefined,
                }),
            });
            toast('File saved and re-encrypted!', 'success');
            previewEditMode = false;
            contentPreviewEncrypted(previewCurrentPath, previewCurrentName);
        } catch (e) {
            toast(`Save failed: ${e.message}`, 'error');
        }
    }

    function contentTryEncPreviewKey(path, name) {
        const input = document.getElementById('enc-preview-key');
        const key = input ? input.value.trim() : '';
        if (!key) { toast('Enter a key.', 'warning'); return; }
        encPreviewKey = key;
        contentPreviewEncrypted(path, name, key);
    }

    async function contentSaveEdit() {
        const editor = document.getElementById('content-editor');
        if (!editor) return;

        try {
            await api('/content/save', {
                method: 'POST',
                body: JSON.stringify({ path: previewCurrentPath, content: editor.value }),
            });
            toast('File saved!', 'success');
            previewOrigContent = editor.value;
            previewEditMode = false;
            contentPreviewFile(previewCurrentPath, previewCurrentName);
        } catch (e) {
            toast(`Save failed: ${e.message}`, 'error');
        }
    }

    function contentDiscardEdit() {
        previewEditMode = false;
        contentPreviewFile(previewCurrentPath, previewCurrentName);
    }

    let _ctRenamePath = '';
    let _ctRenameName = '';
    let _ctRenameFromPreview = false;

    function contentRenameFile(path, name, hasRelease) {
        _ctRenamePath = path || previewCurrentPath;
        _ctRenameName = name || previewCurrentName;
        _ctRenameFromPreview = (!path);  // if no path passed, we're in preview mode

        const modal = document.getElementById('ct-rename-modal');
        const info = document.getElementById('ct-rename-modal-info');
        const input = document.getElementById('ct-rename-input');
        const status = document.getElementById('ct-rename-modal-status');
        const confirmBtn = document.getElementById('ct-rename-confirm-btn');
        const releaseInfo = document.getElementById('ct-rename-modal-release-info');

        const showRelease = hasRelease !== undefined ? hasRelease : previewCurrentHasRelease;
        info.innerHTML = `Current name: <code style="font-size:0.82rem">${esc(_ctRenameName)}</code>`;
        input.value = _ctRenameName;
        status.style.display = 'none';
        if (releaseInfo) releaseInfo.style.display = showRelease ? 'block' : 'none';
        confirmBtn.disabled = false;
        confirmBtn.textContent = 'âœï¸ Rename';
        modal.style.display = 'flex';
        setTimeout(() => { input.focus(); input.select(); }, 100);
    }

    async function contentDoRenameConfirm() {
        const modal = document.getElementById('ct-rename-modal');
        const input = document.getElementById('ct-rename-input');
        const status = document.getElementById('ct-rename-modal-status');
        const confirmBtn = document.getElementById('ct-rename-confirm-btn');
        const newName = input.value.trim();
        const releaseInfo = document.getElementById('ct-rename-modal-release-info');
        const releaseCheckbox = document.getElementById('ct-rename-update-release');
        const updateRelease = releaseInfo && releaseInfo.style.display !== 'none'
            && releaseCheckbox && releaseCheckbox.checked;

        if (!newName || newName === _ctRenameName) {
            modal.style.display = 'none';
            return;
        }

        confirmBtn.disabled = true;
        confirmBtn.textContent = 'â³ Renamingâ€¦';
        status.style.display = 'block';
        status.innerHTML = '<span class="spinner"></span> Renamingâ€¦';

        try {
            const result = await api('/content/rename', {
                method: 'POST',
                body: JSON.stringify({ path: _ctRenamePath, new_name: newName }),
            });

            if (updateRelease) {
                // Delete old artifact (sidecar has old_asset_name)
                status.innerHTML = '<span class="spinner"></span> Removing old release artifactâ€¦';
                try {
                    await api('/backup/delete-release', {
                        method: 'POST',
                        body: JSON.stringify({ path: result.new_path }),
                    });
                } catch (e) { /* old artifact may already be gone */ }

                // Upload with new name
                status.innerHTML = '<span class="spinner"></span> Uploading with new nameâ€¦';
                await api('/backup/upload-release', {
                    method: 'POST',
                    body: JSON.stringify({ path: result.new_path }),
                });
            }

            modal.style.display = 'none';
            toast(`Renamed â†’ ${result.new_name}`, 'success');

            if (_ctRenameFromPreview) {
                // Update preview state
                previewCurrentPath = result.new_path;
                previewCurrentName = result.new_name;
                const titleEl = document.getElementById('content-preview-filename');
                if (titleEl) titleEl.textContent = result.new_name;
            } else {
                // Refresh the file list
                contentLoadFolder(contentCurrentPath);
            }
        } catch (e) {
            status.innerHTML = `<span style="color:var(--error)">âŒ ${esc(e.message)}</span>`;
            confirmBtn.disabled = false;
            confirmBtn.textContent = 'âœï¸ Rename';
        }
    }

    let _ctMovePath = '';
    let _ctMoveName = '';
    let _ctMoveFromPreview = false;

    async function contentMoveFile(path, name) {
        _ctMovePath = path || previewCurrentPath;
        _ctMoveName = name || previewCurrentName;
        _ctMoveFromPreview = (!path);

        const modal = document.getElementById('ct-move-modal');
        const info = document.getElementById('ct-move-modal-info');
        const folderList = document.getElementById('ct-move-folder-list');
        const subArea = document.getElementById('ct-move-subfolder-area');
        const input = document.getElementById('ct-move-input');
        const status = document.getElementById('ct-move-modal-status');
        const confirmBtn = document.getElementById('ct-move-confirm-btn');

        // Determine current file's parent folder path
        const pathParts = _ctMovePath.split('/');
        pathParts.pop(); // remove filename
        const currentParent = pathParts.join('/'); // e.g. "docs/examples" or "docs"
        const currentRoot = pathParts[0] || ''; // e.g. "docs"

        info.innerHTML = `Move <code style="font-size:0.82rem">${esc(_ctMoveName)}</code>
            <div style="font-size:0.75rem;color:var(--text-muted);margin-top:0.2rem">from <code>${esc(currentParent || '/')}</code></div>`;

        // Show modal immediately with loading state
        folderList.innerHTML = '<span class="spinner" style="width:14px;height:14px"></span> <span style="font-size:0.8rem;color:var(--text-muted)">Loading foldersâ€¦</span>';
        subArea.innerHTML = '';
        input.value = currentParent || '';
        status.style.display = 'none';
        confirmBtn.disabled = false;
        confirmBtn.textContent = 'ğŸ“‚ Move';
        modal.style.display = 'flex';

        // Fetch ALL project directories
        try {
            const data = await api('/content/all-folders');
            const allFolders = data.folders || [];

            if (!allFolders.length) {
                folderList.innerHTML = '<span style="font-size:0.8rem;color:var(--text-muted)">No folders found</span>';
                return;
            }

            let pillsHtml = '';
            for (const folder of allFolders) {
                const isCurrent = folder.name === currentRoot;
                const style = isCurrent
                    ? 'background:var(--bg-secondary);color:var(--text-primary);border:2px solid var(--accent-primary)'
                    : 'background:var(--accent-primary);color:#fff;border:none';
                pillsHtml += `<button class="btn btn-sm" style="${style};padding:0.2rem 0.6rem;font-size:0.8rem;border-radius:12px;cursor:pointer" onclick="_ctMoveSelectFolder('${esc(folder.name)}')" title="${esc(folder.name)}">ğŸ“ ${esc(folder.name)}</button>`;
            }
            folderList.innerHTML = pillsHtml;

            // Auto-drill-down to current folder context
            if (currentParent) {
                // Walk the path hierarchy to expand subfolders
                for (let i = 1; i <= pathParts.length; i++) {
                    const partialPath = pathParts.slice(0, i).join('/');
                    await _ctMoveSelectFolder(partialPath);
                }
            }
        } catch (e) {
            folderList.innerHTML = `<span style="color:var(--error);font-size:0.8rem">âŒ ${esc(e.message)}</span>`;
        }
        setTimeout(() => input.focus(), 100);
    }

    async function _ctMoveSelectFolder(folderPath) {
        const input = document.getElementById('ct-move-input');
        const subArea = document.getElementById('ct-move-subfolder-area');
        input.value = folderPath;

        // Remove any subfolder rows deeper than this level
        const depth = folderPath.split('/').length;
        const rows = subArea.querySelectorAll('[data-depth]');
        rows.forEach(r => {
            if (parseInt(r.dataset.depth) >= depth) r.remove();
        });

        // Fetch subdirectories
        try {
            const result = await api(`/content/list?path=${encodeURIComponent(folderPath)}`);
            const dirs = (result.files || []).filter(f => f.is_dir);
            if (dirs.length === 0) return; // no subdirectories

            const row = document.createElement('div');
            row.dataset.depth = depth;
            row.style.cssText = 'display:flex;flex-wrap:wrap;gap:0.35rem;margin-top:0.5rem;padding:0.4rem 0.5rem;background:var(--bg-tertiary);border-radius:8px;align-items:center';
            row.innerHTML = `<span style="font-size:0.72rem;color:var(--text-muted);margin-right:0.2rem">${'â€º'.repeat(depth)}</span>`;
            for (const d of dirs) {
                const btn = document.createElement('button');
                btn.className = 'btn btn-sm';
                btn.style.cssText = 'background:var(--bg-secondary);color:var(--text-primary);border:1px solid var(--border-subtle);padding:0.15rem 0.5rem;font-size:0.78rem;border-radius:10px;cursor:pointer';
                btn.textContent = `ğŸ“‚ ${d.name}`;
                btn.title = d.path;
                btn.onclick = () => _ctMoveSelectFolder(d.path);
                row.appendChild(btn);
            }
            subArea.appendChild(row);
            subArea.scrollTop = subArea.scrollHeight;
        } catch (e) {
            // silently ignore â€” folder may not exist yet
        }
    }

    async function contentDoMoveConfirm() {
        const modal = document.getElementById('ct-move-modal');
        const input = document.getElementById('ct-move-input');
        const status = document.getElementById('ct-move-modal-status');
        const confirmBtn = document.getElementById('ct-move-confirm-btn');
        const dest = input.value.trim();

        if (!dest) { toast('Enter a destination folder', 'error'); return; }

        confirmBtn.disabled = true;
        confirmBtn.textContent = 'â³ Movingâ€¦';
        status.style.display = 'block';
        status.innerHTML = '<span class="spinner"></span> Movingâ€¦';

        try {
            const result = await api('/content/move', {
                method: 'POST',
                body: JSON.stringify({ path: _ctMovePath, destination: dest }),
            });
            modal.style.display = 'none';
            toast(`Moved â†’ ${result.new_path}`, 'success');
            contentLoaded = false; // refresh folder list

            if (_ctMoveFromPreview) {
                contentClosePreview();
            } else {
                contentLoadFolder(contentCurrentPath);
            }
        } catch (e) {
            status.innerHTML = `<span style="color:var(--error)">âŒ ${esc(e.message)}</span>`;
            confirmBtn.disabled = false;
            confirmBtn.textContent = 'ğŸ“‚ Move';
        }
    }

    function contentDeleteFromPreview() {
        contentDeleteFile(previewCurrentPath, previewCurrentName, true, previewCurrentHasRelease);
    }

    function contentEncryptFromPreview() {
        contentEncryptFile(previewCurrentPath, previewCurrentHasRelease);
    }

    function contentClosePreview() {
        previewEditMode = false;
        previewCurrentPath = '';
        previewCurrentName = '';
        if (contentCurrentPath) {
            contentLoadFolder(contentCurrentPath);
        }
    }


    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  Encryption Key Setup
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    async function contentEncKeySetup() {
        const browser = document.getElementById('content-browser');
        browser.innerHTML = `
            <div class="content-preview-panel">
                <div class="content-preview-header">
                    <button class="btn btn-secondary btn-sm" onclick="contentClosePreview()">â† Back</button>
                    <span class="content-preview-title">ğŸ”‘ Set Up Content Encryption Key</span>
                </div>
                <div class="content-preview-body" style="padding:1.5rem">
                    <p style="color:var(--text-secondary);line-height:1.6;margin-bottom:1.5rem">
                        Content encryption requires a <strong>CONTENT_VAULT_ENC_KEY</strong> in your <code>.env</code> file.
                        Choose your own key or generate a strong random one.
                    </p>
                    <div style="display:flex;gap:0.5rem;align-items:flex-end;flex-wrap:wrap">
                        <div style="flex:1;min-width:250px">
                            <label style="font-size:0.8rem;font-weight:600;color:var(--text-secondary);display:block;margin-bottom:0.35rem">Encryption Key</label>
                            <input type="text" id="enc-key-input" placeholder="Enter at least 8 charactersâ€¦" style="width:100%;font-family:monospace">
                        </div>
                        <button class="btn btn-secondary" onclick="contentGenerateKey()">ğŸ² Generate</button>
                        <button class="btn btn-primary" onclick="contentSaveEncKey()">ğŸ’¾ Save Key</button>
                    </div>
                    <p style="color:var(--text-muted);font-size:0.8rem;margin-top:1rem">
                        âš ï¸ This key is stored in <code>.env</code>. Losing it means losing access to encrypted content.
                        Make sure it's backed up (push to GitHub Secrets or save it securely).
                    </p>
                </div>
            </div>`;
    }

    async function contentGenerateKey() {
        try {
            const result = await api('/content/setup-enc-key', {
                method: 'POST',
                body: JSON.stringify({ generate: true }),
            });
            // Show it in the input for the user to see before saving
            // Actually it's already saved! Let them know.
            const input = document.getElementById('enc-key-input');
            if (input) input.value = result.key_value;
            encKeyConfigured = true;
            toast('ğŸ”‘ Encryption key generated and saved!', 'success');
            // Refresh secrets tab if used later
            if (typeof secretsLoaded !== 'undefined') secretsLoaded = false;
        } catch (e) {
            toast(`Failed: ${e.message}`, 'error');
        }
    }

    async function contentSaveEncKey() {
        const input = document.getElementById('enc-key-input');
        const keyVal = input ? input.value.trim() : '';
        if (!keyVal || keyVal.length < 8) {
            toast('Key must be at least 8 characters.', 'warning');
            return;
        }

        try {
            await api('/content/setup-enc-key', {
                method: 'POST',
                body: JSON.stringify({ key: keyVal }),
            });
            encKeyConfigured = true;
            toast('ğŸ”‘ Encryption key saved!', 'success');
            if (typeof secretsLoaded !== 'undefined') secretsLoaded = false;
            contentClosePreview();
        } catch (e) {
            toast(`Failed: ${e.message}`, 'error');
        }
    }


    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  Markdown Renderer
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    /**
     * Basic markdown â†’ HTML renderer.
     * Handles headers, bold, italic, code blocks, inline code, links, lists, and paragraphs.
     */
    function renderMarkdown(md) {
        let html = esc(md);

        // Code blocks (``` ... ```)
        html = html.replace(/```(\w*)\n([\s\S]*?)```/g, '<pre class="content-preview-code notranslate" translate="no"><code>$2</code></pre>');

        // Headers â€” generate slug IDs for anchor links (GitHub-compatible)
        function _slugify(text) {
            return text.toLowerCase()
                .replace(/<[^>]+>/g, '')          // strip HTML tags
                .replace(/&[^;]+;/g, '')          // strip HTML entities
                .replace(/[^\w\s-]/g, '')          // strip non-word chars (keep hyphens)
                .trim()
                .replace(/\s+/g, '-');             // spaces â†’ dashes (preserve consecutive -)
        }
        html = html.replace(/^######\s+(.+)$/gm, (_, t) => `<h6 id="${_slugify(t)}">${t}</h6>`);
        html = html.replace(/^#####\s+(.+)$/gm, (_, t) => `<h5 id="${_slugify(t)}">${t}</h5>`);
        html = html.replace(/^####\s+(.+)$/gm, (_, t) => `<h4 id="${_slugify(t)}">${t}</h4>`);
        html = html.replace(/^###\s+(.+)$/gm, (_, t) => `<h3 id="${_slugify(t)}">${t}</h3>`);
        html = html.replace(/^##\s+(.+)$/gm, (_, t) => `<h2 id="${_slugify(t)}">${t}</h2>`);
        html = html.replace(/^#\s+(.+)$/gm, (_, t) => `<h1 id="${_slugify(t)}">${t}</h1>`);

        // Bold and italic
        html = html.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
        html = html.replace(/\*(.+?)\*/g, '<em>$1</em>');

        // Inline code
        html = html.replace(/`([^`]+)`/g, '<code class="notranslate" translate="no" style="background:var(--bg-inset);padding:0.1em 0.3em;border-radius:3px;font-size:0.9em">$1</code>');

        // Links â€” anchor links use data-anchor, doc links use data-doclink
        html = html.replace(/\[([^\]]+)\]\(([^)]+)\)/g, (_, text, href) => {
            if (href.startsWith('#')) {
                return `<a href="#" data-anchor="${href.substring(1)}">${text}</a>`;
            }
            // Relative doc/media links (./file.md, ../other/file.md, file.md)
            if (!href.startsWith('http://') && !href.startsWith('https://') && !href.startsWith('//')) {
                return `<a href="#" data-doclink="${href}">${text}</a>`;
            }
            return `<a href="${href}" target="_blank" rel="noopener">${text}</a>`;
        });

        // Unordered lists
        html = html.replace(/^[\-\*]\s+(.+)$/gm, '<li>$1</li>');
        html = html.replace(/((?:<li>.*<\/li>\n?)+)/g, '<ul>$1</ul>');

        // Horizontal rules
        html = html.replace(/^---+$/gm, '<hr>');

        // Line breaks â†’ paragraphs
        html = html.replace(/\n\n/g, '</p><p>');
        html = '<p>' + html + '</p>';

        // Clean up
        html = html.replace(/<p><\/p>/g, '');
        html = html.replace(/<p>\s*(<h[1-6]>)/g, '$1');
        html = html.replace(/(<\/h[1-6]>)\s*<\/p>/g, '$1');
        html = html.replace(/<p>\s*(<pre)/g, '$1');
        html = html.replace(/(<\/pre>)\s*<\/p>/g, '$1');
        html = html.replace(/<p>\s*(<ul>)/g, '$1');
        html = html.replace(/(<\/ul>)\s*<\/p>/g, '$1');
        html = html.replace(/<p>\s*(<hr>)/g, '$1');

        return html;
    }


    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  Helpers
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    function formatFileSize(bytes) {
        if (bytes < 1024) return bytes + ' B';
        if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
        if (bytes < 1024 * 1024 * 1024) return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
        return (bytes / (1024 * 1024 * 1024)).toFixed(1) + ' GB';
    }


    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  Translate toggle for preview content
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    function contentToggleTranslate(btn) {
        const container = btn.parentElement.parentElement;  // .content-preview-rendered
        const previewBody = document.getElementById('content-preview-body');  // parent wrapper
        const isBlocked = container.classList.contains('notranslate');

        if (isBlocked) {
            // â”€â”€ Enable translation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            // Remove notranslate from BOTH the rendered div AND the parent body
            // (the parent has translate="no" which blocks GT for all children)
            container.classList.remove('notranslate');
            container.removeAttribute('translate');
            if (previewBody) {
                previewBody.removeAttribute('translate');
                previewBody.classList.remove('notranslate');
            }
            btn.textContent = 'ğŸŒ Translate off';

            // Force Google Translate to re-scan by resetting then reapplying
            const gtSelect = document.querySelector('.goog-te-combo');
            if (gtSelect && gtSelect.value) {
                const targetLang = gtSelect.value;
                gtSelect.value = '';
                gtSelect.dispatchEvent(new Event('change'));
                setTimeout(() => {
                    gtSelect.value = targetLang;
                    gtSelect.dispatchEvent(new Event('change'));
                }, 300);
            }
        } else {
            // â”€â”€ Disable translation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            // Restore notranslate on both levels
            container.classList.add('notranslate');
            container.setAttribute('translate', 'no');
            if (previewBody) {
                previewBody.setAttribute('translate', 'no');
            }

            // Re-render original markdown content (un-mangled by GT)
            if (previewOrigContent || encPreviewContent) {
                const src = previewOrigContent || encPreviewContent;
                const rendered = renderMarkdown(src);
                // Clear everything except the first child (toggle button row)
                while (container.children.length > 1) {
                    container.removeChild(container.lastChild);
                }
                // Append fresh rendered content
                const wrapper = document.createElement('div');
                wrapper.innerHTML = rendered;
                while (wrapper.firstChild) {
                    container.appendChild(wrapper.firstChild);
                }
            }

            btn.textContent = 'ğŸŒ Translate';
        }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  Upload
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    let _contentUploadXhr = null;
    let _contentReleaseUploadId = null;  // tracks active release upload for cancellation

    function contentCancelUpload() {
        // 1. Abort the XHR upload if still in progress
        if (_contentUploadXhr) {
            _contentUploadXhr.abort();
            _contentUploadXhr = null;
        }
        // 2. Cancel any active server-side optimization (ffmpeg)
        api('/content/optimize-cancel', { method: 'POST' }).catch(() => { });
        // 3. Cancel any active release upload
        if (_contentReleaseUploadId) {
            api(`/content/release-cancel/${_contentReleaseUploadId}`, { method: 'POST' }).catch(() => { });
            _contentReleaseUploadId = null;
        }
        // 4. Reset the progress UI
        const progressEl = document.getElementById('content-upload-progress');
        if (progressEl) progressEl.style.display = 'none';
        const bar = document.getElementById('content-upload-bar');
        if (bar) { bar.style.width = '0%'; bar.style.background = ''; }
        const label = document.getElementById('content-upload-label');
        if (label) label.textContent = 'ğŸ“¤ Uploading...';
        showToast('Upload cancelled', 'info');
    }

    function contentShowUpload() {
        const zone = document.getElementById('content-upload-zone');
        if (zone) {
            zone.style.display = zone.style.display === 'none' ? 'block' : 'none';
        }
    }

    function contentInitDragDrop() {
        const dropzone = document.getElementById('content-dropzone');
        if (!dropzone) return;

        ['dragenter', 'dragover'].forEach(evt => {
            dropzone.addEventListener(evt, (e) => {
                e.preventDefault();
                e.stopPropagation();
                dropzone.classList.add('drag-active');
            });
        });

        ['dragleave', 'drop'].forEach(evt => {
            dropzone.addEventListener(evt, (e) => {
                e.preventDefault();
                e.stopPropagation();
                dropzone.classList.remove('drag-active');
            });
        });

        dropzone.addEventListener('drop', (e) => {
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                contentDoUpload(files);
            }
        });
    }

    function contentUploadFiles(event) {
        const files = event.target.files;
        if (!files || files.length === 0) return;
        contentDoUpload(files);
    }

    async function contentDoUpload(files) {
        if (!contentCurrentPath) {
            toast('No folder selected for upload', 'warning');
            return;
        }

        const dropzone = document.getElementById('content-dropzone');
        const progressEl = document.getElementById('content-upload-progress');
        const bar = document.getElementById('content-upload-bar');
        const label = document.getElementById('content-upload-label');
        const detail = document.getElementById('content-upload-detail');
        const eta = document.getElementById('content-upload-eta');

        // Hide dropzone, show progress
        if (dropzone) dropzone.style.display = 'none';
        if (progressEl) progressEl.style.display = 'block';

        let uploaded = 0;
        const totalFiles = files.length;
        let totalSavings = 0;

        for (let i = 0; i < totalFiles; i++) {
            const file = files[i];
            label.textContent = `ğŸ“¤ Uploading ${file.name} (${i + 1}/${totalFiles})â€¦`;
            bar.style.background = 'linear-gradient(90deg, var(--accent), var(--accent-hover))';

            try {
                const result = await new Promise((resolve, reject) => {
                    const formData = new FormData();
                    formData.append('file', file);
                    formData.append('folder', contentCurrentPath);

                    const xhr = new XMLHttpRequest();
                    _contentUploadXhr = xhr;
                    let uploadDone = false;
                    let optimizePollId = null;

                    const startTime = Date.now();

                    xhr.upload.addEventListener('progress', (e) => {
                        if (!e.lengthComputable) return;
                        const pct = Math.round((e.loaded / e.total) * 100);
                        bar.style.width = pct + '%';
                        detail.textContent = `${pct}% Â· ${formatFileSize(e.loaded)} / ${formatFileSize(e.total)}`;

                        const elapsedSec = (Date.now() - startTime) / 1000;
                        const speed = e.loaded / elapsedSec;
                        const remaining = (e.total - e.loaded) / speed;
                        eta.textContent = remaining > 60
                            ? `~${Math.ceil(remaining / 60)} min left`
                            : remaining > 5
                                ? `~${Math.ceil(remaining)}s left`
                                : '';
                    });

                    // When upload bytes are fully sent, switch to "optimizing" stage
                    xhr.upload.addEventListener('load', () => {
                        uploadDone = true;
                        bar.style.width = '0%';
                        bar.style.background = 'linear-gradient(90deg, #818cf8, #a78bfa)';
                        label.textContent = `âš¡ Optimizing ${file.name}â€¦`;
                        detail.textContent = 'Processing on serverâ€¦';
                        eta.textContent = '';

                        // Poll optimize status for real-time progress
                        const isMedia = file.type.startsWith('video/') || file.type.startsWith('audio/');
                        if (isMedia) {
                            optimizePollId = setInterval(async () => {
                                try {
                                    const st = await api('/content/optimize-status');
                                    if (st.status === 'encoding') {
                                        // Compute progress % from encoded time vs duration
                                        let pct = 0;
                                        if (st.duration_sec > 0 && st.time) {
                                            const parts = st.time.split(':');
                                            if (parts.length === 3) {
                                                const secs = parseInt(parts[0]) * 3600
                                                    + parseInt(parts[1]) * 60
                                                    + parseFloat(parts[2]);
                                                pct = Math.min(99, Math.round((secs / st.duration_sec) * 100));
                                            }
                                        }
                                        bar.style.width = pct + '%';

                                        const encoder = st.encoder || '';
                                        let info = encoder ? `[${encoder}] ` : '';
                                        if (st.speed) info += `${st.speed} `;
                                        if (st.fps) info += `${st.fps} fps `;
                                        if (st.time) info += `Â· ${st.time}`;
                                        detail.textContent = info || 'Encodingâ€¦';

                                        label.textContent = `âš¡ Encoding ${file.name}â€¦ ${pct}%`;
                                        eta.textContent = st.elapsed ? `${Math.round(st.elapsed)}s elapsed` : '';

                                        if (st.deadline_warning) {
                                            eta.textContent += ' âš ï¸ Deadline approaching';
                                        }
                                    }
                                } catch (e) { /* ignore poll errors */ }
                            }, 2000);
                        } else {
                            // Non-media: show indeterminate bar
                            bar.style.width = '60%';
                        }
                    });

                    xhr.addEventListener('load', () => {
                        _contentUploadXhr = null;
                        if (optimizePollId) clearInterval(optimizePollId);

                        if (xhr.status >= 200 && xhr.status < 300) {
                            try {
                                const data = JSON.parse(xhr.responseText);
                                if (data.success) {
                                    resolve(data);
                                } else {
                                    reject(new Error(data.error || 'Upload failed'));
                                }
                            } catch (e) {
                                reject(new Error('Invalid response'));
                            }
                        } else {
                            let errMsg = `Server error (HTTP ${xhr.status})`;
                            try {
                                const err = JSON.parse(xhr.responseText);
                                errMsg = err.error || errMsg;
                            } catch (e) { }
                            reject(new Error(errMsg));
                        }
                    });

                    xhr.addEventListener('error', () => {
                        _contentUploadXhr = null;
                        if (optimizePollId) clearInterval(optimizePollId);
                        reject(new Error('Network error'));
                    });

                    xhr.addEventListener('abort', () => {
                        _contentUploadXhr = null;
                        if (optimizePollId) clearInterval(optimizePollId);
                        reject(new Error('Upload cancelled'));
                    });

                    xhr.open('POST', '/api/content/upload');
                    xhr.send(formData);
                });

                uploaded++;

                // Show per-file result
                if (result.optimized && result.savings_pct) {
                    totalSavings += (result.savings || 0);
                    detail.textContent = `${result.original_name} â†’ ${result.name} (âˆ’${result.savings_pct}%, tier: ${result.tier})`;
                }

                // Stage 3: If large file â†’ poll GitHub Release upload progress
                if (result.release_upload) {
                    const releaseId = result.release_upload;
                    _contentReleaseUploadId = releaseId;  // track for cancel
                    bar.style.width = '2%';
                    bar.style.background = 'linear-gradient(90deg, #8b5cf6, #a78bfa)';
                    label.textContent = `â˜ï¸ Backing up ${result.name} to GitHub Releaseâ€¦`;
                    detail.textContent = 'Queuedâ€¦';
                    eta.textContent = '';

                    // Poll release status until done/failed/cancelled
                    await new Promise((resolve) => {
                        const pollId = setInterval(async () => {
                            try {
                                const st = await api(`/content/release-status/${releaseId}`);

                                if (st.status === 'uploading') {
                                    const pct = st.progress_pct || 0;
                                    bar.style.width = pct + '%';
                                    label.textContent = `â˜ï¸ Uploading ${result.name}â€¦ ${pct}%`;
                                    // Build detail line: speed + elapsed
                                    let info = st.speed || '';
                                    if (st.elapsed_sec) info += ` Â· ${Math.round(st.elapsed_sec)}s`;
                                    detail.textContent = info || st.message || 'Uploadingâ€¦';
                                    eta.textContent = st.eta || (st.size_mb ? `${st.size_mb} MB` : '');
                                } else if (st.status === 'done') {
                                    clearInterval(pollId);
                                    _contentReleaseUploadId = null;
                                    bar.style.width = '100%';
                                    bar.style.background = 'linear-gradient(90deg, #22c55e, #4ade80)';
                                    label.textContent = `â˜ï¸ ${result.name} backed up`;
                                    detail.textContent = st.message || 'Done';
                                    eta.textContent = '';
                                    toast(`â˜ï¸ ${result.name} backed up to GitHub Release`, 'success');
                                    resolve();
                                } else if (st.status === 'failed' || st.status === 'cancelled') {
                                    clearInterval(pollId);
                                    _contentReleaseUploadId = null;
                                    bar.style.background = 'linear-gradient(90deg, #f87171, #ef4444)';
                                    bar.style.width = '100%';
                                    label.textContent = `âš ï¸ Release backup ${st.status}`;
                                    detail.textContent = st.message || st.status;
                                    eta.textContent = '';
                                    toast(`Release backup ${st.status}: ${st.message}`, 'error');
                                    resolve();
                                } else {
                                    // pending / setup
                                    detail.textContent = st.message || st.status || 'Pendingâ€¦';
                                }
                            } catch (e) {
                                // Poll errors are non-fatal
                            }
                        }, 1500);

                        // Safety: don't poll forever (30 min max)
                        setTimeout(() => {
                            clearInterval(pollId);
                            _contentReleaseUploadId = null;
                            resolve();
                        }, 30 * 60 * 1000);
                    });
                }

                // Stage 4: If encrypt checkbox is checked, encrypt after upload
                const encryptCb = document.getElementById('content-upload-encrypt-cb');
                if (encryptCb && encryptCb.checked && result.path) {
                    bar.style.width = '0%';
                    bar.style.background = 'linear-gradient(90deg, #f59e0b, #fbbf24)';
                    label.textContent = `ğŸ”’ Encrypting ${result.name}â€¦`;
                    detail.textContent = 'Calling encrypt APIâ€¦';
                    eta.textContent = '';
                    try {
                        const encResult = await api('/content/encrypt', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ path: result.path, delete_original: true }),
                        });
                        if (encResult.success) {
                            bar.style.width = '100%';
                            bar.style.background = 'linear-gradient(90deg, #22c55e, #4ade80)';
                            label.textContent = `ğŸ”’ ${result.name} encrypted`;
                            detail.textContent = `${formatFileSize(encResult.original_size)} â†’ ${formatFileSize(encResult.encrypted_size)}`;
                            toast(`ğŸ”’ ${result.name} encrypted`, 'success');
                        } else {
                            toast(`Encrypt failed: ${encResult.error || 'unknown'}`, 'error');
                        }
                    } catch (encErr) {
                        toast(`Encrypt error: ${encErr.message}`, 'error');
                    }
                }

            } catch (e) {
                toast(`Failed to upload ${file.name}: ${e.message}`, 'error');
            }
        }

        // Done â€” show success
        bar.style.width = '100%';
        bar.style.background = 'linear-gradient(90deg, #22c55e, #4ade80)';
        let doneMsg = `âœ… ${uploaded}/${totalFiles} file(s) uploaded`;
        if (totalSavings > 0) doneMsg += ` Â· saved ${formatFileSize(totalSavings)}`;
        label.textContent = doneMsg;
        eta.textContent = '';

        // Refresh folder after delay
        setTimeout(() => {
            contentLoaded = false;
            contentLoadFolder(contentCurrentPath);
        }, 2000);
    }


</script>
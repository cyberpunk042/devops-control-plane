<!-- Assistant Engine â€” event-driven side panel
     Loads superstructure JSON, renders interaction path on hover/focus.
     Exposes: window._assistant { activate, deactivate, refresh, enable, disable, resolvers }
     Depends on: #assistant-panel in DOM, admin.css assistant classes -->

<script>
(function() {
    'use strict';

    // â”€â”€ State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let _catalogue = null;        // Map<contextId, contextObj>
    let _currentCtx = null;       // current context object
    let _panelEl = null;          // #assistant-panel element
    let _containerEl = null;      // element we're listening on
    let _flatNodes = [];          // [{ node, parents: [ancestorâ€¦] }]
    let _focusPath = null;        // { target: node, chain: [parents] }
    let _hoverPath = null;        // { target: node, chain: [parents] }
    let _stickyPath = null;       // last successful hover â€” survives mouse-to-panel trips
    let _enabled = true;          // panel visibility toggle
    let _hoverDebounce = null;    // debounce timer for hover
    let _listeners = {};          // attached event listener refs

    // â”€â”€ Catalogue Loading â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    async function _loadCatalogue() {
        if (_catalogue) return;
        try {
            const resp = await fetch('/static/data/assistant-catalogue.json');
            if (!resp.ok) {
                console.warn('[assistant] catalogue fetch failed:', resp.status);
                return;
            }
            const data = await resp.json();
            _catalogue = new Map();
            for (const ctx of data) {
                _catalogue.set(ctx.context, ctx);
            }
        } catch (e) {
            console.warn('[assistant] catalogue load error:', e);
        }
    }

    // â”€â”€ Panel Resolution â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    function _resolvePanel() {
        const el = document.getElementById('assistant-panel');
        if (!el) {
            console.warn('[assistant] #assistant-panel not found in DOM');
        }
        return el;
    }

    // â”€â”€ Template Variable Resolution â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    function _resolve(text) {
        if (!text) return '';
        return text.replace(/\{\{(\w+)\}\}/g, function(match, name) {
            const resolver = window._assistant.resolvers[name];
            if (typeof resolver === 'function') {
                try { return resolver(); }
                catch (e) { return ''; }
            }
            return '';
        });
    }

    // â”€â”€ State-Variant Resolution â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // A node (or childTemplate) can carry a `variants` array.
    // Each variant has a `when` condition checked against a DOM element.
    // The first matching variant's content/expanded override the base.
    // If no variant matches, the base fields are used as-is.

    function _resolveVariant(node, element) {
        if (!node.variants || !node.variants.length || !element) return node;

        for (var i = 0; i < node.variants.length; i++) {
            var v = node.variants[i];
            if (!v.when) continue;

            var match = true;

            if (v.when.textContains) {
                match = match && element.textContent
                    .toLowerCase()
                    .includes(v.when.textContains.toLowerCase());
            }

            if (match && v.when.hasSelector) {
                match = match && !!element.querySelector(v.when.hasSelector);
            }

            if (match) {
                // Merge: variant fields override base, everything else preserved
                return {
                    id: node.id,
                    title: v.title || node.title,
                    icon: v.icon || node.icon,
                    content: v.content !== undefined ? v.content : node.content,
                    expanded: v.expanded !== undefined ? v.expanded : node.expanded,
                    selector: node.selector,
                    separator: node.separator,
                    children: node.children,
                    dynamic: node.dynamic,
                    childTemplate: node.childTemplate,
                    variants: node.variants,
                    _element: node._element,
                    _isDynamic: node._isDynamic,
                    _variantIndex: i
                };
            }
        }

        return node;  // No variant matched â†’ base content
    }

    // Resolve variant for a DOM element matched to a static node.
    // Static nodes don't have _element, so we find the element via selector.
    function _resolveStaticVariant(node) {
        if (!node.variants || !node.variants.length) return node;
        if (node._element) return _resolveVariant(node, node._element);
        if (!node.selector || !_containerEl) return node;

        try {
            var el = _containerEl.querySelector(node.selector);
            if (el) return _resolveVariant(node, el);
        } catch (e) {
            // Invalid selector
        }
        return node;
    }

    // â”€â”€ Tree Flattening â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Builds a flat index of [{ node, parents }] for selector matching.
    // Deepest nodes first so specific selectors win over general ones.

    function _flattenTree(children, parentChain) {
        const result = [];
        for (const child of (children || [])) {
            // Recurse children first â†’ deepest nodes appear first
            if (child.children && child.children.length) {
                result.push(..._flattenTree(child.children, [...parentChain, child]));
            }
            result.push({ node: child, parents: [...parentChain] });

            // Handle dynamic children â€” query DOM for real elements
            if (child.dynamic && child.childTemplate && _containerEl) {
                _resolveDynamic(child, parentChain, result);
            }
        }
        return result;
    }

    function _resolveDynamic(parentNode, grandParentChain, result) {
        const tpl = parentNode.childTemplate;
        if (!tpl.selector) return;

        const elements = _containerEl.querySelectorAll(tpl.selector);
        elements.forEach(function(el, i) {
            // Extract display name from the element's DOM
            // 1. If childTemplate defines nameSelector, use that
            // 2. Otherwise try font-weight:600 / strong heuristic
            // 3. Fallback: first text node
            var nameEl = tpl.nameSelector
                ? el.querySelector(tpl.nameSelector)
                : el.querySelector('[style*="font-weight:600"], [style*="font-weight: 600"], strong');
            var extractedName;
            if (nameEl) {
                extractedName = nameEl.textContent.trim();
            } else {
                // Fallback: first text node only (avoid grabbing child element text)
                var walker = document.createTreeWalker(el, NodeFilter.SHOW_TEXT, null, false);
                var firstText = walker.nextNode();
                extractedName = firstText ? firstText.textContent.trim() : '';
            }

            if (!extractedName) return;

            // Apply {{name}} template interpolation to all template strings
            var nodeTitle = (tpl.title || '').replace(/\{\{name\}\}/g, extractedName);
            var nodeContent = (tpl.content || '').replace(/\{\{name\}\}/g, extractedName);
            var nodeExpanded = tpl.expanded
                ? tpl.expanded.replace(/\{\{name\}\}/g, extractedName)
                : undefined;

            // â”€â”€ Context-aware enrichment â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            // Read DOM state to add application-specific knowledge.

            // Detect "default" badge (environment rows)
            var defaultBadge = el.querySelector('[style*="accent-glow"]');
            if (defaultBadge && defaultBadge.textContent.trim().toLowerCase() === 'default') {
                nodeTitle += ' Â· default';
                var defaultNote = '\n\nAs the default environment, it will be pre-selected when you define secrets and variables in Step 3.';
                nodeExpanded = nodeExpanded ? nodeExpanded + defaultNote : defaultNote;
            }

            // Extract stack/path/domain metadata (module rows)
            var metaSpans = el.querySelectorAll('span');
            var extractedStack = '', extractedPath = '', extractedDomain = '';
            metaSpans.forEach(function(sp) {
                var txt = sp.textContent.trim();
                if (txt.indexOf('Stack:') === 0) extractedStack = txt.replace('Stack:', '').trim();
                if (txt.indexOf('Domain:') === 0) extractedDomain = txt.replace('Domain:', '').trim();
            });
            var codeEl = el.querySelector('code');
            if (codeEl) extractedPath = codeEl.textContent.trim();

            if (extractedStack) {
                nodeTitle += ' Â· ' + extractedStack;
                // Build styled detail card (same UX as stack select)
                var _dcpStacks = (window._dcp && window._dcp.stacks) || [];
                var stackEntry = _dcpStacks.find(function(s) { return s.name === extractedStack; });
                if (stackEntry) {
                    var stackHtml = '<div class="assistant-stack-detail">';

                    if (stackEntry.parent) {
                        // Flavored: language first, then framework
                        var parentEntry = _dcpStacks.find(function(s) { return s.name === stackEntry.parent; });
                        if (parentEntry) {
                            stackHtml += '<div class="assistant-stack-detail-name">' +
                                (parentEntry.icon || '') + ' ' + parentEntry.name + '</div>';
                            stackHtml += '<div class="assistant-stack-detail-text">' +
                                (parentEntry.detail || parentEntry.description) + '</div>';
                        }
                        stackHtml += '<div class="assistant-stack-detail-framework">' +
                            '\u21b3 ' + extractedStack + '</div>';
                        stackHtml += '<div class="assistant-stack-detail-text">' +
                            (stackEntry.detail || stackEntry.description) + '</div>';
                    } else {
                        // Base stack
                        stackHtml += '<div class="assistant-stack-detail-name">' +
                            (stackEntry.icon || '') + ' ' + extractedStack + '</div>';
                        stackHtml += '<div class="assistant-stack-detail-text">' +
                            (stackEntry.detail || stackEntry.description) + '</div>';
                    }

                    if (stackEntry.capabilities && stackEntry.capabilities.length > 0) {
                        stackHtml += '<div class="assistant-stack-detail-caps">' +
                            'Capabilities: ' + stackEntry.capabilities.join(', ') + '</div>';
                    }

                    stackHtml += '</div>';
                    nodeExpanded = stackHtml + (nodeExpanded ? '\n' + nodeExpanded : '');
                }
            }

            var syntheticNode = {
                id: parentNode.id + '-dyn-' + i,
                title: nodeTitle,
                content: nodeContent,
                expanded: nodeExpanded,
                selector: null,
                _element: el,
                _isDynamic: true,
                children: []
            };

            // Apply childTemplate variants if defined
            if (tpl.variants && tpl.variants.length) {
                syntheticNode.variants = tpl.variants;
                syntheticNode = _resolveVariant(syntheticNode, el);
                // Re-apply {{name}} interpolation to variant content
                if (syntheticNode.content) {
                    syntheticNode.content = syntheticNode.content.replace(/\{\{name\}\}/g, extractedName);
                }
                if (syntheticNode.expanded) {
                    syntheticNode.expanded = syntheticNode.expanded.replace(/\{\{name\}\}/g, extractedName);
                }
            }

            // Dynamic children go deepest-first (before their parent)
            result.unshift({ node: syntheticNode, parents: [...grandParentChain, parentNode] });
        });
    }

    // â”€â”€ Node Matching â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Given a DOM element (from hover/focus), find the matching node.

    function _matchNode(element) {
        if (!element || !_flatNodes.length) return null;

        for (let i = 0; i < _flatNodes.length; i++) {
            const entry = _flatNodes[i];
            const node = entry.node;

            // Dynamic nodes: match by direct element reference
            if (node._element) {
                if (node._element === element || node._element.contains(element)) {
                    return entry;
                }
                continue;
            }

            // Static nodes: match by CSS selector
            if (!node.selector) continue;

            try {
                // 1. Direct match: the element itself IS the selector target
                if (element.matches(node.selector)) {
                    return entry;
                }

                // 2. Inside: the element is a descendant of the selector target
                if (element.closest(node.selector)) {
                    return entry;
                }

                // 3. Field-group proximity: the element shares a wrapper div
                //    with the selector target. This handles hovering a <label>
                //    that's a sibling of <input id="wiz-name">.
                //    Skip for ID selectors â€” they already uniquely target
                //    elements and proximity would false-positive on siblings
                //    in the same flex row.
                if (node.selector.charAt(0) !== '#') {
                    const targetEl = _containerEl.querySelector(node.selector);
                    if (targetEl && targetEl.parentElement) {
                        const wrapper = targetEl.parentElement.closest('div');
                        if (wrapper && wrapper !== _containerEl &&
                            (wrapper === element || wrapper.contains(element))) {
                            return entry;
                        }
                    }
                }
            } catch (e) {
                // Invalid selector â€” skip silently
            }
        }

        return null;
    }

    // â”€â”€ Path Merging â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Merge focus and hover paths. Deduplicate shared parents.
    // Returns [{ node, depth, isTarget }] sorted shallowest-first.

    function _mergeInteractionPaths(focusPath, hoverPath) {
        const nodeMap = new Map();  // nodeId â†’ { node, depth, isTarget }

        function _addPath(path) {
            if (!path) return;
            // Add parents (in-chain)
            for (let i = 0; i < path.chain.length; i++) {
                const n = path.chain[i];
                if (!nodeMap.has(n.id)) {
                    nodeMap.set(n.id, { node: n, depth: i, isTarget: false });
                }
            }
            // Add target
            const depth = path.chain.length;
            const existing = nodeMap.get(path.target.id);
            if (existing) {
                existing.isTarget = true;  // promote to target
            } else {
                nodeMap.set(path.target.id, {
                    node: path.target,
                    depth: depth,
                    isTarget: true
                });
            }
        }

        _addPath(focusPath);
        _addPath(hoverPath);

        // Sort by depth (shallowest first)
        var sorted = Array.from(nodeMap.values());
        sorted.sort(function(a, b) { return a.depth - b.depth; });

        // Limit: keep only target + 1 immediate parent (max 2 nodes from target)
        var maxTargetDepth = -1;
        for (var i = 0; i < sorted.length; i++) {
            if (sorted[i].isTarget && sorted[i].depth > maxTargetDepth) {
                maxTargetDepth = sorted[i].depth;
            }
        }
        if (maxTargetDepth >= 0) {
            var minDepth = Math.max(0, maxTargetDepth - 1);
            sorted = sorted.filter(function(e) { return e.depth >= minDepth; });
            // Normalize depths so shallowest shown renders at depth 0
            for (var j = 0; j < sorted.length; j++) {
                sorted[j].depth = sorted[j].depth - minDepth;
            }
        }

        return sorted;
    }

    // â”€â”€ Rendering â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    function _renderContextHeader() {
        if (!_panelEl || !_currentCtx) return;

        _panelEl.innerHTML = '';

        const inner = document.createElement('div');
        inner.className = 'assistant-panel-inner';

        const header = document.createElement('div');
        header.className = 'assistant-context-header';
        header.innerHTML =
            '<div class="assistant-context-title">' +
                (_currentCtx.icon ? _currentCtx.icon + ' ' : '') +
                _currentCtx.title +
            '</div>' +
            '<div class="assistant-context-content">' +
                _resolve(_currentCtx.content) +
            '</div>';

        inner.appendChild(header);
        _panelEl.appendChild(inner);
    }

    function _renderInteractionPath() {
        if (!_panelEl || !_currentCtx) return;

        // If no interaction, fall back to sticky path or entry state
        if (!_focusPath && !_hoverPath) {
            if (_stickyPath) {
                // Restore sticky hover so panel keeps its content
                _hoverPath = _stickyPath;
            } else {
                _renderContextHeader();
                _panelEl.classList.add('entry-state');
                return;
            }
        }

        // Save current path as sticky (survives mouse-to-panel trips)
        if (_hoverPath) _stickyPath = _hoverPath;

        _panelEl.classList.remove('entry-state');

        // Re-render context header + path
        _renderContextHeader();

        const inner = _panelEl.querySelector('.assistant-panel-inner');
        if (!inner) return;

        // Merge paths
        const pathNodes = _mergeInteractionPaths(_focusPath, _hoverPath);

        // Render each node
        for (let i = 0; i < pathNodes.length; i++) {
            var entry = pathNodes[i];

            // Resolve state-variant content for static nodes
            var node = entry.node._isDynamic
                ? entry.node  // Dynamic nodes already resolved in _resolveDynamic
                : _resolveStaticVariant(entry.node);

            // Separator
            if (node.separator) {
                var sep = document.createElement('hr');
                sep.className = 'assistant-separator';
                inner.appendChild(sep);
            }

            var div = document.createElement('div');
            div.className = 'assistant-node';
            div.dataset.nodeId = node.id;
            div.dataset.depth = entry.depth;

            // State class
            if (entry.isTarget) {
                div.classList.add('active-target');
            } else {
                div.classList.add('in-chain');
            }

            // Title
            var titleEl = document.createElement('div');
            titleEl.className = 'assistant-node-title';
            titleEl.textContent = (node.icon ? node.icon + ' ' : '') + (node.title || '');
            div.appendChild(titleEl);

            // Content
            var contentEl = document.createElement('div');
            contentEl.className = 'assistant-node-content';
            contentEl.innerHTML = _resolve(node.content);
            div.appendChild(contentEl);

            // Expanded content â€” show for active targets and their direct parent
            var showExpanded = entry.isTarget ||
                (node.expanded && i < pathNodes.length - 1 && pathNodes[i + 1].isTarget);
            if (showExpanded && node.expanded) {
                var expandedEl = document.createElement('div');
                expandedEl.className = 'assistant-node-expanded';
                expandedEl.innerHTML = _resolve(node.expanded);
                div.appendChild(expandedEl);
            }

            inner.appendChild(div);
        }

        // Center the active target in the panel viewport, then apply highlights
        requestAnimationFrame(function() {
            var didHighlight = _highlightSelectedStack();
            _highlightActiveEnv();
            // If a stack is highlighted, _highlightSelectedStack scrolls to it.
            // Otherwise, fall back to centering on the active target node.
            if (!didHighlight) {
                _centerActiveNode();
            }
        });
    }

    // â”€â”€ Scroll Centering â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Uses direct scrollTop on the panel â€” never touches page scroll.

    function _centerActiveNode() {
        if (!_panelEl) return;

        var target = _panelEl.querySelector('.assistant-node.active-target');
        if (!target) return;

        // Calculate where target sits relative to the panel's scroll container
        var targetTop = target.offsetTop;
        var targetHeight = target.offsetHeight;
        var panelHeight = _panelEl.clientHeight;

        // Scroll so target is vertically centered in the panel
        var scrollTo = targetTop - (panelHeight / 2) + (targetHeight / 2);
        _panelEl.scrollTo({ top: Math.max(0, scrollTo), behavior: 'smooth' });
    }

    // â”€â”€ Event Handlers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    function _onHover(e) {
        if (!_enabled) return;

        // Debounce rapid hover changes (50ms)
        clearTimeout(_hoverDebounce);
        _hoverDebounce = setTimeout(function() {
            var matched = _matchNode(e.target);
            if (!matched) return;

            // Same hover target as before? Don't re-render
            if (_hoverPath && _hoverPath.target.id === matched.node.id) return;

            _hoverPath = { target: matched.node, chain: matched.parents };
            _renderInteractionPath();
        }, 50);
    }

    function _onFocus(e) {
        if (!_enabled) return;

        // Only hold persistent focus for interactive input elements.
        // Buttons perform an action and shouldn't stick in the panel
        // after you move the mouse away.
        var tag = e.target.tagName;
        if (tag !== 'INPUT' && tag !== 'SELECT' && tag !== 'TEXTAREA') return;

        var matched = _matchNode(e.target);
        if (!matched) return;

        // Same node? Don't re-render
        if (_focusPath && _focusPath.target.id === matched.node.id) return;

        _focusPath = { target: matched.node, chain: matched.parents };
        _renderInteractionPath();
    }

    function _onBlur(e) {
        if (!_enabled) return;

        _focusPath = null;
        _renderInteractionPath();
    }

    function _onMouseLeave(e) {
        if (!_enabled) return;

        // Don't clear hover if mouse moved to the assistant panel or its gap
        var layout = _containerEl && _containerEl.closest('.assistant-layout');
        if (layout && e.relatedTarget && (layout === e.relatedTarget || layout.contains(e.relatedTarget))) return;

        clearTimeout(_hoverDebounce);
        _hoverPath = null;
        _stickyPath = null;
        _renderInteractionPath();
    }

    function _onLayoutLeave(e) {
        if (!_enabled) return;

        // Mouse truly left the entire assistant region (body + panel)
        // relatedTarget is outside the layout â€” clear everything
        var layout = _containerEl && _containerEl.closest('.assistant-layout');
        if (layout && e.relatedTarget && layout.contains(e.relatedTarget)) return;

        clearTimeout(_hoverDebounce);
        _hoverPath = null;
        _stickyPath = null;
        _renderInteractionPath();
    }

    function _onChange(e) {
        if (!_enabled) return;

        // Center the changed element in the wizard view
        if (e.target && e.target.scrollIntoView) {
            e.target.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }

        // Navigate assistant to this element's node
        var matched = _matchNode(e.target);
        if (matched) {
            _hoverPath = { target: matched.node, chain: matched.parents };
        }

        // Re-render â€” _highlightSelectedStack is called from
        // _renderInteractionPath's requestAnimationFrame, so it
        // runs automatically on every render, not just on change.
        _renderInteractionPath();
    }

    // Highlight the selected stack's ENTIRE SECTION + show detail descriptions.
    // Called at the end of EVERY _renderInteractionPath render.
    // Returns true if a highlight was applied.
    function _highlightSelectedStack() {
        if (!_panelEl) return false;
        var select = document.getElementById('wiz-mod-stack');
        if (!select || !select.value || select.value === '' || select.value === '__custom__') return false;

        var stackName = select.value;
        var stacks = (window._dcp && window._dcp.stacks) || [];
        var stack = stacks.find(function(s) { return s.name === stackName; });
        if (!stack) return false;

        // Find the base/parent stack
        var baseStack = stack;
        if (stack.parent) {
            var parent = stacks.find(function(s) { return s.name === stack.parent; });
            if (parent) baseStack = parent;
        }

        var expandedEls = _panelEl.querySelectorAll('.assistant-node-expanded');
        var applied = false;

        expandedEls.forEach(function(el) {
            var html = el.innerHTML;

            // Check this expanded block contains the selected stack
            if (html.indexOf('\u2022 ' + stackName + ' \u2014') === -1) return;

            // â”€â”€ Line-by-line processing â”€â”€
            var lines = html.split('\n');
            var selectedIdx = -1;

            // Find the line with the selected stack
            for (var i = 0; i < lines.length; i++) {
                if (lines[i].indexOf('\u2022 ' + stackName + ' \u2014') !== -1) {
                    selectedIdx = i;
                    break;
                }
            }
            if (selectedIdx === -1) return;

            // Walk backwards to find section header (non-bullet, non-empty line)
            var headerIdx = selectedIdx;
            for (var i = selectedIdx - 1; i >= 0; i--) {
                var trimmed = lines[i].trim();
                if (trimmed === '') break;          // blank line = section boundary
                if (trimmed.charAt(0) === '\u2022') continue; // bullet = still in section
                headerIdx = i;                      // non-bullet non-empty = header
                break;
            }

            // Walk forwards to find end of section (next blank or non-bullet)
            var endIdx = selectedIdx;
            for (var i = selectedIdx + 1; i < lines.length; i++) {
                var trimmed = lines[i].trim();
                if (trimmed === '') break;
                if (trimmed.charAt(0) !== '\u2022') break;
                endIdx = i;
            }

            // â”€â”€ Wrap section + mark entries â”€â”€
            for (var i = headerIdx; i <= endIdx; i++) {
                if (lines[i].indexOf('\u2022 ' + stackName + ' \u2014') !== -1) {
                    lines[i] = '<span class="assistant-stack-selected">' + lines[i] + '</span>';
                } else if (stack.parent && lines[i].indexOf('\u2022 ' + stack.parent + ' \u2014') !== -1) {
                    lines[i] = '<span class="assistant-stack-parent">' + lines[i] + '</span>';
                }
            }

            // Wrap entire section in a container
            lines[headerIdx] = '<span class="assistant-stack-section">' + lines[headerIdx];
            lines[endIdx] = lines[endIdx] + '</span>';

            // â”€â”€ Insert detail block BEFORE the listing â”€â”€
            var baseDetail = baseStack.detail || baseStack.description || '';
            var stackDetail = stack.detail || stack.description || '';

            var detailDiv = document.createElement('div');
            detailDiv.className = 'assistant-stack-detail';

            if (stack.parent && baseStack.name !== stack.name) {
                // Flavored stack: show LANGUAGE first, then FRAMEWORK
                // Language header
                detailDiv.innerHTML =
                    '<div class="assistant-stack-detail-name">' +
                        (baseStack.icon || '') + ' ' + baseStack.name +
                    '</div>' +
                    '<div class="assistant-stack-detail-text">' + baseDetail + '</div>' +
                    // Framework section
                    '<div class="assistant-stack-detail-framework">' +
                        '\u21b3 ' + stack.name +
                    '</div>' +
                    '<div class="assistant-stack-detail-text">' + stackDetail + '</div>';
            } else {
                // Base stack: just show the stack itself
                detailDiv.innerHTML =
                    '<div class="assistant-stack-detail-name">' +
                        (stack.icon || '') + ' ' + stack.name +
                    '</div>' +
                    '<div class="assistant-stack-detail-text">' + stackDetail + '</div>';
            }

            // Capabilities
            if (stack.capabilities && stack.capabilities.length > 0) {
                var capsEl = document.createElement('div');
                capsEl.className = 'assistant-stack-detail-caps';
                capsEl.textContent = 'Capabilities: ' + stack.capabilities.join(', ');
                detailDiv.appendChild(capsEl);
            }


            // Set innerHTML with section + entry highlights
            el.innerHTML = lines.join('\n');

            // Insert detail block AFTER the highlighted section (not at the top)
            var sectionEl = el.querySelector('.assistant-stack-section');
            if (sectionEl && sectionEl.nextSibling) {
                sectionEl.parentNode.insertBefore(detailDiv, sectionEl.nextSibling);
            } else if (sectionEl) {
                sectionEl.parentNode.appendChild(detailDiv);
            } else {
                // Fallback: prepend if no section found
                el.insertBefore(detailDiv, el.firstChild);
            }

            applied = true;

            // â”€â”€ Scroll to the selected entry â”€â”€
            var highlighted = el.querySelector('.assistant-stack-selected');
            if (highlighted) {
                var hRect = highlighted.getBoundingClientRect();
                var pRect = _panelEl.getBoundingClientRect();
                var scrollTo = _panelEl.scrollTop + (hRect.top - pRect.top) - (pRect.height / 2) + (hRect.height / 2);
                _panelEl.scrollTo({ top: Math.max(0, scrollTo), behavior: 'smooth' });
            }
        });

        return applied;
    }

    // Highlight assistant nodes that represent the active environment.
    // Finds state cards with "Â· ACTIVE" in the label and adds a
    // visual highlight class to the parent assistant node.
    function _highlightActiveEnv() {
        if (!_panelEl) return;

        var stateLabels = _panelEl.querySelectorAll('.state-label');
        stateLabels.forEach(function(label) {
            if (label.textContent.indexOf('ACTIVE') === -1) return;

            // Walk up to the nearest assistant-node container
            var node = label.closest('.assistant-node');
            if (node) {
                node.classList.add('assistant-node-active-env');
            }
        });
    }

    function _onWheel(e) {
        if (!_panelEl) return;

        var scrollTop = _panelEl.scrollTop;
        var scrollMax = _panelEl.scrollHeight - _panelEl.clientHeight;

        // If panel has no overflow, let event pass through
        if (scrollMax <= 0) return;

        // Scrolling down and panel hasn't reached bottom
        if (e.deltaY > 0 && scrollTop < scrollMax) {
            e.preventDefault();
            _panelEl.scrollTop = Math.min(scrollTop + e.deltaY, scrollMax);
            return;
        }

        // Scrolling up and panel hasn't reached top
        if (e.deltaY < 0 && scrollTop > 0) {
            e.preventDefault();
            _panelEl.scrollTop = Math.max(scrollTop + e.deltaY, 0);
            return;
        }

        // Panel fully scrolled in this direction â€” let event pass to page
    }

    // â”€â”€ Listener Management â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    function _attachListeners(containerEl) {
        _detachListeners();

        _listeners = {
            hover:      function(e) { _onHover(e); },
            focus:      function(e) { _onFocus(e); },
            blur:       function(e) { _onBlur(e); },
            mouseleave: function(e) { _onMouseLeave(e); },
            layoutleave: function(e) { _onLayoutLeave(e); },
            wheel:      function(e) { _onWheel(e); },
            change:     function(e) { _onChange(e); }
        };

        containerEl.addEventListener('mouseover', _listeners.hover);
        containerEl.addEventListener('focusin', _listeners.focus);
        containerEl.addEventListener('change', _listeners.change);
        containerEl.addEventListener('focusout', _listeners.blur);
        containerEl.addEventListener('mouseleave', _listeners.mouseleave);

        // Attach wheel + layout leave to the layout container (parent of both body + panel)
        var layout = containerEl.closest('.assistant-layout') || containerEl.parentElement;
        if (layout) {
            layout.addEventListener('wheel', _listeners.wheel, { passive: false });
            layout.addEventListener('mouseleave', _listeners.layoutleave);
            _listeners._layoutTarget = layout;
        }
    }

    function _detachListeners() {
        if (!_containerEl || !_listeners.hover) return;

        _containerEl.removeEventListener('mouseover', _listeners.hover);
        _containerEl.removeEventListener('focusin', _listeners.focus);
        _containerEl.removeEventListener('focusout', _listeners.blur);
        _containerEl.removeEventListener('mouseleave', _listeners.mouseleave);
        if (_listeners.change) _containerEl.removeEventListener('change', _listeners.change);

        if (_listeners._layoutTarget) {
            _listeners._layoutTarget.removeEventListener('wheel', _listeners.wheel);
            _listeners._layoutTarget.removeEventListener('mouseleave', _listeners.layoutleave);
        }

        _listeners = {};
    }

    // â”€â”€ Public API â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    async function activate(contextId, containerEl) {
        await _loadCatalogue();
        if (!_catalogue) return;

        var ctx = _catalogue.get(contextId);
        if (!ctx) {
            console.warn('[assistant] no context found for:', contextId);
            return;
        }

        // Clean up previous context
        _detachListeners();

        _currentCtx = ctx;
        _containerEl = containerEl;
        _panelEl = _resolvePanel();
        if (!_panelEl) return;

        // Flatten the tree for selector matching
        _flatNodes = _flattenTree(ctx.children, []);

        // Reset interaction state
        _focusPath = null;
        _hoverPath = null;
        _stickyPath = null;

        // Render entry state
        _renderContextHeader();
        _panelEl.classList.add('entry-state');

        // Show panel
        if (_enabled) {
            _panelEl.classList.remove('disabled');
        }

        // Listen for interactions on the container
        _attachListeners(containerEl);
    }

    function deactivate() {
        _detachListeners();
        _currentCtx = null;
        _containerEl = null;
        _flatNodes = [];
        _focusPath = null;
        _hoverPath = null;
        if (_panelEl) {
            _panelEl.innerHTML = '';
            _panelEl.classList.remove('entry-state');
        }
    }

    function refresh() {
        if (!_currentCtx || !_containerEl) return;

        // Re-flatten tree (picks up new dynamic children)
        _flatNodes = _flattenTree(_currentCtx.children, []);

        // Re-render current state
        _renderInteractionPath();
    }

    function enable() {
        _enabled = true;
        if (_panelEl) _panelEl.classList.remove('disabled');
    }

    function disable() {
        _enabled = false;
        if (_panelEl) _panelEl.classList.add('disabled');
    }

    // â”€â”€ Expose â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    window._assistant = {
        activate:   activate,
        deactivate: deactivate,
        refresh:    refresh,
        enable:     enable,
        disable:    disable,
        resolvers:  {}
    };

    // â”€â”€ Default resolvers for wizard contexts â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    window._assistant.resolvers.envCount = function() {
        var envs = document.querySelectorAll('#wiz-envs > div');
        return envs ? envs.length : 0;
    };

    window._assistant.resolvers.domainCount = function() {
        var domains = document.querySelectorAll('#wiz-domains > span');
        return domains ? domains.length : 0;
    };

    window._assistant.resolvers.moduleCount = function() {
        var mods = document.querySelectorAll('#wizard-modules-list > div');
        return mods ? mods.length : 0;
    };

    window._assistant.resolvers.selectedStack = function() {
        var select = document.getElementById('wiz-mod-stack');
        if (!select || !select.value || select.value === '' || select.value === '__custom__') return '';

        var stacks = (window._dcp && window._dcp.stacks) || [];
        var stack = stacks.find(function(s) { return s.name === select.value; });
        if (!stack) return '\n\nâš  Stack "' + select.value + '" not found in definitions';

        var lines = [];
        lines.push('');
        lines.push('â”â”â” ' + (stack.icon || 'ğŸ“') + ' ' + stack.name + ' â”â”â”');
        lines.push(stack.description);
        if (stack.domain && stack.domain !== 'service') {
            lines.push('Domain: ' + stack.domain);
        }

        if (stack.parent) {
            var parent = stacks.find(function(s) { return s.name === stack.parent; });
            lines.push('');
            lines.push('â†³ Based on ' + (parent ? (parent.icon || '') + ' ' : '') + stack.parent);

            if (parent && parent.capabilities && stack.capabilities) {
                var parentCaps = {};
                parent.capabilities.forEach(function(c) { parentCaps[c] = true; });
                var inherited = stack.capabilities.filter(function(c) { return parentCaps[c]; });
                var added = stack.capabilities.filter(function(c) { return !parentCaps[c]; });

                if (inherited.length > 0) {
                    lines.push('  Inherited: ' + inherited.join(', '));
                }
                if (added.length > 0) {
                    lines.push('  âœ¨ Added: ' + added.join(', '));
                }
            }
        } else {
            if (stack.capabilities && stack.capabilities.length > 0) {
                lines.push('');
                lines.push('Capabilities: ' + stack.capabilities.join(', '));
            }
        }

        return lines.join('\n');
    };

    // â”€â”€ Integrations step resolvers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    window._assistant.resolvers.toolsMissing = function() {
        // Missing tool rows have IDs and are inside the tools container
        var rows = document.querySelectorAll('#wiz-int-body [id^="wiz-int-tool-"]:not([style*="success"])');
        // Better: count rows that contain the "Install" button (only missing tools have one)
        var missing = document.querySelectorAll('#wiz-int-body [id^="wiz-int-tool-"] button');
        return missing ? missing.length : 0;
    };

    window._assistant.resolvers.toolsInstalled = function() {
        // Installed tool pills contain "âœ“" and have success-colored background
        var pills = document.querySelectorAll('#wiz-int-body span[id^="wiz-int-tool-"][style*="success"]');
        return pills ? pills.length : 0;
    };

    window._assistant.resolvers.toolsTotal = function() {
        var all = document.querySelectorAll('#wiz-int-body [id^="wiz-int-tool-"]');
        return all ? all.length : 0;
    };

    window._assistant.resolvers.filesDetected = function() {
        // File pills with â— indicator (found files)
        var pills = document.querySelectorAll('#wiz-int-files-section span[id^="wiz-int-file-"]');
        var count = 0;
        if (pills) {
            pills.forEach(function(p) {
                if (p.textContent.indexOf('â—') !== -1) count++;
            });
        }
        return count;
    };

    window._assistant.resolvers.filesTotal = function() {
        var pills = document.querySelectorAll('#wiz-int-files-section span[id^="wiz-int-file-"]');
        return pills ? pills.length : 0;
    };

    window._assistant.resolvers.integrationCount = function() {
        var cards = document.querySelectorAll('[id^="wiz-int-wrap-"]');
        return cards ? cards.length : 0;
    };

    // â”€â”€ GitHub card resolvers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    window._assistant.resolvers.ghUser = function() {
        var pill = document.getElementById('wiz-gh-pill-user');
        if (!pill) return '';
        return pill.textContent.trim();  // e.g. "@cyberpunk042"
    };

    window._assistant.resolvers.ghRepo = function() {
        var pill = document.getElementById('wiz-gh-pill-repo');
        if (!pill) return '';
        var text = pill.textContent.trim();
        return text.indexOf('no repo') !== -1 ? '' : text;
    };

    window._assistant.resolvers.ghVis = function() {
        var pill = document.getElementById('wiz-gh-pill-vis');
        if (!pill) return '';
        var text = pill.textContent.trim();
        if (text.indexOf('private') !== -1) return 'private';
        if (text.indexOf('public') !== -1) return 'public';
        return '';
    };

    window._assistant.resolvers.ghBranch = function() {
        var pill = document.getElementById('wiz-gh-pill-branch');
        if (!pill) return '';
        return pill.textContent.replace('ğŸŒ¿', '').trim();
    };

    window._assistant.resolvers.ghEnvTotal = function() {
        var section = document.getElementById('wiz-gh-section-envs');
        if (!section) return 0;
        var rows = section.querySelectorAll('[style*="display:flex"][style*="align-items:center"]');
        return rows ? rows.length : 0;
    };

    window._assistant.resolvers.ghEnvAligned = function() {
        var section = document.getElementById('wiz-gh-section-envs');
        if (!section) return 0;
        var summary = section.querySelector('summary');
        if (!summary) return 0;
        var match = summary.textContent.match(/(\d+)\/\d+/);
        return match ? parseInt(match[1], 10) : 0;
    };

    window._assistant.resolvers.ghEnvMissing = function() {
        var total = window._assistant.resolvers.ghEnvTotal();
        var aligned = window._assistant.resolvers.ghEnvAligned();
        return total - aligned;
    };

    window._assistant.resolvers.ghWorkflows = function() {
        var pill = document.getElementById('wiz-gh-pill-workflows');
        if (!pill) return 0;
        var match = pill.textContent.match(/(\d+)/);
        return match ? parseInt(match[1], 10) : 0;
    };

    // â”€â”€ Pages card resolvers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    window._assistant.resolvers.pagesSegments = function() {
        var pill = document.getElementById('wiz-pages-pill-segments');
        if (!pill) return 0;
        var match = pill.textContent.match(/(\d+)/);
        return match ? parseInt(match[1], 10) : 0;
    };

    window._assistant.resolvers.pagesFolders = function() {
        var pill = document.getElementById('wiz-pages-pill-folders');
        if (!pill) return 0;
        var match = pill.textContent.match(/(\d+)/);
        return match ? parseInt(match[1], 10) : 0;
    };

    window._assistant.resolvers.pagesBranch = function() {
        var pill = document.getElementById('wiz-pages-pill-branch');
        if (!pill) return '';
        return pill.textContent.replace('ğŸŒ¿', '').trim();
    };

    window._assistant.resolvers.pagesBuildersAvail = function() {
        var section = document.getElementById('wiz-pages-section-builders');
        if (!section) return 0;
        var pills = section.querySelectorAll('span');
        var count = 0;
        if (pills) {
            pills.forEach(function(p) {
                if (p.textContent.indexOf('âœ…') !== -1) count++;
            });
        }
        return count;
    };

    window._assistant.resolvers.pagesBuildersTotal = function() {
        var section = document.getElementById('wiz-pages-section-builders');
        if (!section) return 0;
        var summary = section.querySelector('summary');
        if (!summary) return 0;
        var match = summary.textContent.match(/(\d+)\/(\d+)/);
        return match ? parseInt(match[2], 10) : 0;
    };

    window._assistant.resolvers.pagesUninit = function() {
        var section = document.getElementById('wiz-pages-section-folders');
        if (!section) return 0;
        var rows = section.querySelectorAll('span');
        var count = 0;
        if (rows) {
            rows.forEach(function(s) {
                if (s.textContent.trim() === 'â¬œ') count++;
            });
        }
        return count;
    };

})();
</script>

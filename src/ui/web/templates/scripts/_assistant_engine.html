<!-- Assistant Engine â€” event-driven side panel
     Loads superstructure JSON, renders interaction path on hover/focus.
     Exposes: window._assistant { activate, deactivate, refresh, enable, disable, resolvers }
     Depends on: #assistant-panel in DOM, admin.css assistant classes -->

<script>
(function() {
    'use strict';

    // â”€â”€ State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let _catalogue = null;        // Map<contextId, contextObj>
    let _currentCtx = null;       // current context object
    let _panelEl = null;          // #assistant-panel element
    let _containerEl = null;      // element we're listening on
    let _flatNodes = [];          // [{ node, parents: [ancestorâ€¦] }]
    let _focusPath = null;        // { target: node, chain: [parents] }
    let _hoverPath = null;        // { target: node, chain: [parents] }
    let _stickyPath = null;       // last successful hover â€” survives mouse-to-panel trips
    let _enabled = true;          // panel visibility toggle
    let _hoverDebounce = null;    // debounce timer for hover
    let _listeners = {};          // attached event listener refs

    // â”€â”€ Catalogue Loading â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    async function _loadCatalogue() {
        if (_catalogue) return;
        try {
            const resp = await fetch('/static/data/assistant-catalogue.json');
            if (!resp.ok) {
                console.warn('[assistant] catalogue fetch failed:', resp.status);
                return;
            }
            const data = await resp.json();
            _catalogue = new Map();
            for (const ctx of data) {
                _catalogue.set(ctx.context, ctx);
            }
        } catch (e) {
            console.warn('[assistant] catalogue load error:', e);
        }
    }

    // â”€â”€ Panel Resolution â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    function _resolvePanel() {
        const el = document.getElementById('assistant-panel');
        if (!el) {
            console.warn('[assistant] #assistant-panel not found in DOM');
        }
        return el;
    }

    // â”€â”€ Template Variable Resolution â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    function _resolve(text) {
        if (!text) return '';
        return text.replace(/\{\{(\w+)\}\}/g, function(match, name) {
            const resolver = window._assistant.resolvers[name];
            if (typeof resolver === 'function') {
                try { return resolver(); }
                catch (e) { return ''; }
            }
            return '';
        });
    }

    // â”€â”€ State-Variant Resolution â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // A node (or childTemplate) can carry a `variants` array.
    // Each variant has a `when` condition checked against a DOM element.
    // The first matching variant's content/expanded override the base.
    // If no variant matches, the base fields are used as-is.

    function _resolveVariant(node, element) {
        if (!node.variants || !node.variants.length || !element) return node;

        for (var i = 0; i < node.variants.length; i++) {
            var v = node.variants[i];
            if (!v.when) continue;

            var match = true;

            if (v.when.textContains) {
                match = match && element.textContent
                    .toLowerCase()
                    .includes(v.when.textContains.toLowerCase());
            }

            if (match && v.when.hasSelector) {
                match = match && !!element.querySelector(v.when.hasSelector);
            }

            if (match && v.when.resolver) {
                var resolverFn = window._assistant.resolvers[v.when.resolver];
                var resolverVal = resolverFn ? String(resolverFn()) : '';
                if (v.when.equals !== undefined) {
                    match = match && resolverVal === String(v.when.equals);
                } else if (v.when.contains !== undefined) {
                    match = match && resolverVal.toLowerCase().indexOf(String(v.when.contains).toLowerCase()) !== -1;
                } else if (v.when.not !== undefined) {
                    match = match && resolverVal !== String(v.when.not);
                }
            }

            if (match) {
                // Merge: variant fields override base, everything else preserved
                return {
                    id: node.id,
                    title: v.title || node.title,
                    icon: v.icon || node.icon,
                    content: v.content !== undefined ? v.content : node.content,
                    expanded: v.expanded !== undefined ? v.expanded : node.expanded,
                    selector: node.selector,
                    separator: node.separator,
                    children: node.children,
                    dynamic: node.dynamic,
                    childTemplate: node.childTemplate,
                    variants: node.variants,
                    _element: node._element,
                    _isDynamic: node._isDynamic,
                    _variantIndex: i
                };
            }
        }

        return node;  // No variant matched â†’ base content
    }

    // Resolve variant for a DOM element matched to a static node.
    // Static nodes don't have _element, so we find the element via selector.
    function _resolveStaticVariant(node) {
        if (!node.variants || !node.variants.length) return node;
        if (node._element) return _resolveVariant(node, node._element);
        if (!node.selector || !_containerEl) return node;

        try {
            var el = _containerEl.querySelector(node.selector);
            if (el) return _resolveVariant(node, el);
        } catch (e) {
            // Invalid selector
        }
        return node;
    }

    // â”€â”€ Tree Flattening â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Builds a flat index of [{ node, parents }] for selector matching.
    // Deepest nodes first so specific selectors win over general ones.

    function _flattenTree(children, parentChain) {
        const result = [];
        for (const child of (children || [])) {
            // Recurse children first â†’ deepest nodes appear first
            if (child.children && child.children.length) {
                result.push(..._flattenTree(child.children, [...parentChain, child]));
            }
            result.push({ node: child, parents: [...parentChain] });

            // Handle dynamic children â€” query DOM for real elements
            if (child.dynamic && child.childTemplate && _containerEl) {
                _resolveDynamic(child, parentChain, result);
            }
        }
        return result;
    }

    function _resolveDynamic(parentNode, grandParentChain, result) {
        const tpl = parentNode.childTemplate;
        if (!tpl.selector) return;

        const elements = _containerEl.querySelectorAll(tpl.selector);
        elements.forEach(function(el, i) {
            // Extract display name from the element's DOM
            // 1. If childTemplate defines nameSelector, use that
            // 2. Otherwise try font-weight:600 / strong heuristic
            // 3. Fallback: first text node
            var nameEl = tpl.nameSelector
                ? el.querySelector(tpl.nameSelector)
                : el.querySelector('[style*="font-weight:600"], [style*="font-weight: 600"], strong');
            var extractedName;
            if (nameEl) {
                extractedName = nameEl.textContent.trim();
            } else {
                // Fallback: first text node only (avoid grabbing child element text)
                var walker = document.createTreeWalker(el, NodeFilter.SHOW_TEXT, null, false);
                var firstText = walker.nextNode();
                extractedName = firstText ? firstText.textContent.trim() : '';
            }

            if (!extractedName) return;

            // Apply {{name}} template interpolation to all template strings
            var nodeTitle = (tpl.title || '').replace(/\{\{name\}\}/g, extractedName);
            var nodeContent = (tpl.content || '').replace(/\{\{name\}\}/g, extractedName);
            var nodeExpanded = tpl.expanded
                ? tpl.expanded.replace(/\{\{name\}\}/g, extractedName)
                : undefined;

            // â”€â”€ Context-aware enrichment â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            // Read DOM state to add application-specific knowledge.

            // Detect "default" badge (environment rows)
            var defaultBadge = el.querySelector('[style*="accent-glow"]');
            if (defaultBadge && defaultBadge.textContent.trim().toLowerCase() === 'default') {
                nodeTitle += ' Â· default';
                var defaultNote = '\n\nAs the default environment, it will be pre-selected when you define secrets and variables in Step 3.';
                nodeExpanded = nodeExpanded ? nodeExpanded + defaultNote : defaultNote;
            }

            // Extract stack/path/domain metadata (module rows)
            var metaSpans = el.querySelectorAll('span');
            var extractedStack = '', extractedPath = '', extractedDomain = '';
            metaSpans.forEach(function(sp) {
                var txt = sp.textContent.trim();
                if (txt.indexOf('Stack:') === 0) extractedStack = txt.replace('Stack:', '').trim();
                if (txt.indexOf('Domain:') === 0) extractedDomain = txt.replace('Domain:', '').trim();
            });
            var codeEl = el.querySelector('code');
            if (codeEl) extractedPath = codeEl.textContent.trim();

            if (extractedStack) {
                nodeTitle += ' Â· ' + extractedStack;
                // Build styled detail card (same UX as stack select)
                var _dcpStacks = (window._dcp && window._dcp.stacks) || [];
                var stackEntry = _dcpStacks.find(function(s) { return s.name === extractedStack; });
                if (stackEntry) {
                    var stackHtml = '<div class="assistant-stack-detail">';

                    if (stackEntry.parent) {
                        // Flavored: language first, then framework
                        var parentEntry = _dcpStacks.find(function(s) { return s.name === stackEntry.parent; });
                        if (parentEntry) {
                            stackHtml += '<div class="assistant-stack-detail-name">' +
                                (parentEntry.icon || '') + ' ' + parentEntry.name + '</div>';
                            stackHtml += '<div class="assistant-stack-detail-text">' +
                                (parentEntry.detail || parentEntry.description) + '</div>';
                        }
                        stackHtml += '<div class="assistant-stack-detail-framework">' +
                            '\u21b3 ' + extractedStack + '</div>';
                        stackHtml += '<div class="assistant-stack-detail-text">' +
                            (stackEntry.detail || stackEntry.description) + '</div>';
                    } else {
                        // Base stack
                        stackHtml += '<div class="assistant-stack-detail-name">' +
                            (stackEntry.icon || '') + ' ' + extractedStack + '</div>';
                        stackHtml += '<div class="assistant-stack-detail-text">' +
                            (stackEntry.detail || stackEntry.description) + '</div>';
                    }

                    if (stackEntry.capabilities && stackEntry.capabilities.length > 0) {
                        stackHtml += '<div class="assistant-stack-detail-caps">' +
                            'Capabilities: ' + stackEntry.capabilities.join(', ') + '</div>';
                    }

                    stackHtml += '</div>';
                    nodeExpanded = stackHtml + (nodeExpanded ? '\n' + nodeExpanded : '');
                }
            }

            // â”€â”€ Dockerfile enrichment (per-file analysis) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            // Reuses the same logic as the dockerfileAnalysis resolver
            // to produce identical quality per-file breakdowns.
            if (parentNode.id === 'docker-section-dockerfiles') {
                // Base images: accent-colored spans (exclude stage/port text)
                var baseSpans = el.querySelectorAll('span[style*="accent"]');
                var bases = [];
                baseSpans.forEach(function(s) {
                    var txt = s.textContent.trim();
                    if (txt.indexOf('AS ') !== 0 && txt.indexOf('-stage') === -1 && txt.indexOf('EXPOSE') === -1) {
                        bases.push(txt);
                    }
                });

                // Stages
                var stageSpans = el.querySelectorAll('span[style*="text-muted"]');
                var stages = [];
                stageSpans.forEach(function(s) {
                    var txt = s.textContent.trim();
                    if (txt.indexOf('AS ') === 0) stages.push(txt.substring(3));
                });

                // Ports
                var portSpan = el.querySelector('span[style*="text-muted"]');
                var portMatch = portSpan ? portSpan.textContent.match(/EXPOSE\s+([\d, ]+)/) : null;
                var ports = portMatch ? portMatch[1] : '';

                // Build per-image breakdown cards using _parseDockerImage
                var imageCards = '';
                bases.forEach(function(b) {
                    var p = _parseDockerImage(b);
                    if (!p) return;
                    imageCards += '<div style="display:flex;gap:0.3rem;flex-wrap:wrap;margin-top:0.25rem">' +
                        '<span style="font-size:0.7rem;padding:0.1rem 0.35rem;border-radius:4px;background:color-mix(in srgb, var(--accent) 12%, transparent);color:var(--accent);font-weight:600">ğŸ”§ ' + p.label + '</span>' +
                        '<span style="font-size:0.7rem;padding:0.1rem 0.35rem;border-radius:4px;background:color-mix(in srgb, var(--text-secondary) 10%, transparent);color:var(--text-secondary)">ğŸ“Œ ' + p.version + '</span>' +
                        (p.variant ? '<span style="font-size:0.7rem;padding:0.1rem 0.35rem;border-radius:4px;background:color-mix(in srgb, var(--success) 10%, transparent);color:var(--success)">ğŸ“¦ ' + p.variant + '</span>' : '') +
                        '</div>' +
                        (p.variantExplain ? '<div style="font-size:0.65rem;color:var(--text-muted);margin-top:0.15rem;padding-left:0.2rem">' + p.variantExplain + '</div>' : '');
                });

                // Stage info
                var stageInfo = '';
                if (stages.length > 0) {
                    stageInfo = '<div style="font-size:0.68rem;color:var(--accent);margin-top:0.2rem">âš¡ ' + (stages.length + 1) + '-stage build (stages: ' + stages.join(', ') + ')</div>';
                }

                // Port info
                var portInfo = '';
                if (ports) {
                    portInfo = '<div style="font-size:0.68rem;color:var(--text-muted);margin-top:0.1rem">ğŸ”Œ EXPOSE ' + ports + '</div>';
                }

                nodeExpanded = '<div class="assistant-state-card state-info" style="margin-bottom:0.4rem">' +
                    '<div class="state-label">ğŸ“„ ' + extractedName + '</div>' +
                    '<div class="state-detail">' + imageCards + stageInfo + portInfo + '</div>' +
                    '</div>';
            }

            // â”€â”€ Compose service enrichment (per-service analysis) â”€â”€â”€â”€
            // Same logic as dockerSvcAnalysis resolver for identical quality.
            if (parentNode.id === 'docker-section-compose-svcs') {
                var imageEl = el.querySelector('code');
                var image = imageEl ? imageEl.textContent.trim() : '?';

                var parsed = null;
                if (image !== '(build)' && image !== '?') {
                    parsed = _parseDockerImage(image);
                }

                // Determine role and card style
                var role = 'application';
                var cardStyle = 'state-success';
                if (parsed) {
                    if (parsed.family === 'database') { role = 'database'; cardStyle = 'state-info'; }
                    else if (parsed.family === 'cache') { role = 'cache'; cardStyle = 'state-info'; }
                    else if (parsed.family === 'webserver') { role = 'proxy'; cardStyle = 'state-info'; }
                }
                if (image === '(build)') { role = 'application (builds from Dockerfile)'; }

                // Volumes, deps, restart from muted spans
                var mutedSpans = el.querySelectorAll('span[style*="text-muted"]');
                var metaHtml = '';
                mutedSpans.forEach(function(s) {
                    var txt = s.textContent.trim();
                    if (txt) metaHtml += '<span style="font-size:0.65rem;padding:0.05rem 0.25rem;border-radius:3px;background:color-mix(in srgb, var(--text-muted) 8%, transparent);color:var(--text-muted);margin-right:0.2rem">' + txt + '</span>';
                });

                // Image breakdown pills
                var imagePills = '';
                if (parsed) {
                    imagePills = '<div style="display:flex;gap:0.3rem;flex-wrap:wrap;margin-top:0.25rem">' +
                        '<span style="font-size:0.7rem;padding:0.1rem 0.35rem;border-radius:4px;background:color-mix(in srgb, var(--accent) 12%, transparent);color:var(--accent);font-weight:600">ğŸ”§ ' + parsed.label + '</span>' +
                        '<span style="font-size:0.7rem;padding:0.1rem 0.35rem;border-radius:4px;background:color-mix(in srgb, var(--text-secondary) 10%, transparent);color:var(--text-secondary)">ğŸ“Œ ' + parsed.version + '</span>' +
                        (parsed.variant ? '<span style="font-size:0.7rem;padding:0.1rem 0.35rem;border-radius:4px;background:color-mix(in srgb, var(--success) 10%, transparent);color:var(--success)">ğŸ“¦ ' + parsed.variant + '</span>' : '') +
                        '</div>' +
                        (parsed.variantExplain ? '<div style="font-size:0.65rem;color:var(--text-muted);margin-top:0.15rem;padding-left:0.2rem">' + parsed.variantExplain + '</div>' : '');
                } else if (image === '(build)') {
                    imagePills = '<div style="font-size:0.68rem;color:var(--accent);margin-top:0.2rem">ğŸ”¨ Builds from local Dockerfile â€” see Dockerfile Analysis for image details</div>';
                }

                nodeExpanded = '<div class="assistant-state-card ' + cardStyle + '" style="margin-bottom:0.4rem">' +
                    '<div class="state-label">' + extractedName + ' <span style="font-size:0.7rem;opacity:0.7">(' + role + ')</span></div>' +
                    '<div class="state-detail">' + imagePills +
                    (metaHtml ? '<div style="margin-top:0.2rem">' + metaHtml + '</div>' : '') +
                    '</div></div>';
            }

            // â”€â”€ K8s manifest enrichment (per-file analysis) â”€â”€â”€â”€â”€â”€â”€â”€â”€
            // Reads resource kinds from the muted span next to the file path.
            if (parentNode.id === 'k8s-section-manifests') {
                // Parse "count Â· Kind1, Kind2" from the muted span
                var kindSpan = el.querySelector('span[style*="text-muted"]');
                var kindText = kindSpan ? kindSpan.textContent.trim() : '';
                var countMatch = kindText.match(/^(\d+)\s*Â·\s*(.+)$/);
                var resCount = countMatch ? countMatch[1] : '?';
                var kindList = countMatch ? countMatch[2].split(',').map(function(k) { return k.trim(); }) : [];

                // Map known K8s kinds to icons and descriptions
                var kindMap = {
                    'Deployment': { icon: 'ğŸš€', desc: 'manages replicated pods with rolling updates' },
                    'StatefulSet': { icon: 'ğŸ—„', desc: 'pods with stable identity and persistent storage' },
                    'DaemonSet': { icon: 'ğŸ“¡', desc: 'runs one pod per node across the cluster' },
                    'Service': { icon: 'ğŸŒ', desc: 'stable network endpoint for pods' },
                    'ConfigMap': { icon: 'ğŸ”§', desc: 'key-value config injected as env vars or files' },
                    'Secret': { icon: 'ğŸ”’', desc: 'base64-encoded sensitive data' },
                    'Ingress': { icon: 'ğŸŒ', desc: 'HTTP routing rules for external traffic' },
                    'PersistentVolumeClaim': { icon: 'ğŸ“€', desc: 'requests durable storage for pods' },
                    'CronJob': { icon: 'â°', desc: 'scheduled pod execution' },
                    'Job': { icon: 'âš¡', desc: 'run-to-completion batch task' },
                    'HorizontalPodAutoscaler': { icon: 'ğŸ“ˆ', desc: 'auto-scales replicas on metrics' },
                    'ServiceAccount': { icon: 'ğŸ”‘', desc: 'pod identity for RBAC permissions' },
                    'Role': { icon: 'ğŸ›¡', desc: 'namespace-scoped permission set' },
                    'ClusterRole': { icon: 'ğŸ›¡', desc: 'cluster-wide permission set' },
                    'RoleBinding': { icon: 'ğŸ”—', desc: 'binds a Role to a ServiceAccount' },
                    'Namespace': { icon: 'ğŸ“‚', desc: 'virtual cluster partition' },
                    'NetworkPolicy': { icon: 'ğŸ”', desc: 'pod-level network access rules' },
                    'PodDisruptionBudget': { icon: 'ğŸ›Ÿ', desc: 'minimum availability during disruptions' }
                };

                var kindPills = '';
                kindList.forEach(function(k) {
                    var info = kindMap[k] || { icon: 'ğŸ“¦', desc: 'Kubernetes resource' };
                    kindPills += '<div style="display:flex;gap:0.3rem;align-items:center;margin-top:0.15rem">' +
                        '<span style="font-size:0.7rem;padding:0.1rem 0.35rem;border-radius:4px;background:color-mix(in srgb, var(--accent) 12%, transparent);color:var(--accent);font-weight:600">' + info.icon + ' ' + k + '</span>' +
                        '<span style="font-size:0.65rem;color:var(--text-muted)">' + info.desc + '</span>' +
                        '</div>';
                });

                nodeExpanded = '<div class="assistant-state-card state-info" style="margin-bottom:0.4rem">' +
                    '<div class="state-label">ğŸ“„ ' + extractedName + ' <span style="font-size:0.7rem;opacity:0.7">(' + resCount + ' resource' + (resCount !== '1' ? 's' : '') + ')</span></div>' +
                    '<div class="state-detail">' + kindPills + '</div>' +
                    '</div>';
            }

            // â”€â”€ K8s Helm chart enrichment (per-chart analysis) â”€â”€â”€â”€â”€â”€
            // Reads chart metadata from the DOM row structure.
            if (parentNode.id === 'k8s-section-helm') {
                var chartVersion = '';
                var versionEl = el.querySelector('code[style*="text-muted"]');
                if (versionEl) chartVersion = versionEl.textContent.trim();

                // Read metadata spans (values.yaml, templates/, subcharts, env values)
                var chartMeta = [];
                var metaSpansHelm = el.querySelectorAll('span[style*="text-muted"]');
                metaSpansHelm.forEach(function(s) {
                    var txt = s.textContent.trim();
                    if (txt) chartMeta.push(txt);
                });
                var envValuesSpan = el.querySelector('span[style*="accent"]');
                if (envValuesSpan) chartMeta.push(envValuesSpan.textContent.trim());

                var chartMetaHtml = '';
                chartMeta.forEach(function(m) {
                    chartMetaHtml += '<span style="font-size:0.65rem;padding:0.05rem 0.25rem;border-radius:3px;background:color-mix(in srgb, var(--text-muted) 8%, transparent);color:var(--text-muted);margin-right:0.2rem">' + m + '</span>';
                });

                nodeExpanded = '<div class="assistant-state-card state-info" style="margin-bottom:0.4rem">' +
                    '<div class="state-label">âˆ ' + extractedName + (chartVersion ? ' <span style="font-size:0.7rem;opacity:0.7">v' + chartVersion + '</span>' : '') + '</div>' +
                    '<div class="state-detail">' +
                    (chartMetaHtml ? '<div style="display:flex;flex-wrap:wrap;gap:0.15rem;margin-top:0.15rem">' + chartMetaHtml + '</div>' : '') +
                    '<div style="font-size:0.68rem;color:var(--text-muted);margin-top:0.2rem">Helm chart bundles K8s resources into a reusable, configurable package. Install with: helm install ' + extractedName + ' ./' + extractedName + '</div>' +
                    '</div></div>';
            }

            // â”€â”€ K8s Kustomize overlay enrichment (per-overlay) â”€â”€â”€â”€â”€â”€
            if (parentNode.id === 'k8s-section-kustomize') {
                var patchSpan = el.querySelector('span[style*="text-muted"]');
                var patchText = patchSpan ? patchSpan.textContent.trim() : '';

                nodeExpanded = '<div class="assistant-state-card state-info" style="margin-bottom:0.4rem">' +
                    '<div class="state-label">ğŸ“ ' + extractedName + (patchText ? ' <span style="font-size:0.7rem;opacity:0.7">(' + patchText + ')</span>' : '') + '</div>' +
                    '<div class="state-detail">' +
                    '<div style="font-size:0.68rem;color:var(--text-muted);margin-top:0.1rem">Environment overlay â€” applies patches on top of base manifests for ' + extractedName + '-specific configuration.</div>' +
                    '<div style="font-size:0.68rem;color:var(--text-muted);margin-top:0.1rem">Apply: <code style="font-size:0.65rem">kubectl apply -k overlays/' + extractedName + '/</code></div>' +
                    '</div></div>';
            }

            // â”€â”€ Terraform file enrichment (per-file analysis) â”€â”€â”€â”€â”€â”€â”€â”€
            // Reads the file type from the muted span next to the file path.
            if (parentNode.id === 'tf-section-files') {
                var typeSpan = el.querySelector('span[style*="text-muted"]');
                var fileType = typeSpan ? typeSpan.textContent.trim() : '';

                // Map .tf file types to icons and descriptions
                var tfFileTypeMap = {
                    'resource':  { icon: 'ğŸ“¦', desc: 'declares infrastructure objects â€” the core of any Terraform config' },
                    'variable':  { icon: 'ğŸ“¥', desc: 'input parameters â€” make configs reusable across environments' },
                    'output':    { icon: 'ğŸ“¤', desc: 'exports values after apply â€” IPs, URLs, ARNs, connection strings' },
                    'provider':  { icon: 'â˜', desc: 'configures cloud API connections â€” credentials, region, features' },
                    'data':      { icon: 'ğŸ”', desc: 'reads existing infrastructure â€” lookup AMIs, VPCs, DNS zones without creating them' },
                    'module':    { icon: 'ğŸ“¦', desc: 'imports reusable infrastructure packages from registry, Git, or local path' },
                    'backend':   { icon: 'ğŸ’¾', desc: 'configures where Terraform state is stored and how it\'s locked' },
                    'locals':    { icon: 'ğŸ·ï¸', desc: 'computed values used within the same module â€” reduce repetition' },
                    'terraform': { icon: 'âš™ï¸', desc: 'terraform block â€” version constraints, required providers, backend' },
                    'mixed':     { icon: 'ğŸ“„', desc: 'contains multiple block types â€” resources, variables, outputs, etc.' }
                };

                var typeInfo = tfFileTypeMap[fileType] || { icon: 'ğŸ“„', desc: 'Terraform configuration file' };

                nodeExpanded = '<div class="assistant-state-card state-info" style="margin-bottom:0.4rem">' +
                    '<div class="state-label">' + typeInfo.icon + ' ' + extractedName + (fileType ? ' <span style="font-size:0.7rem;opacity:0.7">(' + fileType + ')</span>' : '') + '</div>' +
                    '<div class="state-detail">' +
                    '<div style="font-size:0.7rem;color:var(--text-secondary);margin-top:0.1rem">' + typeInfo.desc + '</div>' +
                    '</div></div>';
            }

            // â”€â”€ Terraform provider enrichment (per-provider analysis) â”€
            // Maps provider names to cloud platform descriptions.
            if (parentNode.id === 'tf-section-providers') {
                var providerName = extractedName.toLowerCase().trim();
                // Strip registry prefix: hashicorp/aws â†’ aws
                if (providerName.indexOf('/') !== -1) providerName = providerName.split('/').pop();

                var tfProviderMap = {
                    'aws':          { icon: 'ğŸŸ§', label: 'Amazon Web Services', desc: '1000+ resource types â€” EC2, S3, RDS, Lambda, ECS, EKS, and more' },
                    'google':       { icon: 'ğŸ”µ', label: 'Google Cloud Platform', desc: 'Compute Engine, GKE, Cloud SQL, BigQuery, Cloud Functions' },
                    'azurerm':      { icon: 'ğŸ”·', label: 'Microsoft Azure', desc: 'VMs, AKS, Cosmos DB, App Service, Azure Functions' },
                    'digitalocean': { icon: 'ğŸ”µ', label: 'DigitalOcean', desc: 'Droplets, DOKS (K8s), Spaces, Databases, App Platform' },
                    'kubernetes':   { icon: 'â˜¸ï¸', label: 'Kubernetes', desc: 'manages K8s resources (Deployments, Services, ConfigMaps) via Terraform' },
                    'helm':         { icon: 'âˆ', label: 'Helm', desc: 'deploys Helm charts as Terraform resources â€” integrates with K8s provider' },
                    'cloudflare':   { icon: 'ğŸŸ ', label: 'Cloudflare', desc: 'DNS records, Workers, Tunnels, WAF rules, Page Rules' },
                    'github':       { icon: 'ğŸ™', label: 'GitHub', desc: 'repositories, teams, branch protection, Actions secrets' },
                    'gitlab':       { icon: 'ğŸ¦Š', label: 'GitLab', desc: 'projects, groups, CI/CD variables, deploy tokens' },
                    'null':         { icon: 'â¬œ', label: 'Null Provider', desc: 'placeholder resources for local-exec and remote-exec provisioners' },
                    'random':       { icon: 'ğŸ²', label: 'Random Provider', desc: 'generates random values â€” IDs, passwords, pet names, shuffles' },
                    'local':        { icon: 'ğŸ“', label: 'Local Provider', desc: 'manages local files and directories via Terraform state' },
                    'tls':          { icon: 'ğŸ”', label: 'TLS Provider', desc: 'generates TLS certificates and private keys' },
                    'docker':       { icon: 'ğŸ³', label: 'Docker', desc: 'manages Docker containers, images, networks, and volumes' },
                    'vault':        { icon: 'ğŸ”’', label: 'HashiCorp Vault', desc: 'manages secrets, auth backends, policies, and mounts' }
                };

                var provInfo = tfProviderMap[providerName] || { icon: 'â˜', label: providerName, desc: 'Terraform provider â€” see registry.terraform.io for documentation' };

                nodeExpanded = '<div class="assistant-state-card state-info" style="margin-bottom:0.4rem">' +
                    '<div class="state-label">' + provInfo.icon + ' ' + provInfo.label + '</div>' +
                    '<div class="state-detail">' +
                    '<div style="font-size:0.7rem;color:var(--text-secondary);margin-top:0.1rem">' + provInfo.desc + '</div>' +
                    '<div style="font-size:0.65rem;color:var(--text-muted);margin-top:0.15rem">Registry: registry.terraform.io/providers/hashicorp/' + providerName + '</div>' +
                    '</div></div>';
            }

            // â”€â”€ Terraform module enrichment (per-module analysis) â”€â”€â”€â”€â”€
            // Reads module source from the code element to determine source type.
            if (parentNode.id === 'tf-section-modules') {
                var sourceEl = el.querySelector('code[style*="text-muted"]');
                var moduleSource = sourceEl ? sourceEl.textContent.trim() : '';

                // Determine source type from the source string
                var sourceType = 'unknown';
                var sourceIcon = 'ğŸ“¦';
                var sourceDesc = 'Terraform module';
                if (moduleSource.indexOf('registry.terraform.io') !== -1 || (!moduleSource.startsWith('./') && !moduleSource.startsWith('../') && !moduleSource.startsWith('git') && !moduleSource.startsWith('http') && moduleSource.indexOf('/') !== -1 && !moduleSource.startsWith('.'))) {
                    sourceType = 'registry';
                    sourceIcon = 'ğŸ“¦';
                    sourceDesc = 'Terraform Registry module â€” official or community-maintained, versioned and documented';
                } else if (moduleSource.startsWith('git::') || moduleSource.startsWith('github.com') || moduleSource.startsWith('git@')) {
                    sourceType = 'git';
                    sourceIcon = 'ğŸ”—';
                    sourceDesc = 'Git-sourced module â€” version pinned via ?ref=tag, branch, or commit SHA';
                } else if (moduleSource.startsWith('./') || moduleSource.startsWith('../')) {
                    sourceType = 'local';
                    sourceIcon = 'ğŸ“';
                    sourceDesc = 'Local module â€” project-local reusable block, no network fetch needed';
                } else if (moduleSource.startsWith('http://') || moduleSource.startsWith('https://')) {
                    sourceType = 'http';
                    sourceIcon = 'ğŸŒ';
                    sourceDesc = 'HTTP-sourced module â€” downloaded from URL as archive';
                } else if (moduleSource.startsWith('s3::') || moduleSource.startsWith('gcs::')) {
                    sourceType = 'cloud';
                    sourceIcon = 'â˜';
                    sourceDesc = 'Cloud storage module â€” downloaded from S3 bucket or GCS';
                }

                nodeExpanded = '<div class="assistant-state-card state-info" style="margin-bottom:0.4rem">' +
                    '<div class="state-label">' + sourceIcon + ' ' + extractedName + ' <span style="font-size:0.7rem;opacity:0.7">(' + sourceType + ')</span></div>' +
                    '<div class="state-detail">' +
                    (moduleSource ? '<div style="font-size:0.68rem;color:var(--accent);margin-top:0.1rem"><code style="font-size:0.65rem">' + moduleSource + '</code></div>' : '') +
                    '<div style="font-size:0.7rem;color:var(--text-secondary);margin-top:0.15rem">' + sourceDesc + '</div>' +
                    '</div></div>';
            }

            var syntheticNode = {
                id: parentNode.id + '-dyn-' + i,
                title: nodeTitle,
                content: nodeContent,
                expanded: nodeExpanded,
                selector: null,
                _element: el,
                _isDynamic: true,
                children: []
            };

            // Apply childTemplate variants if defined
            if (tpl.variants && tpl.variants.length) {
                syntheticNode.variants = tpl.variants;
                syntheticNode = _resolveVariant(syntheticNode, el);
                // Re-apply {{name}} interpolation to variant content
                if (syntheticNode.content) {
                    syntheticNode.content = syntheticNode.content.replace(/\{\{name\}\}/g, extractedName);
                }
                if (syntheticNode.expanded) {
                    syntheticNode.expanded = syntheticNode.expanded.replace(/\{\{name\}\}/g, extractedName);
                }
            }

            // Dynamic children go deepest-first (before their parent)
            result.unshift({ node: syntheticNode, parents: [...grandParentChain, parentNode] });
        });
    }

    // â”€â”€ Node Matching â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Given a DOM element (from hover/focus), find the matching node.

    function _matchNode(element) {
        if (!element || !_flatNodes.length) return null;

        // Collect ALL matching nodes, then return the deepest one.
        // When multiple nodes share the same selector (e.g., a parent and its
        // children all point at #wiz-docker-base), we want the most specific
        // child â€” the one with the longest parent chain.
        var bestMatch = null;
        var bestDepth = -1;

        for (let i = 0; i < _flatNodes.length; i++) {
            const entry = _flatNodes[i];
            const node = entry.node;
            var matched = false;

            // Dynamic nodes: match by direct element reference
            if (node._element) {
                if (node._element === element || node._element.contains(element)) {
                    matched = true;
                }
            } else if (node.selector) {
                // Static nodes: match by CSS selector
                try {
                    // 1. Direct match: the element itself IS the selector target
                    if (element.matches(node.selector)) {
                        matched = true;
                    }

                    // 2. Inside: the element is a descendant of the selector target
                    if (!matched && element.closest(node.selector)) {
                        matched = true;
                    }

                    // 3. Field-group proximity: the element shares a wrapper div
                    //    with the selector target. This handles hovering a <label>
                    //    that's a sibling of <input id="wiz-name">.
                    //    Skip for ID selectors â€” they already uniquely target
                    //    elements and proximity would false-positive on siblings
                    //    in the same flex row.
                    if (!matched && node.selector.charAt(0) !== '#') {
                        const targetEl = _containerEl.querySelector(node.selector);
                        if (targetEl && targetEl.parentElement) {
                            const wrapper = targetEl.parentElement.closest('div');
                            if (wrapper && wrapper !== _containerEl &&
                                (wrapper === element || wrapper.contains(element))) {
                                matched = true;
                            }
                        }
                    }
                } catch (e) {
                    // Invalid selector â€” skip silently
                }
            }

            if (matched) {
                var depth = entry.parents ? entry.parents.length : 0;
                if (depth > bestDepth) {
                    bestDepth = depth;
                    bestMatch = entry;
                }
            }
        }

        return bestMatch;
    }

    // â”€â”€ Path Merging â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Merge focus and hover paths. Deduplicate shared parents.
    // Returns [{ node, depth, isTarget }] sorted shallowest-first.

    function _mergeInteractionPaths(focusPath, hoverPath) {
        const nodeMap = new Map();  // nodeId â†’ { node, depth, isTarget }

        function _addPath(path) {
            if (!path) return;
            // Add parents (in-chain)
            for (let i = 0; i < path.chain.length; i++) {
                const n = path.chain[i];
                if (!nodeMap.has(n.id)) {
                    nodeMap.set(n.id, { node: n, depth: i, isTarget: false });
                }
            }
            // Add target
            const depth = path.chain.length;
            const existing = nodeMap.get(path.target.id);
            if (existing) {
                existing.isTarget = true;  // promote to target
            } else {
                nodeMap.set(path.target.id, {
                    node: path.target,
                    depth: depth,
                    isTarget: true
                });
            }
        }

        _addPath(focusPath);
        _addPath(hoverPath);

        // Sort by depth (shallowest first)
        var sorted = Array.from(nodeMap.values());
        sorted.sort(function(a, b) { return a.depth - b.depth; });

        // Limit: keep only target + 1 immediate parent (max 2 nodes from target)
        var maxTargetDepth = -1;
        for (var i = 0; i < sorted.length; i++) {
            if (sorted[i].isTarget && sorted[i].depth > maxTargetDepth) {
                maxTargetDepth = sorted[i].depth;
            }
        }
        if (maxTargetDepth >= 0) {
            var minDepth = Math.max(0, maxTargetDepth - 1);
            sorted = sorted.filter(function(e) { return e.depth >= minDepth; });
            // Normalize depths so shallowest shown renders at depth 0
            for (var j = 0; j < sorted.length; j++) {
                sorted[j].depth = sorted[j].depth - minDepth;
            }
        }

        return sorted;
    }

    // â”€â”€ Rendering â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    function _renderContextHeader() {
        if (!_panelEl || !_currentCtx) return;

        _panelEl.innerHTML = '';

        const inner = document.createElement('div');
        inner.className = 'assistant-panel-inner';

        const header = document.createElement('div');
        header.className = 'assistant-context-header';
        header.innerHTML =
            '<div class="assistant-context-title">' +
                (_currentCtx.icon ? _currentCtx.icon + ' ' : '') +
                _currentCtx.title +
            '</div>' +
            '<div class="assistant-context-content">' +
                _resolve(_currentCtx.content) +
            '</div>';

        inner.appendChild(header);
        _panelEl.appendChild(inner);
    }

    function _renderInteractionPath() {
        if (!_panelEl || !_currentCtx) return;

        // If no interaction, fall back to sticky path or entry state
        if (!_focusPath && !_hoverPath) {
            if (_stickyPath) {
                // Restore sticky hover so panel keeps its content
                _hoverPath = _stickyPath;
            } else {
                _renderContextHeader();
                _panelEl.classList.add('entry-state');
                return;
            }
        }

        // Save current path as sticky (survives mouse-to-panel trips).
        // Ancestor guard: only update sticky if the new hover is at the same
        // depth or deeper. This prevents a brief border-crossing on the way
        // to the panel from clobbering a deep target with its parent.
        if (_hoverPath) {
            var newDepth = _hoverPath.chain ? _hoverPath.chain.length : 0;
            var stickyDepth = _stickyPath && _stickyPath.chain ? _stickyPath.chain.length : -1;
            if (newDepth >= stickyDepth) {
                _stickyPath = _hoverPath;
            }
        }

        _panelEl.classList.remove('entry-state');

        // Re-render context header + path
        _renderContextHeader();

        const inner = _panelEl.querySelector('.assistant-panel-inner');
        if (!inner) return;

        // Merge paths
        const pathNodes = _mergeInteractionPaths(_focusPath, _hoverPath);

        // Render each node
        for (let i = 0; i < pathNodes.length; i++) {
            var entry = pathNodes[i];

            // Resolve state-variant content for static nodes
            var node = entry.node._isDynamic
                ? entry.node  // Dynamic nodes already resolved in _resolveDynamic
                : _resolveStaticVariant(entry.node);

            // Separator
            if (node.separator) {
                var sep = document.createElement('hr');
                sep.className = 'assistant-separator';
                inner.appendChild(sep);
            }

            var div = document.createElement('div');
            div.className = 'assistant-node';
            div.dataset.nodeId = node.id;
            div.dataset.depth = entry.depth;

            // State class
            if (entry.isTarget) {
                div.classList.add('active-target');
            } else {
                div.classList.add('in-chain');
            }

            // Title
            var titleEl = document.createElement('div');
            titleEl.className = 'assistant-node-title';
            titleEl.textContent = (node.icon ? node.icon + ' ' : '') + (node.title || '');
            div.appendChild(titleEl);

            // Content
            var contentEl = document.createElement('div');
            contentEl.className = 'assistant-node-content';
            contentEl.innerHTML = _resolve(node.content);
            div.appendChild(contentEl);

            // Expanded content â€” show for active targets and their direct parent
            var showExpanded = entry.isTarget ||
                (node.expanded && i < pathNodes.length - 1 && pathNodes[i + 1].isTarget);
            if (showExpanded && node.expanded) {
                var expandedEl = document.createElement('div');
                expandedEl.className = 'assistant-node-expanded';
                expandedEl.innerHTML = _resolve(node.expanded);
                div.appendChild(expandedEl);
            }

            inner.appendChild(div);
        }

        // Center the active target in the panel viewport, then apply highlights
        requestAnimationFrame(function() {
            var didHighlight = _highlightSelectedStack();
            _highlightActiveEnv();
            // If a stack is highlighted, _highlightSelectedStack scrolls to it.
            // Otherwise, fall back to centering on the active target node.
            if (!didHighlight) {
                _centerActiveNode();
            }
        });
    }

    // â”€â”€ Scroll Centering â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Uses direct scrollTop on the panel â€” never touches page scroll.

    function _centerActiveNode() {
        if (!_panelEl) return;

        var target = _panelEl.querySelector('.assistant-node.active-target');
        if (!target) return;

        // Calculate where target sits relative to the panel's scroll container
        var targetTop = target.offsetTop;
        var targetHeight = target.offsetHeight;
        var panelHeight = _panelEl.clientHeight;

        // Scroll so target is vertically centered in the panel
        var scrollTo = targetTop - (panelHeight / 2) + (targetHeight / 2);
        _panelEl.scrollTo({ top: Math.max(0, scrollTo), behavior: 'smooth' });
    }

    // â”€â”€ Event Handlers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    function _onHover(e) {
        if (!_enabled) return;

        // Debounce rapid hover changes (50ms)
        clearTimeout(_hoverDebounce);
        _hoverDebounce = setTimeout(function() {
            var matched = _matchNode(e.target);
            if (!matched) return;

            // Same hover target as before? Don't re-render
            if (_hoverPath && _hoverPath.target.id === matched.node.id) return;

            // Padding guard: if the mouse is on a container's own
            // padding/dead-space (e.target IS the selector element, not a
            // child within it), and we already have a deeper hover target,
            // skip â€” the user is crossing dead space, not targeting the parent.
            if (_hoverPath && _hoverPath.chain && matched.node.selector) {
                var newDepth = matched.parents ? matched.parents.length : 0;
                var currentDepth = _hoverPath.chain.length;
                if (newDepth < currentDepth) {
                    try {
                        if (e.target.matches(matched.node.selector)) {
                            return; // Mouse is on container padding, not content
                        }
                    } catch(ex) {}
                }
            }

            _hoverPath = { target: matched.node, chain: matched.parents };
            _renderInteractionPath();
        }, 50);
    }

    function _onFocus(e) {
        if (!_enabled) return;

        // Only hold persistent focus for interactive input elements.
        // Buttons perform an action and shouldn't stick in the panel
        // after you move the mouse away.
        var tag = e.target.tagName;
        if (tag !== 'INPUT' && tag !== 'SELECT' && tag !== 'TEXTAREA') return;

        var matched = _matchNode(e.target);
        if (!matched) return;

        // Same node? Don't re-render
        if (_focusPath && _focusPath.target.id === matched.node.id) return;

        _focusPath = { target: matched.node, chain: matched.parents };
        _renderInteractionPath();
    }

    function _onBlur(e) {
        if (!_enabled) return;

        _focusPath = null;
        _renderInteractionPath();
    }

    function _onMouseLeave(e) {
        if (!_enabled) return;

        // Don't clear hover if mouse moved to the assistant panel or its gap
        var layout = _containerEl && _containerEl.closest('.assistant-layout');
        if (layout && e.relatedTarget && (layout === e.relatedTarget || layout.contains(e.relatedTarget))) return;

        clearTimeout(_hoverDebounce);
        _hoverPath = null;
        _stickyPath = null;
        _renderInteractionPath();
    }

    function _onLayoutLeave(e) {
        if (!_enabled) return;

        // Mouse truly left the entire assistant region (body + panel)
        // relatedTarget is outside the layout â€” clear everything
        var layout = _containerEl && _containerEl.closest('.assistant-layout');
        if (layout && e.relatedTarget && layout.contains(e.relatedTarget)) return;

        clearTimeout(_hoverDebounce);
        _hoverPath = null;
        _stickyPath = null;
        _renderInteractionPath();
    }

    function _onChange(e) {
        if (!_enabled) return;

        // Center the changed element in the wizard view
        if (e.target && e.target.scrollIntoView) {
            e.target.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }

        // Navigate assistant to this element's node
        var matched = _matchNode(e.target);
        if (matched) {
            _hoverPath = { target: matched.node, chain: matched.parents };
        }

        // Re-render â€” _highlightSelectedStack is called from
        // _renderInteractionPath's requestAnimationFrame, so it
        // runs automatically on every render, not just on change.
        _renderInteractionPath();
    }

    // Highlight the selected stack's ENTIRE SECTION + show detail descriptions.
    // Called at the end of EVERY _renderInteractionPath render.
    // Returns true if a highlight was applied.
    function _highlightSelectedStack() {
        if (!_panelEl) return false;
        var select = document.getElementById('wiz-mod-stack');
        if (!select || !select.value || select.value === '' || select.value === '__custom__') return false;

        var stackName = select.value;
        var stacks = (window._dcp && window._dcp.stacks) || [];
        var stack = stacks.find(function(s) { return s.name === stackName; });
        if (!stack) return false;

        // Find the base/parent stack
        var baseStack = stack;
        if (stack.parent) {
            var parent = stacks.find(function(s) { return s.name === stack.parent; });
            if (parent) baseStack = parent;
        }

        var expandedEls = _panelEl.querySelectorAll('.assistant-node-expanded');
        var applied = false;

        expandedEls.forEach(function(el) {
            var html = el.innerHTML;

            // Check this expanded block contains the selected stack
            if (html.indexOf('\u2022 ' + stackName + ' \u2014') === -1) return;

            // â”€â”€ Line-by-line processing â”€â”€
            var lines = html.split('\n');
            var selectedIdx = -1;

            // Find the line with the selected stack
            for (var i = 0; i < lines.length; i++) {
                if (lines[i].indexOf('\u2022 ' + stackName + ' \u2014') !== -1) {
                    selectedIdx = i;
                    break;
                }
            }
            if (selectedIdx === -1) return;

            // Walk backwards to find section header (non-bullet, non-empty line)
            var headerIdx = selectedIdx;
            for (var i = selectedIdx - 1; i >= 0; i--) {
                var trimmed = lines[i].trim();
                if (trimmed === '') break;          // blank line = section boundary
                if (trimmed.charAt(0) === '\u2022') continue; // bullet = still in section
                headerIdx = i;                      // non-bullet non-empty = header
                break;
            }

            // Walk forwards to find end of section (next blank or non-bullet)
            var endIdx = selectedIdx;
            for (var i = selectedIdx + 1; i < lines.length; i++) {
                var trimmed = lines[i].trim();
                if (trimmed === '') break;
                if (trimmed.charAt(0) !== '\u2022') break;
                endIdx = i;
            }

            // â”€â”€ Wrap section + mark entries â”€â”€
            for (var i = headerIdx; i <= endIdx; i++) {
                if (lines[i].indexOf('\u2022 ' + stackName + ' \u2014') !== -1) {
                    lines[i] = '<span class="assistant-stack-selected">' + lines[i] + '</span>';
                } else if (stack.parent && lines[i].indexOf('\u2022 ' + stack.parent + ' \u2014') !== -1) {
                    lines[i] = '<span class="assistant-stack-parent">' + lines[i] + '</span>';
                }
            }

            // Wrap entire section in a container
            lines[headerIdx] = '<span class="assistant-stack-section">' + lines[headerIdx];
            lines[endIdx] = lines[endIdx] + '</span>';

            // â”€â”€ Insert detail block BEFORE the listing â”€â”€
            var baseDetail = baseStack.detail || baseStack.description || '';
            var stackDetail = stack.detail || stack.description || '';

            var detailDiv = document.createElement('div');
            detailDiv.className = 'assistant-stack-detail';

            if (stack.parent && baseStack.name !== stack.name) {
                // Flavored stack: show LANGUAGE first, then FRAMEWORK
                // Language header
                detailDiv.innerHTML =
                    '<div class="assistant-stack-detail-name">' +
                        (baseStack.icon || '') + ' ' + baseStack.name +
                    '</div>' +
                    '<div class="assistant-stack-detail-text">' + baseDetail + '</div>' +
                    // Framework section
                    '<div class="assistant-stack-detail-framework">' +
                        '\u21b3 ' + stack.name +
                    '</div>' +
                    '<div class="assistant-stack-detail-text">' + stackDetail + '</div>';
            } else {
                // Base stack: just show the stack itself
                detailDiv.innerHTML =
                    '<div class="assistant-stack-detail-name">' +
                        (stack.icon || '') + ' ' + stack.name +
                    '</div>' +
                    '<div class="assistant-stack-detail-text">' + stackDetail + '</div>';
            }

            // Capabilities
            if (stack.capabilities && stack.capabilities.length > 0) {
                var capsEl = document.createElement('div');
                capsEl.className = 'assistant-stack-detail-caps';
                capsEl.textContent = 'Capabilities: ' + stack.capabilities.join(', ');
                detailDiv.appendChild(capsEl);
            }


            // Set innerHTML with section + entry highlights
            el.innerHTML = lines.join('\n');

            // Insert detail block AFTER the highlighted section (not at the top)
            var sectionEl = el.querySelector('.assistant-stack-section');
            if (sectionEl && sectionEl.nextSibling) {
                sectionEl.parentNode.insertBefore(detailDiv, sectionEl.nextSibling);
            } else if (sectionEl) {
                sectionEl.parentNode.appendChild(detailDiv);
            } else {
                // Fallback: prepend if no section found
                el.insertBefore(detailDiv, el.firstChild);
            }

            applied = true;

            // â”€â”€ Scroll to the selected entry â”€â”€
            var highlighted = el.querySelector('.assistant-stack-selected');
            if (highlighted) {
                var hRect = highlighted.getBoundingClientRect();
                var pRect = _panelEl.getBoundingClientRect();
                var scrollTo = _panelEl.scrollTop + (hRect.top - pRect.top) - (pRect.height / 2) + (hRect.height / 2);
                _panelEl.scrollTo({ top: Math.max(0, scrollTo), behavior: 'smooth' });
            }
        });

        return applied;
    }

    // Highlight assistant nodes that represent the active environment.
    // Finds state cards with "Â· ACTIVE" in the label and adds a
    // visual highlight class to the parent assistant node.
    function _highlightActiveEnv() {
        if (!_panelEl) return;

        var stateLabels = _panelEl.querySelectorAll('.state-label');
        stateLabels.forEach(function(label) {
            if (label.textContent.indexOf('ACTIVE') === -1) return;

            // Walk up to the nearest assistant-node container
            var node = label.closest('.assistant-node');
            if (node) {
                node.classList.add('assistant-node-active-env');
            }
        });
    }

    function _onWheel(e) {
        if (!_panelEl) return;

        var scrollTop = _panelEl.scrollTop;
        var scrollMax = _panelEl.scrollHeight - _panelEl.clientHeight;

        // If panel has no overflow, let event pass through
        if (scrollMax <= 0) return;

        // Scrolling down and panel hasn't reached bottom
        if (e.deltaY > 0 && scrollTop < scrollMax) {
            e.preventDefault();
            _panelEl.scrollTop = Math.min(scrollTop + e.deltaY, scrollMax);
            return;
        }

        // Scrolling up and panel hasn't reached top
        if (e.deltaY < 0 && scrollTop > 0) {
            e.preventDefault();
            _panelEl.scrollTop = Math.max(scrollTop + e.deltaY, 0);
            return;
        }

        // Panel fully scrolled in this direction â€” let event pass to page
    }

    // â”€â”€ Listener Management â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    function _attachListeners(containerEl) {
        _detachListeners();

        _listeners = {
            hover:      function(e) { _onHover(e); },
            focus:      function(e) { _onFocus(e); },
            blur:       function(e) { _onBlur(e); },
            mouseleave: function(e) { _onMouseLeave(e); },
            layoutleave: function(e) { _onLayoutLeave(e); },
            wheel:      function(e) { _onWheel(e); },
            change:     function(e) { _onChange(e); }
        };

        containerEl.addEventListener('mouseover', _listeners.hover);
        containerEl.addEventListener('focusin', _listeners.focus);
        containerEl.addEventListener('change', _listeners.change);
        containerEl.addEventListener('focusout', _listeners.blur);
        containerEl.addEventListener('mouseleave', _listeners.mouseleave);

        // Attach wheel + layout leave to the layout container (parent of both body + panel)
        var layout = containerEl.closest('.assistant-layout') || containerEl.parentElement;
        if (layout) {
            layout.addEventListener('wheel', _listeners.wheel, { passive: false });
            layout.addEventListener('mouseleave', _listeners.layoutleave);
            _listeners._layoutTarget = layout;
        }
    }

    function _detachListeners() {
        if (!_containerEl || !_listeners.hover) return;

        _containerEl.removeEventListener('mouseover', _listeners.hover);
        _containerEl.removeEventListener('focusin', _listeners.focus);
        _containerEl.removeEventListener('focusout', _listeners.blur);
        _containerEl.removeEventListener('mouseleave', _listeners.mouseleave);
        if (_listeners.change) _containerEl.removeEventListener('change', _listeners.change);

        if (_listeners._layoutTarget) {
            _listeners._layoutTarget.removeEventListener('wheel', _listeners.wheel);
            _listeners._layoutTarget.removeEventListener('mouseleave', _listeners.layoutleave);
        }

        _listeners = {};
    }

    // â”€â”€ Public API â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    async function activate(contextId, containerEl) {
        await _loadCatalogue();
        if (!_catalogue) return;

        var ctx = _catalogue.get(contextId);
        if (!ctx) {
            console.warn('[assistant] no context found for:', contextId);
            return;
        }

        // Clean up previous context
        _detachListeners();

        _currentCtx = ctx;
        _containerEl = containerEl;
        _panelEl = _resolvePanel();
        if (!_panelEl) return;

        // Flatten the tree for selector matching
        _flatNodes = _flattenTree(ctx.children, []);

        // Reset interaction state
        _focusPath = null;
        _hoverPath = null;
        _stickyPath = null;

        // Render entry state
        _renderContextHeader();
        _panelEl.classList.add('entry-state');

        // Show panel
        if (_enabled) {
            _panelEl.classList.remove('disabled');
        }

        // Listen for interactions on the container
        _attachListeners(containerEl);
    }

    function deactivate() {
        _detachListeners();
        _currentCtx = null;
        _containerEl = null;
        _flatNodes = [];
        _focusPath = null;
        _hoverPath = null;
        if (_panelEl) {
            _panelEl.innerHTML = '';
            _panelEl.classList.remove('entry-state');
        }
    }

    function refresh() {
        if (!_currentCtx || !_containerEl) return;

        // Re-flatten tree (picks up new dynamic children)
        _flatNodes = _flattenTree(_currentCtx.children, []);

        // Re-render current state
        _renderInteractionPath();
    }

    function enable() {
        _enabled = true;
        if (_panelEl) _panelEl.classList.remove('disabled');
    }

    function disable() {
        _enabled = false;
        if (_panelEl) _panelEl.classList.add('disabled');
    }

    // â”€â”€ Expose â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    window._assistant = {
        activate:   activate,
        deactivate: deactivate,
        refresh:    refresh,
        enable:     enable,
        disable:    disable,
        resolvers:  {}
    };

    // â”€â”€ Default resolvers for wizard contexts â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    window._assistant.resolvers.envCount = function() {
        var envs = document.querySelectorAll('#wiz-envs > div');
        return envs ? envs.length : 0;
    };

    window._assistant.resolvers.domainCount = function() {
        var domains = document.querySelectorAll('#wiz-domains > span');
        return domains ? domains.length : 0;
    };

    window._assistant.resolvers.moduleCount = function() {
        var mods = document.querySelectorAll('#wizard-modules-list > div');
        return mods ? mods.length : 0;
    };

    window._assistant.resolvers.selectedStack = function() {
        var select = document.getElementById('wiz-mod-stack');
        if (!select || !select.value || select.value === '' || select.value === '__custom__') return '';

        var stacks = (window._dcp && window._dcp.stacks) || [];
        var stack = stacks.find(function(s) { return s.name === select.value; });
        if (!stack) return '\n\nâš  Stack "' + select.value + '" not found in definitions';

        var lines = [];
        lines.push('');
        lines.push('â”â”â” ' + (stack.icon || 'ğŸ“') + ' ' + stack.name + ' â”â”â”');
        lines.push(stack.description);
        if (stack.domain && stack.domain !== 'service') {
            lines.push('Domain: ' + stack.domain);
        }

        if (stack.parent) {
            var parent = stacks.find(function(s) { return s.name === stack.parent; });
            lines.push('');
            lines.push('â†³ Based on ' + (parent ? (parent.icon || '') + ' ' : '') + stack.parent);

            if (parent && parent.capabilities && stack.capabilities) {
                var parentCaps = {};
                parent.capabilities.forEach(function(c) { parentCaps[c] = true; });
                var inherited = stack.capabilities.filter(function(c) { return parentCaps[c]; });
                var added = stack.capabilities.filter(function(c) { return !parentCaps[c]; });

                if (inherited.length > 0) {
                    lines.push('  Inherited: ' + inherited.join(', '));
                }
                if (added.length > 0) {
                    lines.push('  âœ¨ Added: ' + added.join(', '));
                }
            }
        } else {
            if (stack.capabilities && stack.capabilities.length > 0) {
                lines.push('');
                lines.push('Capabilities: ' + stack.capabilities.join(', '));
            }
        }

        return lines.join('\n');
    };

    // â”€â”€ Integrations step resolvers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    window._assistant.resolvers.toolsMissing = function() {
        // Missing tool rows have IDs and are inside the tools container
        var rows = document.querySelectorAll('#wiz-int-body [id^="wiz-int-tool-"]:not([style*="success"])');
        // Better: count rows that contain the "Install" button (only missing tools have one)
        var missing = document.querySelectorAll('#wiz-int-body [id^="wiz-int-tool-"] button');
        return missing ? missing.length : 0;
    };

    window._assistant.resolvers.toolsInstalled = function() {
        // Installed tool pills contain "âœ“" and have success-colored background
        var pills = document.querySelectorAll('#wiz-int-body span[id^="wiz-int-tool-"][style*="success"]');
        return pills ? pills.length : 0;
    };

    window._assistant.resolvers.toolsTotal = function() {
        var all = document.querySelectorAll('#wiz-int-body [id^="wiz-int-tool-"]');
        return all ? all.length : 0;
    };

    window._assistant.resolvers.filesDetected = function() {
        // File pills with â— indicator (found files)
        var pills = document.querySelectorAll('#wiz-int-files-section span[id^="wiz-int-file-"]');
        var count = 0;
        if (pills) {
            pills.forEach(function(p) {
                if (p.textContent.indexOf('â—') !== -1) count++;
            });
        }
        return count;
    };

    window._assistant.resolvers.filesTotal = function() {
        var pills = document.querySelectorAll('#wiz-int-files-section span[id^="wiz-int-file-"]');
        return pills ? pills.length : 0;
    };

    window._assistant.resolvers.integrationCount = function() {
        var cards = document.querySelectorAll('[id^="wiz-int-wrap-"]');
        return cards ? cards.length : 0;
    };

    // â”€â”€ GitHub card resolvers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    window._assistant.resolvers.ghUser = function() {
        var pill = document.getElementById('wiz-gh-pill-user');
        if (!pill) return '';
        return pill.textContent.trim();  // e.g. "@cyberpunk042"
    };

    window._assistant.resolvers.ghRepo = function() {
        var pill = document.getElementById('wiz-gh-pill-repo');
        if (!pill) return '';
        var text = pill.textContent.trim();
        return text.indexOf('no repo') !== -1 ? '' : text;
    };

    window._assistant.resolvers.ghVis = function() {
        var pill = document.getElementById('wiz-gh-pill-vis');
        if (!pill) return '';
        var text = pill.textContent.trim();
        if (text.indexOf('private') !== -1) return 'private';
        if (text.indexOf('public') !== -1) return 'public';
        return '';
    };

    window._assistant.resolvers.ghBranch = function() {
        var pill = document.getElementById('wiz-gh-pill-branch');
        if (!pill) return '';
        return pill.textContent.replace('ğŸŒ¿', '').trim();
    };

    window._assistant.resolvers.ghEnvTotal = function() {
        var section = document.getElementById('wiz-gh-section-envs');
        if (!section) return 0;
        var rows = section.querySelectorAll('[style*="display:flex"][style*="align-items:center"]');
        return rows ? rows.length : 0;
    };

    window._assistant.resolvers.ghEnvAligned = function() {
        var section = document.getElementById('wiz-gh-section-envs');
        if (!section) return 0;
        var summary = section.querySelector('summary');
        if (!summary) return 0;
        var match = summary.textContent.match(/(\d+)\/\d+/);
        return match ? parseInt(match[1], 10) : 0;
    };

    window._assistant.resolvers.ghEnvMissing = function() {
        var total = window._assistant.resolvers.ghEnvTotal();
        var aligned = window._assistant.resolvers.ghEnvAligned();
        return total - aligned;
    };

    window._assistant.resolvers.ghWorkflows = function() {
        var pill = document.getElementById('wiz-gh-pill-workflows');
        if (!pill) return 0;
        var match = pill.textContent.match(/(\d+)/);
        return match ? parseInt(match[1], 10) : 0;
    };

    // â”€â”€ Pages card resolvers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    window._assistant.resolvers.pagesSegments = function() {
        var pill = document.getElementById('wiz-pages-pill-segments');
        if (!pill) return 0;
        var match = pill.textContent.match(/(\d+)/);
        return match ? parseInt(match[1], 10) : 0;
    };

    window._assistant.resolvers.pagesFolders = function() {
        var pill = document.getElementById('wiz-pages-pill-folders');
        if (!pill) return 0;
        var match = pill.textContent.match(/(\d+)/);
        return match ? parseInt(match[1], 10) : 0;
    };

    window._assistant.resolvers.pagesBranch = function() {
        var pill = document.getElementById('wiz-pages-pill-branch');
        if (!pill) return '';
        return pill.textContent.replace('ğŸŒ¿', '').trim();
    };

    window._assistant.resolvers.pagesBuildersAvail = function() {
        var section = document.getElementById('wiz-pages-section-builders');
        if (!section) return 0;
        var pills = section.querySelectorAll('span');
        var count = 0;
        if (pills) {
            pills.forEach(function(p) {
                if (p.textContent.indexOf('âœ…') !== -1) count++;
            });
        }
        return count;
    };

    window._assistant.resolvers.pagesBuildersTotal = function() {
        var section = document.getElementById('wiz-pages-section-builders');
        if (!section) return 0;
        var summary = section.querySelector('summary');
        if (!summary) return 0;
        var match = summary.textContent.match(/(\d+)\/(\d+)/);
        return match ? parseInt(match[2], 10) : 0;
    };

    window._assistant.resolvers.pagesUninit = function() {
        var section = document.getElementById('wiz-pages-section-folders');
        if (!section) return 0;
        var rows = section.querySelectorAll('span');
        var count = 0;
        if (rows) {
            rows.forEach(function(s) {
                if (s.textContent.trim() === 'â¬œ') count++;
            });
        }
        return count;
    };

    // â”€â”€ Docker card resolvers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    window._assistant.resolvers.dockerDaemon = function() {
        var pill = document.getElementById('wiz-docker-pill-daemon');
        if (!pill) return '';
        return pill.textContent.indexOf('âœ“') !== -1 ? 'âœ“' : 'âœ—';
    };

    window._assistant.resolvers.dockerVersion = function() {
        var pill = document.getElementById('wiz-docker-pill-daemon');
        if (!pill) return '';
        var match = pill.textContent.match(/Â·\s*(.+)/);
        return match ? match[1].trim() : '';
    };

    window._assistant.resolvers.dockerComposeCli = function() {
        var pill = document.getElementById('wiz-docker-pill-compose-cli');
        if (!pill) return '';
        return pill.textContent.indexOf('âœ“') !== -1 ? 'âœ“' : 'â—‹';
    };

    window._assistant.resolvers.dockerDockerfiles = function() {
        var pill = document.getElementById('wiz-docker-pill-dockerfile');
        if (!pill) return 0;
        var match = pill.textContent.match(/(\d+)/);
        return match ? parseInt(match[1], 10) : 0;
    };

    window._assistant.resolvers.dockerServices = function() {
        var pill = document.getElementById('wiz-docker-pill-composefile');
        if (!pill) return 0;
        var match = pill.textContent.match(/(\d+)\s*svc/);
        return match ? parseInt(match[1], 10) : 0;
    };

    window._assistant.resolvers.dockerIgnoreRules = function() {
        var pill = document.getElementById('wiz-docker-pill-dockerignore');
        if (!pill) return 0;
        var match = pill.textContent.match(/(\d+)\s*rule/);
        return match ? parseInt(match[1], 10) : 0;
    };

    window._assistant.resolvers.dockerModules = function() {
        var pill = document.getElementById('wiz-docker-fullsetup-pill-modules');
        if (!pill) return 0;
        var match = pill.textContent.match(/(\d+)/);
        return match ? parseInt(match[1], 10) : 0;
    };

    window._assistant.resolvers.dockerStack = function() {
        var badge = document.getElementById('wiz-docker-stack-badge');
        if (!badge) return '';
        return badge.textContent.trim();
    };

    // â”€â”€ K8s template variable resolvers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    window._assistant.resolvers.k8sManifests = function() {
        var section = document.getElementById('wiz-k8s-section-manifests');
        if (!section) return 0;
        var summary = section.querySelector('summary');
        if (!summary) return 0;
        var match = summary.textContent.match(/(\d+)\s*file/);
        return match ? parseInt(match[1], 10) : 0;
    };

    window._assistant.resolvers.k8sResources = function() {
        var strip = document.getElementById('wiz-k8s-section-status');
        if (!strip) return 0;
        var pills = strip.querySelectorAll('span');
        for (var i = 0; i < pills.length; i++) {
            var match = pills[i].textContent.match(/(\d+)\s*resource/);
            if (match) return parseInt(match[1], 10);
        }
        return 0;
    };

    // â”€â”€ Terraform template variable resolvers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    window._assistant.resolvers.tfResources = function() {
        var strip = document.getElementById('wiz-tf-section-status');
        if (!strip) return 0;
        var pills = strip.querySelectorAll('span');
        for (var i = 0; i < pills.length; i++) {
            var match = pills[i].textContent.match(/(\d+)\s*resource/);
            if (match) return parseInt(match[1], 10);
        }
        return 0;
    };

    window._assistant.resolvers.tfProviders = function() {
        var strip = document.getElementById('wiz-tf-section-status');
        if (!strip) return 0;
        var pills = strip.querySelectorAll('span');
        for (var i = 0; i < pills.length; i++) {
            var match = pills[i].textContent.match(/(\d+)\s*provider/);
            if (match) return parseInt(match[1], 10);
        }
        return 0;
    };

    // â”€â”€ Terraform field value resolvers (for <select> elements) â”€â”€
    window._assistant.resolvers.tfProviderValue = function() {
        var el = document.getElementById('wiz-tf-provider');
        return el ? el.value : '';
    };
    window._assistant.resolvers.tfBackendValue = function() {
        var el = document.getElementById('wiz-tf-backend');
        return el ? el.value : '';
    };

    // â”€â”€ Docker image breakdown resolvers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    // Knowledge map: runtime name â†’ { label, description, variant explanations }
    var _dockerImageKnowledge = {
        'python':           { label: 'Python',       family: 'python',  variantInfo: { 'slim': 'Debian-based minimal (~150MB) â€” good balance of compatibility and size', 'alpine': 'Alpine Linux (~50MB) â€” smallest, may need musl workarounds for some C extensions', 'bookworm': 'Full Debian Bookworm â€” all system libraries included, largest image', 'bullseye': 'Full Debian Bullseye â€” older stable Debian' } },
        'golang':           { label: 'Go',           family: 'go',      variantInfo: { 'alpine': 'Alpine base (~250MB) â€” ideal for multi-stage builds where final image copies only the binary', 'bookworm': 'Full Debian â€” all build tools available', 'bullseye': 'Older Debian stable' } },
        'node':             { label: 'Node.js',      family: 'node',    variantInfo: { 'alpine': 'Alpine base (~180MB) â€” smallest, works for most npm packages', 'slim': 'Debian slim (~200MB) â€” better native module compatibility', 'bookworm': 'Full Debian â€” all build tools for native addons', 'bullseye': 'Older Debian stable', 'lts': 'Long Term Support release' } },
        'rust':             { label: 'Rust',         family: 'rust',    variantInfo: { 'slim': 'Debian slim â€” smaller image with Rust toolchain', 'alpine': 'Alpine base â€” smallest but may need musl target', 'bookworm': 'Full Debian' } },
        'eclipse-temurin':  { label: 'Java (Temurin)', family: 'java', variantInfo: { 'jdk-alpine': 'Alpine + JDK â€” smallest Java runtime', 'jdk-jammy': 'Ubuntu Jammy + JDK', 'jre-alpine': 'Alpine + JRE only â€” no compiler, smallest runtime', 'jdk': 'Default JDK' } },
        'ruby':             { label: 'Ruby',         family: 'ruby',    variantInfo: { 'slim': 'Debian slim â€” most common Ruby choice', 'alpine': 'Alpine â€” smallest but gem native extensions may need extra packages', 'bookworm': 'Full Debian' } },
        'elixir':           { label: 'Elixir',       family: 'elixir',  variantInfo: { 'slim': 'Debian slim with Erlang/OTP', 'alpine': 'Alpine base' } },
        'php':              { label: 'PHP',          family: 'php',     variantInfo: { 'cli': 'CLI only â€” no web server', 'fpm': 'FastCGI Process Manager â€” for nginx/Apache', 'apache': 'Built-in Apache â€” simplest for web apps', 'alpine': 'Alpine base' } },
        'gcc':              { label: 'GCC (C/C++)',  family: 'c',       variantInfo: {} },
        'swift':            { label: 'Swift',        family: 'swift',   variantInfo: { 'slim': 'Minimal Swift runtime', 'jammy': 'Ubuntu Jammy base' } },
        'alpine':           { label: 'Alpine Linux', family: 'generic', variantInfo: {} },
        'nginx':            { label: 'Nginx',        family: 'webserver', variantInfo: { 'alpine': 'Alpine base (~40MB) â€” smallest web server image', 'bookworm': 'Full Debian' } },
        'postgres':         { label: 'PostgreSQL',   family: 'database', variantInfo: { 'alpine': 'Alpine base â€” smaller database image', 'bookworm': 'Full Debian with all extensions' } },
        'mysql':            { label: 'MySQL',        family: 'database', variantInfo: {} },
        'mongo':            { label: 'MongoDB',      family: 'database', variantInfo: {} },
        'redis':            { label: 'Redis',        family: 'cache',   variantInfo: { 'alpine': 'Alpine base (~30MB) â€” most common Redis choice' } },
        'mcr.microsoft.com/dotnet/sdk': { label: '.NET SDK', family: 'dotnet', variantInfo: { 'alpine': 'Alpine base', 'jammy': 'Ubuntu Jammy' } },
        'mcr.microsoft.com/dotnet/aspnet': { label: '.NET ASP.NET Runtime', family: 'dotnet', variantInfo: { 'alpine': 'Alpine base â€” smallest runtime' } }
    };

    // Parse an image string like "python:3.12-slim" into { runtime, version, variant, label, ... }
    function _parseDockerImage(imageStr) {
        if (!imageStr) return null;
        imageStr = imageStr.trim();

        // Handle registry prefixes (mcr.microsoft.com/dotnet/sdk:8.0)
        var colonIdx = imageStr.lastIndexOf(':');
        var repo = colonIdx !== -1 ? imageStr.substring(0, colonIdx) : imageStr;
        var tag = colonIdx !== -1 ? imageStr.substring(colonIdx + 1) : 'latest';

        // Split tag into version and variant: "3.12-slim" â†’ "3.12", "slim"
        // Handle multi-part variants: "21-jdk-alpine" â†’ "21", "jdk-alpine"
        var version = tag;
        var variant = '';
        var dashIdx = tag.indexOf('-');
        if (dashIdx !== -1) {
            version = tag.substring(0, dashIdx);
            variant = tag.substring(dashIdx + 1);
        }

        // Look up knowledge
        var knowledge = _dockerImageKnowledge[repo] || null;
        var label = knowledge ? knowledge.label : repo;
        var family = knowledge ? knowledge.family : 'unknown';

        // Variant explanation
        var variantExplain = '';
        if (knowledge && variant && knowledge.variantInfo[variant]) {
            variantExplain = knowledge.variantInfo[variant];
        } else if (variant === 'slim') {
            variantExplain = 'Minimal Debian-based image â€” smaller than full, more compatible than Alpine';
        } else if (variant === 'alpine') {
            variantExplain = 'Alpine Linux base â€” smallest image size, uses musl libc instead of glibc';
        } else if (variant === 'latest' || !variant) {
            variantExplain = 'Default variant â€” full image with all tools and libraries';
        }

        return {
            raw: imageStr,
            repo: repo,
            tag: tag,
            version: version,
            variant: variant,
            label: label,
            family: family,
            variantExplain: variantExplain
        };
    }

    // Resolver: parsed base image from the genconfig form field
    window._assistant.resolvers.dockerBaseRuntime = function() {
        var input = document.getElementById('wiz-docker-base');
        if (!input) return '';
        var parsed = _parseDockerImage(input.value);
        return parsed ? parsed.label : '';
    };

    window._assistant.resolvers.dockerBaseVersion = function() {
        var input = document.getElementById('wiz-docker-base');
        if (!input) return '';
        var parsed = _parseDockerImage(input.value);
        return parsed ? parsed.version : '';
    };

    window._assistant.resolvers.dockerBaseVariant = function() {
        var input = document.getElementById('wiz-docker-base');
        if (!input) return '';
        var parsed = _parseDockerImage(input.value);
        return parsed ? parsed.variant : '';
    };

    window._assistant.resolvers.dockerBaseVariantExplain = function() {
        var input = document.getElementById('wiz-docker-base');
        if (!input) return '';
        var parsed = _parseDockerImage(input.value);
        return parsed ? parsed.variantExplain : '';
    };

    // Composite resolver: full image breakdown as highlighted HTML state-cards
    window._assistant.resolvers.dockerBaseBreakdown = function() {
        var input = document.getElementById('wiz-docker-base');
        if (!input || !input.value) return '<div class="assistant-state-card state-warning"><div class="state-label">No base image configured</div></div>';
        var p = _parseDockerImage(input.value);
        if (!p) return '<div class="assistant-state-card state-warning"><div class="state-label">Could not parse image</div></div>';
        return '<div class="assistant-state-card state-info" style="margin-bottom:0.4rem">' +
            '<div class="state-label">ğŸ”§ Runtime Â· ' + p.label + '</div>' +
            '<div class="state-detail">Image repository: <code>' + p.repo + '</code><br>' +
            'The ' + p.label + ' runtime provides the interpreter, compiler, or server binary pre-installed in your container.</div>' +
            '</div>' +
            '<div class="assistant-state-card state-info" style="margin-bottom:0.4rem">' +
            '<div class="state-label">ğŸ“Œ Version Â· ' + p.version + '</div>' +
            '<div class="state-detail">Pinned to <strong>' + p.version + '</strong> â€” ensures reproducible builds across environments. ' +
            'Security patches arrive within this version line automatically on rebuild.</div>' +
            '</div>' +
            '<div class="assistant-state-card ' + (p.variant ? 'state-success' : 'state-warning') + '">' +
            '<div class="state-label">ğŸ“¦ Variant Â· ' + (p.variant || 'default') + '</div>' +
            '<div class="state-detail">' + (p.variantExplain || 'Default variant â€” full image with all tools and libraries.') + '</div>' +
            '</div>';
    };

    // â”€â”€ Dockerfile analysis resolver â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Returns HTML state-cards per Dockerfile with image breakdown

    window._assistant.resolvers.dockerfileAnalysis = function() {
        var section = document.getElementById('wiz-docker-section-dockerfiles');
        if (!section) return '<div class="assistant-state-card state-warning"><div class="state-label">No Dockerfiles detected</div></div>';
        var rows = section.querySelectorAll('div[style*="border-bottom"]');
        if (!rows || rows.length === 0) return '<div class="assistant-state-card state-warning"><div class="state-label">No Dockerfiles detected</div></div>';
        var html = '';
        rows.forEach(function(row) {
            var codeEl = row.querySelector('code');
            var path = codeEl ? codeEl.textContent.trim() : '?';

            // Base images are accent-colored spans
            var baseSpans = row.querySelectorAll('span[style*="accent"]');
            var bases = [];
            baseSpans.forEach(function(s) {
                var txt = s.textContent.trim();
                if (txt.indexOf('AS ') !== 0 && txt.indexOf('-stage') === -1 && txt.indexOf('EXPOSE') === -1) {
                    bases.push(txt);
                }
            });

            // Stages
            var stageSpans = row.querySelectorAll('span[style*="text-muted"]');
            var stages = [];
            stageSpans.forEach(function(s) {
                var txt = s.textContent.trim();
                if (txt.indexOf('AS ') === 0) stages.push(txt.substring(3));
            });

            // Ports
            var portSpan = row.querySelector('span[style*="text-muted"]');
            var portMatch = portSpan ? portSpan.textContent.match(/EXPOSE\s+([\d, ]+)/) : null;
            var ports = portMatch ? portMatch[1] : '';

            // Build per-image breakdown cards
            var imageCards = '';
            bases.forEach(function(b) {
                var p = _parseDockerImage(b);
                if (!p) return;
                imageCards += '<div style="display:flex;gap:0.3rem;flex-wrap:wrap;margin-top:0.25rem">' +
                    '<span style="font-size:0.7rem;padding:0.1rem 0.35rem;border-radius:4px;background:color-mix(in srgb, var(--accent) 12%, transparent);color:var(--accent);font-weight:600">ğŸ”§ ' + p.label + '</span>' +
                    '<span style="font-size:0.7rem;padding:0.1rem 0.35rem;border-radius:4px;background:color-mix(in srgb, var(--text-secondary) 10%, transparent);color:var(--text-secondary)">ğŸ“Œ ' + p.version + '</span>' +
                    (p.variant ? '<span style="font-size:0.7rem;padding:0.1rem 0.35rem;border-radius:4px;background:color-mix(in srgb, var(--success) 10%, transparent);color:var(--success)">ğŸ“¦ ' + p.variant + '</span>' : '') +
                    '</div>' +
                    (p.variantExplain ? '<div style="font-size:0.65rem;color:var(--text-muted);margin-top:0.15rem;padding-left:0.2rem">' + p.variantExplain + '</div>' : '');
            });

            // Stage info
            var stageInfo = '';
            if (stages.length > 0) {
                stageInfo = '<div style="font-size:0.68rem;color:var(--accent);margin-top:0.2rem">âš¡ ' + (stages.length + 1) + '-stage build (stages: ' + stages.join(', ') + ')</div>';
            }

            // Port info
            var portInfo = '';
            if (ports) {
                portInfo = '<div style="font-size:0.68rem;color:var(--text-muted);margin-top:0.1rem">ğŸ”Œ EXPOSE ' + ports + '</div>';
            }

            html += '<div class="assistant-state-card state-info" style="margin-bottom:0.4rem">' +
                '<div class="state-label">ğŸ“„ ' + path + '</div>' +
                '<div class="state-detail">' + imageCards + stageInfo + portInfo + '</div>' +
                '</div>';
        });
        return html;
    };

    // â”€â”€ Compose service topology resolver â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Returns HTML state-cards per service with image breakdown and role classification

    window._assistant.resolvers.dockerSvcAnalysis = function() {
        var section = document.getElementById('wiz-docker-section-compose-svcs');
        if (!section) return '<div class="assistant-state-card state-warning"><div class="state-label">No compose services detected</div></div>';
        var rows = section.querySelectorAll('div[style*="border-bottom"]');
        if (!rows || rows.length === 0) return '<div class="assistant-state-card state-warning"><div class="state-label">No compose services detected</div></div>';

        var services = [];
        var html = '';

        rows.forEach(function(row) {
            var nameEl = row.querySelector('strong');
            var imageEl = row.querySelector('code');
            var name = nameEl ? nameEl.textContent.trim() : '?';
            var image = imageEl ? imageEl.textContent.trim() : '?';

            var parsed = null;
            if (image !== '(build)' && image !== '?') {
                parsed = _parseDockerImage(image);
            }

            // Determine role and card style
            var role = 'application';
            var cardStyle = 'state-success';
            if (parsed) {
                if (parsed.family === 'database') { role = 'database'; cardStyle = 'state-info'; }
                else if (parsed.family === 'cache') { role = 'cache'; cardStyle = 'state-info'; }
                else if (parsed.family === 'webserver') { role = 'proxy'; cardStyle = 'state-info'; }
            }
            if (image === '(build)') { role = 'application (builds from Dockerfile)'; }

            services.push({ name: name, role: role, parsed: parsed });

            // Volumes, deps, restart from muted spans
            var mutedSpans = row.querySelectorAll('span[style*="text-muted"]');
            var metaHtml = '';
            mutedSpans.forEach(function(s) {
                var txt = s.textContent.trim();
                if (txt) metaHtml += '<span style="font-size:0.65rem;padding:0.05rem 0.25rem;border-radius:3px;background:color-mix(in srgb, var(--text-muted) 8%, transparent);color:var(--text-muted);margin-right:0.2rem">' + txt + '</span>';
            });

            // Image breakdown pills
            var imagePills = '';
            if (parsed) {
                imagePills = '<div style="display:flex;gap:0.3rem;flex-wrap:wrap;margin-top:0.25rem">' +
                    '<span style="font-size:0.7rem;padding:0.1rem 0.35rem;border-radius:4px;background:color-mix(in srgb, var(--accent) 12%, transparent);color:var(--accent);font-weight:600">ğŸ”§ ' + parsed.label + '</span>' +
                    '<span style="font-size:0.7rem;padding:0.1rem 0.35rem;border-radius:4px;background:color-mix(in srgb, var(--text-secondary) 10%, transparent);color:var(--text-secondary)">ğŸ“Œ ' + parsed.version + '</span>' +
                    (parsed.variant ? '<span style="font-size:0.7rem;padding:0.1rem 0.35rem;border-radius:4px;background:color-mix(in srgb, var(--success) 10%, transparent);color:var(--success)">ğŸ“¦ ' + parsed.variant + '</span>' : '') +
                    '</div>' +
                    (parsed.variantExplain ? '<div style="font-size:0.65rem;color:var(--text-muted);margin-top:0.15rem;padding-left:0.2rem">' + parsed.variantExplain + '</div>' : '');
            } else if (image === '(build)') {
                imagePills = '<div style="font-size:0.68rem;color:var(--accent);margin-top:0.2rem">ğŸ”¨ Builds from local Dockerfile â€” see Dockerfile Analysis above for image details</div>';
            }

            html += '<div class="assistant-state-card ' + cardStyle + '" style="margin-bottom:0.4rem">' +
                '<div class="state-label">' + name + ' <span style="font-size:0.7rem;opacity:0.7">(' + role + ')</span></div>' +
                '<div class="state-detail">' + imagePills +
                (metaHtml ? '<div style="margin-top:0.2rem">' + metaHtml + '</div>' : '') +
                '</div></div>';
        });

        // Topology summary card
        var hasDb = services.some(function(s) { return s.role === 'database'; });
        var hasCache = services.some(function(s) { return s.role === 'cache'; });
        var topology = '';
        if (services.length === 1) topology = 'Single service';
        else if (hasDb && hasCache) topology = 'Full stack (app + database + cache)';
        else if (hasDb) topology = 'App + Database';
        else topology = 'Multi-service (' + services.length + ' services)';

        return '<div class="assistant-state-card state-success" style="margin-bottom:0.5rem">' +
            '<div class="state-label">ğŸ—º Topology Â· ' + topology + '</div>' +
            '<div class="state-detail">' + services.length + ' service(s) detected</div>' +
            '</div>' + html;
    };

})();
</script>

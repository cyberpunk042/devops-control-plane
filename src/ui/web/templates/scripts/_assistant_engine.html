<!-- Assistant Engine — event-driven side panel
     Loads superstructure JSON, renders interaction path on hover/focus.
     Exposes: window._assistant { activate, deactivate, refresh, enable, disable, resolvers }
     Depends on: #assistant-panel in DOM, admin.css assistant classes -->

<script>
(function() {
    'use strict';

    // ── State ──────────────────────────────────────────────────────
    let _catalogue = null;        // Map<contextId, contextObj>
    let _currentCtx = null;       // current context object
    let _panelEl = null;          // #assistant-panel element
    let _containerEl = null;      // element we're listening on
    let _flatNodes = [];          // [{ node, parents: [ancestor…] }]
    let _focusPath = null;        // { target: node, chain: [parents] }
    let _hoverPath = null;        // { target: node, chain: [parents] }
    let _stickyPath = null;       // last successful hover — survives mouse-to-panel trips
    let _enabled = true;          // panel visibility toggle
    let _hoverDebounce = null;    // debounce timer for hover
    let _dwellTimer = null;       // hover dwell — clears stale focus after 300ms
    let _stickyDwellTimer = null;  // sticky dwell — delays sticky update to ignore transient crossings
    let _listeners = {};          // attached event listener refs

    // ── Catalogue Loading ──────────────────────────────────────────

    async function _loadCatalogue() {
        if (_catalogue) return;
        try {
            const resp = await fetch('/static/data/assistant-catalogue.json');
            if (!resp.ok) {
                console.warn('[assistant] catalogue fetch failed:', resp.status);
                return;
            }
            const data = await resp.json();
            _catalogue = new Map();
            for (const ctx of data) {
                _catalogue.set(ctx.context, ctx);
            }
        } catch (e) {
            console.warn('[assistant] catalogue load error:', e);
        }
    }

    // ── Panel Resolution ───────────────────────────────────────────

    function _resolvePanel() {
        const el = document.getElementById('assistant-panel');
        if (!el) {
            console.warn('[assistant] #assistant-panel not found in DOM');
        }
        return el;
    }

    // ── Template Variable Resolution ───────────────────────────────

    function _resolve(text) {
        if (!text) return '';
        return text.replace(/\{\{(\w+)\}\}/g, function(match, name) {
            const resolver = window._assistant.resolvers[name];
            if (typeof resolver === 'function') {
                try { return resolver(); }
                catch (e) { return ''; }
            }
            return '';
        });
    }

    // ── State-Variant Resolution ───────────────────────────────────
    // A node (or childTemplate) can carry a `variants` array.
    // Each variant has a `when` condition checked against a DOM element.
    // The first matching variant's content/expanded override the base.
    // If no variant matches, the base fields are used as-is.

    function _resolveVariant(node, element) {
        if (!node.variants || !node.variants.length || !element) return node;

        for (var i = 0; i < node.variants.length; i++) {
            var v = node.variants[i];
            if (!v.when) continue;

            var match = true;

            if (v.when.textContains) {
                match = match && element.textContent
                    .toLowerCase()
                    .includes(v.when.textContains.toLowerCase());
            }

            if (match && v.when.dataAttr) {
                var attrs = v.when.dataAttr;
                for (var key in attrs) {
                    if (attrs.hasOwnProperty(key)) {
                        var actual = element.dataset ? element.dataset[key] : element.getAttribute('data-' + key);
                        match = match && actual !== null && actual !== undefined && String(actual) === String(attrs[key]);
                    }
                }
            }

            if (match && v.when.hasSelector) {
                match = match && !!element.querySelector(v.when.hasSelector);
            }

            if (match && v.when.resolver) {
                var resolverFn = window._assistant.resolvers[v.when.resolver];
                var resolverVal = resolverFn ? String(resolverFn()) : '';
                if (v.when.equals !== undefined) {
                    match = match && resolverVal === String(v.when.equals);
                } else if (v.when.contains !== undefined) {
                    match = match && resolverVal.toLowerCase().indexOf(String(v.when.contains).toLowerCase()) !== -1;
                } else if (v.when.not !== undefined) {
                    match = match && resolverVal !== String(v.when.not);
                }
            }

            if (match) {
                // Merge: variant fields override base, everything else preserved
                return {
                    id: node.id,
                    title: v.title || node.title,
                    icon: v.icon || node.icon,
                    content: v.content !== undefined ? v.content : node.content,
                    expanded: v.expanded !== undefined ? v.expanded : node.expanded,
                    selector: node.selector,
                    separator: node.separator,
                    children: node.children,
                    dynamic: node.dynamic,
                    childTemplate: node.childTemplate,
                    variants: node.variants,
                    _element: node._element,
                    _isDynamic: node._isDynamic,
                    _variantIndex: i
                };
            }
        }

        return node;  // No variant matched → base content
    }

    // Resolve variant for a DOM element matched to a static node.
    // If matchedEl is provided (from _matchNode), use it directly.
    // Otherwise fall back to querySelector (which gets the first match only).
    function _resolveStaticVariant(node, matchedEl) {
        if (!node.variants || !node.variants.length) return node;
        // Prefer the actual hovered element passed from the match pipeline
        if (matchedEl) return _resolveVariant(node, matchedEl);
        if (node._element) return _resolveVariant(node, node._element);
        if (!node.selector || !_containerEl) return node;

        try {
            var el = _containerEl.querySelector(node.selector);
            if (el) return _resolveVariant(node, el);
        } catch (e) {
            // Invalid selector
        }
        return node;
    }

    // ── Tree Flattening ────────────────────────────────────────────
    // Builds a flat index of [{ node, parents }] for selector matching.
    // Deepest nodes first so specific selectors win over general ones.

    function _flattenTree(children, parentChain) {
        const result = [];
        for (const child of (children || [])) {
            // Recurse children first → deepest nodes appear first
            if (child.children && child.children.length) {
                result.push(..._flattenTree(child.children, [...parentChain, child]));
            }
            result.push({ node: child, parents: [...parentChain] });

            // Handle dynamic children — query DOM for real elements
            if (child.dynamic && child.childTemplate && _containerEl) {
                _resolveDynamic(child, parentChain, result);
            }
        }
        return result;
    }

    function _resolveDynamic(parentNode, grandParentChain, result) {
        const tpl = parentNode.childTemplate;
        if (!tpl.selector) return;

        const elements = _containerEl.querySelectorAll(tpl.selector);
        elements.forEach(function(el, i) {
            // Extract display name from the element's DOM
            // 1. If childTemplate defines nameSelector, use that
            // 2. Otherwise try font-weight:600 / strong heuristic
            // 3. Fallback: first text node
            var nameEl = tpl.nameSelector
                ? el.querySelector(tpl.nameSelector)
                : el.querySelector('[style*="font-weight:600"], [style*="font-weight: 600"], strong');
            var extractedName;
            if (nameEl) {
                extractedName = nameEl.textContent.trim();
            } else {
                // Fallback: first text node only (avoid grabbing child element text)
                var walker = document.createTreeWalker(el, NodeFilter.SHOW_TEXT, null, false);
                var firstText = walker.nextNode();
                extractedName = firstText ? firstText.textContent.trim() : '';
            }

            if (!extractedName) return;

            // Apply {{name}} template interpolation to all template strings
            var nodeTitle = (tpl.title || '').replace(/\{\{name\}\}/g, extractedName);
            var nodeContent = (tpl.content || '').replace(/\{\{name\}\}/g, extractedName);
            var nodeExpanded = tpl.expanded
                ? tpl.expanded.replace(/\{\{name\}\}/g, extractedName)
                : undefined;

            // ── Context-aware enrichment ──────────────────────────
            // Read DOM state to add application-specific knowledge.

            // Detect "default" badge (environment rows)
            var defaultBadge = el.querySelector('[style*="accent-glow"]');
            if (defaultBadge && defaultBadge.textContent.trim().toLowerCase() === 'default') {
                nodeTitle += ' · default';
                var defaultNote = '\n\nAs the default environment, it will be pre-selected when you define secrets and variables in Step 3.';
                nodeExpanded = nodeExpanded ? nodeExpanded + defaultNote : defaultNote;
            }

            // Extract stack/path/domain metadata (module rows)
            var metaSpans = el.querySelectorAll('span');
            var extractedStack = '', extractedPath = '', extractedDomain = '';
            metaSpans.forEach(function(sp) {
                var txt = sp.textContent.trim();
                if (txt.indexOf('Stack:') === 0) extractedStack = txt.replace('Stack:', '').trim();
                if (txt.indexOf('Domain:') === 0) extractedDomain = txt.replace('Domain:', '').trim();
            });
            var codeEl = el.querySelector('code');
            if (codeEl) extractedPath = codeEl.textContent.trim();

            if (extractedStack) {
                nodeTitle += ' · ' + extractedStack;
                // Build styled detail card (same UX as stack select)
                var _dcpStacks = (window._dcp && window._dcp.stacks) || [];
                var stackEntry = _dcpStacks.find(function(s) { return s.name === extractedStack; });
                if (stackEntry) {
                    var stackHtml = '<div class="assistant-stack-detail">';

                    if (stackEntry.parent) {
                        // Flavored: language first, then framework
                        var parentEntry = _dcpStacks.find(function(s) { return s.name === stackEntry.parent; });
                        if (parentEntry) {
                            stackHtml += '<div class="assistant-stack-detail-name">' +
                                (parentEntry.icon || '') + ' ' + parentEntry.name + '</div>';
                            stackHtml += '<div class="assistant-stack-detail-text">' +
                                (parentEntry.detail || parentEntry.description) + '</div>';
                        }
                        stackHtml += '<div class="assistant-stack-detail-framework">' +
                            '\u21b3 ' + extractedStack + '</div>';
                        stackHtml += '<div class="assistant-stack-detail-text">' +
                            (stackEntry.detail || stackEntry.description) + '</div>';
                    } else {
                        // Base stack
                        stackHtml += '<div class="assistant-stack-detail-name">' +
                            (stackEntry.icon || '') + ' ' + extractedStack + '</div>';
                        stackHtml += '<div class="assistant-stack-detail-text">' +
                            (stackEntry.detail || stackEntry.description) + '</div>';
                    }

                    if (stackEntry.capabilities && stackEntry.capabilities.length > 0) {
                        stackHtml += '<div class="assistant-stack-detail-caps">' +
                            'Capabilities: ' + stackEntry.capabilities.join(', ') + '</div>';
                    }

                    stackHtml += '</div>';
                    nodeExpanded = stackHtml + (nodeExpanded ? '\n' + nodeExpanded : '');
                }
            }

            // ── Enricher dispatch ────────────────────────────────────
            // Domain-specific enrichers register on window._assistant.enrichers
            // keyed by parentNode.id. Each returns { title?, content?, expanded? }
            // or null. This replaces the inline if/else chain.
            var enricher = window._assistant.enrichers[parentNode.id];
            if (enricher) {
                var enriched = enricher(el, extractedName, parentNode);
                if (enriched) {
                    if (enriched.title)    nodeTitle    = enriched.title;
                    if (enriched.content)  nodeContent  = enriched.content;
                    if (enriched.expanded) nodeExpanded = enriched.expanded;
                }
            }

            var syntheticNode = {
                id: parentNode.id + '-dyn-' + i,
                title: nodeTitle,
                content: nodeContent,
                expanded: nodeExpanded,
                selector: null,
                _element: el,
                _isDynamic: true,
                children: []
            };

            // Apply childTemplate variants if defined
            if (tpl.variants && tpl.variants.length) {
                syntheticNode.variants = tpl.variants;
                syntheticNode = _resolveVariant(syntheticNode, el);
                // Re-apply {{name}} interpolation to variant content
                if (syntheticNode.title) {
                    syntheticNode.title = syntheticNode.title.replace(/\{\{name\}\}/g, extractedName);
                }
                if (syntheticNode.content) {
                    syntheticNode.content = syntheticNode.content.replace(/\{\{name\}\}/g, extractedName);
                }
                if (syntheticNode.expanded) {
                    syntheticNode.expanded = syntheticNode.expanded.replace(/\{\{name\}\}/g, extractedName);
                }
            }

            // Dynamic children go deepest-first (before their parent)
            result.unshift({ node: syntheticNode, parents: [...grandParentChain, parentNode] });
        });
    }

    // ── Node Matching ──────────────────────────────────────────────
    // Given a DOM element (from hover/focus), find the matching node.

    function _matchNode(element) {
        if (!element || !_flatNodes.length) return null;

        // Collect ALL matching nodes, then return the deepest one.
        // When multiple nodes share the same selector (e.g., a parent and its
        // children all point at #wiz-docker-base), we want the most specific
        // child — the one with the longest parent chain.
        var bestMatch = null;
        var bestDepth = -1;

        for (let i = 0; i < _flatNodes.length; i++) {
            const entry = _flatNodes[i];
            const node = entry.node;
            var matched = false;
            var proximateTarget = null; // Local — never stale across calls

            // Dynamic nodes: match by direct element reference
            if (node._element) {
                if (node._element === element || node._element.contains(element)) {
                    matched = true;
                }
            } else if (node.selector) {
                // Static nodes: match by CSS selector
                try {
                    // 1. Direct match: the element itself IS the selector target
                    if (element.matches(node.selector)) {
                        matched = true;
                    }

                    // 2. Inside: the element is a descendant of the selector target
                    if (!matched && element.closest(node.selector)) {
                        matched = true;
                    }

                    // 2.5 Contains: the element wraps the selector target.
                    //     Handles <label><input id="mf-dk-compose">text</label>
                    //     where hovering the label should match the input child.
                    if (!matched) {
                        var contained = element.querySelector(node.selector);
                        if (contained) {
                            matched = true;
                            proximateTarget = contained;
                        }
                    }

                    // 3. Field-group proximity: the element shares a wrapper div
                    //    with the selector target. This handles hovering a <label>
                    //    that's a sibling of <input id="wiz-name">.
                    //    Skip for ID and class selectors — class selectors are
                    //    already matched by closest/querySelector in steps 2/2.5,
                    //    and proximity can false-positive when the ancestor div
                    //    is a large container (e.g. a service card).
                    //    Limit the walk to 2 levels to avoid matching the entire
                    //    card container via a distant ancestor div.
                    if (!matched && node.selector.charAt(0) !== '#' && node.selector.charAt(0) !== '.') {
                        const targets = _containerEl.querySelectorAll(node.selector);
                        for (let t = 0; t < targets.length; t++) {
                            const targetEl = targets[t];
                            // Walk up at most 2 levels from targetEl to find a nearby div
                            var walk = targetEl.parentElement;
                            var wrapper = null;
                            for (var w = 0; w < 2 && walk && walk !== _containerEl; w++) {
                                if (walk.tagName === 'DIV') { wrapper = walk; break; }
                                walk = walk.parentElement;
                            }
                            if (wrapper && wrapper !== _containerEl &&
                                (wrapper === element || wrapper.contains(element))) {
                                matched = true;
                                proximateTarget = targetEl;
                                break;
                            }
                        }
                    }
                } catch (e) {
                    // Invalid selector — skip silently
                }
            }

            if (matched) {
                var depth = entry.parents ? entry.parents.length : 0;
                if (depth > bestDepth) {
                    bestDepth = depth;
                    bestMatch = entry;
                    // Capture the actual matched DOM element for variant resolution.
                    // For class selectors (.gh-secret-pill), this is the specific pill
                    // the user hovered, not querySelector's first-match.
                    // When matched via proximity (step 3), use the proximate target
                    // so resolvers get the actual element the selector matched.
                    try {
                        if (proximateTarget) {
                            bestMatch._matchedElement = proximateTarget;
                        } else {
                            bestMatch._matchedElement = element.matches(node.selector) ? element : (element.closest(node.selector) || element);
                        }
                    } catch(ex) {
                        bestMatch._matchedElement = element;
                    }
                }
            }
        }

        return bestMatch;
    }

    // ── Path Merging ───────────────────────────────────────────────
    // Merge focus and hover paths. Deduplicate shared parents.
    // Returns [{ node, depth, isTarget }] sorted shallowest-first.

    function _mergeInteractionPaths(focusPath, hoverPath) {
        const nodeMap = new Map();  // nodeId → { node, depth, isTarget }

        function _addPath(path) {
            if (!path) return;
            // Add parents (in-chain)
            for (let i = 0; i < path.chain.length; i++) {
                const n = path.chain[i];
                if (!nodeMap.has(n.id)) {
                    nodeMap.set(n.id, { node: n, depth: i, isTarget: false });
                }
            }
            // Add target
            const depth = path.chain.length;
            const existing = nodeMap.get(path.target.id);
            if (existing) {
                existing.isTarget = true;  // promote to target
            } else {
                nodeMap.set(path.target.id, {
                    node: path.target,
                    depth: depth,
                    isTarget: true
                });
            }
        }

        _addPath(focusPath);
        _addPath(hoverPath);

        // Sort by depth (shallowest first)
        var sorted = Array.from(nodeMap.values());
        sorted.sort(function(a, b) { return a.depth - b.depth; });

        // Limit: keep only target + 1 immediate parent (max 2 nodes from target)
        var maxTargetDepth = -1;
        for (var i = 0; i < sorted.length; i++) {
            if (sorted[i].isTarget && sorted[i].depth > maxTargetDepth) {
                maxTargetDepth = sorted[i].depth;
            }
        }
        if (maxTargetDepth >= 0) {
            var minDepth = Math.max(0, maxTargetDepth - 1);
            sorted = sorted.filter(function(e) { return e.depth >= minDepth; });
            // Normalize depths so shallowest shown renders at depth 0
            for (var j = 0; j < sorted.length; j++) {
                sorted[j].depth = sorted[j].depth - minDepth;
            }
        }

        return sorted;
    }

    // ── Rendering ──────────────────────────────────────────────────

    function _renderContextHeader() {
        if (!_panelEl || !_currentCtx) return;

        _panelEl.innerHTML = '';

        // Resolve variants on the root node (step-aware header content)
        var resolved = _containerEl ? _resolveVariant(_currentCtx, _containerEl) : _currentCtx;

        const inner = document.createElement('div');
        inner.className = 'assistant-panel-inner';

        const header = document.createElement('div');
        header.className = 'assistant-context-header';
        header.innerHTML =
            '<div class="assistant-context-title">' +
                (resolved.icon ? resolved.icon + ' ' : '') +
                resolved.title +
            '</div>' +
            '<div class="assistant-context-content">' +
                _resolve(resolved.content) +
            '</div>';

        inner.appendChild(header);
        _panelEl.appendChild(inner);
    }

    function _renderInteractionPath() {
        if (!_panelEl || !_currentCtx) return;

        // If no interaction, fall back to sticky path or entry state
        if (!_focusPath && !_hoverPath) {
            if (_stickyPath) {
                // Restore sticky hover so panel keeps its content
                _hoverPath = _stickyPath;
            } else {
                _renderContextHeader();
                _panelEl.classList.add('entry-state');
                return;
            }
        }

        // Save current path as sticky (survives mouse-to-panel trips).
        // Dwell guard: only commit sticky after 200ms on the same target.
        // This prevents a quick crossing through a wide element (e.g. Container
        // Image occupying 3fr) from overwriting a deliberately-hovered target.
        if (_hoverPath) {
            var candidateId = _hoverPath.target.id;
            var currentStickyId = _stickyPath ? _stickyPath.target.id : null;
            if (candidateId !== currentStickyId) {
                // New hover target — start dwell timer for sticky update
                clearTimeout(_stickyDwellTimer);
                var pendingPath = _hoverPath;
                _stickyDwellTimer = setTimeout(function() {
                    _stickyPath = pendingPath;
                }, 200);
            }
            // If same target, sticky is already correct (or pending)
        }

        _panelEl.classList.remove('entry-state');

        // Re-render context header + path
        _renderContextHeader();

        const inner = _panelEl.querySelector('.assistant-panel-inner');
        if (!inner) return;

        // Merge paths
        const pathNodes = _mergeInteractionPaths(_focusPath, _hoverPath);

        // Render each node
        for (let i = 0; i < pathNodes.length; i++) {
            var entry = pathNodes[i];

            // Determine the correct element for this target entry.
            // When focus and hover target DIFFERENT nodes, each target must
            // use the element from its own originating path — not the other's.
            var matchedEl = null;
            if (entry.isTarget) {
                if (_hoverPath && _hoverPath.target.id === entry.node.id) {
                    matchedEl = _hoverPath.element;
                } else if (_focusPath && _focusPath.target.id === entry.node.id) {
                    matchedEl = _focusPath.element;
                } else {
                    // Fallback: prefer hover, then focus
                    matchedEl = (_hoverPath && _hoverPath.element) || (_focusPath && _focusPath.element);
                }
            }
            // Expose the matched element so resolvers can access per-item context
            window._assistant._resolveElement = matchedEl || null;
            var node = entry.node._isDynamic
                ? entry.node  // Dynamic nodes already resolved in _resolveDynamic
                : _resolveStaticVariant(entry.node, matchedEl);

            // Separator
            if (node.separator) {
                var sep = document.createElement('hr');
                sep.className = 'assistant-separator';
                inner.appendChild(sep);
            }

            var div = document.createElement('div');
            div.className = 'assistant-node';
            div.dataset.nodeId = node.id;
            div.dataset.depth = entry.depth;

            // State class
            if (entry.isTarget) {
                div.classList.add('active-target');
            } else {
                div.classList.add('in-chain');
            }

            // Title
            var titleEl = document.createElement('div');
            titleEl.className = 'assistant-node-title';
            titleEl.textContent = (node.icon ? node.icon + ' ' : '') + (node.title || '');
            div.appendChild(titleEl);

            // Content
            var contentEl = document.createElement('div');
            contentEl.className = 'assistant-node-content';
            contentEl.innerHTML = _resolve(node.content);
            div.appendChild(contentEl);

            // Expanded content — show for active targets and their direct parent
            var showExpanded = entry.isTarget ||
                (node.expanded && i < pathNodes.length - 1 && pathNodes[i + 1].isTarget);
            if (showExpanded && node.expanded) {
                var expandedEl = document.createElement('div');
                expandedEl.className = 'assistant-node-expanded';
                expandedEl.innerHTML = _resolve(node.expanded);
                div.appendChild(expandedEl);
            }

            inner.appendChild(div);
        }

        // Clear resolve context after render
        window._assistant._resolveElement = null;

        // Center the active target in the panel viewport, then apply highlights
        requestAnimationFrame(function() {
            var didHighlight = _highlightSelectedStack();
            _highlightActiveEnv();
            // If a stack is highlighted, _highlightSelectedStack scrolls to it.
            // Otherwise, fall back to centering on the active target node.
            if (!didHighlight) {
                _centerActiveNode();
            }
        });
    }

    // ── Scroll Centering ───────────────────────────────────────────
    // Uses direct scrollTop on the panel — never touches page scroll.

    function _centerActiveNode() {
        if (!_panelEl) return;

        var target = _panelEl.querySelector('.assistant-node.active-target');
        if (!target) return;

        // Calculate where target sits relative to the panel's scroll container
        var targetTop = target.offsetTop;
        var targetHeight = target.offsetHeight;
        var panelHeight = _panelEl.clientHeight;

        // Scroll so target is vertically centered in the panel
        var scrollTo = targetTop - (panelHeight / 2) + (targetHeight / 2);
        _panelEl.scrollTo({ top: Math.max(0, scrollTo), behavior: 'smooth' });
    }

    // ── Event Handlers ─────────────────────────────────────────────

    function _onHover(e) {
        if (!_enabled) return;

        // Debounce rapid hover changes (50ms)
        clearTimeout(_hoverDebounce);
        _hoverDebounce = setTimeout(function() {
            var matched = _matchNode(e.target);
            if (!matched) return;

            // Same hover target? Don't re-render.
            // For dynamic nodes (_isDynamic), compare node ID only — sub-elements
            // within the same card (badges, buttons) all resolve to one node.
            // For static nodes, also compare element (class-selector nodes like
            // .gh-secret-pill have multiple DOM elements sharing one catalogue node).
            if (_hoverPath && _hoverPath.target.id === matched.node.id
                && (matched.node._isDynamic || _hoverPath.element === matched._matchedElement)) return;

            // Padding guard: if the mouse is on a container's own
            // padding/dead-space (e.target IS the selector element, not a
            // child within it), and we already have a deeper hover target,
            // skip — the user is crossing dead space, not targeting the parent.
            if (_hoverPath && _hoverPath.chain && matched.node.selector) {
                var newDepth = matched.parents ? matched.parents.length : 0;
                var currentDepth = _hoverPath.chain.length;
                if (newDepth < currentDepth) {
                    try {
                        if (e.target.matches(matched.node.selector)) {
                            return; // Mouse is on container padding, not content
                        }
                    } catch(ex) {}
                }
            }

            _hoverPath = { target: matched.node, chain: matched.parents, element: matched._matchedElement };
            _renderInteractionPath();

            // Dwell timer: after 300ms on the same element, clear stale _focusPath.
            // This makes hover-dwell act as the new "remembered" target, replacing
            // any leftover focus from a checkbox click or previous interaction.
            clearTimeout(_dwellTimer);
            if (_focusPath) {
                _dwellTimer = setTimeout(function() {
                    if (_focusPath) {
                        _focusPath = null;
                        _renderInteractionPath();
                    }
                }, 300);
            }
        }, 50);
    }

    function _onFocus(e) {
        if (!_enabled) return;

        // Only hold persistent focus for continuous-edit elements (text, select).
        // Buttons and checkboxes are fire-and-forget — they perform a single
        // action and shouldn't stick in the panel after you move away.
        var tag = e.target.tagName;
        if (tag !== 'INPUT' && tag !== 'SELECT' && tag !== 'TEXTAREA') return;
        if (tag === 'INPUT' && (e.target.type === 'checkbox' || e.target.type === 'radio')) return;

        var matched = _matchNode(e.target);
        if (!matched) return;

        // Same node AND element? Don't re-render
        if (_focusPath && _focusPath.target.id === matched.node.id
            && _focusPath.element === matched._matchedElement) return;

        _focusPath = { target: matched.node, chain: matched.parents, element: matched._matchedElement };
        _renderInteractionPath();
    }

    function _onBlur(e) {
        if (!_enabled) return;

        _focusPath = null;
        _renderInteractionPath();
    }

    function _onMouseLeave(e) {
        if (!_enabled) return;

        // Mouse moved to the assistant panel or its gap — revert to sticky.
        // Clear the hover debounce too: without this, a pending 50ms debounce
        // callback from the last mouseover (e.g. crossing Container Image)
        // would fire AFTER this handler and overwrite the sticky revert.
        var layout = _containerEl && _containerEl.closest('.assistant-layout');
        if (layout && e.relatedTarget && (layout === e.relatedTarget || layout.contains(e.relatedTarget))) {
            clearTimeout(_hoverDebounce);
            clearTimeout(_stickyDwellTimer);
            _hoverPath = null;
            _renderInteractionPath();
            return;
        }

        clearTimeout(_hoverDebounce);
        clearTimeout(_stickyDwellTimer);
        _hoverPath = null;
        _stickyPath = null;
        _renderInteractionPath();
    }

    function _onLayoutLeave(e) {
        if (!_enabled) return;

        // Mouse truly left the entire assistant region (body + panel)
        // relatedTarget is outside the layout — clear everything
        var layout = _containerEl && _containerEl.closest('.assistant-layout');
        if (layout && e.relatedTarget && layout.contains(e.relatedTarget)) return;

        clearTimeout(_hoverDebounce);
        clearTimeout(_stickyDwellTimer);
        _hoverPath = null;
        _stickyPath = null;
        _renderInteractionPath();
    }

    function _onChange(e) {
        if (!_enabled) return;

        // Center the changed element in the wizard view
        if (e.target && e.target.scrollIntoView) {
            e.target.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }

        // Navigate assistant to this element's node
        var matched = _matchNode(e.target);
        if (matched) {
            _hoverPath = { target: matched.node, chain: matched.parents, element: matched._matchedElement };
            // Update sticky path so the panel stays on this node
            _stickyPath = _hoverPath;
        }

        // Re-render — _highlightSelectedStack is called from
        // _renderInteractionPath's requestAnimationFrame, so it
        // runs automatically on every render, not just on change.
        _renderInteractionPath();
    }

    // Highlight the selected stack's ENTIRE SECTION + show detail descriptions.
    // Called at the end of EVERY _renderInteractionPath render.
    // Returns true if a highlight was applied.
    function _highlightSelectedStack() {
        if (!_panelEl) return false;
        var select = document.getElementById('wiz-mod-stack');
        if (!select || !select.value || select.value === '' || select.value === '__custom__') return false;

        var stackName = select.value;
        var stacks = (window._dcp && window._dcp.stacks) || [];
        var stack = stacks.find(function(s) { return s.name === stackName; });
        if (!stack) return false;

        // Find the base/parent stack
        var baseStack = stack;
        if (stack.parent) {
            var parent = stacks.find(function(s) { return s.name === stack.parent; });
            if (parent) baseStack = parent;
        }

        var expandedEls = _panelEl.querySelectorAll('.assistant-node-expanded');
        var applied = false;

        expandedEls.forEach(function(el) {
            var html = el.innerHTML;

            // Check this expanded block contains the selected stack
            if (html.indexOf('\u2022 ' + stackName + ' \u2014') === -1) return;

            // ── Line-by-line processing ──
            var lines = html.split('\n');
            var selectedIdx = -1;

            // Find the line with the selected stack
            for (var i = 0; i < lines.length; i++) {
                if (lines[i].indexOf('\u2022 ' + stackName + ' \u2014') !== -1) {
                    selectedIdx = i;
                    break;
                }
            }
            if (selectedIdx === -1) return;

            // Walk backwards to find section header (non-bullet, non-empty line)
            var headerIdx = selectedIdx;
            for (var i = selectedIdx - 1; i >= 0; i--) {
                var trimmed = lines[i].trim();
                if (trimmed === '') break;          // blank line = section boundary
                if (trimmed.charAt(0) === '\u2022') continue; // bullet = still in section
                headerIdx = i;                      // non-bullet non-empty = header
                break;
            }

            // Walk forwards to find end of section (next blank or non-bullet)
            var endIdx = selectedIdx;
            for (var i = selectedIdx + 1; i < lines.length; i++) {
                var trimmed = lines[i].trim();
                if (trimmed === '') break;
                if (trimmed.charAt(0) !== '\u2022') break;
                endIdx = i;
            }

            // ── Wrap section + mark entries ──
            for (var i = headerIdx; i <= endIdx; i++) {
                if (lines[i].indexOf('\u2022 ' + stackName + ' \u2014') !== -1) {
                    lines[i] = '<span class="assistant-stack-selected">' + lines[i] + '</span>';
                } else if (stack.parent && lines[i].indexOf('\u2022 ' + stack.parent + ' \u2014') !== -1) {
                    lines[i] = '<span class="assistant-stack-parent">' + lines[i] + '</span>';
                }
            }

            // Wrap entire section in a container
            lines[headerIdx] = '<span class="assistant-stack-section">' + lines[headerIdx];
            lines[endIdx] = lines[endIdx] + '</span>';

            // ── Insert detail block BEFORE the listing ──
            var baseDetail = baseStack.detail || baseStack.description || '';
            var stackDetail = stack.detail || stack.description || '';

            var detailDiv = document.createElement('div');
            detailDiv.className = 'assistant-stack-detail';

            if (stack.parent && baseStack.name !== stack.name) {
                // Flavored stack: show LANGUAGE first, then FRAMEWORK
                // Language header
                detailDiv.innerHTML =
                    '<div class="assistant-stack-detail-name">' +
                        (baseStack.icon || '') + ' ' + baseStack.name +
                    '</div>' +
                    '<div class="assistant-stack-detail-text">' + baseDetail + '</div>' +
                    // Framework section
                    '<div class="assistant-stack-detail-framework">' +
                        '\u21b3 ' + stack.name +
                    '</div>' +
                    '<div class="assistant-stack-detail-text">' + stackDetail + '</div>';
            } else {
                // Base stack: just show the stack itself
                detailDiv.innerHTML =
                    '<div class="assistant-stack-detail-name">' +
                        (stack.icon || '') + ' ' + stack.name +
                    '</div>' +
                    '<div class="assistant-stack-detail-text">' + stackDetail + '</div>';
            }

            // Capabilities
            if (stack.capabilities && stack.capabilities.length > 0) {
                var capsEl = document.createElement('div');
                capsEl.className = 'assistant-stack-detail-caps';
                capsEl.textContent = 'Capabilities: ' + stack.capabilities.join(', ');
                detailDiv.appendChild(capsEl);
            }


            // Set innerHTML with section + entry highlights
            el.innerHTML = lines.join('\n');

            // Insert detail block AFTER the highlighted section (not at the top)
            var sectionEl = el.querySelector('.assistant-stack-section');
            if (sectionEl && sectionEl.nextSibling) {
                sectionEl.parentNode.insertBefore(detailDiv, sectionEl.nextSibling);
            } else if (sectionEl) {
                sectionEl.parentNode.appendChild(detailDiv);
            } else {
                // Fallback: prepend if no section found
                el.insertBefore(detailDiv, el.firstChild);
            }

            applied = true;

            // ── Scroll to the selected entry ──
            var highlighted = el.querySelector('.assistant-stack-selected');
            if (highlighted) {
                var hRect = highlighted.getBoundingClientRect();
                var pRect = _panelEl.getBoundingClientRect();
                var scrollTo = _panelEl.scrollTop + (hRect.top - pRect.top) - (pRect.height / 2) + (hRect.height / 2);
                _panelEl.scrollTo({ top: Math.max(0, scrollTo), behavior: 'smooth' });
            }
        });

        return applied;
    }

    // Highlight assistant nodes that represent the active environment.
    // Finds state cards with "· ACTIVE" in the label and adds a
    // visual highlight class to the parent assistant node.
    function _highlightActiveEnv() {
        if (!_panelEl) return;

        var stateLabels = _panelEl.querySelectorAll('.state-label');
        stateLabels.forEach(function(label) {
            if (label.textContent.indexOf('ACTIVE') === -1) return;

            // Walk up to the nearest assistant-node container
            var node = label.closest('.assistant-node');
            if (node) {
                node.classList.add('assistant-node-active-env');
            }
        });
    }

    function _onWheel(e) {
        if (!_panelEl) return;

        var scrollTop = _panelEl.scrollTop;
        var scrollMax = _panelEl.scrollHeight - _panelEl.clientHeight;

        // If panel has no overflow, let event pass through
        if (scrollMax <= 0) return;

        // Scrolling down and panel hasn't reached bottom
        if (e.deltaY > 0 && scrollTop < scrollMax) {
            e.preventDefault();
            _panelEl.scrollTop = Math.min(scrollTop + e.deltaY, scrollMax);
            return;
        }

        // Scrolling up and panel hasn't reached top
        if (e.deltaY < 0 && scrollTop > 0) {
            e.preventDefault();
            _panelEl.scrollTop = Math.max(scrollTop + e.deltaY, 0);
            return;
        }

        // Panel fully scrolled in this direction — let event pass to page
    }

    // ── Listener Management ────────────────────────────────────────

    function _attachListeners(containerEl) {
        _detachListeners();

        _listeners = {
            hover:      function(e) { _onHover(e); },
            focus:      function(e) { _onFocus(e); },
            blur:       function(e) { _onBlur(e); },
            mouseleave: function(e) { _onMouseLeave(e); },
            layoutleave: function(e) { _onLayoutLeave(e); },
            wheel:      function(e) { _onWheel(e); },
            change:     function(e) { _onChange(e); }
        };

        containerEl.addEventListener('mouseover', _listeners.hover);
        containerEl.addEventListener('focusin', _listeners.focus);
        containerEl.addEventListener('change', _listeners.change);
        containerEl.addEventListener('focusout', _listeners.blur);
        containerEl.addEventListener('mouseleave', _listeners.mouseleave);

        // Attach wheel + layout leave to the layout container (parent of both body + panel)
        var layout = containerEl.closest('.assistant-layout') || containerEl.parentElement;
        if (layout) {
            layout.addEventListener('wheel', _listeners.wheel, { passive: false });
            layout.addEventListener('mouseleave', _listeners.layoutleave);
            _listeners._layoutTarget = layout;
        }
    }

    function _detachListeners() {
        if (!_containerEl || !_listeners.hover) return;

        _containerEl.removeEventListener('mouseover', _listeners.hover);
        _containerEl.removeEventListener('focusin', _listeners.focus);
        _containerEl.removeEventListener('focusout', _listeners.blur);
        _containerEl.removeEventListener('mouseleave', _listeners.mouseleave);
        if (_listeners.change) _containerEl.removeEventListener('change', _listeners.change);

        if (_listeners._layoutTarget) {
            _listeners._layoutTarget.removeEventListener('wheel', _listeners.wheel);
            _listeners._layoutTarget.removeEventListener('mouseleave', _listeners.layoutleave);
        }

        _listeners = {};
    }

    // ── Public API ─────────────────────────────────────────────────

    async function activate(contextId, containerEl, panelEl) {
        await _loadCatalogue();
        if (!_catalogue) return;

        var ctx = _catalogue.get(contextId);
        if (!ctx) {
            console.warn('[assistant] no context found for:', contextId);
            return;
        }

        // Clean up previous context
        _detachListeners();

        _currentCtx = ctx;
        _containerEl = containerEl;
        _panelEl = panelEl || _resolvePanel();
        if (!_panelEl) return;

        // Flatten the tree for selector matching
        _flatNodes = _flattenTree(ctx.children, []);

        // Reset interaction state
        _focusPath = null;
        _hoverPath = null;
        _stickyPath = null;

        // Render entry state
        _renderContextHeader();
        _panelEl.classList.add('entry-state');

        // Show panel
        if (_enabled) {
            _panelEl.classList.remove('disabled');
        }

        // Listen for interactions on the container
        _attachListeners(containerEl);
    }

    function deactivate() {
        _detachListeners();
        _currentCtx = null;
        _containerEl = null;
        _flatNodes = [];
        _focusPath = null;
        _hoverPath = null;
        if (_panelEl) {
            _panelEl.innerHTML = '';
            _panelEl.classList.remove('entry-state');
        }
    }

    function refresh() {
        if (!_currentCtx || !_containerEl) return;

        // Re-flatten tree (picks up new dynamic children)
        _flatNodes = _flattenTree(_currentCtx.children, []);

        // Re-render current state
        _renderInteractionPath();
    }

    function enable() {
        _enabled = true;
        if (_panelEl) _panelEl.classList.remove('disabled');
    }

    function disable() {
        _enabled = false;
        if (_panelEl) _panelEl.classList.add('disabled');
    }

    // ── Expose ─────────────────────────────────────────────────────

    window._assistant = {
        activate:   activate,
        deactivate: deactivate,
        refresh:    refresh,
        enable:     enable,
        disable:    disable,
        resolvers:  {},
        enrichers:  {},   // keyed by parentNode.id → function(el, extractedName, parentNode) → { title?, content?, expanded? } | null
        _shared:    {}    // cross-file utilities (image parsing, port analysis, etc.)
    };

})();
</script>

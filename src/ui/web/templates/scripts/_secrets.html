<script>
    // â”€â”€ Secrets tab â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    let vaultState = {};
    let ghSecrets = [];      // Secret names set on GitHub
    let ghVariables = [];    // Variable names set on GitHub
    let ghAvailable = false; // Whether gh CLI is available
    let envData = {};        // Raw env values (config keys only)
    let envKeys = [];        // Full key metadata from API
    let envSections = [];    // Section names from .env
    let secretsInitialValues = {};
    let secretsDirty = false;
    let secretsLoaded = false;
    let _recentPushResults = [];  // optimistic update buffer
    let currentTarget = 'both';

    // Auto-provided by GitHub Actions runtime â€” can't be set/deleted via API
    const AUTO_PROVIDED = ['GITHUB_TOKEN', 'GITHUB_REPOSITORY'];

    /**
     * Derive tier for a key based on its metadata.
     *
     * - 'auto'   â†’ GITHUB_TOKEN / GITHUB_REPOSITORY (runtime-provided)
     * - 'local'  â†’ key has `# local-only` comment in .env
     * - 'secret' â†’ pushable via `gh secret set` (kind === 'secret')
     * - 'var'    â†’ pushable via `gh variable set` (kind === 'config')
     *
     * By default everything is pushable to GitHub. Users opt-out
     * per-key by toggling the # local-only comment.
     */
    function getSecretTier(name, keyMeta) {
        if (AUTO_PROVIDED.includes(name)) return 'auto';
        // Check per-key local_only flag from API
        if (keyMeta && keyMeta.local_only) return 'local';
        // Fallback: look it up in envKeys
        const found = envKeys.find(k => k.key === name);
        if (found && found.local_only) return 'local';
        // kind-based: secret â†’ gh secret set, config â†’ gh variable set
        const kind = (keyMeta && keyMeta.kind) || (found && found.kind) || 'config';
        return kind === 'secret' ? 'secret' : 'var';
    }


    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  Load
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    async function loadSecretsTab() {
        try {
            const [status, secrets, keys, ghStatus, ghData] = await Promise.all([
                api('/vault/status'),
                api('/vault/secrets'),
                api('/vault/keys'),
                api('/gh/status').catch(() => ({ installed: false, authenticated: false })),
                api('/gh/secrets').catch(() => ({ available: false, secrets: [], variables: [] })),
            ]);

            vaultState = status;
            ghAvailable = ghData.available || false;
            // Normalize to uppercase â€” GitHub stores names case-insensitively
            // and gh list returns them in UPPERCASE
            ghSecrets = (ghData.secrets || []).map(s => s.toUpperCase());
            ghVariables = (ghData.variables || []).map(s => s.toUpperCase());

            // Merge any optimistic updates from recent pushes
            // (handles race condition where gh list hasn't propagated yet)
            if (_recentPushResults.length > 0) {
                for (const r of _recentPushResults) {
                    if (!r.success) continue;
                    const upper = r.name.toUpperCase();
                    if (r.kind === 'secret' && !ghSecrets.includes(upper)) {
                        ghSecrets.push(upper);
                    }
                    if (r.kind === 'variable' && !ghVariables.includes(upper)) {
                        ghVariables.push(upper);
                    }
                }
                _recentPushResults = [];
            }

            // Build envData and envKeys from keys response
            envData = {};
            envKeys = keys.keys || [];
            envSections = (keys.sections || []).map(s => s.name);
            for (const k of envKeys) {
                envData[k.key] = k.value || '';
            }

            renderVaultStatusBar(status);
            renderGhStatusAlert(ghStatus, ghData);
            renderSecretFiles(secrets.files);
            renderSecretsForm(keys, status);

        } catch (e) {
            console.error('Failed to load secrets tab:', e);
            document.getElementById('secrets-form').innerHTML = `
            <p class="empty-state">
                <span style="font-size:2rem;display:block;margin-bottom:0.5rem">âš ï¸</span>
                Failed to load vault: ${esc(e.message)}
            </p>`;
        }
    }


    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  Status bars
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    function renderVaultStatusBar(status) {
        const icon = document.getElementById('vault-status-icon');
        const text = document.getElementById('vault-status-text');
        const lockBtn = document.getElementById('vault-lock-btn');

        if (status.empty) {
            icon.textContent = 'ğŸ“­';
            text.textContent = 'No .env file found â€” create one to manage secrets';
            text.style.color = 'var(--text-secondary)';
            lockBtn.style.display = 'none';
            return;
        }

        if (status.locked) {
            icon.textContent = 'ğŸ”’';
            text.textContent = 'Vault is locked â€” secrets are encrypted at rest';
            text.style.color = 'var(--success)';
            lockBtn.textContent = 'ğŸ”“ Unlock';
            lockBtn.onclick = () => showVaultUnlockModal();
            lockBtn.style.display = '';
        } else {
            icon.textContent = 'ğŸ”“';
            if (status.has_passphrase) {
                text.textContent = `Vault is unlocked â€” auto-lock in ${status.auto_lock_minutes}min`;
            } else {
                text.textContent = 'Vault is unlocked â€” no passphrase registered (auto-lock disabled)';
            }
            text.style.color = 'var(--warning)';
            lockBtn.textContent = 'ğŸ”’ Lock';
            lockBtn.onclick = () => showVaultLockModal();
            lockBtn.style.display = '';
        }

        if (status.rate_limited) {
            text.textContent = `âš ï¸ Rate limited â€” try again in ${status.retry_after}s`;
            text.style.color = 'var(--error)';
            lockBtn.style.display = 'none';
        }
    }

    function renderGhStatusAlert(ghStatus, ghData) {
        const container = document.getElementById('gh-status-alert');
        if (!container) return;

        if (!ghStatus.installed) {
            container.innerHTML = `
                <div class="alert-bar warning">
                    <span>âš ï¸ <strong>gh CLI not installed</strong> â€” GitHub secret sync unavailable</span>
                    <button class="btn btn-sm" onclick="refreshSecrets()" title="Refresh">ğŸ”„</button>
                </div>`;
        } else if (!ghStatus.authenticated) {
            container.innerHTML = `
                <div class="alert-bar warning">
                    <span>âš ï¸ <strong>gh CLI not authenticated</strong> â€” Run <code>gh auth login</code></span>
                    <button class="btn btn-sm" onclick="refreshSecrets()" title="Refresh">ğŸ”„</button>
                </div>`;
        } else {
            container.innerHTML = `
                <div class="alert-bar success">
                    <span>âœ… <strong>gh CLI ready</strong> â€” ${ghSecrets.length} secret(s), ${ghVariables.length} variable(s) on GitHub</span>
                    <button class="btn btn-sm" onclick="refreshSecrets()" title="Refresh">ğŸ”„</button>
                </div>`;
        }
    }

    function renderSecretFiles(files) {
        const container = document.getElementById('secrets-form');
        if (!files.length) return;

        const filesHtml = `
        <div class="secret-files-header">
            <span class="secret-files-title">Detected Secret Files</span>
        </div>
        <div class="secret-files-list">
            ${files.map(f => {
            const statusCls = f.locked ? 'ok' : 'degraded';
            const statusLabel = f.locked ? 'encrypted' : 'plaintext';
            const icon = f.locked ? 'ğŸ”’' : 'ğŸ“„';
            const sizeStr = f.locked
                ? (f.vault_size ? `${(f.vault_size / 1024).toFixed(1)}KB vault` : '')
                : (f.size ? `${(f.size / 1024).toFixed(1)}KB` : '');
            return `<div class="secret-file-row">
                    <span class="secret-file-icon">${icon}</span>
                    <span class="secret-file-name">${esc(f.name)}</span>
                    <span class="secret-file-size">${sizeStr}</span>
                    <span class="status-badge ${statusCls}" style="font-size:0.7rem;padding:2px 8px;">
                        <span class="status-dot"></span>${statusLabel}
                    </span>
                </div>`;
        }).join('')}
        </div>`;

        container.insertAdjacentHTML('afterbegin', filesHtml);
    }


    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  Main form rendering â€” section-based, orchestrator-style
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    function renderSecretsForm(data, status) {
        const container = document.getElementById('secrets-form');

        // â”€â”€ STATE: empty â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        if (data.state === 'empty') {
            container.innerHTML = `
            <div class="env-empty-state" style="margin-top:var(--space-lg)">
                <div class="empty-create-box">
                    <span style="font-size:2.5rem;display:block;margin-bottom:var(--space-md)">ğŸ“</span>
                    <h3 style="margin-bottom:var(--space-sm)">No .env file found</h3>
                    <p style="color:var(--text-secondary);margin-bottom:var(--space-lg);font-size:0.88rem;line-height:1.6;max-width:400px;margin-left:auto;margin-right:auto">
                        Create a <code>.env</code> to store environment variables, API keys,
                        and other secrets. You can encrypt it with the vault afterwards.
                    </p>
                    <div style="display:flex;gap:var(--space-sm);justify-content:center;flex-wrap:wrap">
                        <button class="btn btn-primary" onclick="showAddKeysModal('create')">
                            âœ¨ Create .env
                        </button>
                        <button class="btn btn-secondary" onclick="createEnvFromTemplate()">
                            ğŸ“‹ Use Template
                        </button>
                    </div>
                </div>
            </div>`;
            return;
        }

        // â”€â”€ STATE: locked â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        if (data.state === 'locked') {
            container.innerHTML = `
            <div class="env-keys-section" style="margin-top:var(--space-lg)">
                <div class="env-keys-locked">
                    <span style="font-size:1.5rem">ğŸ”’</span>
                    <span>Environment keys are encrypted. Unlock the vault to view them.</span>
                </div>
            </div>`;
            return;
        }

        // â”€â”€ STATE: unlocked â€” no keys â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        if (!data.keys || !data.keys.length) {
            container.innerHTML = `
            <div class="env-keys-section" style="margin-top:var(--space-lg)">
                <div class="empty-create-box" style="padding:var(--space-xl)">
                    <span style="font-size:2rem;display:block;margin-bottom:var(--space-sm)">ğŸ“­</span>
                    <h3 style="margin-bottom:var(--space-sm);font-size:0.95rem">.env is empty</h3>
                    <p style="color:var(--text-muted);font-size:0.85rem;margin-bottom:var(--space-md);line-height:1.5">
                        Your <code>.env</code> file exists but has no key-value entries yet.
                    </p>
                    <button class="btn btn-primary" onclick="showAddKeysModal('add')">
                        âœ¨ Add Keys
                    </button>
                </div>
            </div>`;
            return;
        }

        // â”€â”€ Build section-based form â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        const sections = data.sections && data.sections.length > 0
            ? data.sections
            : [{ name: 'Environment Variables', keys: data.keys }];

        const defaultCollapsed = sections.length > 3
            ? sections.slice(2).map(s => s.name)
            : [];

        let html = '';

        // GitHub status alert placeholder
        html += '<div id="gh-status-alert"></div>';

        for (const section of sections) {
            const catId = section.name.replace(/[^a-zA-Z0-9]/g, '').toLowerCase();
            const storageKey = `secrets-collapse-${catId}`;
            const storedState = sessionStorage.getItem(storageKey);
            const isCollapsed = storedState !== null
                ? storedState === 'true'
                : defaultCollapsed.includes(section.name);

            const configuredCount = section.keys.filter(k => k.has_value).length;
            const totalCount = section.keys.length;
            const badgeBg = configuredCount === totalCount
                ? 'var(--success)' : configuredCount > 0 ? 'var(--warning)' : 'var(--bg-inset)';
            const badgeColor = configuredCount === totalCount
                ? '#fff' : configuredCount > 0 ? '#000' : 'var(--text-muted)';
            const badge = `<span style="font-size:0.7rem;padding:0.1rem 0.4rem;border-radius:4px;background:${badgeBg};color:${badgeColor};margin-left:0.5rem">${configuredCount}/${totalCount}</span>`;

            const isGeneral = section.name === 'General';
            const renameBtn = !isGeneral
                ? `<span class="btn-icon" style="font-size:0.65rem;margin-left:0.25rem;cursor:pointer;opacity:0.5;" title="Rename section" onclick="event.stopPropagation(); renameSectionPrompt('${esc(section.name)}')">âœï¸</span>`
                : '';

            html += `
                <div class="section-title" style="cursor:pointer;user-select:none;display:flex;align-items:center;gap:0.35rem;"
                     onclick="toggleSecretSection('${catId}')">
                    <span id="secrets-chevron-${catId}" style="transition:transform 0.2s;display:inline-block;transform:rotate(${isCollapsed ? '0deg' : '90deg'});font-size:0.7rem;">â–¶</span>
                    <span>${esc(section.name)}</span>
                    ${badge}
                    ${renameBtn}
                </div>
                <div id="secrets-section-${catId}" style="display:${isCollapsed ? 'none' : 'block'};">`;

            for (const k of section.keys) {
                const kindIcon = k.kind === 'secret' ? 'ğŸ”‘' : 'âš™ï¸';
                const kindTitle = k.kind === 'secret' ? 'Secret' : 'Config';
                const isSecret = k.kind === 'secret';
                const inputType = isSecret ? 'password' : 'text';
                const currentValue = !isSecret && k.has_value ? (k.value || '') : '';
                const placeholder = k.has_value
                    ? (isSecret ? 'â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢' : (k.masked || 'Enter valueâ€¦'))
                    : 'Enter valueâ€¦';

                const tier = getSecretTier(k.key, k);
                const ghSet = ghSecrets.includes(k.key.toUpperCase());
                const varSet = ghVariables.includes(k.key.toUpperCase());

                // Local status column
                const localStatusHtml = `
                    <div title="Local (.env)">${k.has_value ? 'âœ…' : 'âŒ'} Local</div>
                    ${k.has_value ? `<button class="btn-icon" onclick="markForDeletion('${esc(k.key)}')" style="font-size:0.7rem;" title="Mark ${esc(k.key)} for deletion">ğŸ—‘ï¸</button>` : ''}
                `;

                // GitHub status column â€” derived from tier
                let ghColumn;
                const isOnGh = ghSet || varSet;
                const canDeleteGh = (tier === 'secret' && ghSet) || (tier === 'var' && varSet);
                const deleteKind = tier === 'var' ? 'variable' : 'secret';

                switch (tier) {
                    case 'auto':
                        ghColumn = `<div title="Auto-provided by GitHub Actions â€” cannot be overridden" style="color:var(--text-muted)">ğŸ”„ Auto</div>`;
                        break;
                    case 'local':
                        ghColumn = `
                            <div title="Local only â€” not pushed to GitHub" style="color:var(--text-muted)">ğŸ“ Local</div>
                            <button class="btn-icon" onclick="toggleLocalOnly('${esc(k.key)}', false)" style="font-size:0.65rem;" title="Enable GitHub sync for ${esc(k.key)}">â†—ï¸</button>
                        `;
                        break;
                    case 'secret':
                        ghColumn = `
                            <div title="GitHub Secret (gh secret set)">${ghSet ? 'âœ…' : 'âŒ'} Secret</div>
                            <button class="btn-icon" onclick="toggleLocalOnly('${esc(k.key)}', true)" style="font-size:0.65rem;" title="Make ${esc(k.key)} local-only">ğŸ“Œ</button>
                        `;
                        break;
                    case 'var':
                        ghColumn = `
                            <div title="GitHub Variable (gh variable set)">${varSet ? 'âœ…' : 'âŒ'} Variable</div>
                            <button class="btn-icon" onclick="toggleLocalOnly('${esc(k.key)}', true)" style="font-size:0.65rem;" title="Make ${esc(k.key)} local-only">ğŸ“Œ</button>
                        `;
                        break;
                }

                html += `
                    <div class="secret-config-row" data-key-name="${esc(k.key)}">
                        <div class="secret-config-name" translate="no">
                            <span class="env-key-kind" title="${kindTitle} â€” click to move section" style="cursor:pointer" onclick="showMoveKeyMenu(event, '${esc(k.key)}')">${kindIcon}</span>
                            ${esc(k.key)}
                        </div>
                        <div class="secret-config-value">
                            <input type="${inputType}"
                                   id="secret-${esc(k.key)}"
                                   data-secret-name="${esc(k.key)}"
                                   data-is-secret="${isSecret}"
                                   data-tier="${tier}"
                                   data-kind="${k.kind}"
                                   placeholder="${placeholder}"
                                   value="${esc(currentValue)}"
                                   autocomplete="off">
                        </div>
                        <div class="secret-config-status" style="text-align:center;font-size:0.8rem;display:flex;align-items:center;gap:0.25rem;justify-content:center;">
                            ${localStatusHtml}
                        </div>
                        <div class="secret-config-status" style="text-align:center;font-size:0.8rem;display:flex;align-items:center;gap:0.25rem;justify-content:center;">
                            ${ghColumn}
                            ${canDeleteGh ? `<button class="btn-icon" onclick="removeSecret('${esc(k.key)}','github','${deleteKind}')" style="font-size:0.7rem;" title="Remove ${esc(k.key)} from GitHub">ğŸ—‘ï¸</button>` : ''}
                        </div>
                    </div>`;
            }

            html += `</div>`;  // close collapsible section
        }

        // â”€â”€ Add Keys button â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        html += `
            <div style="margin-top:var(--space-lg);display:flex;justify-content:center;">
                <button class="btn btn-primary btn-sm" onclick="showAddKeysModal('add')">
                    + Add Keys
                </button>
            </div>`;

        // â”€â”€ Pending sync badge counts â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // Count pushable keys that are not yet on GitHub
        let pendingSecrets = 0, pendingVars = 0;
        for (const k of envKeys) {
            if (!k.has_value) continue;
            const t = getSecretTier(k.key, k);
            if (t === 'auto' || t === 'local') continue;
            if (t === 'secret' && !ghSecrets.includes(k.key.toUpperCase())) pendingSecrets++;
            if (t === 'var' && !ghVariables.includes(k.key.toUpperCase())) pendingVars++;
        }
        const totalPending = pendingSecrets + pendingVars;

        // â”€â”€ Save Section â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        html += `
            <div style="margin-top:1.5rem;padding-top:1rem;border-top:1px solid var(--border-subtle);">
                <div style="display:flex;align-items:center;gap:1rem;flex-wrap:wrap;">
                    <label style="color:var(--text-muted);">Save to:</label>
                    <div style="display:flex;border:1px solid var(--border);border-radius:8px;overflow:hidden;">
                        <button type="button" class="target-btn active" data-target="both" onclick="selectTarget('both')">Both</button>
                        <button type="button" class="target-btn" data-target="local" onclick="selectTarget('local')">Local Only</button>
                        <button type="button" class="target-btn" data-target="github" onclick="selectTarget('github')">GitHub Only</button>
                    </div>
                    <button class="btn btn-primary" id="save-secrets-btn" onclick="pushSecrets(currentTarget)" disabled>ğŸ’¾ Save & Push</button>
                    <span id="sync-pending-badge" style="font-size:0.8rem;color:var(--warning);${totalPending > 0 ? '' : 'display:none;'}"></span>
                </div>
            </div>`;

        // â”€â”€ Manage Section â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        html += `
            <div style="margin-top:1rem;padding-top:1rem;border-top:1px solid var(--border-subtle);">
                <div style="font-size:0.85rem;font-weight:600;color:var(--text-muted);margin-bottom:0.75rem;">ğŸ› ï¸ Manage</div>
                <div style="display:flex;gap:0.75rem;flex-wrap:wrap;">
                    <button class="btn btn-secondary btn-sm" onclick="syncEnvToGithub()" title="Force re-push all .env values to GitHub (secrets + variables)">â˜ï¸ Sync .env â†’ GitHub</button>
                    <button class="btn btn-secondary btn-sm" onclick="clearSecretsPrompt('local')" title="Clear all local .env secret values" style="color:var(--warning);">ğŸ—‘ï¸ Clear Local</button>
                    <button class="btn btn-secondary btn-sm" onclick="clearSecretsPrompt('github')" title="Remove all GitHub secrets" style="color:var(--error);">ğŸ—‘ï¸ Clear GitHub</button>
                </div>
            </div>`;

        container.innerHTML = html;

        // Re-render gh status alert now that the placeholder exists
        api('/gh/status').then(s => api('/gh/secrets').then(d => renderGhStatusAlert(s, d))).catch(() => { });

        // Snapshot initial values for dirty tracking
        secretsInitialValues = {};
        document.querySelectorAll('#secrets-form [data-secret-name]').forEach(el => {
            secretsInitialValues[el.dataset.secretName] = el.value;
        });
        secretsDirty = false;
        secretsLoaded = true;

        // Listen for changes
        document.getElementById('secrets-form').addEventListener('input', (e) => {
            if (e.target.dataset && e.target.dataset.secretName && e.target.dataset.markedDelete) {
                unmarkDeletion(e.target.dataset.secretName);
            }
            checkSecretsDirty();
        });
        document.getElementById('secrets-form').addEventListener('change', (e) => {
            if (e.target.dataset && e.target.dataset.secretName && e.target.dataset.markedDelete) {
                unmarkDeletion(e.target.dataset.secretName);
            }
            checkSecretsDirty();
        });

        checkSecretsDirty();
    }


    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  Target selector & dirty tracking
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    function selectTarget(target) {
        currentTarget = target;
        document.querySelectorAll('.target-btn').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.target === target);
        });
        const btn = document.getElementById('save-secrets-btn');
        if (btn) {
            const labels = { both: 'ğŸ’¾ Save & Push', local: 'ğŸ“ Save', github: 'â˜ï¸ Push' };
            btn.textContent = labels[target];
        }
    }

    function checkSecretsDirty() {
        const fields = document.querySelectorAll('#secrets-form [data-secret-name]');
        let changed = 0;
        let deletionCount = 0;
        let changedNames = [];

        fields.forEach(el => {
            const name = el.dataset.secretName;
            const isMarkedDelete = el.dataset.markedDelete === 'true';
            if (isMarkedDelete) {
                changed++;
                deletionCount++;
                changedNames.push(name);
            } else if (el.value !== (secretsInitialValues[name] ?? '')) {
                changed++;
                changedNames.push(name);
            }
        });

        // Also count unsynced secrets (local â†’ GitHub)
        let unsyncedSecrets = 0, unsyncedVars = 0;
        for (const k of envKeys) {
            if (!k.has_value) continue;
            const t = getSecretTier(k.key, k);
            if (t === 'auto' || t === 'local') continue;
            if (t === 'secret' && !ghSecrets.includes(k.key.toUpperCase())) unsyncedSecrets++;
            if (t === 'var' && !ghVariables.includes(k.key.toUpperCase())) unsyncedVars++;
        }

        const hasAnythingToDo = changed > 0 || unsyncedSecrets > 0 || unsyncedVars > 0;
        secretsDirty = changed > 0;

        const saveBtn = document.getElementById('save-secrets-btn');
        if (saveBtn) {
            saveBtn.disabled = !hasAnythingToDo;
            saveBtn.title = hasAnythingToDo
                ? `${changed} change(s) pending`
                : 'No changes to save';
        }

        // Pending badge
        const badge = document.getElementById('sync-pending-badge');
        if (badge) {
            const parts = [];
            if (unsyncedSecrets > 0) parts.push(`${unsyncedSecrets} secret(s) not on GitHub`);
            if (unsyncedVars > 0) parts.push(`${unsyncedVars} variable(s) not on GitHub`);
            if (deletionCount > 0) parts.push(`${deletionCount} marked for deletion`);
            const modified = changed - deletionCount;
            if (modified > 0) parts.push(`${modified} value(s) modified`);

            if (parts.length > 0) {
                badge.textContent = 'âš ï¸ ' + parts.join(' Â· ');
                badge.title = parts.join('\n');
                badge.style.display = '';
            } else {
                badge.style.display = 'none';
            }
        }
    }


    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  Section collapsing
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    function toggleSecretSection(catId) {
        const section = document.getElementById(`secrets-section-${catId}`);
        const chevron = document.getElementById(`secrets-chevron-${catId}`);
        if (!section) return;
        const isNowCollapsed = section.style.display !== 'none';
        section.style.display = isNowCollapsed ? 'none' : 'block';
        if (chevron) chevron.style.transform = isNowCollapsed ? 'rotate(0deg)' : 'rotate(90deg)';
        sessionStorage.setItem(`secrets-collapse-${catId}`, isNowCollapsed ? 'true' : 'false');
    }

    async function renameSectionPrompt(oldName) {
        const newName = prompt(`Rename section "${oldName}":`, oldName);
        if (!newName || !newName.trim() || newName.trim() === oldName) return;

        try {
            await api('/vault/rename-section', {
                method: 'POST',
                body: JSON.stringify({ old_name: oldName, new_name: newName.trim() }),
            });
            toast(`Section renamed: ${oldName} â†’ ${newName.trim()}`, 'success');
            secretsLoaded = false;
            await loadSecretsTab();
            selectTarget(currentTarget);
        } catch (e) {
            toast(`Failed to rename: ${e.message}`, 'error');
        }
    }


    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  Mark for deletion / undo
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    function markForDeletion(name) {
        const input = document.querySelector(`[data-secret-name="${name}"]`);
        if (!input) return;
        input.dataset.markedDelete = 'true';
        input.value = '';
        input.disabled = true;
        input.placeholder = 'ğŸ—‘ï¸ Will be deleted on Save';
        input.style.borderColor = 'var(--error)';
        input.style.opacity = '0.5';

        const row = input.closest('.secret-config-row');
        if (row) {
            const nameEl = row.querySelector('.secret-config-name');
            if (nameEl) nameEl.style.textDecoration = 'line-through';
            const localStatus = row.querySelectorAll('.secret-config-status')[0];
            if (localStatus) {
                localStatus.innerHTML = `
                    <div title="Marked for deletion" style="color:var(--error);">ğŸ—‘ï¸ Delete</div>
                    <button class="btn-icon" onclick="unmarkDeletion('${name}')" style="font-size:0.7rem;" title="Undo: keep ${name}">â†©ï¸</button>
                `;
            }
        }
        checkSecretsDirty();
    }

    function unmarkDeletion(name) {
        const input = document.querySelector(`[data-secret-name="${name}"]`);
        if (!input) return;
        delete input.dataset.markedDelete;
        input.disabled = false;
        input.style.borderColor = '';
        input.style.opacity = '';

        const isSecret = input.dataset.isSecret === 'true';
        const localSet = envData[name] && envData[name].length > 0;
        input.placeholder = localSet && isSecret ? 'â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢' : 'Enter valueâ€¦';
        if (!isSecret && localSet) input.value = envData[name];

        const row = input.closest('.secret-config-row');
        if (row) {
            const nameEl = row.querySelector('.secret-config-name');
            if (nameEl) nameEl.style.textDecoration = '';
            const localStatus = row.querySelectorAll('.secret-config-status')[0];
            if (localStatus) {
                localStatus.innerHTML = `
                    <div title="Local (.env)">${localSet ? 'âœ…' : 'âŒ'} Local</div>
                    ${localSet ? `<button class="btn-icon" onclick="markForDeletion('${name}')" style="font-size:0.7rem;" title="Mark ${name} for deletion">ğŸ—‘ï¸</button>` : ''}
                `;
            }
        }
        checkSecretsDirty();
    }


    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  Save & Push (orchestrator-style)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    async function pushSecrets(target = 'both') {
        const inputs = document.querySelectorAll('[data-secret-name]');

        // Collect changed values and deletions
        const secrets = {};
        const deletions = [];

        inputs.forEach(input => {
            const name = input.dataset.secretName;
            const initial = secretsInitialValues[name] ?? '';
            if (input.dataset.markedDelete === 'true') {
                deletions.push(name);
            } else if (input.value && input.value !== initial) {
                secrets[name] = input.value;
            }
        });

        // When target is 'both', also include pushable keys missing from GitHub
        // For secret-type keys, envData won't have the raw value â€” send null
        // to signal the backend to read it from .env directly.
        const syncKeys = [];
        if (target === 'both') {
            for (const k of envKeys) {
                if (!k.has_value) continue;
                if (secrets[k.key] || deletions.includes(k.key)) continue;
                const t = getSecretTier(k.key, k);
                if (t === 'auto' || t === 'local') continue;
                const missingFromGh = (t === 'secret' && !ghSecrets.includes(k.key.toUpperCase()))
                    || (t === 'var' && !ghVariables.includes(k.key.toUpperCase()));
                if (missingFromGh) {
                    if (envData[k.key]) {
                        secrets[k.key] = envData[k.key];
                    } else {
                        // Secret-type key â€” raw value not available in frontend
                        syncKeys.push(k.key);
                    }
                }
            }
        }

        if (Object.keys(secrets).length === 0 && deletions.length === 0 && syncKeys.length === 0) return;

        // Split into gh secrets vs gh variables based on per-key tier
        const ghPush = target === 'both' || target === 'github';
        const secretsForGh = {};
        const variablesForGh = {};
        if (ghPush) {
            for (const [name, val] of Object.entries(secrets)) {
                const t = getSecretTier(name);
                if (t === 'auto' || t === 'local') continue;
                if (t === 'secret') {
                    secretsForGh[name] = val;
                } else if (t === 'var') {
                    variablesForGh[name] = val;
                }
            }
        }

        const output = document.getElementById('secrets-output');
        const terminal = document.getElementById('secrets-terminal');
        const actionCount = Object.keys(secrets).length + deletions.length + syncKeys.length;
        const targetLabel = target === 'both' ? 'local & GitHub' : target;

        output.style.display = 'block';
        terminal.className = 'terminal';
        terminal.textContent = `Saving ${actionCount} change(s) to ${targetLabel}â€¦\n`;

        // Loading state
        for (const name of [...Object.keys(secrets), ...deletions, ...syncKeys]) {
            const row = document.querySelector(`[data-key-name="${name}"]`);
            if (row) { row.style.opacity = '0.5'; row.style.pointerEvents = 'none'; }
        }

        try {
            const response = await api('/secrets/push', {
                method: 'POST',
                body: JSON.stringify({
                    secrets: secretsForGh,
                    variables: variablesForGh,
                    env_values: (target === 'both' || target === 'local') ? secrets : {},
                    deletions: (target === 'both' || target === 'local') ? deletions : [],
                    sync_keys: syncKeys,
                    push_to_github: ghPush,
                    save_to_env: target === 'both' || target === 'local',
                    exclude_from_github: AUTO_PROVIDED,
                }),
            });

            if (response.error) {
                terminal.className = 'terminal error';
                terminal.textContent = `âŒ Error: ${response.error}\n`;
                return;
            }

            let text = '';

            // Show env save status
            if (response.env_saved) {
                const savedKeys = Object.keys(secrets);
                if (savedKeys.length > 0) text += `ğŸ“ Saved to .env: ${savedKeys.join(', ')}\n`;
                if (response.deletions_applied && response.deletions_applied.length > 0) {
                    text += `ğŸ—‘ï¸ Deleted from .env: ${response.deletions_applied.join(', ')}\n`;
                }
            }

            // Show GitHub push results
            for (const r of (response.results || [])) {
                const icon = r.kind === 'variable' ? 'ğŸ“‹' : 'â˜ï¸';
                const label = r.kind === 'variable' ? 'variable' : 'secret';
                if (r.success) {
                    text += `${icon} ${r.name}: pushed as GitHub ${label}\n`;
                } else {
                    text += `âŒ ${r.name}: ${r.error}\n`;
                }
            }

            terminal.textContent = text || 'Done!';
            terminal.className = response.all_success !== false ? 'terminal' : 'terminal error';

            // Smooth refresh
            if (response.all_success !== false) {
                // Buffer push results for optimistic gh column update
                _recentPushResults = response.results || [];

                const formEl = document.getElementById('secrets-form');
                formEl.style.position = 'relative';
                const overlay = document.createElement('div');
                overlay.id = 'secrets-loading-overlay';
                overlay.style.cssText = 'position:absolute;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.4);display:flex;align-items:center;justify-content:center;border-radius:8px;z-index:10;';
                overlay.innerHTML = '<div style="color:#fff;font-size:1rem;">ğŸ”„ Refreshingâ€¦</div>';
                formEl.appendChild(overlay);

                secretsLoaded = false;
                await loadSecretsTab();
                selectTarget(currentTarget);
            }
        } catch (error) {
            terminal.className = 'terminal error';
            terminal.textContent = `âŒ Error: ${error.message}`;
        }
    }


    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  Sync .env â†’ GitHub
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    async function syncEnvToGithub() {
        if (!envData || Object.keys(envData).length === 0) {
            toast('No local .env values found.', 'error');
            return;
        }

        // Collect all pushable keys, split by kind â†’ secret vs variable
        const secrets = {};
        const variables = {};
        for (const k of envKeys) {
            if (!k.has_value) continue;
            const t = getSecretTier(k.key, k);
            if (t === 'auto' || t === 'local') continue;
            const val = envData[k.key];
            if (!val) continue;
            if (t === 'secret') secrets[k.key] = val;
            else if (t === 'var') variables[k.key] = val;
        }

        const totalCount = Object.keys(secrets).length + Object.keys(variables).length;
        if (totalCount === 0) {
            toast('No pushable secrets/variables found. All keys may be flagged as local-only or auto-provided.', 'warning');
            return;
        }

        if (!confirm(`Push ${totalCount} value(s) from .env â†’ GitHub?\n\nThis will overwrite existing GitHub values.`)) return;

        const output = document.getElementById('secrets-output');
        const terminal = document.getElementById('secrets-terminal');
        output.style.display = 'block';
        terminal.className = 'terminal';
        terminal.textContent = `â˜ï¸ Syncing ${totalCount} value(s) from .env â†’ GitHubâ€¦\n`;

        try {
            const data = await api('/secrets/push', {
                method: 'POST',
                body: JSON.stringify({
                    secrets,
                    variables,
                    push_to_github: true,
                    save_to_env: false,
                }),
            });

            if (data.error) {
                terminal.className = 'terminal error';
                terminal.textContent = `âŒ ${data.error}\n`;
                return;
            }

            let text = '', ok = 0, fail = 0;
            for (const r of (data.results || [])) {
                const icon = r.kind === 'variable' ? 'ğŸ“‹' : 'â˜ï¸';
                if (r.success) { text += `${icon} ${r.name}\n`; ok++; }
                else { text += `âŒ ${r.name}: ${r.error}\n`; fail++; }
            }
            terminal.textContent = `â˜ï¸ Sync complete: ${ok} pushed${fail ? `, ${fail} failed` : ''}\n\n${text}`;
            terminal.className = fail ? 'terminal error' : 'terminal';

            _recentPushResults = data.results || [];
            secretsLoaded = false;
            await loadSecretsTab();
            selectTarget(currentTarget);
        } catch (error) {
            terminal.className = 'terminal error';
            terminal.textContent = `âŒ Error: ${error.message}`;
        }
    }


    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  Remove single secret from GitHub
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    async function removeSecret(name, target, kind = 'secret') {
        const label = target === 'local' ? 'local .env' : target === 'github' ? 'GitHub' : 'local & GitHub';
        if (!confirm(`Remove ${name} from ${label}?\n\nThis cannot be undone.`)) return;

        const rowInput = document.querySelector(`[data-secret-name="${name}"]`);
        if (rowInput) {
            const rowEl = rowInput.closest('.secret-config-row');
            if (rowEl) { rowEl.style.opacity = '0.5'; rowEl.style.pointerEvents = 'none'; }
        }

        const output = document.getElementById('secrets-output');
        const terminal = document.getElementById('secrets-terminal');
        output.style.display = 'block';
        terminal.className = 'terminal';
        terminal.textContent = `ğŸ—‘ï¸ Removing ${name} from ${label}â€¦\n`;

        try {
            const data = await api('/secret/remove', {
                method: 'POST',
                body: JSON.stringify({ name, target, kind }),
            });

            let text = `ğŸ—‘ï¸ ${name}:\n`;
            if (data.local) text += `  Local: ${data.local.success ? 'âœ… removed' : 'âŒ ' + data.local.error}\n`;
            if (data.github) text += `  GitHub: ${data.github.success ? 'âœ… removed' : 'âŒ ' + data.github.error}\n`;
            terminal.textContent = text;

            secretsLoaded = false;
            await loadSecretsTab();
            selectTarget(currentTarget);
        } catch (error) {
            terminal.className = 'terminal error';
            terminal.textContent = `âŒ Error: ${error.message}`;
        }
    }


    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  Clear all secrets
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    async function clearSecretsPrompt(target) {
        const label = target === 'local' ? 'local .env' : 'GitHub';

        let secretsToRemove;
        if (target === 'local') {
            secretsToRemove = Object.keys(envData)
                .filter(n => envData[n] && !AUTO_PROVIDED.includes(n))
                .map(n => ({ name: n, kind: 'secret' }));
        } else {
            // Include both GitHub secrets AND variables
            const items = [];
            for (const n of ghSecrets) {
                if (!AUTO_PROVIDED.includes(n)) items.push({ name: n, kind: 'secret' });
            }
            for (const n of ghVariables) {
                if (!AUTO_PROVIDED.includes(n)) items.push({ name: n, kind: 'variable' });
            }
            secretsToRemove = items;
        }

        if (secretsToRemove.length === 0) {
            toast(`No secrets to clear from ${label}.`, 'warning');
            return;
        }

        const names = secretsToRemove.map(s => s.name);
        if (!confirm(`âš ï¸ DANGER: Remove ${secretsToRemove.length} items from ${label}?\n\n${names.join(', ')}\n\nThis cannot be undone!`)) return;
        if (!confirm(`Are you absolutely sure? This will delete all secret values from ${label}.`)) return;

        const output = document.getElementById('secrets-output');
        const terminal = document.getElementById('secrets-terminal');
        output.style.display = 'block';
        terminal.className = 'terminal';
        terminal.textContent = `ğŸ—‘ï¸ Clearing ${secretsToRemove.length} items from ${label}â€¦\n`;

        let ok = 0, fail = 0;
        for (const item of secretsToRemove) {
            try {
                const data = await api('/secret/remove', {
                    method: 'POST',
                    body: JSON.stringify({ name: item.name, target, kind: item.kind }),
                });
                const result = target === 'local' ? data.local : data.github;
                if (result?.success) { terminal.textContent += `âœ… ${item.name}\n`; ok++; }
                else { terminal.textContent += `âŒ ${item.name}: ${result?.error || 'unknown'}\n`; fail++; }
            } catch (e) {
                terminal.textContent += `âŒ ${item.name}: ${e.message}\n`;
                fail++;
            }
        }

        terminal.textContent += `\nğŸ—‘ï¸ Done: ${ok} removed${fail ? `, ${fail} failed` : ''}`;
        terminal.className = fail ? 'terminal error' : 'terminal';

        secretsLoaded = false;
        await loadSecretsTab();
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  Toggle local-only flag
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    async function toggleLocalOnly(name, localOnly) {
        const action = localOnly ? 'flag as local-only' : 'enable GitHub sync for';
        try {
            await api('/vault/toggle-local-only', {
                method: 'POST',
                body: JSON.stringify({ key: name, local_only: localOnly }),
            });
            toast(`${name}: ${localOnly ? 'flagged as local-only' : 'GitHub sync enabled'}`, 'success');
            secretsLoaded = false;
            await loadSecretsTab();
            selectTarget(currentTarget);
        } catch (e) {
            toast(`Failed to ${action} ${name}: ${e.message}`, 'error');
        }
    }


    function refreshSecrets() {
        if (secretsDirty) {
            if (!confirm('You have unsaved secret changes. Refresh anyway?')) return;
        }
        document.getElementById('secrets-form').innerHTML = '<div class="loading">Loading secretsâ€¦</div>';
        secretsLoaded = false;
        loadSecretsTab();
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  Move key between sections
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    function showMoveKeyMenu(event, keyName) {
        event.stopPropagation();

        // Remove any existing menu
        const existing = document.getElementById('move-key-menu');
        if (existing) existing.remove();

        const menu = document.createElement('div');
        menu.id = 'move-key-menu';
        menu.style.cssText = `position:fixed;z-index:1000;background:var(--surface);border:1px solid var(--border);border-radius:6px;box-shadow:0 4px 16px rgba(0,0,0,0.4);padding:var(--space-xs) 0;min-width:180px;max-height:260px;overflow-y:auto;font-size:0.85rem;`;

        const rect = event.target.getBoundingClientRect();
        menu.style.left = rect.left + 'px';
        menu.style.top = (rect.bottom + 4) + 'px';

        let items = '';
        for (const s of envSections) {
            items += `<div class="move-key-item" style="padding:0.35rem 0.75rem;cursor:pointer;white-space:nowrap;" onmouseenter="this.style.background='var(--hover)'" onmouseleave="this.style.background=''" onclick="moveKeyToSection('${esc(keyName)}', '${esc(s)}')">${esc(s)}</div>`;
        }
        items += `<div style="border-top:1px solid var(--border);margin:0.2rem 0"></div>`;
        items += `<div class="move-key-item" style="padding:0.35rem 0.75rem;cursor:pointer;color:var(--primary);white-space:nowrap;" onmouseenter="this.style.background='var(--hover)'" onmouseleave="this.style.background=''" onclick="moveKeyNewSection('${esc(keyName)}')">+ New sectionâ€¦</div>`;

        menu.innerHTML = items;
        document.body.appendChild(menu);

        // Close on click outside
        const closeMenu = (e) => {
            if (!menu.contains(e.target)) {
                menu.remove();
                document.removeEventListener('click', closeMenu);
            }
        };
        setTimeout(() => document.addEventListener('click', closeMenu), 0);
    }

    async function moveKeyToSection(keyName, section) {
        const menu = document.getElementById('move-key-menu');
        if (menu) menu.remove();

        try {
            await api('/vault/move-key', {
                method: 'POST',
                body: JSON.stringify({ key: keyName, section }),
            });
            toast(`${keyName} â†’ ${section}`, 'success');
            secretsLoaded = false;
            await loadSecretsTab();
            selectTarget(currentTarget);
        } catch (e) {
            toast(`Failed to move ${keyName}: ${e.message}`, 'error');
        }
    }

    function moveKeyNewSection(keyName) {
        const menu = document.getElementById('move-key-menu');
        if (menu) menu.remove();

        const name = prompt('New section name:');
        if (name && name.trim()) {
            moveKeyToSection(keyName, name.trim());
        }
    }


    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  Add / Create keys modal
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    let _addKeysMode = 'create';

    function showAddKeysModal(mode) {
        _addKeysMode = mode;
        const isCreate = mode === 'create';
        const title = isCreate ? 'âœ¨ Create .env File' : 'âœ¨ Add Keys to .env';
        const desc = isCreate
            ? 'Add your environment variables below. You can lock it with the vault afterwards.'
            : 'Add new key-value pairs to your existing .env file.';
        const btnLabel = isCreate ? 'Create' : 'Add Keys';

        // Build section options
        let sectionOptions = '<option value="">â€” append to end â€”</option>';
        for (const s of envSections) {
            sectionOptions += `<option value="${esc(s)}">${esc(s)}</option>`;
        }
        sectionOptions += '<option value="__new__">+ Create new sectionâ€¦</option>';

        const sectionSelector = !isCreate ? `
            <div class="form-group" style="margin-bottom:var(--space-md)">
                <label for="env-section-select">Section</label>
                <select id="env-section-select" style="width:100%" onchange="onSectionSelectChange(this)">
                    ${sectionOptions}
                </select>
                <input type="text" id="env-section-new" placeholder="New section nameâ€¦"
                    style="display:none;margin-top:var(--space-xs)" autocomplete="off">
            </div>` : '';

        const modal = document.createElement('div');
        modal.className = 'vault-modal-overlay';
        modal.id = 'vault-modal';
        modal.innerHTML = `
        <div class="vault-modal" style="max-width:520px">
            <h2 style="margin-bottom:var(--space-md)">${title}</h2>
            <p style="color:var(--text-secondary);margin-bottom:var(--space-lg);font-size:0.88rem;line-height:1.5">
                ${desc}
            </p>
            ${sectionSelector}
            <div id="env-entries">
                <div class="env-entry-row">
                    <input type="text" class="env-entry-key" placeholder="KEY" autocomplete="off">
                    <input type="text" class="env-entry-value" placeholder="value" autocomplete="off">
                    <button class="btn-icon" onclick="removeEnvEntry(this)" title="Remove">âœ•</button>
                </div>
            </div>
            <button class="btn btn-ghost" onclick="addEnvEntry()" style="margin-top:var(--space-sm);font-size:0.82rem">
                + Add another
            </button>
            <div id="vault-modal-error" style="color:var(--error);font-size:0.82rem;margin-top:var(--space-sm);display:none"></div>
            <div style="display:flex;gap:var(--space-sm);justify-content:flex-end;margin-top:var(--space-lg)">
                <button class="btn btn-secondary" onclick="closeVaultModal()">Cancel</button>
                <button class="btn btn-primary" id="vault-modal-btn" onclick="doAddKeys()">${btnLabel}</button>
            </div>
        </div>`;
        document.body.appendChild(modal);
        modal.querySelector('.env-entry-key').focus();
    }

    function onSectionSelectChange(sel) {
        const newInput = document.getElementById('env-section-new');
        if (sel.value === '__new__') {
            newInput.style.display = 'block';
            newInput.focus();
        } else {
            newInput.style.display = 'none';
        }
    }

    function addEnvEntry() {
        const container = document.getElementById('env-entries');
        const row = document.createElement('div');
        row.className = 'env-entry-row';
        row.innerHTML = `
        <input type="text" class="env-entry-key" placeholder="KEY" autocomplete="off">
        <input type="text" class="env-entry-value" placeholder="value" autocomplete="off">
        <button class="btn-icon" onclick="removeEnvEntry(this)" title="Remove">âœ•</button>`;
        container.appendChild(row);
        row.querySelector('.env-entry-key').focus();
    }

    function removeEnvEntry(btn) {
        const row = btn.closest('.env-entry-row');
        const container = document.getElementById('env-entries');
        if (container.children.length > 1) { row.remove(); }
        else { row.querySelectorAll('input').forEach(i => i.value = ''); }
    }

    async function doAddKeys() {
        const rows = document.querySelectorAll('.env-entry-row');
        const entries = [];
        rows.forEach(row => {
            const key = row.querySelector('.env-entry-key').value.trim();
            const value = row.querySelector('.env-entry-value').value.trim();
            if (key) entries.push({ key, value });
        });

        const btn = document.getElementById('vault-modal-btn');
        const errEl = document.getElementById('vault-modal-error');

        if (!entries.length) {
            errEl.textContent = 'Add at least one key';
            errEl.style.display = 'block';
            return;
        }

        // Resolve section
        let section = '';
        const sectionSel = document.getElementById('env-section-select');
        if (sectionSel) {
            if (sectionSel.value === '__new__') {
                section = (document.getElementById('env-section-new')?.value || '').trim();
                if (!section) {
                    errEl.textContent = 'Enter a name for the new section';
                    errEl.style.display = 'block';
                    return;
                }
            } else {
                section = sectionSel.value;
            }
        }

        btn.disabled = true;
        btn.textContent = _addKeysMode === 'create' ? 'Creatingâ€¦' : 'Addingâ€¦';

        const endpoint = _addKeysMode === 'create' ? '/vault/create' : '/vault/add-keys';
        const successMsg = _addKeysMode === 'create'
            ? `.env created with ${entries.length} keys`
            : `${entries.length} key(s) added to .env`;

        const body = { entries };
        if (section) body.section = section;

        try {
            await api(endpoint, { method: 'POST', body: JSON.stringify(body) });
            closeVaultModal();
            toast(successMsg, 'success');
            await loadSecretsTab();
        } catch (e) {
            errEl.textContent = e.message;
            errEl.style.display = 'block';
        } finally {
            btn.disabled = false;
            btn.textContent = _addKeysMode === 'create' ? 'Create' : 'Add Keys';
        }
    }

    async function createEnvFromTemplate() {
        try {
            await api('/vault/create', { method: 'POST', body: JSON.stringify({ entries: [] }) });
            toast('.env created from template', 'success');
            await loadSecretsTab();
        } catch (e) { toast(e.message, 'error'); }
    }


    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  Vault lock/unlock modals
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    function showVaultLockModal() {
        const modal = document.createElement('div');
        modal.className = 'vault-modal-overlay';
        modal.id = 'vault-modal';
        modal.innerHTML = `
        <div class="vault-modal">
            <h2 style="margin-bottom:var(--space-md)">ğŸ”’ Lock Vault</h2>
            <p style="color:var(--text-secondary);margin-bottom:var(--space-sm);font-size:0.88rem;line-height:1.5">
                Your <code>.env</code> will be encrypted with AES-256-GCM and the plaintext securely deleted.
            </p>
            <p style="color:var(--warning);margin-bottom:var(--space-lg);font-size:0.82rem;line-height:1.4;font-weight:600">
                âš ï¸ Your passphrase is the ONLY way to recover your secrets. If you lose it, your data is gone.
            </p>
            <div class="form-group" style="margin-bottom:var(--space-md)">
                <label for="vault-passphrase">Passphrase (min 4 characters)</label>
                <input type="password" id="vault-passphrase" placeholder="Enter passphraseâ€¦"
                    autocomplete="off">
            </div>
            <div class="form-group" style="margin-bottom:var(--space-md)">
                <label for="vault-passphrase-confirm">Confirm passphrase</label>
                <input type="password" id="vault-passphrase-confirm" placeholder="Re-enter passphraseâ€¦"
                    autocomplete="off" onkeydown="if(event.key==='Enter') vaultDoLock()">
            </div>
            <div id="vault-modal-error" style="color:var(--error);font-size:0.82rem;margin-bottom:var(--space-sm);display:none"></div>
            <div style="display:flex;gap:var(--space-sm);justify-content:flex-end">
                <button class="btn btn-secondary" onclick="closeVaultModal()">Cancel</button>
                <button class="btn btn-primary" id="vault-modal-btn" onclick="vaultDoLock()">ğŸ”’ Lock</button>
            </div>
        </div>`;
        document.body.appendChild(modal);
        document.getElementById('vault-passphrase').focus();
    }

    function showVaultUnlockModal() {
        const modal = document.createElement('div');
        modal.className = 'vault-modal-overlay';
        modal.id = 'vault-modal';
        modal.innerHTML = `
        <div class="vault-modal">
            <h2 style="margin-bottom:var(--space-md)">ğŸ”“ Unlock Vault</h2>
            <p style="color:var(--text-secondary);margin-bottom:var(--space-lg);font-size:0.88rem;line-height:1.5">
                Decrypt your <code>.env.vault</code> back to plaintext. Auto-lock will re-encrypt after inactivity.
            </p>
            <div class="form-group" style="margin-bottom:var(--space-md)">
                <label for="vault-passphrase">Passphrase</label>
                <input type="password" id="vault-passphrase" placeholder="Enter passphraseâ€¦"
                    autocomplete="off" onkeydown="if(event.key==='Enter') vaultDoUnlock()">
            </div>
            <div id="vault-modal-error" style="color:var(--error);font-size:0.82rem;margin-bottom:var(--space-sm);display:none"></div>
            <div style="display:flex;gap:var(--space-sm);justify-content:flex-end">
                <button class="btn btn-secondary" onclick="closeVaultModal()">Cancel</button>
                <button class="btn btn-primary" id="vault-modal-btn" onclick="vaultDoUnlock()">ğŸ”“ Unlock</button>
            </div>
        </div>`;
        document.body.appendChild(modal);
        document.getElementById('vault-passphrase').focus();
    }

    function closeVaultModal() {
        const modal = document.getElementById('vault-modal');
        if (modal) modal.remove();
    }

    async function vaultDoLock() {
        const passphrase = document.getElementById('vault-passphrase').value;
        const confirm_pass = document.getElementById('vault-passphrase-confirm').value;
        const errEl = document.getElementById('vault-modal-error');
        const btn = document.getElementById('vault-modal-btn');

        if (!passphrase || passphrase.length < 4) {
            errEl.textContent = 'Passphrase must be at least 4 characters';
            errEl.style.display = 'block';
            return;
        }

        if (passphrase !== confirm_pass) {
            errEl.textContent = 'Passphrases do not match â€” please re-enter';
            errEl.style.display = 'block';
            document.getElementById('vault-passphrase-confirm').value = '';
            document.getElementById('vault-passphrase-confirm').focus();
            return;
        }

        btn.disabled = true;
        btn.innerHTML = '<span class="spinner"></span> Lockingâ€¦';

        try {
            await api('/vault/lock', { method: 'POST', body: JSON.stringify({ passphrase }) });
            closeVaultModal();
            toast('Vault locked â€” secrets encrypted', 'success');
            await loadSecretsTab();
        } catch (e) {
            errEl.textContent = e.message;
            errEl.style.display = 'block';
        } finally {
            btn.disabled = false;
            btn.textContent = 'ğŸ”’ Lock';
        }
    }

    async function vaultDoUnlock() {
        const passphrase = document.getElementById('vault-passphrase').value;
        const errEl = document.getElementById('vault-modal-error');
        const btn = document.getElementById('vault-modal-btn');

        if (!passphrase) {
            errEl.textContent = 'Enter your passphrase';
            errEl.style.display = 'block';
            return;
        }

        btn.disabled = true;
        btn.innerHTML = '<span class="spinner"></span> Unlockingâ€¦';

        try {
            await api('/vault/unlock', { method: 'POST', body: JSON.stringify({ passphrase }) });
            closeVaultModal();
            toast('Vault unlocked â€” secrets decrypted', 'success');
            await loadSecretsTab();
        } catch (e) {
            errEl.textContent = e.message;
            errEl.style.display = 'block';
        } finally {
            btn.disabled = false;
            btn.textContent = 'ğŸ”“ Unlock';
        }
    }
</script>
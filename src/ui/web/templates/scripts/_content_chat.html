// ─────────────────────────────────────────────────────────────────
// _content_chat.html
// Content Vault — Chat Panel (Threads + Messages + Compose)
// Included by: _content.html (Jinja2 include)
// ─────────────────────────────────────────────────────────────────

function _chatCleanup() {
  const popup = document.getElementById('chat-ref-popup');
  if (popup) popup.style.display = 'none';
  // Stop auto-poll and idle tracking when leaving chat view
  _chatStopPoll();
  _chatStopIdleTracker();
}

let _chatPollTimer = null;
const _CHAT_POLL_BASE = 5000;     // 5s when active
const _CHAT_POLL_MAX  = 60000;    // 60s max when idle
let _chatPollInterval = _CHAT_POLL_BASE;
let _chatLastActivity = Date.now();
let _chatIdleTimer = null;

function _chatOnActivity() {
  _chatLastActivity = Date.now();
  // If interval was degraded, reset to base and restart
  if (_chatPollInterval > _CHAT_POLL_BASE) {
    _chatPollInterval = _CHAT_POLL_BASE;
    if (_chatPollTimer) {
      _chatStopPoll();
      _chatStartPoll();
    }
  }
}

function _chatStartIdleTracker() {
  _chatStopIdleTracker();
  // Listen for user activity on the document
  document.addEventListener('mousemove', _chatOnActivity);
  document.addEventListener('keydown', _chatOnActivity);
  document.addEventListener('click', _chatOnActivity);
  document.addEventListener('scroll', _chatOnActivity);
  // Check idle every 30s — double the interval if no activity
  _chatIdleTimer = setInterval(() => {
    const idleMs = Date.now() - _chatLastActivity;
    if (idleMs > 30000 && _chatPollInterval < _CHAT_POLL_MAX) {
      _chatPollInterval = Math.min(_chatPollInterval * 2, _CHAT_POLL_MAX);
      console.debug('[chat-poll] idle ' + Math.round(idleMs/1000) + 's — interval now ' + (_chatPollInterval/1000) + 's');
      // Restart with new interval
      if (_chatPollTimer) {
        _chatStopPoll();
        _chatStartPoll();
      }
    }
  }, 30000);
}

function _chatStopIdleTracker() {
  document.removeEventListener('mousemove', _chatOnActivity);
  document.removeEventListener('keydown', _chatOnActivity);
  document.removeEventListener('click', _chatOnActivity);
  document.removeEventListener('scroll', _chatOnActivity);
  if (_chatIdleTimer) {
    clearInterval(_chatIdleTimer);
    _chatIdleTimer = null;
  }
}

let _chatPollCycles = 0;

function _chatStartPoll() {
  _chatStopPoll();
  _chatLastActivity = Date.now();
  _chatPollCycles = 0;
  _chatStartIdleTracker();
  _chatPollTimer = setInterval(async () => {
    if (!_chatSelectedThread) return;
    _chatPollCycles++;
    try {
      // Single combined request: sync + threads + messages
      const poll = await apiPost('/chat/poll', {
        thread_id: _chatSelectedThread,
        n: 100,
      });

      // Update thread list
      if (poll.threads) {
        _chatThreads = poll.threads;
        _chatLoaded = true;
        chatRenderThreadList(_chatThreads);
      }

      // Update messages (only re-render if changed)
      const newMsgs = poll.messages || [];
      if (newMsgs.length !== _chatMessages.length ||
          (newMsgs.length > 0 && _chatMessages.length > 0 &&
           newMsgs[newMsgs.length - 1].id !== _chatMessages[_chatMessages.length - 1].id)) {
        _chatMessages = newMsgs;
        chatRenderMessages();
      }
    } catch (e) {
      console.debug('[chat-poll] error:', e.message);
    }
  }, _chatPollInterval);
}

function _chatStopPoll() {
  if (_chatPollTimer) {
    clearInterval(_chatPollTimer);
    _chatPollTimer = null;
  }
}

// ═══════════════════════════════════════════════════════════════
// Feature 1 — Panel Layout (renderChatPanel)
// ═══════════════════════════════════════════════════════════════

async function renderChatPanel() {
  const browser = document.getElementById('content-chat-panel');

  browser.innerHTML = `
<div class="chat-panel">

    <!-- LEFT: Thread sidebar card -->
    <div class="chat-sidebar-card">
        <div class="chat-sidebar-header">
            <span class="chat-sidebar-title">Threads</span>
            <div class="chat-sidebar-actions">
                <button class="btn btn-primary btn-sm" onclick="chatShowNewThread()" title="New thread">+ New</button>
                <button class="btn btn-secondary btn-sm" onclick="chatSync('both')"
                    title="Reconnect &amp; restart sync">&#x1F504;</button>
            </div>
        </div>
        <input type="text" id="chat-thread-search" class="chat-search-input"
            placeholder="Search threads..."
            oninput="chatFilterThreads(this.value)">
        <div id="chat-thread-list" class="chat-thread-list">
            <div class="chat-empty"><span class="spinner"></span></div>
        </div>
    </div>

    <!-- RIGHT: Conversation area -->
    <div class="chat-conversation">
        <div id="chat-thread-header" class="chat-conv-header">
            <p class="chat-empty-sub" style="padding:1rem;text-align:center;color:var(--text-muted)">
                Select a thread to begin</p>
        </div>

        <!-- Source filter bar -->
        <div class="chat-filter-bar">
            <div class="chat-filters">
                <button class="chat-source-filter active" data-source="all"
                    onclick="chatFilterBySource('all')">All</button>
                <button class="chat-source-filter" data-source="manual"
                    onclick="chatFilterBySource('manual')">&#x1F464; Manual</button>
                <button class="chat-source-filter" data-source="trace"
                    onclick="chatFilterBySource('trace')">&#x1F4CB; Trace</button>
                <button class="chat-source-filter" data-source="system"
                    onclick="chatFilterBySource('system')">&#x2699;&#xFE0F; System</button>
            </div>
            <button class="btn btn-sm chat-sort-btn" onclick="chatToggleSort()"
                title="Toggle sort order">
                <span id="chat-sort-icon">&#x2B07;</span> Newest first
            </button>
        </div>

        <!-- Messages -->
        <div id="chat-messages" class="chat-messages">
            <div class="chat-empty">
                <span class="chat-empty-icon">&#x1F4AD;</span>
                <p>Select a thread to view messages</p>
            </div>
        </div>

        <!-- Compose area -->
        <div class="chat-compose">
            <div class="chat-compose-wrap">
                <textarea id="chat-compose-input" class="chat-textarea" rows="2"
                    placeholder="Type a message... Use @ for references"
                    oninput="chatOnInput(this)"
                    onkeydown="chatOnKeydown(event)"></textarea>
                <div id="chat-ref-popup" class="chat-ref-popup"></div>
            </div>
            <div class="chat-compose-footer">
                <label class="chat-encrypt-label">
                    <input type="checkbox" id="chat-encrypt-cb" onchange="chatToggleEncryptHint(this.checked)"> &#x1F512; Encrypt
                </label>
                <label class="chat-encrypt-label" style="margin-left:0.75rem"
                    title="Published messages can be rendered on GitHub Pages and other public-facing features">
                    <input type="checkbox" id="chat-publish-cb"> &#x1F310; Publish
                </label>
                <span style="flex:1"></span>
                <span id="chat-compose-status" class="chat-compose-status"></span>
                <button class="btn btn-primary btn-sm chat-send-btn"
                    onclick="chatSendMessage()" id="chat-send-btn">Send &#x2192;</button>
            </div>
        </div>

    </div>
</div>

<!-- New thread modal -->
<div id="chat-new-thread-modal" class="chat-modal-overlay">
    <div class="chat-modal">
        <h3>&#x1F4AC; New Thread</h3>
        <div class="form-group">
            <label>Title</label>
            <input type="text" id="chat-new-thread-title" placeholder="Thread title">
        </div>
        <div class="form-group">
            <label>Tags (comma-separated)</label>
            <input type="text" id="chat-new-thread-tags" placeholder="deploy, staging">
        </div>
        <div class="chat-modal-actions">
            <button class="btn btn-secondary btn-sm" onclick="chatCloseNewThread()">Cancel</button>
            <button class="btn btn-primary btn-sm" onclick="chatCreateThread()">Create Thread</button>
        </div>
    </div>
</div>
`;

  await chatLoadThreads();
}


// ═══════════════════════════════════════════════════════════════
// Feature 2 — Thread List
// ═══════════════════════════════════════════════════════════════

async function chatLoadThreads() {
  const list = document.getElementById('chat-thread-list');
  if (!list) return;
  var isInitialLoad = !_chatLoaded;
  try {
    const data = await api('/chat/threads');
    _chatThreads = data.threads || [];
    _chatLoaded = true;
    chatRenderThreadList(_chatThreads);

    // On initial load, select a thread (and start polling)
    if (isInitialLoad) {
      if (_chatSelectedThread) {
        // Thread pre-selected from URL hash — load it
        chatSelectThread(_chatSelectedThread);
      } else if (_chatThreads.length > 0) {
        // Auto-select General or first thread
        let gen = null;
        for (let i = 0; i < _chatThreads.length; i++) {
          if (_chatThreads[i].title === 'General') { gen = _chatThreads[i]; break; }
        }
        chatSelectThread(gen ? gen.thread_id : _chatThreads[0].thread_id);
      }
    }
    // On subsequent refreshes (auto-poll), just re-render the list — no re-selection
  } catch (e) {
    // Only show error state on initial load, not during poll refreshes
    if (!_chatLoaded) {
      list.innerHTML = `<div class="chat-empty">
        <span class="chat-empty-icon">&#x1F4AD;</span>
        <p>No chat threads yet</p>
        <p class="chat-empty-sub">${esc(e.message || 'Could not load threads')}</p>
        <button class="btn btn-primary btn-sm" onclick="chatShowNewThread()"
            style="margin-top:0.75rem">+ Create First Thread</button>
      </div>`;
    }
    // Otherwise keep the existing thread list visible
  }
}

function chatRenderThreadList(threads) {
  const list = document.getElementById('chat-thread-list');
  if (!list) return;
  if (threads.length === 0) {
    list.innerHTML = `<div class="chat-empty">
      <span class="chat-empty-icon">&#x1F4AD;</span>
      <p>No threads yet</p>
      <button class="btn btn-primary btn-sm" onclick="chatShowNewThread()"
          style="margin-top:0.75rem">+ Create First Thread</button>
    </div>`;
    return;
  }
  // Load seen counts from localStorage
  var seen = _chatGetSeenCounts();
  let html = '';
  for (let i = 0; i < threads.length; i++) {
    const t = threads[i];
    const isActive = t.thread_id === _chatSelectedThread;
    const isGeneral = t.title === 'General';
    const icon = isGeneral ? '&#x1F4CC;' : (t.anchor_run ? '&#x1F517;' : '&#x1F4AC;');
    const relTime = _chatRelativeTime(t.created_at);
    const msgCount = t.message_count || 0;
    let tagBadges = '';
    const tags = (t.tags || []).slice(0, 3);
    for (let j = 0; j < tags.length; j++) {
      tagBadges += '<span class="chat-thread-tag">' + esc(tags[j]) + '</span>';
    }
    const cls = 'chat-thread-item' + (isActive ? ' active' : '');
    // Unseen detection
    const seenCount = seen[t.thread_id] || 0;
    const unseenCount = msgCount > seenCount ? msgCount - seenCount : 0;
    const hasUnseen = unseenCount > 0 && !isActive;

    html += '<div class="' + cls + '" data-thread-id="' + esc(t.thread_id) + '"'
      + ' onclick="chatSelectThread(this.dataset.threadId)">' 
      + '<div class="chat-thread-row1">'
      + (hasUnseen ? '<span class="chat-thread-unseen-dot"></span>' : '')
      + '<span class="chat-thread-icon">' + icon + '</span>'
      + '<span class="chat-thread-title"' + (hasUnseen ? ' style="font-weight:700"' : '') + '>' + esc(t.title) + '</span>'
      + '<span class="chat-thread-time">' + relTime + '</span>'
      + (!isGeneral ? '<button class="chat-thread-delete-btn" onclick="event.stopPropagation(); chatConfirmDeleteThread(\'' + esc(t.thread_id) + '\', \'' + esc(t.title) + '\')" title="Delete thread">&#x1F5D1;</button>' : '')
      + '</div>';

    if (tags.length > 0 || msgCount > 0 || hasUnseen) {
      html += '<div class="chat-thread-row2">' + tagBadges;
      if (hasUnseen) {
        html += '<span class="chat-thread-unseen-badge">' + unseenCount + ' new</span>';
      }
      if (msgCount > 0) {
        html += '<span class="chat-thread-count">' + msgCount + ' msg' + (msgCount !== 1 ? 's' : '') + '</span>';
      }
      html += '</div>';
    }
    html += '</div>';
  }
  list.innerHTML = html;
}

function chatFilterThreads(query) {
  if (!_chatThreads) return;
  const q = query.toLowerCase().trim();
  if (!q) { chatRenderThreadList(_chatThreads); return; }
  const filtered = _chatThreads.filter(function(t) {
    if (t.title.toLowerCase().indexOf(q) >= 0) return true;
    const tags = t.tags || [];
    for (let i = 0; i < tags.length; i++) {
      if (tags[i].toLowerCase().indexOf(q) >= 0) return true;
    }
    return false;
  });
  chatRenderThreadList(filtered);
}


// ═══════════════════════════════════════════════════════════════
// Feature 3 — Thread Selection + Messages
// ═══════════════════════════════════════════════════════════════

async function chatSelectThread(threadId) {
  _chatSelectedThread = threadId;
  contentUpdateHash();

  // Mark this thread as seen
  _chatMarkThreadSeen(threadId);

  chatRenderThreadList(_chatThreads);

  const header = document.getElementById('chat-thread-header');
  let thread = null;
  for (let i = 0; i < _chatThreads.length; i++) {
    if (_chatThreads[i].thread_id === threadId) { thread = _chatThreads[i]; break; }
  }
  if (header && thread) {
    let tagsHtml = '';
    const threadTags = thread.tags || [];
    for (let j = 0; j < threadTags.length; j++) {
      tagsHtml += '<span class="chat-header-tag">' + esc(threadTags[j]) + '</span>';
    }
    const anchorHtml = thread.anchor_run
      ? '<span class="chat-header-anchor">&#x1F517; ' + esc(thread.anchor_run) + '</span>' : '';

    header.innerHTML = '<div class="chat-conv-header-row">'
      + '<h3 class="chat-conv-title">' + esc(thread.title) + '</h3>'
      + tagsHtml + anchorHtml
      + '<span class="chat-header-meta">by ' + esc(thread.created_by)
      + ' &middot; ' + _chatRelativeTime(thread.created_at) + '</span>'
      + '</div>';
  }
  await chatLoadMessages(threadId);
}

// ── Seen / Unseen helpers (localStorage) ───────────────────────────
const _CHAT_SEEN_KEY = 'scp-chat-seen-counts';

function _chatGetSeenCounts() {
  try {
    return JSON.parse(localStorage.getItem(_CHAT_SEEN_KEY) || '{}');
  } catch(e) { return {}; }
}

function _chatMarkThreadSeen(threadId) {
  // Find current message count for this thread
  var count = 0;
  for (var i = 0; i < _chatThreads.length; i++) {
    if (_chatThreads[i].thread_id === threadId) {
      count = _chatThreads[i].message_count || 0;
      break;
    }
  }
  var seen = _chatGetSeenCounts();
  seen[threadId] = count;
  try { localStorage.setItem(_CHAT_SEEN_KEY, JSON.stringify(seen)); } catch(e) {}
}

async function chatLoadMessages(threadId) {
  const container = document.getElementById('chat-messages');
  if (!container) return;
  container.innerHTML = '<div class="chat-empty">'
    + '<span class="spinner"></span>'
    + '<p>Loading messages...</p>'
    + '</div>';
  try {
    const data = await api('/chat/messages?thread_id=' + encodeURIComponent(threadId) + '&n=100');
    _chatMessages = data.messages || [];
    chatRenderMessages();
    // Start auto-polling every 10s while viewing this thread
    _chatStartPoll();
  } catch (e) {
    container.innerHTML = '<div class="chat-empty">'
      + '<p style="color:var(--error)">&amp;#x26A0; ' + esc(e.message) + '</p>'
      + '</div>';
    // Don't kill the poll — transient errors should self-heal on next cycle
  }
}


// ═══════════════════════════════════════════════════════════════
// Feature 4 — Message Rendering
// ═══════════════════════════════════════════════════════════════

function chatRenderMessages() {
  const container = document.getElementById('chat-messages');
  if (!container) return;
  let messages = _chatMessages;
  if (_chatSourceFilter !== 'all') {
    messages = messages.filter(function(m) { return m.source === _chatSourceFilter; });
  }
  messages = messages.slice().sort(function(a, b) {
    const cmp = (a.ts || '').localeCompare(b.ts || '');
    return _chatSortNewest ? -cmp : cmp;
  });
  if (messages.length === 0) {
    const filterActive = _chatSourceFilter !== 'all';
    container.innerHTML = '<div class="chat-empty">'
      + '<span class="chat-empty-icon">' + (filterActive ? '&#x1F50D;' : '&#x270D;&#xFE0F;') + '</span>'
      + '<p>' + (filterActive
          ? 'No <strong>' + _chatSourceFilter + '</strong> messages in this thread'
          : 'No messages yet &mdash; send the first one!') + '</p>'
      + '</div>';
    return;
  }
  let html = '';
  for (let i = 0; i < messages.length; i++) {
    html += _chatRenderBubble(messages[i]);
  }
  container.innerHTML = html;
  if (!_chatSortNewest) container.scrollTop = container.scrollHeight;
}

function _chatRenderBubble(msg) {
  const src = msg.source || 'manual';
  const isEnc = (msg.flags && msg.flags.encrypted) || false;
  const isPub = (msg.flags && msg.flags.publish) || false;
  const relTime = _chatRelativeTime(msg.ts);
  const escaped = esc(msg.text);
  const refs = _chatEmbedRefs(escaped);
  const displayText = refs.html;
  const mediaHtml = refs.mediaEmbeds;
  const srcLabels = {
    manual: '&#x1F464; Manual',
    trace:  '&#x1F4CB; Trace',
    system: '&#x2699;&#xFE0F; System'
  };
  const sourceLabel = srcLabels[src] || src;
  let badges = '<span class="chat-msg-badge ' + src + '">' + sourceLabel + '</span>';
  if (msg.trace_id) badges += '<span class="chat-msg-badge trace">trace</span>';
  if (isEnc) badges += '<span class="chat-msg-badge encrypted">&#x1F510; encrypted</span>';
  if (isPub) badges += '<span class="chat-msg-badge published">&#x1F310; published</span>';

  return '<div class="chat-message ' + src + '" data-msg-id="' + esc(msg.id) + '">'
    + '<div class="chat-msg-header">'
    + '<span class="chat-msg-avatar">' + (esc(msg.user || 'U'))[0].toUpperCase() + '</span>'
    + '<span class="chat-msg-user">' + esc(msg.user || 'Unknown')
    + (msg.hostname ? ' <span style="font-size:0.65rem;color:var(--text-muted);font-weight:400">@' + esc(msg.hostname) + '</span>' : '')
    + '</span>'
    + badges
    + '<span class="chat-msg-time">' + relTime + '</span>'
    + '<span class="chat-msg-actions">'
    + '<button class="chat-msg-action-btn" onclick="chatTogglePublish(\'' + esc(msg.id) + '\', ' + (isPub ? 'false' : 'true') + ')" title="' + (isPub ? 'Unpublish' : 'Publish') + '">'
    + (isPub ? '&#x1F310;' : '&#x1F311;') + '</button>'
    + '<button class="chat-msg-action-btn" onclick="chatToggleEncrypt(\'' + esc(msg.id) + '\', ' + (isEnc ? 'false' : 'true') + ')" title="' + (isEnc ? 'Decrypt' : 'Encrypt') + '">'
    + (isEnc ? '&#x1F513;' : '&#x1F512;') + '</button>'
    + '<button class="chat-msg-delete-btn" onclick="chatConfirmDelete(\'' + esc(msg.id) + '\')" title="Delete message">&#x1F5D1;&#xFE0F;</button>'
    + '</span>'
    + '</div>'
    + '<div class="chat-msg-body">' + _chatRenderBody(msg, displayText) + '</div>'
    + mediaHtml
    + '</div>';
}

function _chatRenderBody(msg, displayText) {
  if (msg.source !== 'trace' || !msg.trace_id) return displayText;

  // Rich trace card for trace-source messages
  var tid = esc(msg.trace_id);
  var badgeId = 'tbadge_' + Math.random().toString(36).slice(2, 8);
  var btnId = 'tbtn_' + Math.random().toString(36).slice(2, 8);
  var card = '<div class="chat-trace-card" style="margin:4px 0;padding:10px 14px;border-radius:var(--radius-md);background:var(--bg-secondary);border:1px solid var(--border-subtle);border-left:3px solid var(--accent)">'
    + '<div style="display:flex;align-items:center;gap:8px;flex-wrap:wrap">'
    + '<span style="font-size:1rem">&#x1F4DD;</span>'
    + '<strong style="font-size:0.8rem">Session Trace</strong>'
    + '<span style="font-size:0.62rem;padding:1px 6px;border-radius:3px;background:rgba(99,102,241,0.1);color:var(--accent);font-family:var(--font-mono)">' + tid + '</span>'
    + '<span id="' + badgeId + '" style="font-size:0.56rem;padding:1px 5px;border-radius:3px;background:rgba(100,100,100,0.1);color:var(--text-muted)">&#x23F3;</span>'
    + '</div>'
    + '<div style="font-size:0.74rem;color:var(--text-secondary);margin-top:6px">' + displayText + '</div>'
    + '<div style="display:flex;gap:8px;margin-top:8px">'
    + '<button class="btn btn-sm btn-ghost" style="font-size:0.68rem" onclick="_chatLoadTraceEvents(this, \'' + tid + '\')" title="Expand event timeline">&#x25B8; View events</button>'
    + '<button class="btn btn-sm btn-ghost" style="font-size:0.68rem" onclick="switchTab(\'debugging\');debugSwitchMode(\'traces\')" title="Open in Debugging tab">&#x1F41B; Open in Debugging</button>'
    + '<button id="' + btnId + '" class="btn btn-sm btn-ghost chat-trace-share-btn" style="font-size:0.68rem;display:none" onclick="_chatToggleTraceShare(this, \'' + tid + '\')" title="Share/unshare this trace">&#x1F4E4; Share</button>'
    + '</div>'
    + '<div class="chat-trace-events" data-trace-id="' + tid + '" style="display:none;margin-top:8px"></div>'
    + '</div>';

  // Async: fetch actual shared status and update badge + button
  setTimeout(function() { _chatUpdateTraceBadge(msg.trace_id, badgeId, btnId); }, 0);

  return card;
}

async function _chatUpdateTraceBadge(traceId, badgeId, btnId) {
  try {
    var res = await apiFetch('/trace/get?trace_id=' + encodeURIComponent(traceId));
    var badge = document.getElementById(badgeId);
    var btn = document.getElementById(btnId);
    if (!badge) return;
    if (res.trace && res.trace.shared) {
      badge.innerHTML = '&#x1F310; Shared';
      badge.title = 'Shared — committed to git';
      badge.style.background = 'rgba(52,211,153,0.12)';
      badge.style.color = 'var(--success)';
      if (btn) { btn.innerHTML = '&#x1F513; Unshare'; btn.style.display = ''; }
    } else {
      badge.innerHTML = '&#x1F512; Local';
      badge.title = 'Local-only trace — not shared to git';
      badge.style.background = 'rgba(245,158,11,0.12)';
      badge.style.color = 'var(--warning)';
      if (btn) { btn.innerHTML = '&#x1F4E4; Share'; btn.style.display = ''; }
    }
  } catch(e) {
    // Trace might not exist on this machine — just show unknown
    var badge = document.getElementById(badgeId);
    if (badge) { badge.innerHTML = '&#x2753;'; badge.title = 'Trace not found locally'; }
  }
}

async function _chatToggleTraceShare(btn, traceId) {
  var card = btn.closest('.chat-trace-card');
  var badge = card.querySelector('span[title*="Local"], span[title*="Shared"]');
  var isShared = badge && badge.title.indexOf('Shared') !== -1;

  try {
    if (isShared) {
      // Unshare
      await apiPost('/trace/unshare', { trace_id: traceId });
      toast('Trace marked as local-only', 'success');
      if (badge) {
        badge.innerHTML = '&#x1F512; Local';
        badge.title = 'Local-only trace — not shared to git';
        badge.style.background = 'rgba(245,158,11,0.12)';
        badge.style.color = 'var(--warning)';
      }
      btn.innerHTML = '&#x1F4E4; Share';
    } else {
      // Share
      await apiPost('/trace/share', { trace_id: traceId });
      toast('Trace shared to git', 'success');
      if (badge) {
        badge.innerHTML = '&#x1F310; Shared';
        badge.title = 'Shared — committed to git';
        badge.style.background = 'rgba(52,211,153,0.12)';
        badge.style.color = 'var(--success)';
      }
      btn.innerHTML = '&#x1F513; Unshare';
    }
  } catch(e) {
    toast('Failed: ' + e.message, 'error');
  }
}

async function _chatLoadTraceEvents(btn, traceId) {
  var container = btn.closest('.chat-trace-card').querySelector('.chat-trace-events');
  if (!container) return;

  // Toggle
  if (container.style.display !== 'none' && container.dataset.loaded === 'true') {
    container.style.display = 'none';
    btn.innerHTML = '&#x25B8; View events';
    return;
  }

  container.style.display = '';
  btn.innerHTML = '&#x25BE; Hide events';

  if (container.dataset.loaded === 'true') return;

  container.innerHTML = '<span class="spinner"></span> Loading events...';
  try {
    var data = await api('/trace/events?trace_id=' + encodeURIComponent(traceId));
    var events = data.events || [];
    container.dataset.loaded = 'true';

    if (!events.length) {
      container.innerHTML = '<div style="font-size:0.72rem;color:var(--text-muted)">No events captured.</div>';
      return;
    }

    // Group by domain
    var groups = [];
    var cur = null;
    for (var i = 0; i < events.length; i++) {
      var domain = (events[i].type || '').split(':')[0] || 'other';
      if (!cur || cur.domain !== domain) {
        cur = { domain: domain, events: [] };
        groups.push(cur);
      }
      cur.events.push(events[i]);
    }

    var html = '<div style="font-size:0.68rem;font-weight:600;margin-bottom:4px">' + events.length + ' events</div>';
    for (var g = 0; g < groups.length; g++) {
      var gr = groups[g];
      var gDur = 0;
      for (var j = 0; j < gr.events.length; j++) gDur += (gr.events[j].duration_ms || 0);
      html += '<div style="margin-bottom:4px">'
        + '<div style="display:flex;align-items:center;gap:4px;padding:3px 6px;border-radius:3px;background:rgba(99,102,241,0.06);font-size:0.66rem;cursor:pointer" onclick="this.nextElementSibling.style.display=this.nextElementSibling.style.display===\'none\'?\'\':\'none\'">'
        + '<strong style="text-transform:capitalize">' + esc(gr.domain) + '</strong>'
        + '<span style="color:var(--text-muted)">' + gr.events.length + ' events</span>'
        + (gDur ? '<span style="color:var(--text-muted)">&#x23F1; ' + gDur + 'ms</span>' : '')
        + '</div>'
        + '<div style="display:none;padding-left:14px;border-left:2px solid rgba(99,102,241,0.15);margin-left:6px;margin-top:2px">';
      for (var k = 0; k < gr.events.length; k++) {
        var ev = gr.events[k];
        var ri = ev.result === 'ok' ? '&#x2705;' : ev.result === 'failed' ? '&#x274C;' : '&#x2699;&#xFE0F;';
        var evMsg = (ev.detail && ev.detail.summary) || (ev.detail && ev.detail.error) || '';
        var evFail = ev.result === 'failed';
        var hasDet = ev.detail && Object.keys(ev.detail).length > 0;
        var detId = 'cevt_' + Math.random().toString(36).slice(2, 8);
        var detJson = hasDet ? JSON.stringify(ev.detail, null, 2) : '';
        html += '<div style="padding:2px 0;border-bottom:1px solid var(--border-subtle)">'
          + '<div style="display:flex;align-items:center;gap:4px;font-size:0.64rem;cursor:' + (hasDet ? 'pointer' : 'default') + '"'
          + (hasDet ? ' onclick="var d=document.getElementById(\'' + detId + '\');d.style.display=d.style.display===\'none\'?\'\':\'none\'"' : '') + '>'
          + '<span style="font-family:var(--font-mono);color:var(--text-muted);min-width:16px">#' + ev.seq + '</span>'
          + '<span>' + ri + '</span>'
          + '<span style="font-family:var(--font-mono);color:var(--accent)">' + esc(ev.type) + '</span>'
          + (ev.target ? '<span style="color:var(--text-secondary)">' + esc(ev.target) + '</span>' : '')
          + (ev.duration_ms ? '<span style="color:var(--text-muted)">&#x23F1; ' + ev.duration_ms + 'ms</span>' : '')
          + (hasDet ? '<span style="color:var(--text-muted);font-size:0.54rem">&#x25B8; detail</span>' : '')
          + '</div>'
          + (evMsg ? '<div style="font-size:0.6rem;padding-left:20px;margin-top:1px;color:' + (evFail ? 'var(--error)' : 'var(--text-muted)') + ';font-family:var(--font-mono)">' + esc(evMsg) + '</div>' : '')
          + (hasDet ? '<pre id="' + detId + '" style="display:none;margin:3px 0 1px 20px;padding:4px 8px;font-size:0.56rem;background:var(--bg-tertiary);border:1px solid var(--border-subtle);border-radius:var(--radius-sm);overflow-x:auto;max-height:250px;color:var(--text-secondary);font-family:var(--font-mono);white-space:pre-wrap;word-break:break-word">' + esc(detJson) + '</pre>' : '')
          + '</div>';
      }
      html += '</div></div>';
    }
    container.innerHTML = html;
  } catch(e) {
    container.innerHTML = '<div style="color:var(--error);font-size:0.72rem">Failed to load events: ' + esc(e.message) + '</div>';
  }
}


// ═══════════════════════════════════════════════════════════════
// Feature 4b — Delete Message
// ═══════════════════════════════════════════════════════════════

function chatConfirmDelete(msgId) {
  var delBody = '<p style="color:var(--text-secondary)">'
    + 'Are you sure you want to delete this message?'
    + ' This cannot be undone.</p>';
  var delClick = "chatDoDelete('" + esc(msgId) + "')";
  modalOpen({
    title: '\uD83D\uDDD1\uFE0F Delete Message',
    body: delBody,
    footerButtons: [
      { label: 'Cancel', cls: 'btn-ghost', onclick: 'modalClose()' },
      { label: 'Delete', cls: 'btn-primary', style: 'background:var(--error)', onclick: delClick },
    ],
  });
}

async function chatDoDelete(msgId) {
  try {
    const resp = await api('/chat/delete-message', {
      method: 'POST',
      body: JSON.stringify({
        thread_id: _chatSelectedThread,
        message_id: msgId,
      }),
    });
    modalClose();
    if (resp.deleted) {
      toast('Message deleted', 'success');
      chatSelectThread(_chatSelectedThread);
    } else {
      toast('Message not found', 'warning');
    }
  } catch (e) {
    modalClose();
    toast('Delete failed: ' + e.message, 'error');
  }
}


// ═══════════════════════════════════════════════════════════════
// Feature 4c — Delete Thread
// ═══════════════════════════════════════════════════════════════

function chatConfirmDeleteThread(threadId, threadTitle) {
  var delBody = '<p style="color:var(--text-secondary);margin-bottom:1rem">'
    + 'You are about to permanently delete the thread <strong>"' + esc(threadTitle) + '"</strong> '
    + 'and all its messages. This cannot be undone.</p>'
    + '<label style="display:block;margin-bottom:0.5rem;color:var(--text-muted);font-size:0.85rem">'
    + 'Type <strong>CONFIRM</strong> to proceed:</label>'
    + '<input type="text" id="chat-delete-thread-confirm" '
    + 'style="width:100%;padding:0.5rem;border:1px solid var(--border);border-radius:6px;'
    + 'background:var(--bg-secondary);color:var(--text-primary);font-size:0.9rem" '
    + 'autocomplete="off" spellcheck="false" '
    + 'oninput="_chatDeleteThreadValidate()" '
    + 'placeholder="Type CONFIRM here">';

  modalOpen({
    title: '\u26A0\uFE0F Delete Thread',
    body: delBody,
    footerButtons: [
      { label: 'Cancel', cls: 'btn-ghost', onclick: 'modalClose()' },
      { label: 'Delete Thread', cls: 'btn-primary', style: 'background:var(--error);opacity:0.5;pointer-events:none',
        id: 'chat-delete-thread-btn',
        onclick: "chatDoDeleteThread('" + esc(threadId) + "')" },
    ],
  });

  // Focus the input after modal renders
  setTimeout(function() {
    var inp = document.getElementById('chat-delete-thread-confirm');
    if (inp) inp.focus();
  }, 100);
}

function _chatDeleteThreadValidate() {
  var inp = document.getElementById('chat-delete-thread-confirm');
  var btn = document.getElementById('chat-delete-thread-btn');
  if (!inp || !btn) return;
  if (inp.value.trim() === 'CONFIRM') {
    btn.style.opacity = '1';
    btn.style.pointerEvents = 'auto';
  } else {
    btn.style.opacity = '0.5';
    btn.style.pointerEvents = 'none';
  }
}

async function chatDoDeleteThread(threadId) {
  try {
    const resp = await apiPost('/chat/delete-thread', {
      thread_id: threadId,
    });
    modalClose();
    if (resp.deleted) {
      toast('Thread deleted', 'success');
      _chatSelectedThread = null;
      _chatMessages = [];
      _chatStopPoll();

      // Clear the right-side panes immediately
      var msgPane = document.getElementById('chat-messages');
      if (msgPane) msgPane.innerHTML = '<div class="chat-empty"><p>Select a thread to view messages</p></div>';
      var header = document.getElementById('chat-thread-header');
      if (header) header.innerHTML = '';
      var compose = document.getElementById('chat-compose');
      if (compose) compose.style.display = 'none';

      await chatLoadThreads();
    } else {
      toast('Thread not found', 'warning');
    }
  } catch (e) {
    modalClose();
    toast('Delete failed: ' + e.message, 'error');
  }
}

// ═══════════════════════════════════════════════════════════════
// Feature 5 — Compose + Send
// ═══════════════════════════════════════════════════════════════

function chatOnInput(textarea) {
  textarea.style.height = 'auto';
  textarea.style.height = Math.min(textarea.scrollHeight, 200) + 'px';
  if (typeof chatCheckRefTrigger === 'function') {
    chatCheckRefTrigger(textarea.value, textarea.selectionStart);
  }
}

function chatOnKeydown(event) {
  if ((event.ctrlKey || event.metaKey) && event.key === 'Enter') {
    event.preventDefault();
    chatSendMessage();
    return;
  }
  if (typeof chatRefKeydown === 'function') {
    chatRefKeydown(event);
  }
}

async function chatSendMessage() {
  const input = document.getElementById('chat-compose-input');
  const status = document.getElementById('chat-compose-status');
  const sendBtn = document.getElementById('chat-send-btn');
  if (!input) return;
  const text = input.value.trim();
  if (!text) return;
  if (!_chatSelectedThread) {
    if (status) {
      status.textContent = 'Select a thread first';
      status.className = 'chat-compose-status warning';
    }
    return;
  }
  sendBtn.disabled = true;
  if (status) {
    status.textContent = 'Sending...';
    status.className = 'chat-compose-status';
  }
  const encCb = document.getElementById('chat-encrypt-cb');
  const encrypt = encCb ? encCb.checked : false;
  try {
    const pubCb = document.getElementById('chat-publish-cb');
    const publish = pubCb ? pubCb.checked : false;
    const msg = await api('/chat/send', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        text: text,
        thread_id: _chatSelectedThread,
        encrypt: encrypt,
        publish: publish,
        source: 'manual'
      })
    });
    _chatMessages.unshift(msg);
    chatRenderMessages();
    input.value = '';
    input.style.height = 'auto';
    if (status) {
      status.textContent = '\u2714 Sent';
      status.className = 'chat-compose-status success';
    }
    setTimeout(function() {
      if (status) {
        status.textContent = '';
        status.className = 'chat-compose-status';
      }
    }, 2000);
    const popup = document.getElementById('chat-ref-popup');
    if (popup) popup.style.display = 'none';
  } catch (e) {
    if (status) {
      status.textContent = '&#x26A0; ' + e.message;
      status.className = 'chat-compose-status error';
    }
  } finally {
    sendBtn.disabled = false;
  }
}


// ═══════════════════════════════════════════════════════════════
// Feature 6 — Filters + Sort
// ═══════════════════════════════════════════════════════════════

function chatFilterBySource(source) {
  _chatSourceFilter = source;
  document.querySelectorAll('.chat-source-filter').forEach(function(btn) {
    if (btn.dataset.source === source) btn.classList.add('active');
    else btn.classList.remove('active');
  });
  chatRenderMessages();
}

function chatToggleSort() {
  _chatSortNewest = !_chatSortNewest;
  const sortBtn = document.getElementById('chat-sort-icon');
  if (sortBtn && sortBtn.parentElement) {
    sortBtn.parentElement.innerHTML = '<span id="chat-sort-icon">'
      + (_chatSortNewest ? '&#x2B07;' : '&#x2B06;') + '</span> '
      + (_chatSortNewest ? 'Newest first' : 'Oldest first');
  }
  chatRenderMessages();
}


// ═══════════════════════════════════════════════════════════════
// Feature 7 — Thread Creation
// ═══════════════════════════════════════════════════════════════

function chatShowNewThread() {
  const modal = document.getElementById('chat-new-thread-modal');
  if (modal) {
    modal.classList.add('visible');
    const ti = document.getElementById('chat-new-thread-title');
    if (ti) { ti.value = ''; ti.focus(); }
    const tg = document.getElementById('chat-new-thread-tags');
    if (tg) tg.value = '';
  }
}

function chatCloseNewThread() {
  const modal = document.getElementById('chat-new-thread-modal');
  if (modal) modal.classList.remove('visible');
}

async function chatCreateThread() {
  const ti = document.getElementById('chat-new-thread-title');
  const tg = document.getElementById('chat-new-thread-tags');
  const title = ti ? ti.value.trim() : '';
  if (!title) {
    toast('Thread title is required', 'warning');
    return;
  }
  const tags = (tg ? tg.value : '').split(',').map(function(s) {
    return s.trim();
  }).filter(Boolean);
  try {
    const thread = await api('/chat/threads/create', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ title: title, tags: tags })
    });
    chatCloseNewThread();
    _chatThreads.unshift(thread);
    chatRenderThreadList(_chatThreads);
    chatSelectThread(thread.thread_id);
    toast('Thread created', 'success');
  } catch (e) {
    toast('Failed: ' + e.message, 'error');
  }
}


// ═══════════════════════════════════════════════════════════════
// Feature 8 — Sync
// ═══════════════════════════════════════════════════════════════

async function chatSync(action) {
  try {
    toast('Syncing chat...', 'info');
    const result = await api('/chat/sync', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ action: action })
    });
    const parts = [];
    if (result.pushed) parts.push('pushed');
    if (result.pulled) parts.push('pulled');
    if (parts.length > 0) toast('Chat ' + parts.join(' & '), 'success');
    else toast('Nothing to sync', 'info');
    await chatLoadThreads();
    // Restart auto-poll after manual sync/reconnect
    if (_chatSelectedThread) _chatStartPoll();
  } catch (e) {
    toast('Sync failed: ' + e.message, 'error');
    _chatStopPoll();
  }
}


// ═══════════════════════════════════════════════════════════════
// Feature 9 — Utilities
// ═══════════════════════════════════════════════════════════════

function _chatRelativeTime(isoString) {
  if (!isoString) return '';
  try {
    const d = new Date(isoString);
    const now = new Date();
    const diffMs = now - d;
    const diffSec = Math.floor(diffMs / 1000);
    const diffMin = Math.floor(diffSec / 60);
    const diffHr  = Math.floor(diffMin / 60);
    const diffDay = Math.floor(diffHr / 24);
    if (diffSec < 60) return 'just now';
    if (diffMin < 60) return diffMin + 'm ago';
    if (diffHr  < 24) return diffHr + 'h ago';
    if (diffDay < 30) return diffDay + 'd ago';
    return d.toLocaleDateString();
  } catch (ex) {
    return isoString;
  }
}

function chatToggleEncryptHint(on) {
  const textarea = document.getElementById('chat-compose-input');
  if (!textarea) return;
  if (on) {
    textarea.style.borderColor = 'var(--warning, #f59e0b)';
    textarea.style.boxShadow = '0 0 0 1px var(--warning, #f59e0b)';
    textarea.placeholder = '\uD83D\uDD10 Encrypted message... Use @ for references';
  } else {
    textarea.style.borderColor = '';
    textarea.style.boxShadow = '';
    textarea.placeholder = 'Type a message... Use @ for references';
  }
}

async function chatTogglePublish(msgId, newValue) {
  try {
    const updated = await api('/chat/update-message', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        thread_id: _chatSelectedThread,
        message_id: msgId,
        publish: newValue,
      })
    });
    // Update in-memory
    for (var i = 0; i < _chatMessages.length; i++) {
      if (_chatMessages[i].id === msgId) {
        _chatMessages[i] = updated;
        break;
      }
    }
    chatRenderMessages();
    toast(newValue ? '\uD83C\uDF10 Published' : 'Unpublished', 'success');
  } catch (e) {
    toast('Failed: ' + e.message, 'error');
  }
}

async function chatToggleEncrypt(msgId, newValue) {
  try {
    const updated = await api('/chat/update-message', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        thread_id: _chatSelectedThread,
        message_id: msgId,
        encrypt: newValue,
      })
    });
    // Update in-memory
    for (var i = 0; i < _chatMessages.length; i++) {
      if (_chatMessages[i].id === msgId) {
        _chatMessages[i] = updated;
        break;
      }
    }
    chatRenderMessages();
    toast(newValue ? '\uD83D\uDD10 Encrypted' : '\uD83D\uDD13 Decrypted', 'success');
  } catch (e) {
    toast('Failed: ' + e.message, 'error');
  }
}
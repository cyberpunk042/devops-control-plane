// ─────────────────────────────────────────────────────────────────
// _content_chat.html
// Content Vault — Chat Panel (Threads + Messages + Compose)
// Included by: _content.html (Jinja2 include)
// ─────────────────────────────────────────────────────────────────

function _chatCleanup() {
  const popup = document.getElementById('chat-ref-popup');
  if (popup) popup.style.display = 'none';
  // Stop auto-poll and idle tracking when leaving chat view
  _chatStopPoll();
  _chatStopIdleTracker();
}

let _chatPollTimer = null;
const _CHAT_POLL_BASE = 5000;     // 5s when active
const _CHAT_POLL_MAX  = 60000;    // 60s max when idle
let _chatPollInterval = _CHAT_POLL_BASE;
let _chatLastActivity = Date.now();
let _chatIdleTimer = null;

function _chatOnActivity() {
  _chatLastActivity = Date.now();
  // If interval was degraded, reset to base and restart
  if (_chatPollInterval > _CHAT_POLL_BASE) {
    _chatPollInterval = _CHAT_POLL_BASE;
    if (_chatPollTimer) {
      _chatStopPoll();
      _chatStartPoll();
    }
  }
}

function _chatStartIdleTracker() {
  _chatStopIdleTracker();
  // Listen for user activity on the document
  document.addEventListener('mousemove', _chatOnActivity);
  document.addEventListener('keydown', _chatOnActivity);
  document.addEventListener('click', _chatOnActivity);
  document.addEventListener('scroll', _chatOnActivity);
  // Check idle every 30s — double the interval if no activity
  _chatIdleTimer = setInterval(() => {
    const idleMs = Date.now() - _chatLastActivity;
    if (idleMs > 30000 && _chatPollInterval < _CHAT_POLL_MAX) {
      _chatPollInterval = Math.min(_chatPollInterval * 2, _CHAT_POLL_MAX);
      console.debug('[chat-poll] idle ' + Math.round(idleMs/1000) + 's — interval now ' + (_chatPollInterval/1000) + 's');
      // Restart with new interval
      if (_chatPollTimer) {
        _chatStopPoll();
        _chatStartPoll();
      }
    }
  }, 30000);
}

function _chatStopIdleTracker() {
  document.removeEventListener('mousemove', _chatOnActivity);
  document.removeEventListener('keydown', _chatOnActivity);
  document.removeEventListener('click', _chatOnActivity);
  document.removeEventListener('scroll', _chatOnActivity);
  if (_chatIdleTimer) {
    clearInterval(_chatIdleTimer);
    _chatIdleTimer = null;
  }
}

let _chatPollCycles = 0;

function _chatStartPoll() {
  _chatStopPoll();
  _chatLastActivity = Date.now();
  _chatPollCycles = 0;
  _chatStartIdleTracker();
  _chatPollTimer = setInterval(async () => {
    if (!_chatSelectedThread) return;
    _chatPollCycles++;
    try {
      // Pull remote changes first, then read local messages
      try {
        await apiPost('/chat/sync', { action: 'pull' });
      } catch (pullErr) {
        // pull failure is non-fatal — continue reading local
        console.debug('[chat-poll] pull failed:', pullErr.message);
      }

      // Refresh thread list every 3rd poll cycle (~15s at base)
      var didThreadRefresh = false;
      if (_chatPollCycles % 3 === 0) {
        try { await chatLoadThreads(); didThreadRefresh = true; } catch(e) {}
      }

      // Skip message fetch if we just refreshed threads (avoids double fetch)
      if (didThreadRefresh) return;

      const data = await api('/chat/messages?thread_id=' + encodeURIComponent(_chatSelectedThread) + '&n=100');
      const newMsgs = data.messages || [];
      // Only re-render if message count or last message changed
      if (newMsgs.length !== _chatMessages.length ||
          (newMsgs.length > 0 && _chatMessages.length > 0 &&
           newMsgs[newMsgs.length - 1].id !== _chatMessages[_chatMessages.length - 1].id)) {
        _chatMessages = newMsgs;
        chatRenderMessages();
      }
    } catch (e) {
      console.debug('[chat-poll] error:', e.message);
    }
  }, _chatPollInterval);
}

function _chatStopPoll() {
  if (_chatPollTimer) {
    clearInterval(_chatPollTimer);
    _chatPollTimer = null;
  }
}

// ═══════════════════════════════════════════════════════════════
// Feature 1 — Panel Layout (renderChatPanel)
// ═══════════════════════════════════════════════════════════════

async function renderChatPanel() {
  const browser = document.getElementById('content-chat-panel');

  browser.innerHTML = `
<div class="chat-panel">

    <!-- LEFT: Thread sidebar card -->
    <div class="chat-sidebar-card">
        <div class="chat-sidebar-header">
            <span class="chat-sidebar-title">Threads</span>
            <div class="chat-sidebar-actions">
                <button class="btn btn-primary btn-sm" onclick="chatShowNewThread()" title="New thread">+ New</button>
                <button class="btn btn-secondary btn-sm" onclick="chatSync('both')"
                    title="Reconnect &amp; restart sync">&#x1F504;</button>
            </div>
        </div>
        <input type="text" id="chat-thread-search" class="chat-search-input"
            placeholder="Search threads..."
            oninput="chatFilterThreads(this.value)">
        <div id="chat-thread-list" class="chat-thread-list">
            <div class="chat-empty"><span class="spinner"></span></div>
        </div>
    </div>

    <!-- RIGHT: Conversation area -->
    <div class="chat-conversation">
        <div id="chat-thread-header" class="chat-conv-header">
            <p class="chat-empty-sub" style="padding:1rem;text-align:center;color:var(--text-muted)">
                Select a thread to begin</p>
        </div>

        <!-- Source filter bar -->
        <div class="chat-filter-bar">
            <div class="chat-filters">
                <button class="chat-source-filter active" data-source="all"
                    onclick="chatFilterBySource('all')">All</button>
                <button class="chat-source-filter" data-source="manual"
                    onclick="chatFilterBySource('manual')">&#x1F464; Manual</button>
                <button class="chat-source-filter" data-source="trace"
                    onclick="chatFilterBySource('trace')">&#x1F4CB; Trace</button>
                <button class="chat-source-filter" data-source="system"
                    onclick="chatFilterBySource('system')">&#x2699;&#xFE0F; System</button>
            </div>
            <button class="btn btn-sm chat-sort-btn" onclick="chatToggleSort()"
                title="Toggle sort order">
                <span id="chat-sort-icon">&#x2B07;</span> Newest first
            </button>
        </div>

        <!-- Messages -->
        <div id="chat-messages" class="chat-messages">
            <div class="chat-empty">
                <span class="chat-empty-icon">&#x1F4AD;</span>
                <p>Select a thread to view messages</p>
            </div>
        </div>

        <!-- Compose area -->
        <div class="chat-compose">
            <div class="chat-compose-wrap">
                <textarea id="chat-compose-input" class="chat-textarea" rows="2"
                    placeholder="Type a message... Use @ for references"
                    oninput="chatOnInput(this)"
                    onkeydown="chatOnKeydown(event)"></textarea>
                <div id="chat-ref-popup" class="chat-ref-popup"></div>
            </div>
            <div class="chat-compose-footer">
                <label class="chat-encrypt-label">
                    <input type="checkbox" id="chat-encrypt-cb" onchange="chatToggleEncryptHint(this.checked)"> &#x1F512; Encrypt
                </label>
                <label class="chat-encrypt-label" style="margin-left:0.75rem"
                    title="Published messages can be rendered on GitHub Pages and other public-facing features">
                    <input type="checkbox" id="chat-publish-cb"> &#x1F310; Publish
                </label>
                <span style="flex:1"></span>
                <span id="chat-compose-status" class="chat-compose-status"></span>
                <button class="btn btn-primary btn-sm chat-send-btn"
                    onclick="chatSendMessage()" id="chat-send-btn">Send &#x2192;</button>
            </div>
        </div>

    </div>
</div>

<!-- New thread modal -->
<div id="chat-new-thread-modal" class="chat-modal-overlay">
    <div class="chat-modal">
        <h3>&#x1F4AC; New Thread</h3>
        <div class="form-group">
            <label>Title</label>
            <input type="text" id="chat-new-thread-title" placeholder="Thread title">
        </div>
        <div class="form-group">
            <label>Tags (comma-separated)</label>
            <input type="text" id="chat-new-thread-tags" placeholder="deploy, staging">
        </div>
        <div class="chat-modal-actions">
            <button class="btn btn-secondary btn-sm" onclick="chatCloseNewThread()">Cancel</button>
            <button class="btn btn-primary btn-sm" onclick="chatCreateThread()">Create Thread</button>
        </div>
    </div>
</div>
`;

  await chatLoadThreads();
}


// ═══════════════════════════════════════════════════════════════
// Feature 2 — Thread List
// ═══════════════════════════════════════════════════════════════

async function chatLoadThreads() {
  const list = document.getElementById('chat-thread-list');
  if (!list) return;
  var isInitialLoad = !_chatLoaded;
  try {
    const data = await api('/chat/threads');
    _chatThreads = data.threads || [];
    _chatLoaded = true;
    chatRenderThreadList(_chatThreads);

    // On initial load, select a thread (and start polling)
    if (isInitialLoad) {
      if (_chatSelectedThread) {
        // Thread pre-selected from URL hash — load it
        chatSelectThread(_chatSelectedThread);
      } else if (_chatThreads.length > 0) {
        // Auto-select General or first thread
        let gen = null;
        for (let i = 0; i < _chatThreads.length; i++) {
          if (_chatThreads[i].title === 'General') { gen = _chatThreads[i]; break; }
        }
        chatSelectThread(gen ? gen.thread_id : _chatThreads[0].thread_id);
      }
    }
    // On subsequent refreshes (auto-poll), just re-render the list — no re-selection
  } catch (e) {
    // Only show error state on initial load, not during poll refreshes
    if (!_chatLoaded) {
      list.innerHTML = `<div class="chat-empty">
        <span class="chat-empty-icon">&#x1F4AD;</span>
        <p>No chat threads yet</p>
        <p class="chat-empty-sub">${esc(e.message || 'Could not load threads')}</p>
        <button class="btn btn-primary btn-sm" onclick="chatShowNewThread()"
            style="margin-top:0.75rem">+ Create First Thread</button>
      </div>`;
    }
    // Otherwise keep the existing thread list visible
  }
}

function chatRenderThreadList(threads) {
  const list = document.getElementById('chat-thread-list');
  if (!list) return;
  if (threads.length === 0) {
    list.innerHTML = `<div class="chat-empty">
      <span class="chat-empty-icon">&#x1F4AD;</span>
      <p>No threads yet</p>
      <button class="btn btn-primary btn-sm" onclick="chatShowNewThread()"
          style="margin-top:0.75rem">+ Create First Thread</button>
    </div>`;
    return;
  }
  // Load seen counts from localStorage
  var seen = _chatGetSeenCounts();
  let html = '';
  for (let i = 0; i < threads.length; i++) {
    const t = threads[i];
    const isActive = t.thread_id === _chatSelectedThread;
    const isGeneral = t.title === 'General';
    const icon = isGeneral ? '&#x1F4CC;' : (t.anchor_run ? '&#x1F517;' : '&#x1F4AC;');
    const relTime = _chatRelativeTime(t.created_at);
    const msgCount = t.message_count || 0;
    let tagBadges = '';
    const tags = (t.tags || []).slice(0, 3);
    for (let j = 0; j < tags.length; j++) {
      tagBadges += '<span class="chat-thread-tag">' + esc(tags[j]) + '</span>';
    }
    const cls = 'chat-thread-item' + (isActive ? ' active' : '');
    // Unseen detection
    const seenCount = seen[t.thread_id] || 0;
    const unseenCount = msgCount > seenCount ? msgCount - seenCount : 0;
    const hasUnseen = unseenCount > 0 && !isActive;

    html += '<div class="' + cls + '" data-thread-id="' + esc(t.thread_id) + '"'
      + ' onclick="chatSelectThread(this.dataset.threadId)">' 
      + '<div class="chat-thread-row1">'
      + (hasUnseen ? '<span class="chat-thread-unseen-dot"></span>' : '')
      + '<span class="chat-thread-icon">' + icon + '</span>'
      + '<span class="chat-thread-title"' + (hasUnseen ? ' style="font-weight:700"' : '') + '>' + esc(t.title) + '</span>'
      + '<span class="chat-thread-time">' + relTime + '</span>'
      + (!isGeneral ? '<button class="chat-thread-delete-btn" onclick="event.stopPropagation(); chatConfirmDeleteThread(\'' + esc(t.thread_id) + '\', \'' + esc(t.title) + '\')" title="Delete thread">&#x1F5D1;</button>' : '')
      + '</div>';

    if (tags.length > 0 || msgCount > 0 || hasUnseen) {
      html += '<div class="chat-thread-row2">' + tagBadges;
      if (hasUnseen) {
        html += '<span class="chat-thread-unseen-badge">' + unseenCount + ' new</span>';
      }
      if (msgCount > 0) {
        html += '<span class="chat-thread-count">' + msgCount + ' msg' + (msgCount !== 1 ? 's' : '') + '</span>';
      }
      html += '</div>';
    }
    html += '</div>';
  }
  list.innerHTML = html;
}

function chatFilterThreads(query) {
  if (!_chatThreads) return;
  const q = query.toLowerCase().trim();
  if (!q) { chatRenderThreadList(_chatThreads); return; }
  const filtered = _chatThreads.filter(function(t) {
    if (t.title.toLowerCase().indexOf(q) >= 0) return true;
    const tags = t.tags || [];
    for (let i = 0; i < tags.length; i++) {
      if (tags[i].toLowerCase().indexOf(q) >= 0) return true;
    }
    return false;
  });
  chatRenderThreadList(filtered);
}


// ═══════════════════════════════════════════════════════════════
// Feature 3 — Thread Selection + Messages
// ═══════════════════════════════════════════════════════════════

async function chatSelectThread(threadId) {
  _chatSelectedThread = threadId;
  contentUpdateHash();

  // Mark this thread as seen
  _chatMarkThreadSeen(threadId);

  chatRenderThreadList(_chatThreads);

  const header = document.getElementById('chat-thread-header');
  let thread = null;
  for (let i = 0; i < _chatThreads.length; i++) {
    if (_chatThreads[i].thread_id === threadId) { thread = _chatThreads[i]; break; }
  }
  if (header && thread) {
    let tagsHtml = '';
    const threadTags = thread.tags || [];
    for (let j = 0; j < threadTags.length; j++) {
      tagsHtml += '<span class="chat-header-tag">' + esc(threadTags[j]) + '</span>';
    }
    const anchorHtml = thread.anchor_run
      ? '<span class="chat-header-anchor">&#x1F517; ' + esc(thread.anchor_run) + '</span>' : '';

    header.innerHTML = '<div class="chat-conv-header-row">'
      + '<h3 class="chat-conv-title">' + esc(thread.title) + '</h3>'
      + tagsHtml + anchorHtml
      + '<span class="chat-header-meta">by ' + esc(thread.created_by)
      + ' &middot; ' + _chatRelativeTime(thread.created_at) + '</span>'
      + '</div>';
  }
  await chatLoadMessages(threadId);
}

// ── Seen / Unseen helpers (localStorage) ───────────────────────────
const _CHAT_SEEN_KEY = 'scp-chat-seen-counts';

function _chatGetSeenCounts() {
  try {
    return JSON.parse(localStorage.getItem(_CHAT_SEEN_KEY) || '{}');
  } catch(e) { return {}; }
}

function _chatMarkThreadSeen(threadId) {
  // Find current message count for this thread
  var count = 0;
  for (var i = 0; i < _chatThreads.length; i++) {
    if (_chatThreads[i].thread_id === threadId) {
      count = _chatThreads[i].message_count || 0;
      break;
    }
  }
  var seen = _chatGetSeenCounts();
  seen[threadId] = count;
  try { localStorage.setItem(_CHAT_SEEN_KEY, JSON.stringify(seen)); } catch(e) {}
}

async function chatLoadMessages(threadId) {
  const container = document.getElementById('chat-messages');
  if (!container) return;
  container.innerHTML = '<div class="chat-empty">'
    + '<span class="spinner"></span>'
    + '<p>Loading messages...</p>'
    + '</div>';
  try {
    const data = await api('/chat/messages?thread_id=' + encodeURIComponent(threadId) + '&n=100');
    _chatMessages = data.messages || [];
    chatRenderMessages();
    // Start auto-polling every 10s while viewing this thread
    _chatStartPoll();
  } catch (e) {
    container.innerHTML = '<div class="chat-empty">'
      + '<p style="color:var(--error)">&amp;#x26A0; ' + esc(e.message) + '</p>'
      + '</div>';
    _chatStopPoll();
  }
}


// ═══════════════════════════════════════════════════════════════
// Feature 4 — Message Rendering
// ═══════════════════════════════════════════════════════════════

function chatRenderMessages() {
  const container = document.getElementById('chat-messages');
  if (!container) return;
  let messages = _chatMessages;
  if (_chatSourceFilter !== 'all') {
    messages = messages.filter(function(m) { return m.source === _chatSourceFilter; });
  }
  messages = messages.slice().sort(function(a, b) {
    const cmp = (a.ts || '').localeCompare(b.ts || '');
    return _chatSortNewest ? -cmp : cmp;
  });
  if (messages.length === 0) {
    const filterActive = _chatSourceFilter !== 'all';
    container.innerHTML = '<div class="chat-empty">'
      + '<span class="chat-empty-icon">' + (filterActive ? '&#x1F50D;' : '&#x270D;&#xFE0F;') + '</span>'
      + '<p>' + (filterActive
          ? 'No <strong>' + _chatSourceFilter + '</strong> messages in this thread'
          : 'No messages yet &mdash; send the first one!') + '</p>'
      + '</div>';
    return;
  }
  let html = '';
  for (let i = 0; i < messages.length; i++) {
    html += _chatRenderBubble(messages[i]);
  }
  container.innerHTML = html;
  if (!_chatSortNewest) container.scrollTop = container.scrollHeight;
}

function _chatRenderBubble(msg) {
  const src = msg.source || 'manual';
  const isEnc = (msg.flags && msg.flags.encrypted) || false;
  const isPub = (msg.flags && msg.flags.publish) || false;
  const relTime = _chatRelativeTime(msg.ts);
  const escaped = esc(msg.text);
  const refs = _chatEmbedRefs(escaped);
  const displayText = refs.html;
  const mediaHtml = refs.mediaEmbeds;
  const srcLabels = {
    manual: '&#x1F464; Manual',
    trace:  '&#x1F4CB; Trace',
    system: '&#x2699;&#xFE0F; System'
  };
  const sourceLabel = srcLabels[src] || src;
  let badges = '<span class="chat-msg-badge ' + src + '">' + sourceLabel + '</span>';
  if (msg.trace_id) badges += '<span class="chat-msg-badge trace">trace</span>';
  if (isEnc) badges += '<span class="chat-msg-badge encrypted">&#x1F510; encrypted</span>';
  if (isPub) badges += '<span class="chat-msg-badge published">&#x1F310; published</span>';

  return '<div class="chat-message ' + src + '" data-msg-id="' + esc(msg.id) + '">'
    + '<div class="chat-msg-header">'
    + '<span class="chat-msg-avatar">' + (esc(msg.user || 'U'))[0].toUpperCase() + '</span>'
    + '<span class="chat-msg-user">' + esc(msg.user || 'Unknown')
    + (msg.hostname ? ' <span style="font-size:0.65rem;color:var(--text-muted);font-weight:400">@' + esc(msg.hostname) + '</span>' : '')
    + '</span>'
    + badges
    + '<span class="chat-msg-time">' + relTime + '</span>'
    + '<span class="chat-msg-actions">'
    + '<button class="chat-msg-action-btn" onclick="chatTogglePublish(\'' + esc(msg.id) + '\', ' + (isPub ? 'false' : 'true') + ')" title="' + (isPub ? 'Unpublish' : 'Publish') + '">'
    + (isPub ? '&#x1F310;' : '&#x1F311;') + '</button>'
    + '<button class="chat-msg-action-btn" onclick="chatToggleEncrypt(\'' + esc(msg.id) + '\', ' + (isEnc ? 'false' : 'true') + ')" title="' + (isEnc ? 'Decrypt' : 'Encrypt') + '">'
    + (isEnc ? '&#x1F513;' : '&#x1F512;') + '</button>'
    + '<button class="chat-msg-delete-btn" onclick="chatConfirmDelete(\'' + esc(msg.id) + '\')" title="Delete message">&#x1F5D1;&#xFE0F;</button>'
    + '</span>'
    + '</div>'
    + '<div class="chat-msg-body">' + displayText + '</div>'
    + mediaHtml
    + '</div>';
}


// ═══════════════════════════════════════════════════════════════
// Feature 4b — Delete Message
// ═══════════════════════════════════════════════════════════════

function chatConfirmDelete(msgId) {
  var delBody = '<p style="color:var(--text-secondary)">'
    + 'Are you sure you want to delete this message?'
    + ' This cannot be undone.</p>';
  var delClick = "chatDoDelete('" + esc(msgId) + "')";
  modalOpen({
    title: '\uD83D\uDDD1\uFE0F Delete Message',
    body: delBody,
    footerButtons: [
      { label: 'Cancel', cls: 'btn-ghost', onclick: 'modalClose()' },
      { label: 'Delete', cls: 'btn-primary', style: 'background:var(--error)', onclick: delClick },
    ],
  });
}

async function chatDoDelete(msgId) {
  try {
    const resp = await api('/chat/delete-message', {
      method: 'POST',
      body: JSON.stringify({
        thread_id: _chatSelectedThread,
        message_id: msgId,
      }),
    });
    modalClose();
    if (resp.deleted) {
      toast('Message deleted', 'success');
      chatSelectThread(_chatSelectedThread);
    } else {
      toast('Message not found', 'warning');
    }
  } catch (e) {
    modalClose();
    toast('Delete failed: ' + e.message, 'error');
  }
}


// ═══════════════════════════════════════════════════════════════
// Feature 4c — Delete Thread
// ═══════════════════════════════════════════════════════════════

function chatConfirmDeleteThread(threadId, threadTitle) {
  var delBody = '<p style="color:var(--text-secondary);margin-bottom:1rem">'
    + 'You are about to permanently delete the thread <strong>"' + esc(threadTitle) + '"</strong> '
    + 'and all its messages. This cannot be undone.</p>'
    + '<label style="display:block;margin-bottom:0.5rem;color:var(--text-muted);font-size:0.85rem">'
    + 'Type <strong>CONFIRM</strong> to proceed:</label>'
    + '<input type="text" id="chat-delete-thread-confirm" '
    + 'style="width:100%;padding:0.5rem;border:1px solid var(--border);border-radius:6px;'
    + 'background:var(--bg-secondary);color:var(--text-primary);font-size:0.9rem" '
    + 'autocomplete="off" spellcheck="false" '
    + 'oninput="_chatDeleteThreadValidate()" '
    + 'placeholder="Type CONFIRM here">';

  modalOpen({
    title: '\u26A0\uFE0F Delete Thread',
    body: delBody,
    footerButtons: [
      { label: 'Cancel', cls: 'btn-ghost', onclick: 'modalClose()' },
      { label: 'Delete Thread', cls: 'btn-primary', style: 'background:var(--error);opacity:0.5;pointer-events:none',
        id: 'chat-delete-thread-btn',
        onclick: "chatDoDeleteThread('" + esc(threadId) + "')" },
    ],
  });

  // Focus the input after modal renders
  setTimeout(function() {
    var inp = document.getElementById('chat-delete-thread-confirm');
    if (inp) inp.focus();
  }, 100);
}

function _chatDeleteThreadValidate() {
  var inp = document.getElementById('chat-delete-thread-confirm');
  var btn = document.getElementById('chat-delete-thread-btn');
  if (!inp || !btn) return;
  if (inp.value.trim() === 'CONFIRM') {
    btn.style.opacity = '1';
    btn.style.pointerEvents = 'auto';
  } else {
    btn.style.opacity = '0.5';
    btn.style.pointerEvents = 'none';
  }
}

async function chatDoDeleteThread(threadId) {
  try {
    const resp = await apiPost('/chat/delete-thread', {
      thread_id: threadId,
    });
    modalClose();
    if (resp.deleted) {
      toast('Thread deleted', 'success');
      _chatSelectedThread = null;
      _chatMessages = [];
      _chatStopPoll();

      // Clear the right-side panes immediately
      var msgPane = document.getElementById('chat-messages');
      if (msgPane) msgPane.innerHTML = '<div class="chat-empty"><p>Select a thread to view messages</p></div>';
      var header = document.getElementById('chat-thread-header');
      if (header) header.innerHTML = '';
      var compose = document.getElementById('chat-compose');
      if (compose) compose.style.display = 'none';

      await chatLoadThreads();
    } else {
      toast('Thread not found', 'warning');
    }
  } catch (e) {
    modalClose();
    toast('Delete failed: ' + e.message, 'error');
  }
}

// ═══════════════════════════════════════════════════════════════
// Feature 5 — Compose + Send
// ═══════════════════════════════════════════════════════════════

function chatOnInput(textarea) {
  textarea.style.height = 'auto';
  textarea.style.height = Math.min(textarea.scrollHeight, 200) + 'px';
  if (typeof chatCheckRefTrigger === 'function') {
    chatCheckRefTrigger(textarea.value, textarea.selectionStart);
  }
}

function chatOnKeydown(event) {
  if ((event.ctrlKey || event.metaKey) && event.key === 'Enter') {
    event.preventDefault();
    chatSendMessage();
    return;
  }
  if (typeof chatRefKeydown === 'function') {
    chatRefKeydown(event);
  }
}

async function chatSendMessage() {
  const input = document.getElementById('chat-compose-input');
  const status = document.getElementById('chat-compose-status');
  const sendBtn = document.getElementById('chat-send-btn');
  if (!input) return;
  const text = input.value.trim();
  if (!text) return;
  if (!_chatSelectedThread) {
    if (status) {
      status.textContent = 'Select a thread first';
      status.className = 'chat-compose-status warning';
    }
    return;
  }
  sendBtn.disabled = true;
  if (status) {
    status.textContent = 'Sending...';
    status.className = 'chat-compose-status';
  }
  const encCb = document.getElementById('chat-encrypt-cb');
  const encrypt = encCb ? encCb.checked : false;
  try {
    const pubCb = document.getElementById('chat-publish-cb');
    const publish = pubCb ? pubCb.checked : false;
    const msg = await api('/chat/send', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        text: text,
        thread_id: _chatSelectedThread,
        encrypt: encrypt,
        publish: publish,
        source: 'manual'
      })
    });
    _chatMessages.unshift(msg);
    chatRenderMessages();
    input.value = '';
    input.style.height = 'auto';
    if (status) {
      status.textContent = '\u2714 Sent';
      status.className = 'chat-compose-status success';
    }
    setTimeout(function() {
      if (status) {
        status.textContent = '';
        status.className = 'chat-compose-status';
      }
    }, 2000);
    const popup = document.getElementById('chat-ref-popup');
    if (popup) popup.style.display = 'none';
  } catch (e) {
    if (status) {
      status.textContent = '&#x26A0; ' + e.message;
      status.className = 'chat-compose-status error';
    }
  } finally {
    sendBtn.disabled = false;
  }
}


// ═══════════════════════════════════════════════════════════════
// Feature 6 — Filters + Sort
// ═══════════════════════════════════════════════════════════════

function chatFilterBySource(source) {
  _chatSourceFilter = source;
  document.querySelectorAll('.chat-source-filter').forEach(function(btn) {
    if (btn.dataset.source === source) btn.classList.add('active');
    else btn.classList.remove('active');
  });
  chatRenderMessages();
}

function chatToggleSort() {
  _chatSortNewest = !_chatSortNewest;
  const sortBtn = document.getElementById('chat-sort-icon');
  if (sortBtn && sortBtn.parentElement) {
    sortBtn.parentElement.innerHTML = '<span id="chat-sort-icon">'
      + (_chatSortNewest ? '&#x2B07;' : '&#x2B06;') + '</span> '
      + (_chatSortNewest ? 'Newest first' : 'Oldest first');
  }
  chatRenderMessages();
}


// ═══════════════════════════════════════════════════════════════
// Feature 7 — Thread Creation
// ═══════════════════════════════════════════════════════════════

function chatShowNewThread() {
  const modal = document.getElementById('chat-new-thread-modal');
  if (modal) {
    modal.classList.add('visible');
    const ti = document.getElementById('chat-new-thread-title');
    if (ti) { ti.value = ''; ti.focus(); }
    const tg = document.getElementById('chat-new-thread-tags');
    if (tg) tg.value = '';
  }
}

function chatCloseNewThread() {
  const modal = document.getElementById('chat-new-thread-modal');
  if (modal) modal.classList.remove('visible');
}

async function chatCreateThread() {
  const ti = document.getElementById('chat-new-thread-title');
  const tg = document.getElementById('chat-new-thread-tags');
  const title = ti ? ti.value.trim() : '';
  if (!title) {
    toast('Thread title is required', 'warning');
    return;
  }
  const tags = (tg ? tg.value : '').split(',').map(function(s) {
    return s.trim();
  }).filter(Boolean);
  try {
    const thread = await api('/chat/threads/create', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ title: title, tags: tags })
    });
    chatCloseNewThread();
    _chatThreads.unshift(thread);
    chatRenderThreadList(_chatThreads);
    chatSelectThread(thread.thread_id);
    toast('Thread created', 'success');
  } catch (e) {
    toast('Failed: ' + e.message, 'error');
  }
}


// ═══════════════════════════════════════════════════════════════
// Feature 8 — Sync
// ═══════════════════════════════════════════════════════════════

async function chatSync(action) {
  try {
    toast('Syncing chat...', 'info');
    const result = await api('/chat/sync', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ action: action })
    });
    const parts = [];
    if (result.pushed) parts.push('pushed');
    if (result.pulled) parts.push('pulled');
    if (parts.length > 0) toast('Chat ' + parts.join(' & '), 'success');
    else toast('Nothing to sync', 'info');
    await chatLoadThreads();
    // Restart auto-poll after manual sync/reconnect
    if (_chatSelectedThread) _chatStartPoll();
  } catch (e) {
    toast('Sync failed: ' + e.message, 'error');
    _chatStopPoll();
  }
}


// ═══════════════════════════════════════════════════════════════
// Feature 9 — Utilities
// ═══════════════════════════════════════════════════════════════

function _chatRelativeTime(isoString) {
  if (!isoString) return '';
  try {
    const d = new Date(isoString);
    const now = new Date();
    const diffMs = now - d;
    const diffSec = Math.floor(diffMs / 1000);
    const diffMin = Math.floor(diffSec / 60);
    const diffHr  = Math.floor(diffMin / 60);
    const diffDay = Math.floor(diffHr / 24);
    if (diffSec < 60) return 'just now';
    if (diffMin < 60) return diffMin + 'm ago';
    if (diffHr  < 24) return diffHr + 'h ago';
    if (diffDay < 30) return diffDay + 'd ago';
    return d.toLocaleDateString();
  } catch (ex) {
    return isoString;
  }
}

function chatToggleEncryptHint(on) {
  const textarea = document.getElementById('chat-compose-input');
  if (!textarea) return;
  if (on) {
    textarea.style.borderColor = 'var(--warning, #f59e0b)';
    textarea.style.boxShadow = '0 0 0 1px var(--warning, #f59e0b)';
    textarea.placeholder = '\uD83D\uDD10 Encrypted message... Use @ for references';
  } else {
    textarea.style.borderColor = '';
    textarea.style.boxShadow = '';
    textarea.placeholder = 'Type a message... Use @ for references';
  }
}

async function chatTogglePublish(msgId, newValue) {
  try {
    const updated = await api('/chat/update-message', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        thread_id: _chatSelectedThread,
        message_id: msgId,
        publish: newValue,
      })
    });
    // Update in-memory
    for (var i = 0; i < _chatMessages.length; i++) {
      if (_chatMessages[i].id === msgId) {
        _chatMessages[i] = updated;
        break;
      }
    }
    chatRenderMessages();
    toast(newValue ? '\uD83C\uDF10 Published' : 'Unpublished', 'success');
  } catch (e) {
    toast('Failed: ' + e.message, 'error');
  }
}

async function chatToggleEncrypt(msgId, newValue) {
  try {
    const updated = await api('/chat/update-message', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        thread_id: _chatSelectedThread,
        message_id: msgId,
        encrypt: newValue,
      })
    });
    // Update in-memory
    for (var i = 0; i < _chatMessages.length; i++) {
      if (_chatMessages[i].id === msgId) {
        _chatMessages[i] = updated;
        break;
      }
    }
    chatRenderMessages();
    toast(newValue ? '\uD83D\uDD10 Encrypted' : '\uD83D\uDD13 Decrypted', 'success');
  } catch (e) {
    toast('Failed: ' + e.message, 'error');
  }
}
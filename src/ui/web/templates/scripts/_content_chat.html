// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// _content_chat.html
// Content Vault â€” Chat Panel (Threads + Messages + Compose)
// Included by: _content.html (Jinja2 include)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function _chatCleanup() {
const popup = document.getElementById('chat-ref-popup');
if (popup) popup.style.display = 'none';
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Feature 1 â€” Panel Layout (renderChatPanel)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function renderChatPanel() {
const browser = document.getElementById('content-chat-panel');

browser.innerHTML = `
<div class="chat-panel">

    <!-- LEFT: Thread sidebar card -->
    <div class="chat-sidebar-card">
        <div class="chat-sidebar-header">
            <span class="chat-sidebar-title">Threads</span>
            <div class="chat-sidebar-actions">
                <button class="btn btn-primary btn-sm" onclick="chatShowNewThread()" title="New thread">+ New</button>
                <button class="btn btn-secondary btn-sm" onclick="chatSync('both')"
                    title="Sync with remote">&#x1F504;</button>
            </div>
        </div>
        <div class="chat-search-wrap">
            <input type="text" id="chat-thread-search" class="chat-search-input"
                placeholder="&#x1F50D; Search threads..." oninput="chatFilterThreads(this.value)">
        </div>
        <div id="chat-thread-list" class="chat-thread-list">
            <div class="chat-empty">
                <span class="spinner"></span>
                <p>Loading threads...</p>
            </div>
        </div>
    </div>

    <!-- RIGHT: Conversation area -->
    <div class="chat-conversation">

        <!-- Thread header -->
        <div id="chat-thread-header" class="chat-conv-header">
            <div class="chat-conv-placeholder">
                <span class="chat-conv-placeholder-icon">&#x1F4AC;</span>
                <span>Select a thread to start chatting</span>
            </div>
        </div>

        <!-- Source filter bar -->
        <div class="chat-filter-bar">
            <div class="chat-filters">
                <button class="chat-source-filter active" data-source="all"
                    onclick="chatFilterBySource('all')">All</button>
                <button class="chat-source-filter" data-source="manual" onclick="chatFilterBySource('manual')">&#x1F464;
                    Manual</button>
                <button class="chat-source-filter" data-source="trace" onclick="chatFilterBySource('trace')">&#x1F4CB;
                    Trace</button>
                <button class="chat-source-filter" data-source="system"
                    onclick="chatFilterBySource('system')">&#x2699;&#xFE0F; System</button>
            </div>
            <span style="flex:1"></span>
            <button class="btn btn-secondary btn-sm chat-sort-btn" onclick="chatToggleSort()" title="Toggle sort order">
                <span id="chat-sort-icon">&#x2B07;</span> Newest first
            </button>
        </div>

        <!-- Messages area -->
        <div id="chat-messages" class="chat-messages">
            <div class="chat-empty">
                <span class="chat-empty-icon">&#x1F4AC;</span>
                <p>Select a thread to view messages</p>
            </div>
        </div>

        <!-- Compose area -->
        <div class="chat-compose">
            <div class="chat-compose-wrap">
                <textarea id="chat-compose-input" class="chat-textarea" rows="2"
                    placeholder="Type a message... Use @ for references" oninput="chatOnInput(this)"
                    onkeydown="chatOnKeydown(event)"></textarea>
                <div id="chat-ref-popup" class="chat-ref-popup"></div>
            </div>
            <div class="chat-compose-footer">
                <label class="chat-encrypt-label">
                    <input type="checkbox" id="chat-encrypt-cb"> &#x1F512; Encrypt
                </label>
                <span style="flex:1"></span>
                <span id="chat-compose-status" class="chat-compose-status"></span>
                <button class="btn btn-primary btn-sm chat-send-btn" onclick="chatSendMessage()" id="chat-send-btn">Send
                    &#x2192;</button>
            </div>
        </div>

    </div>
</div>

<!-- New thread modal -->
<div id="chat-new-thread-modal" class="chat-modal-overlay">
    <div class="chat-modal">
        <h3>&#x1F4AC; New Thread</h3>
        <div class="form-group">
            <label>Title</label>
            <input type="text" id="chat-new-thread-title" placeholder="Thread title">
        </div>
        <div class="form-group">
            <label>Tags (comma-separated)</label>
            <input type="text" id="chat-new-thread-tags" placeholder="deploy, staging">
        </div>
        <div class="chat-modal-actions">
            <button class="btn btn-secondary btn-sm" onclick="chatCloseNewThread()">Cancel</button>
            <button class="btn btn-primary btn-sm" onclick="chatCreateThread()">Create Thread</button>
        </div>
    </div>
</div>
`;

await chatLoadThreads();
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Feature 2 â€” Thread List
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function chatLoadThreads() {
const list = document.getElementById('chat-thread-list');
if (!list) return;
try {
const data = await api('/chat/threads');
_chatThreads = data.threads || [];
_chatLoaded = true;
chatRenderThreadList(_chatThreads);
if (_chatSelectedThread) {
chatSelectThread(_chatSelectedThread);
} else if (_chatThreads.length > 0) {
let gen = null;
for (let i = 0; i < _chatThreads.length; i++) { if (_chatThreads[i].title==='General' ) { gen=_chatThreads[i]; break; }
    } chatSelectThread(gen ? gen.thread_id : _chatThreads[0].thread_id); } } catch (e) { list.innerHTML=`<div
    class="chat-empty">
    <span class="chat-empty-icon">&#x1F4AD;</span>
    <p>No chat threads yet</p>
    <p class="chat-empty-sub">${esc(e.message || 'Could not load threads')}</p>
    <button class="btn btn-primary btn-sm" onclick="chatShowNewThread()" style="margin-top:0.75rem">+ Create First
        Thread</button>
    </div>`;
    }
    }

    function chatRenderThreadList(threads) {
    const list = document.getElementById('chat-thread-list');
    if (!list) return;
    if (threads.length === 0) {
    list.innerHTML = `<div class="chat-empty">
        <span class="chat-empty-icon">&#x1F4AD;</span>
        <p>No threads yet</p>
        <button class="btn btn-primary btn-sm" onclick="chatShowNewThread()" style="margin-top:0.75rem">+ Create First
            Thread</button>
    </div>`;
    return;
    }
    let html = '';
    for (let i = 0; i < threads.length; i++) { const t=threads[i]; const isActive=t.thread_id===_chatSelectedThread;
        const isGeneral=t.title==='General' ; const icon=isGeneral ? '&#x1F4CC;' : (t.anchor_run ? '&#x1F517;'
        : '&#x1F4AC;' ); const relTime=_chatRelativeTime(t.created_at); const msgCount=t.message_count || 0; let
        tagBadges='' ; const tags=(t.tags || []).slice(0, 3); for (let j=0; j < tags.length; j++) { tagBadges +=`<span
        class="chat-thread-tag">${esc(tags[j])}</span>`;
        }
        const cls = 'chat-thread-item' + (isActive ? ' active' : '');

        html += `<div class="${cls}" data-thread-id="${esc(t.thread_id)}"
            onclick="chatSelectThread(this.dataset.threadId)">
            <div class="chat-thread-row1">
                <span class="chat-thread-icon">${icon}</span>
                <span class="chat-thread-title">${esc(t.title)}</span>
                <span class="chat-thread-time">${relTime}</span>
            </div>`;

            if (tags.length > 0 || msgCount > 0) {
            html += `<div class="chat-thread-row2">
                ${tagBadges}`;
                if (msgCount > 0) {
                html += `<span class="chat-thread-count">${msgCount} msg${msgCount !== 1 ? 's' : ''}</span>`;
                }
                html += `</div>`;
            }
            html += `
        </div>`;
        }
        list.innerHTML = html;
        }

        function chatFilterThreads(query) {
        if (!_chatThreads) return;
        const q = query.toLowerCase().trim();
        if (!q) { chatRenderThreadList(_chatThreads); return; }
        const filtered = _chatThreads.filter(function(t) {
        if (t.title.toLowerCase().indexOf(q) >= 0) return true;
        const tags = t.tags || [];
        for (let i = 0; i < tags.length; i++) { if (tags[i].toLowerCase().indexOf(q)>= 0) return true;
            }
            return false;
            });
            chatRenderThreadList(filtered);
            }


            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // Feature 3 â€” Thread Selection + Messages
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            async function chatSelectThread(threadId) {
            _chatSelectedThread = threadId;
            contentUpdateHash();
            chatRenderThreadList(_chatThreads);

            const header = document.getElementById('chat-thread-header');
            let thread = null;
            for (let i = 0; i < _chatThreads.length; i++) { if (_chatThreads[i].thread_id===threadId) {
                thread=_chatThreads[i]; break; } } if (header && thread) { let tagsHtml='' ; const
                threadTags=thread.tags || []; for (let j=0; j < threadTags.length; j++) { tagsHtml +=`<span
                class="chat-header-tag">${esc(threadTags[j])}</span>`;
                }
                const anchorHtml = thread.anchor_run
                ? `<span class="chat-header-anchor">&#x1F517; ${esc(thread.anchor_run)}</span>` : '';

                header.innerHTML = `<div class="chat-conv-header-row">
                    <h3 class="chat-conv-title">${esc(thread.title)}</h3>
                    ${tagsHtml}
                    ${anchorHtml}
                    <span class="chat-header-meta">by ${esc(thread.created_by)}
                        &middot; ${_chatRelativeTime(thread.created_at)}</span>
                </div>`;
                }
                await chatLoadMessages(threadId);
                }

                async function chatLoadMessages(threadId) {
                const container = document.getElementById('chat-messages');
                if (!container) return;
                container.innerHTML = `<div class="chat-empty">
                    <span class="spinner"></span>
                    <p>Loading messages...</p>
                </div>`;
                try {
                const data = await api('/chat/messages?thread_id=' + encodeURIComponent(threadId) + '&n=100');
                _chatMessages = data.messages || [];
                chatRenderMessages();
                } catch (e) {
                container.innerHTML = `<div class="chat-empty">
                    <p style="color:var(--error)">&#x26A0; ${esc(e.message)}</p>
                </div>`;
                }
                }


                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // Feature 4 â€” Message Rendering
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

                function chatRenderMessages() {
                const container = document.getElementById('chat-messages');
                if (!container) return;
                let messages = _chatMessages;
                if (_chatSourceFilter !== 'all') {
                messages = messages.filter(function(m) { return m.source === _chatSourceFilter; });
                }
                messages = messages.slice().sort(function(a, b) {
                const cmp = (a.ts || '').localeCompare(b.ts || '');
                return _chatSortNewest ? -cmp : cmp;
                });
                if (messages.length === 0) {
                const filterActive = _chatSourceFilter !== 'all';
                container.innerHTML = `<div class="chat-empty">
                    <span class="chat-empty-icon">${filterActive ? '&#x1F50D;' : '&#x270D;&#xFE0F;'}</span>
                    <p>${filterActive
                        ? 'No <strong>' + _chatSourceFilter + '</strong> messages in this thread'
                        : 'No messages yet &mdash; send the first one!'}</p>
                </div>`;
                return;
                }
                let html = '';
                for (let i = 0; i < messages.length; i++) { html +=_chatRenderBubble(messages[i]); }
                    container.innerHTML=html; if (!_chatSortNewest) container.scrollTop=container.scrollHeight; }
                    function _chatRenderBubble(msg) { const src=msg.source || 'manual' ; const isEnc=msg.encrypted ||
                    false; const relTime=_chatRelativeTime(msg.ts); const escaped=esc(msg.text); const
                    refs=_chatEmbedRefs(escaped); const displayText=refs.html; const mediaHtml=refs.mediaEmbeds; const
                    srcLabels={ manual: '&#x1F464; Manual' , trace: '&#x1F4CB; Trace' ,
                    system: '&#x2699;&#xFE0F; System' }; const sourceLabel=srcLabels[src] || src; let badges=`<span
                    class="chat-msg-badge ${src}">
                    ${sourceLabel}</span>`;
                    if (msg.trace_id) badges += `<span class="chat-msg-badge trace">trace</span>`;
                    if (isEnc) badges += `<span class="chat-msg-badge encrypted">&#x1F510; encrypted</span>`;

                    return `<div class="chat-message ${src}" data-msg-id="${esc(msg.id)}">
                        <div class="chat-msg-header">
                            <span class="chat-msg-avatar">${(esc(msg.user || 'U'))[0].toUpperCase()}</span>
                            <span class="chat-msg-user">${esc(msg.user || 'Unknown')}</span>
                            ${badges}
                            <span class="chat-msg-time">${relTime}</span>
                            <span class="chat-msg-actions">
                                <button class="chat-msg-delete-btn" onclick="chatConfirmDelete('${esc(msg.id)}')"
                                    title="Delete message">ğŸ—‘ï¸</button>
                            </span>
                        </div>
                        <div class="chat-msg-body">${displayText}</div>
                        ${mediaHtml}
                    </div>`;
                    }

                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // Feature 4b â€” Delete Message
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

                    function chatConfirmDelete(msgId) {
                    var delBody = '<p style="color:var(--text-secondary)">'
                        + 'Are you sure you want to delete this message?'
                        + ' This cannot be undone.</p>';
                    var delClick = "chatDoDelete('" + esc(msgId) + "')";
                    modalOpen({
                    title: '\u{1F5D1}\uFE0F Delete Message',
                    body: delBody,
                    footerButtons: [
                    { label: 'Cancel', cls: 'btn-ghost',
                    onclick: 'modalClose()' },
                    { label: 'Delete', cls: 'btn-primary',
                    style: 'background:var(--error)',
                    onclick: delClick },
                    ],
                    });
                    }

                    async function chatDoDelete(msgId) {
                    try {
                    const resp = await api('/chat/delete-message', {
                    method: 'POST',
                    body: JSON.stringify({
                    thread_id: _chatSelectedThread,
                    message_id: msgId,
                    }),
                    });
                    modalClose();
                    if (resp.deleted) {
                    toast('Message deleted', 'success');
                    chatSelectThread(_chatSelectedThread);
                    } else {
                    toast('Message not found', 'warning');
                    }
                    } catch (e) {
                    modalClose();
                    toast('Delete failed: ' + e.message, 'error');
                    }
                    }


                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // Feature 5 â€” Compose + Send
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

                    function chatOnInput(textarea) {
                    textarea.style.height = 'auto';
                    textarea.style.height = Math.min(textarea.scrollHeight, 200) + 'px';
                    if (typeof chatCheckRefTrigger === 'function') {
                    chatCheckRefTrigger(textarea.value, textarea.selectionStart);
                    }
                    }

                    function chatOnKeydown(event) {
                    if ((event.ctrlKey || event.metaKey) && event.key === 'Enter') {
                    event.preventDefault();
                    chatSendMessage();
                    return;
                    }
                    if (typeof chatRefKeydown === 'function') {
                    chatRefKeydown(event);
                    }
                    }

                    async function chatSendMessage() {
                    const input = document.getElementById('chat-compose-input');
                    const status = document.getElementById('chat-compose-status');
                    const sendBtn = document.getElementById('chat-send-btn');
                    if (!input) return;
                    const text = input.value.trim();
                    if (!text) return;
                    if (!_chatSelectedThread) {
                    if (status) {
                    status.textContent = 'Select a thread first';
                    status.className = 'chat-compose-status warning';
                    }
                    return;
                    }
                    sendBtn.disabled = true;
                    if (status) {
                    status.textContent = 'Sending...';
                    status.className = 'chat-compose-status';
                    }
                    const encCb = document.getElementById('chat-encrypt-cb');
                    const encrypt = encCb ? encCb.checked : false;
                    try {
                    const msg = await api('/chat/send', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                    text: text,
                    thread_id: _chatSelectedThread,
                    encrypt: encrypt,
                    source: 'manual'
                    })
                    });
                    _chatMessages.unshift(msg);
                    chatRenderMessages();
                    input.value = '';
                    input.style.height = 'auto';
                    if (status) {
                    status.textContent = '&#x2714; Sent';
                    status.className = 'chat-compose-status success';
                    }
                    setTimeout(function() {
                    if (status) {
                    status.textContent = '';
                    status.className = 'chat-compose-status';
                    }
                    }, 2000);
                    const popup = document.getElementById('chat-ref-popup');
                    if (popup) popup.style.display = 'none';
                    } catch (e) {
                    if (status) {
                    status.textContent = '&#x26A0; ' + e.message;
                    status.className = 'chat-compose-status error';
                    }
                    } finally {
                    sendBtn.disabled = false;
                    }
                    }


                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // Feature 6 â€” Filters + Sort
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

                    function chatFilterBySource(source) {
                    _chatSourceFilter = source;
                    document.querySelectorAll('.chat-source-filter').forEach(function(btn) {
                    if (btn.dataset.source === source) btn.classList.add('active');
                    else btn.classList.remove('active');
                    });
                    chatRenderMessages();
                    }

                    function chatToggleSort() {
                    _chatSortNewest = !_chatSortNewest;
                    const sortBtn = document.getElementById('chat-sort-icon');
                    if (sortBtn && sortBtn.parentElement) {
                    sortBtn.parentElement.innerHTML = `<span id="chat-sort-icon">${_chatSortNewest ? '&#x2B07;' :
                        '&#x2B06;'}</span> ${_chatSortNewest ? 'Newest first' : 'Oldest first'}`;
                    }
                    chatRenderMessages();
                    }


                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // Feature 7 â€” Thread Creation
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

                    function chatShowNewThread() {
                    const modal = document.getElementById('chat-new-thread-modal');
                    if (modal) {
                    modal.classList.add('visible');
                    const ti = document.getElementById('chat-new-thread-title');
                    if (ti) { ti.value = ''; ti.focus(); }
                    const tg = document.getElementById('chat-new-thread-tags');
                    if (tg) tg.value = '';
                    }
                    }

                    function chatCloseNewThread() {
                    const modal = document.getElementById('chat-new-thread-modal');
                    if (modal) modal.classList.remove('visible');
                    }

                    async function chatCreateThread() {
                    const ti = document.getElementById('chat-new-thread-title');
                    const tg = document.getElementById('chat-new-thread-tags');
                    const title = ti ? ti.value.trim() : '';
                    if (!title) {
                    toast('Thread title is required', 'warning');
                    return;
                    }
                    const tags = (tg ? tg.value : '').split(',').map(function(s) {
                    return s.trim();
                    }).filter(Boolean);
                    try {
                    const thread = await api('/chat/threads/create', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ title: title, tags: tags })
                    });
                    chatCloseNewThread();
                    _chatThreads.unshift(thread);
                    chatRenderThreadList(_chatThreads);
                    chatSelectThread(thread.thread_id);
                    toast('Thread created', 'success');
                    } catch (e) {
                    toast('Failed: ' + e.message, 'error');
                    }
                    }


                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // Feature 8 â€” Sync
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

                    async function chatSync(action) {
                    try {
                    toast('Syncing chat...', 'info');
                    const result = await api('/chat/sync', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ action: action })
                    });
                    const parts = [];
                    if (result.pushed) parts.push('pushed');
                    if (result.pulled) parts.push('pulled');
                    if (parts.length > 0) toast('Chat ' + parts.join(' & '), 'success');
                    else toast('Nothing to sync', 'info');
                    await chatLoadThreads();
                    } catch (e) {
                    toast('Sync failed: ' + e.message, 'error');
                    }
                    }


                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // Feature 9 â€” Utilities
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

                    function _chatRelativeTime(isoString) {
                    if (!isoString) return '';
                    try {
                    const d = new Date(isoString);
                    const now = new Date();
                    const diffMs = now - d;
                    const diffSec = Math.floor(diffMs / 1000);
                    const diffMin = Math.floor(diffSec / 60);
                    const diffHr = Math.floor(diffMin / 60);
                    const diffDay = Math.floor(diffHr / 24);
                    if (diffSec < 60) return 'just now' ; if (diffMin < 60) return diffMin + 'm ago' ; if (diffHr < 24)
                        return diffHr + 'h ago' ; if (diffDay < 30) return diffDay + 'd ago' ; return
                        d.toLocaleDateString(); } catch (ex) { return isoString; } }
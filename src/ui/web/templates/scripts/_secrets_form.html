    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    //  _secrets_form.html
    //  Target selector, dirty tracking, section collapse/rename, mark/unmark deletion
    //  Included by: _secrets.html (Jinja2 include)
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€




    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  Target selector & dirty tracking
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    function selectTarget(target) {
        currentTarget = target;
        document.querySelectorAll('.target-btn').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.target === target);
        });
        const btn = document.getElementById('save-secrets-btn');
        if (btn) {
            const labels = { both: 'ğŸ’¾ Save & Push', local: 'ğŸ“ Save', github: 'â˜ï¸ Push' };
            btn.textContent = labels[target];
        }
    }

    function checkSecretsDirty() {
        const fields = document.querySelectorAll('#secrets-form [data-secret-name]');
        let changed = 0;
        let deletionCount = 0;
        let changedNames = [];

        fields.forEach(el => {
            const name = el.dataset.secretName;
            const isMarkedDelete = el.dataset.markedDelete === 'true';
            // For toggle checkboxes, use checked state as the value
            const effectiveValue = el.dataset.metaToggle === 'true'
                ? (el.checked ? 'true' : 'false')
                : el.value;
            if (isMarkedDelete) {
                changed++;
                deletionCount++;
                changedNames.push(name);
            } else if (effectiveValue !== (secretsInitialValues[name] ?? '')) {
                changed++;
                changedNames.push(name);
            }
        });

        // Also count unsynced secrets (local â†’ GitHub)
        let unsyncedSecrets = 0, unsyncedVars = 0;
        for (const k of envKeys) {
            if (!k.has_value) continue;
            const t = getSecretTier(k.key, k);
            if (t === 'auto' || t === 'local') continue;
            if (t === 'secret' && !ghSecrets.includes(k.key.toUpperCase())) unsyncedSecrets++;
            if (t === 'var' && !ghVariables.includes(k.key.toUpperCase())) unsyncedVars++;
        }

        const hasAnythingToDo = changed > 0 || unsyncedSecrets > 0 || unsyncedVars > 0;
        secretsDirty = changed > 0;

        const saveBtn = document.getElementById('save-secrets-btn');
        if (saveBtn) {
            saveBtn.disabled = !hasAnythingToDo;
            saveBtn.title = hasAnythingToDo
                ? `${changed} change(s) pending`
                : 'No changes to save';
        }

        // Pending badge
        const badge = document.getElementById('sync-pending-badge');
        if (badge) {
            const parts = [];
            if (unsyncedSecrets > 0) parts.push(`${unsyncedSecrets} secret(s) not on GitHub`);
            if (unsyncedVars > 0) parts.push(`${unsyncedVars} variable(s) not on GitHub`);
            if (deletionCount > 0) parts.push(`${deletionCount} marked for deletion`);
            const modified = changed - deletionCount;
            if (modified > 0) parts.push(`${modified} value(s) modified`);

            if (parts.length > 0) {
                badge.textContent = 'âš ï¸ ' + parts.join(' Â· ');
                badge.title = parts.join('\n');
                badge.style.display = '';
            } else {
                badge.style.display = 'none';
            }
        }
    }


    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  Section collapsing
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    function toggleSecretSection(catId) {
        const section = document.getElementById(`secrets-section-${catId}`);
        const chevron = document.getElementById(`secrets-chevron-${catId}`);
        if (!section) return;
        const isNowCollapsed = section.style.display !== 'none';
        section.style.display = isNowCollapsed ? 'none' : 'block';
        if (chevron) chevron.style.transform = isNowCollapsed ? 'rotate(0deg)' : 'rotate(90deg)';
        sessionStorage.setItem(`secrets-collapse-${catId}`, isNowCollapsed ? 'true' : 'false');
    }

    async function renameSectionPrompt(oldName) {
        const newName = prompt(`Rename section "${oldName}":`, oldName);
        if (!newName || !newName.trim() || newName.trim() === oldName) return;

        try {
            await api(`/vault/rename-section${_envQS()}`, {
                method: 'POST',
                body: JSON.stringify({ old_name: oldName, new_name: newName.trim() }),
            });
            toast(`Section renamed: ${oldName} â†’ ${newName.trim()}`, 'success');
            secretsLoaded = false;
            await loadSecretsTab();
            selectTarget(currentTarget);
        } catch (e) {
            toast(`Failed to rename: ${e.message}`, 'error');
        }
    }


    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  Mark for deletion / undo
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    function markForDeletion(name) {
        const input = document.querySelector(`[data-secret-name="${name}"]`);
        if (!input) return;
        input.dataset.markedDelete = 'true';
        input.value = '';
        input.disabled = true;
        input.placeholder = 'ğŸ—‘ï¸ Will be deleted on Save';
        input.style.borderColor = 'var(--error)';
        input.style.opacity = '0.5';

        const row = input.closest('.secret-config-row');
        if (row) {
            const nameEl = row.querySelector('.secret-config-name');
            if (nameEl) nameEl.style.textDecoration = 'line-through';
            const localStatus = row.querySelectorAll('.secret-config-status')[0];
            if (localStatus) {
                localStatus.innerHTML = `
                    <div title="Marked for deletion" style="color:var(--error);">ğŸ—‘ï¸ Delete</div>
                    <button class="btn-icon" onclick="unmarkDeletion('${name}')" style="font-size:0.7rem;" title="Undo: keep ${name}">â†©ï¸</button>
                `;
            }
        }
        checkSecretsDirty();
    }

    function unmarkDeletion(name) {
        const input = document.querySelector(`[data-secret-name="${name}"]`);
        if (!input) return;
        delete input.dataset.markedDelete;
        input.disabled = false;
        input.style.borderColor = '';
        input.style.opacity = '';

        const isSecret = input.dataset.isSecret === 'true';
        const localSet = envData[name] && envData[name].length > 0;
        input.placeholder = localSet && isSecret ? 'â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢' : 'Enter valueâ€¦';
        if (!isSecret && localSet) input.value = envData[name];

        const row = input.closest('.secret-config-row');
        if (row) {
            const nameEl = row.querySelector('.secret-config-name');
            if (nameEl) nameEl.style.textDecoration = '';
            const localStatus = row.querySelectorAll('.secret-config-status')[0];
            if (localStatus) {
                localStatus.innerHTML = `
                    <div title="Local (.env)">${localSet ? 'âœ…' : 'âŒ'} Local</div>
                    ${localSet ? `<button class="btn-icon" onclick="markForDeletion('${name}')" style="font-size:0.7rem;" title="Mark ${name} for deletion">ğŸ—‘ï¸</button>` : ''}
                `;
            }
        }
        checkSecretsDirty();
    }

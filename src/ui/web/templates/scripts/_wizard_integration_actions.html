/* Wizard JS â€” Integration Actions
     Docker/K8s live panels, operational actions, delete config, apply sub-wizard
     form to backend, tool install helper.
     Depends on: _wizard_integrations.html (sub-wizard context)
*/

async function _wizDockerLive(what) {
    const panel = document.getElementById('wiz-docker-live-panel');
    if (!panel) return;
    panel.style.display = 'block';
    panel.innerHTML = '<span class="spinner"></span> Loadingâ€¦';

    try {
        if (what === 'containers') {
            const data = await api('/docker/containers?all=true');
            const list = data.containers || [];
            if (list.length === 0) {
                panel.innerHTML = '<span style="color:var(--text-muted)">No containers found.</span>';
            } else {
                panel.innerHTML = list.map(c =>
                    `<div style="display:flex;gap:0.5rem;padding:0.15rem 0;border-bottom:1px solid var(--border-subtle)">` +
                    `<span style="color:${c.state === 'running' ? 'var(--success)' : 'var(--text-muted)'};width:1rem">â—</span>` +
                    `<span style="flex:1;overflow:hidden;text-overflow:ellipsis">${esc(c.name || c.names || 'â€”')}</span>` +
                    `<span style="color:var(--text-muted)">${esc(c.status || c.state || 'â€”')}</span>` +
                    `<span style="color:var(--text-muted)">${esc(c.image || 'â€”')}</span>` +
                    `</div>`
                ).join('');
            }
        } else if (what === 'images') {
            const data = await api('/docker/images');
            const list = data.images || [];
            if (list.length === 0) {
                panel.innerHTML = '<span style="color:var(--text-muted)">No images found.</span>';
            } else {
                panel.innerHTML = list.map(img =>
                    `<div style="display:flex;gap:0.5rem;padding:0.15rem 0;border-bottom:1px solid var(--border-subtle)">` +
                    `<span style="flex:1;overflow:hidden;text-overflow:ellipsis">${esc(img.repository || img.tag || 'â€”')}</span>` +
                    `<span style="color:var(--text-muted)">${esc(img.tag || img.id || 'â€”')}</span>` +
                    `<span style="color:var(--text-muted)">${esc(img.size || 'â€”')}</span>` +
                    `</div>`
                ).join('');
            }
        } else if (what === 'compose') {
            const data = await api('/docker/compose/status');
            const services = data.services || [];
            if (services.length === 0 && !data.error) {
                panel.innerHTML = '<span style="color:var(--text-muted)">No compose services found.</span>';
            } else if (data.error) {
                panel.innerHTML = `<span style="color:var(--error)">${esc(data.error)}</span>`;
            } else {
                panel.innerHTML = services.map(s =>
                    `<div style="display:flex;gap:0.5rem;padding:0.15rem 0;border-bottom:1px solid var(--border-subtle)">` +
                    `<span style="color:${s.state === 'running' ? 'var(--success)' : 'var(--text-muted)'};width:1rem">â—</span>` +
                    `<span style="flex:1">${esc(s.name || s.service || 'â€”')}</span>` +
                    `<span style="color:var(--text-muted)">${esc(s.state || s.status || 'â€”')}</span>` +
                    `</div>`
                ).join('');
            }
        }
    } catch (e) {
        panel.innerHTML = `<span style="color:var(--error)">Error: ${esc(e.message)}</span>`;
    }
}

// â”€â”€ Docker operational actions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function _wizDockerAction(action, btnEl) {
    const output = document.getElementById('wiz-docker-action-output');
    const origText = btnEl.textContent;
    btnEl.disabled = true;
    btnEl.textContent = 'â³â€¦';

    try {
        let data;
        if (action === 'up') {
            data = await api('/docker/up', { method: 'POST', body: '{}' });
        } else if (action === 'down') {
            data = await api('/docker/down', { method: 'POST', body: '{}' });
        } else if (action === 'restart') {
            data = await api('/docker/restart', { method: 'POST', body: '{}' });
        } else if (action === 'build') {
            data = await api('/docker/build', { method: 'POST', body: '{}' });
        } else if (action === 'build-nc') {
            data = await api('/docker/build', { method: 'POST', body: JSON.stringify({ no_cache: true }) });
        } else if (action === 'prune') {
            data = await api('/docker/prune', { method: 'POST', body: '{}' });
        } else if (action === 'logs') {
            data = await api('/docker/logs?service=app&tail=50');
        }

        btnEl.textContent = origText;
        btnEl.disabled = false;

        if (data && output) {
            output.style.display = 'block';
            if (data.error) {
                output.textContent = 'âŒ ' + data.error;
                output.style.color = 'var(--error)';
                toast(data.error, 'error');
            } else {
                output.style.color = 'var(--text-secondary)';
                output.textContent = data.output || data.logs || data.message || JSON.stringify(data, null, 2);
                toast(`âœ… ${action} complete`, 'success');
            }
        }
    } catch (e) {
        btnEl.textContent = origText;
        btnEl.disabled = false;
        if (output) {
            output.style.display = 'block';
            output.textContent = 'âŒ ' + e.message;
            output.style.color = 'var(--error)';
        }
        toast('Docker action failed: ' + e.message, 'error');
    }
}

// â”€â”€ K8s live panels â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function _wizK8sLive(what) {
    const panel = document.getElementById('wiz-k8s-live-panel');
    if (!panel) return;
    panel.style.display = 'block';
    panel.innerHTML = '<span class="spinner"></span> Loadingâ€¦';

    try {
        if (what === 'validate') {
            const data = await api('/k8s/validate');
            if (data.valid) {
                panel.innerHTML = '<span style="color:var(--success)">âœ… All manifests are valid.</span>';
            } else {
                panel.innerHTML = `<span style="color:var(--error)">âŒ Validation issues:</span><br>` +
                    (data.errors || []).map(e => `<div style="color:var(--error);margin-left:0.5rem">â€¢ ${esc(e)}</div>`).join('');
            }
        } else {
            const data = await api(`/k8s/resources?kind=${what}`);
            const items = data.items || data.resources || [];
            if (items.length === 0) {
                panel.innerHTML = `<span style="color:var(--text-muted)">No ${what} found.</span>`;
            } else {
                panel.innerHTML = items.map(item => {
                    const name = item.metadata?.name || item.name || 'â€”';
                    const ns = item.metadata?.namespace || item.namespace || '';
                    const status = item.status?.phase || item.status || '';
                    return `<div style="display:flex;gap:0.5rem;padding:0.15rem 0;border-bottom:1px solid var(--border-subtle)">` +
                        `<span style="flex:1">${esc(name)}</span>` +
                        (ns ? `<span style="color:var(--text-muted)">${esc(ns)}</span>` : '') +
                        (status ? `<span style="color:${status === 'Running' ? 'var(--success)' : 'var(--text-muted)'}">${esc(status)}</span>` : '') +
                        `</div>`;
                }).join('');
            }
        }
    } catch (e) {
        panel.innerHTML = `<span style="color:var(--error)">Error: ${esc(e.message)}</span>`;
    }
}

// â”€â”€ Delete config with confirmation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function _wizDeleteConfig(target, btnEl) {
    const labels = {
        docker: 'Docker config (Dockerfile, docker-compose.yml)',
        k8s: 'Kubernetes manifests (k8s/)',
        ci: 'CI workflow (.github/workflows/ci.yml)',
        skaffold: 'Skaffold config (skaffold.yaml)',
        terraform: 'Terraform config (terraform/)',
        all: 'ALL generated configs',
    };
    const label = labels[target] || target;

    if (!confirm(`âš ï¸ Delete ${label}?\n\nThis cannot be undone.`)) return;

    btnEl.disabled = true;
    btnEl.textContent = 'â³â€¦';

    try {
        const data = await api('/wizard/config', {
            method: 'DELETE',
            body: JSON.stringify({ target }),
        });
        if (data.ok || (data.deleted && data.deleted.length > 0)) {
            toast(`ğŸ—‘ Deleted: ${data.deleted.join(', ')}`, 'success');
            // Re-detect and re-render
            await _wizRedetect();
        } else if (data.deleted && data.deleted.length === 0) {
            toast('Nothing to delete.', 'info');
            btnEl.textContent = 'ğŸ—‘ Delete';
            btnEl.disabled = false;
        } else {
            toast(data.errors?.join('; ') || 'Delete failed', 'error');
            btnEl.textContent = 'ğŸ—‘ Delete';
            btnEl.disabled = false;
        }
    } catch (e) {
        toast('Delete failed: ' + e.message, 'error');
        btnEl.textContent = 'ğŸ—‘ Delete';
        btnEl.disabled = false;
    }
}


/** Re-run detection and re-render */
async function _wizRedetect() {
    toast('ğŸ”„ Re-scanningâ€¦', 'info');
    try {
        _wizIntDetection = await _wizFetchDetect(true);
        _wizRenderIntegrations();
        toast('âœ… Updated!', 'success');
    } catch (e) { toast('Detection failed: ' + e.message, 'error'); }
}


/** Compose full CI/CD pipeline via /wizard/compose-ci */
async function _wizComposeCi(btnEl) {
    btnEl.disabled = true;
    btnEl.textContent = 'â³ Generatingâ€¦';

    const $ = id => {
        const el = document.getElementById(id);
        return el ? el.value.trim() : '';
    };

    const strategy = $('wiz-ci-compose-strategy') || 'unified';
    const deployMethod = $('wiz-ci-compose-deploy') || 'kubectl';
    const registry = $('wiz-ci-compose-registry') || 'ghcr.io';
    const projectName = (_wizardConfig?.name || 'app');
    const d = _wizIntDetection;

    // Build wizard state from detected integrations
    const state = {
        stack_names: [d._python_version ? 'python' : 'generic'],
    };

    // Docker services (if Docker detected)
    if (d.integrations['int:docker']?.detected || d.files?.dockerfile) {
        const safeName = projectName.replace(/[^a-z0-9-]/gi, '-').toLowerCase();
        const registryType = registry.includes('ghcr') ? 'ghcr'
            : registry.includes('docker.io') ? 'dockerhub'
            : registry.includes('ecr') ? 'ecr' : 'ghcr';
        state.docker_services = [{
            name: safeName,
            image: safeName + ':latest',
            registry: registry + '/' + safeName,
            registry_type: registryType,
        }];
    }

    // Deploy config (if K8s detected)
    if (d.devops_cards?.k8s?.detected || d.files?.k8s_manifests) {
        state.deploy_config = {
            method: deployMethod,
            namespace: 'default',
        };
    }

    // Terraform (if detected)
    if (d.devops_cards?.terraform?.detected || d.files?.terraform) {
        state.terraform_config = {
            provider: 'aws',
        };
    }

    // Environments
    if (_wizardConfig?.environments?.length > 0) {
        state.environments = _wizardConfig.environments.map(e =>
            typeof e === 'string' ? { name: e } : e
        );
    }

    // â”€â”€ Pre-validate â”€â”€
    try {
        const vRes = await api('/wizard/validate', {
            method: 'POST',
            body: JSON.stringify({ state }),
        });
        if (!vRes.ok && vRes.errors?.length > 0) {
            btnEl.textContent = 'ğŸš€ Generate Pipeline';
            btnEl.disabled = false;
            toast(vRes.errors[0], 'error', 6000);
            return;
        }
        if (vRes.warnings?.length > 0) {
            vRes.warnings.forEach(w => toast('âš  ' + w, 'warning', 4000));
        }
    } catch (_) { /* validation unavailable â€” continue */ }

    // â”€â”€ Check tools â”€â”€
    try {
        const tRes = await api('/wizard/check-tools', {
            method: 'POST',
            body: JSON.stringify({ state }),
        });
        if (!tRes.ok && tRes.missing?.length > 0) {
            toast('âš  Missing tools: ' + tRes.missing.join(', '), 'warning', 5000);
        }
    } catch (_) { /* continue */ }

    // â”€â”€ Compose CI â”€â”€
    try {
        const data = await api('/wizard/compose-ci', {
            method: 'POST',
            body: JSON.stringify({ state, strategy, project_name: projectName }),
        });
        btnEl.textContent = 'ğŸš€ Generate Pipeline';
        btnEl.disabled = false;

        const output = document.getElementById('wiz-ci-compose-output');
        if (!output) return;

        if (!data.ok) {
            output.style.display = 'block';
            output.innerHTML = `<span style="color:var(--error)">âŒ ${esc(data.error || 'Unknown error')}</span>`;
            return;
        }

        if (data.files.length === 0) {
            output.style.display = 'block';
            output.innerHTML = `<span style="color:var(--text-muted)">No workflow files generated. Enable more integrations (Docker, K8s, etc.).</span>`;
            return;
        }

        // Show preview
        let previewHtml = `
            <div style="font-size:0.72rem;font-weight:600;color:var(--text-muted);text-transform:uppercase;margin-bottom:0.3rem">
                Generated ${data.files.length} file(s) â€” ${strategy} strategy
            </div>`;

        for (const f of data.files) {
            const lines = f.content.split('\n').length;
            previewHtml += `
                <div style="margin-bottom:0.5rem">
                    <div style="display:flex;align-items:center;gap:0.4rem;margin-bottom:0.2rem">
                        <code style="font-size:0.75rem;color:var(--accent)">${esc(f.path)}</code>
                        <span style="font-size:0.62rem;color:var(--text-muted)">(${lines} lines)</span>
                        <button class="btn btn-sm btn-ghost" style="font-size:0.6rem;padding:0.05rem 0.3rem;margin-left:auto"
                            onclick="navigator.clipboard.writeText(this.closest('[data-yaml]').dataset.yaml);toast('Copied!','success')">
                            ğŸ“‹ Copy
                        </button>
                    </div>
                    <pre data-yaml="${esc(f.content)}"
                        style="background:var(--bg-inset);border:1px solid var(--border-subtle);border-radius:6px;
                               padding:0.4rem 0.5rem;font-size:0.65rem;max-height:200px;overflow:auto;
                               font-family:var(--font-mono,monospace);white-space:pre-wrap;color:var(--text-secondary);
                               line-height:1.4">${esc(f.content)}</pre>
                </div>`;
        }

        previewHtml += `
            <div style="display:flex;gap:0.4rem;margin-top:0.4rem">
                <button class="btn btn-sm btn-primary" style="font-size:0.75rem"
                    onclick="_wizWriteCiFiles(this)">ğŸ’¾ Write Files to Project</button>
            </div>`;

        output.style.display = 'block';
        output.innerHTML = previewHtml;

        // Store files for writing
        output._pendingFiles = data.files;

    } catch (e) {
        btnEl.textContent = 'ğŸš€ Generate Pipeline';
        btnEl.disabled = false;
        toast('Compose failed: ' + e.message, 'error');
    }
}


/** Write composed CI files to disk via /wizard/setup */
async function _wizWriteCiFiles(btnEl) {
    const output = document.getElementById('wiz-ci-compose-output');
    const files = output?._pendingFiles;
    if (!files || files.length === 0) return;

    btnEl.disabled = true;
    btnEl.textContent = 'â³ Writingâ€¦';

    try {
        const data = await api('/wizard/setup', {
            method: 'POST',
            body: JSON.stringify({
                action: 'setup_ci',
                overwrite: true,
                _raw_files: files,
            }),
        });
        if (data.ok) {
            btnEl.textContent = 'âœ… Written!';
            btnEl.style.color = 'var(--success)';
            toast('âœ… CI/CD pipeline files written!', 'success');
            for (const f of files) {
                toast('ğŸ“„ ' + f.path, 'info');
            }
            setTimeout(() => _wizRedetect(), 500);
        } else {
            btnEl.textContent = 'ğŸ’¾ Write Files to Project';
            btnEl.disabled = false;
            toast(data.error || 'Write failed', 'error');
        }
    } catch (e) {
        btnEl.textContent = 'ğŸ’¾ Write Files to Project';
        btnEl.disabled = false;
        toast('Write failed: ' + e.message, 'error');
    }
}

// â”€â”€ Apply sub-wizard form â†’ backend â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function _wizApplySetup(key, btnEl) {
    btnEl.disabled = true;
    btnEl.textContent = 'â³ Validatingâ€¦';

    const $ = id => {
        const el = document.getElementById(id);
        if (!el) return undefined;
        if (el.type === 'checkbox') return el.checked;
        return el.value.trim();
    };

    let payload = { integration: key };

    if (key === 'int:docker') {
        payload.action = 'setup_docker';
        payload.base_image = $('wiz-docker-base');
        payload.workdir = $('wiz-docker-workdir');
        payload.install_cmd = $('wiz-docker-install');
        payload.port = $('wiz-docker-port');
        payload.cmd = $('wiz-docker-cmd');
        payload.compose = $('wiz-docker-compose');
        payload.overwrite = $('wiz-docker-overwrite') || false;
    } else if (key === 'k8s') {
        payload.action = 'setup_k8s';
        payload.app_name = $('wiz-k8s-name');
        payload.image = $('wiz-k8s-image');
        payload.port = $('wiz-k8s-port');
        payload.replicas = $('wiz-k8s-replicas');
        payload.namespace = $('wiz-k8s-namespace');
        payload.service_type = $('wiz-k8s-service-type');
    } else if (key === 'int:ci') {
        payload.action = 'setup_ci';
        payload.branches = $('wiz-ci-branches');
        payload.python_version = $('wiz-ci-python');
        payload.install_cmd = $('wiz-ci-install');
        payload.test_cmd = $('wiz-ci-test');
        payload.lint = $('wiz-ci-lint');
        payload.lint_cmd = $('wiz-ci-lint-cmd');
        payload.overwrite = $('wiz-ci-overwrite') || false;
    } else if (key === 'terraform') {
        payload.action = 'setup_terraform';
        payload.provider = $('wiz-tf-provider');
        payload.region = $('wiz-tf-region');
        payload.project_name = $('wiz-tf-project');
        payload.backend = $('wiz-tf-backend');
        payload.overwrite = $('wiz-tf-overwrite') || false;
    } else if (key === 'int:git') {
        payload.action = 'setup_git';
        payload.remote = $('wiz-git-remote');
    } else {
        btnEl.textContent = 'âœ… Apply';
        btnEl.disabled = false;
        toast('No setup action for this integration.', 'info');
        return;
    }

    // â”€â”€ Pre-apply validation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Build a validation state from the payload fields
    const validationState = {};
    if (payload.namespace) {
        validationState.deploy_config = { namespace: payload.namespace };
    }
    if (payload.provider) {
        validationState.terraform_config = { provider: payload.provider };
    }
    if (key === 'int:docker' && payload.base_image) {
        // Registry URL validation â€” extract from image if applicable
        validationState._skip_secret_warnings = true;
    }

    // Only validate if we have relevant state
    const hasValidation = validationState.deploy_config || validationState.terraform_config;
    if (hasValidation) {
        try {
            const vRes = await api('/wizard/validate', {
                method: 'POST',
                body: JSON.stringify({ state: validationState }),
            });
            if (!vRes.ok && vRes.errors && vRes.errors.length > 0) {
                btnEl.textContent = 'âŒ Validation Failed';
                btnEl.disabled = false;
                toast(vRes.errors[0], 'error', 6000);
                // Show all errors
                for (const err of vRes.errors) {
                    console.warn('[Wizard Validation]', err);
                }
                return;
            }
            // Show warnings but don't block
            if (vRes.warnings && vRes.warnings.length > 0) {
                for (const w of vRes.warnings) {
                    toast('âš  ' + w, 'warning', 5000);
                }
            }
        } catch (e) {
            // Validation endpoint unreachable â€” continue anyway
            console.warn('Validation check failed, proceeding:', e.message);
        }
    }

    // â”€â”€ Apply setup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    btnEl.textContent = 'â³ Applyingâ€¦';

    try {
        const data = await api('/wizard/setup', {
            method: 'POST',
            body: JSON.stringify(payload),
        });
        if (data.ok) {
            btnEl.textContent = 'âœ… Done!';
            btnEl.style.color = 'var(--success)';
            toast(data.message || 'Setup complete!', 'success');
            if (data.files_created) {
                data.files_created.forEach(f => toast('ğŸ“„ Created: ' + f, 'info'));
            }
            const safeId = key.replace(':', '-');
            const cb = document.getElementById('wiz-int-' + safeId);
            if (cb && !cb.checked) { cb.checked = true; _wizToggleBorder(safeId, true); }
            // Re-detect to update status badges
            setTimeout(() => _wizRedetect(), 500);
        } else {
            btnEl.textContent = 'âŒ Failed';
            btnEl.disabled = false;
            toast(data.error || 'Setup failed', 'error');
            if (data.stderr) console.error('stderr:', data.stderr);
            if (data.details) toast(data.details, 'warning', 6000);
        }
    } catch (e) {
        btnEl.textContent = 'âŒ Error';
        btnEl.disabled = false;
        toast('Setup failed: ' + e.message, 'error');
    }
}

// â”€â”€ Tool install helper â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function _wizInstallTool(tool, btnEl) {
    btnEl.disabled = true;
    btnEl.textContent = 'â³â€¦';
    try {
        // First attempt â€” no sudo
        let data = await apiPost('/audit/install-tool', { tool });
        if (data.ok || data.already_installed) {
            const row = document.getElementById('wiz-int-tool-' + tool);
            if (row) {
                const icon = row.querySelector('span');
                if (icon) { icon.textContent = 'âœ“'; icon.style.color = 'var(--success)'; }
            }
            btnEl.textContent = 'âœ…';
            btnEl.style.color = 'var(--success)';
            if (_wizIntDetection) _wizIntDetection.tools[tool] = true;
            toast(tool + ' installed!', 'success');
        } else if (data.needs_sudo) {
            // Sudo required â€” show proper modal instead of prompt()
            btnEl.textContent = 'ğŸ“¦ Install';
            btnEl.disabled = false;
            _showSudoInstallModal(tool, tool, btnEl, true);
        } else {
            btnEl.textContent = 'âŒ';
            toast('Install failed: ' + (data.error || 'unknown'), 'error');
            btnEl.disabled = false;
            setTimeout(() => { btnEl.textContent = 'ğŸ“¦ Retry'; }, 3000);
        }
    } catch (e) {
        btnEl.textContent = 'âŒ';
        toast('Install failed: ' + e.message, 'error');
        btnEl.disabled = false;
        setTimeout(() => { btnEl.textContent = 'ğŸ“¦ Retry'; }, 3000);
    }
}

/** Collect integration checkbox states into _wizardConfig._integrationPrefs */
function _wizCollectIntegrations() {
    if (!_wizIntDetection || !_wizardConfig) return;
    const prefs = {};
    for (const key of Object.keys(_wizIntDetection.integrations)) {
        const cb = document.getElementById('wiz-int-' + key.replace(':', '-'));
        prefs[key] = (cb && cb.checked) ? 'visible' : 'hidden';
    }
    for (const [key, info] of Object.entries(_wizIntDetection.devops_cards)) {
        const cb = document.getElementById('wiz-int-' + key);
        let val;
        if (cb) {
            val = cb.checked ? 'visible' : 'hidden';
        } else {
            // Card was not rendered (detected, no tools needed) â€” preserve existing pref
            const savedPrefs = (_wizardConfig && _wizardConfig._integrationPrefs) || _wizIntDetection.current_prefs || {};
            val = savedPrefs[key] || 'auto';
        }
        prefs[key] = val;
        // Also set int:* key for Integration tab cards (k8s â†’ int:k8s, etc.)
        if (!key.startsWith('int:')) {
            prefs['int:' + key] = val;
        }
    }
    _wizardConfig._integrationPrefs = prefs;
}



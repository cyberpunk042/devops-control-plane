<script>
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 *  Event Stream â€” SSE client + reactive state store (Phase 7B)
 *
 *  Connects to GET /api/events (Server-Sent Events) and maintains
 *  an in-memory state store.  When the server publishes cache:done,
 *  the store updates and any registered renderers re-paint.
 *
 *  Depends on: _globals.html (cardStore, cardInvalidate, toast)
 *  Consumed by: any card script that calls storeRegister(key, fn)
 *
 *  This is ADDITIVE â€” existing api()/cardCached() flows are untouched.
 *  Cards that haven't opted in continue working as before.
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

    // â”€â”€ State Store â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    //
    // In-memory store keyed by cache key (e.g. "testing", "docker").
    // When data arrives (via SSE or explicit set), registered renderers
    // are notified.  sessionStorage is also updated for backward compat.

    const _store = {};               // key â†’ data dict
    const _renderers = {};           // key â†’ [renderFn, ...]
    const _staleKeys = new Set();    // keys marked stale by watcher

    /** Update the store for a key and notify renderers. */
    function storeSet(key, data) {
        _store[key] = data;
        _staleKeys.delete(key);      // fresh data clears stale marker

        // Clear stale visual indicator on the DOM
        document.querySelectorAll(`[data-cache-key="${key}"]`).forEach(el => {
            el.classList.remove('stale');
            el.title = '';
        });

        // Keep sessionStorage in sync (backward compat with cardCached)
        cardStore(key, data);

        // Notify registered renderers
        const fns = _renderers[key];
        if (fns) {
            for (const fn of fns) {
                try { fn(data); } catch (e) {
                    console.error(`[EventStream] render ${key}:`, e);
                }
            }
        }
    }

    /** Read from the store; returns null if not present. */
    function storeGet(key) {
        return _store[key] || null;
    }

    /** Register a render function for a cache key.
     *  The function is called with (data) whenever storeSet(key, ...) fires.
     *  Multiple renderers per key are supported. */
    function storeRegister(key, renderFn) {
        (_renderers[key] ??= []).push(renderFn);
    }

    /** Check if a key is marked stale by the watcher. */
    function storeIsStale(key) {
        return _staleKeys.has(key);
    }

    // â”€â”€ SSE Connection Manager â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    const _sse = {
        /** @type {EventSource|null} */
        source: null,
        /** Server instance ID â€” changes on server restart. */
        instanceId: null,
        /** Last received sequence number (for replay on reconnect). */
        lastSeq: 0,
        /** Whether the SSE connection is currently open. */
        connected: false,
        /** Known event types to listen for. */
        _eventTypes: [
            'sys:ready', 'sys:warming', 'sys:warm', 'sys:heartbeat',
            'state:snapshot',
            'cache:miss', 'cache:done', 'cache:error', 'cache:bust',
            'state:stale',
            'audit:pending', 'audit:saved',
            'run:started', 'run:completed',
        ],

        /** Open the SSE connection. Safe to call multiple times. */
        connect() {
            if (this.source) return;

            const url = '/api/events' + (this.lastSeq ? '?since=' + this.lastSeq : '');
            this.source = new EventSource(url);

            // Register a listener for each known event type
            for (const type of this._eventTypes) {
                this.source.addEventListener(type, (e) => this._dispatch(type, e));
            }

            this.source.onopen = () => {
                this.connected = true;
                console.debug('[SSE] connected');
            };

            this.source.onerror = () => {
                // EventSource auto-reconnects and sends Last-Event-Id header.
                // We just update our state flag.
                if (this.connected) {
                    this.connected = false;
                    console.debug('[SSE] disconnected â€” will auto-reconnect');
                }
            };
        },

        /** Route an SSE event to the appropriate handler. */
        _dispatch(type, sseEvent) {
            let payload;
            try {
                payload = JSON.parse(sseEvent.data);
            } catch (e) {
                console.error('[SSE] bad JSON:', sseEvent.data);
                return;
            }

            // Track sequence for replay on reconnect
            if (payload.seq) {
                this.lastSeq = payload.seq;
            }

            switch (type) {
                case 'sys:ready':      this._onReady(payload);        break;
                case 'state:snapshot': this._onSnapshot(payload);     break;
                case 'cache:done':     this._onCacheDone(payload);    break;
                case 'cache:miss':     this._onCacheMiss(payload);    break;
                case 'cache:error':    this._onCacheError(payload);   break;
                case 'cache:bust':     this._onCacheBust(payload);    break;
                case 'state:stale':    this._onStateStale(payload);   break;
                case 'audit:pending':  this._onAuditPending(payload); break;
                case 'audit:saved':    this._onAuditSaved(payload);   break;
                case 'run:started':    this._onRunStarted(payload);   break;
                case 'run:completed':  this._onRunCompleted(payload); break;
                // sys:warming, sys:warm, sys:heartbeat â€” silently ignored for now
            }
        },

        // â”€â”€ Event Handlers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

        /** Server hello â€” detect restarts. */
        _onReady(payload) {
            const newId = payload.data?.instance_id;
            if (this.instanceId && this.instanceId !== newId) {
                // Server restarted â€” discard stale local state
                console.info('[SSE] server restarted (instance %s â†’ %s), clearing store',
                    this.instanceId, newId);
                for (const key of Object.keys(_store)) {
                    delete _store[key];
                }
                _staleKeys.clear();
                cardInvalidateAll();
            }
            this.instanceId = newId;
            this.connected = true;
        },

        /** Full state replacement (new connection or buffer exhausted). */
        _onSnapshot(payload) {
            const snapshot = payload.data || {};
            for (const [key, entry] of Object.entries(snapshot)) {
                if (entry.data) {
                    storeSet(key, entry.data);
                }
            }
            console.debug('[SSE] snapshot loaded (%d keys)', Object.keys(snapshot).length);
        },

        /** Card computation finished â€” fresh data available. */
        _onCacheDone(payload) {
            const key = payload.key;
            if (!key) return;

            // The payload.data contains the full card data
            storeSet(key, payload.data);

            // Clear any loading indicator that _onCacheMiss may have set
            _sse._clearLoadingIndicator(key);

            const dur = payload.duration_s;
            if (dur != null) {
                console.debug('[SSE] cache:done %s (%.2fs)', key, dur);
            }
        },

        /** Card computation starting â€” show loading indicator if visible. */
        _onCacheMiss(payload) {
            const key = payload.key;
            if (!key) return;

            // Try common badge/detail ID patterns
            // DevOps:        devops-{key}-badge, devops-{key}-detail
            // Integrations:  int-{key}-badge, int-{key}-detail
            // Audit:         audit-{key}-badge, audit-{key}-detail
            for (const prefix of ['devops-', 'int-', 'audit-']) {
                const badge = document.getElementById(prefix + key + '-badge');
                const detail = document.getElementById(prefix + key + '-detail');
                if (badge) {
                    badge.className = 'status-badge';
                    badge.textContent = 'â€”';
                }
                if (detail && !detail.querySelector('.spinner')) {
                    // Only set spinner if there isn't one already
                    detail.innerHTML = '<span class="spinner"></span>';
                }
            }
        },

        /** Card computation failed. */
        _onCacheError(payload) {
            const key = payload.key;
            if (!key) return;

            const msg = payload.error || 'Computation failed';

            for (const prefix of ['devops-', 'int-', 'audit-']) {
                const badge = document.getElementById(prefix + key + '-badge');
                const detail = document.getElementById(prefix + key + '-detail');
                if (badge) {
                    badge.className = 'status-badge failed';
                    badge.innerHTML = '<span class="status-dot"></span>Error';
                }
                if (detail) {
                    detail.innerHTML = `<p class="empty-state-sm" style="color:var(--error)">${esc(msg)}</p>`;
                }
            }
        },

        /** Cache invalidated (user clicked refresh or cascade). */
        _onCacheBust(payload) {
            const scope = payload.data?.scope || '';
            console.debug('[SSE] cache:bust scope=%s', scope);
            // The explicit bust from the UI already invalidated sessionStorage.
            // This handler is for CROSS-TAB sync: another tab busted â†’
            // this tab should know.  We mark keys stale but don't re-render
            // (the subsequent cache:miss â†’ cache:done events will handle rendering).
        },

        /** File watcher detected underlying files changed. */
        _onStateStale(payload) {
            const key = payload.key;
            if (!key) return;

            _staleKeys.add(key);

            // Add stale indicator to card age badges
            document.querySelectorAll(`[data-cache-key="${key}"]`).forEach(el => {
                el.classList.add('stale');
                el.title = 'Underlying files changed â€” click ğŸ”„ to refresh';
            });

            console.debug('[SSE] state:stale %s (stale by %.1fs)',
                key, payload.data?.stale_by_s || 0);
        },

        /** A new pending audit snapshot was staged. */
        _onAuditPending(payload) {
            const key = payload.key;        // card_key e.g. "security"
            const sid = payload.snapshot_id; // e.g. "security_20260218_150300"
            if (!key || !sid) return;

            // Track pending counts
            window._pendingAudits = window._pendingAudits || {};
            (window._pendingAudits[key] ??= []).push(sid);

            // Show per-card badge(s)
            document.querySelectorAll('.audit-pending-badge[data-audit-key="' + key + '"]')
                .forEach(b => { b.style.display = 'inline-flex'; });

            // Update global pending badge (in tab header)
            _sse._updatePendingBadge();

            console.debug('[SSE] audit:pending %s (%s)', key, sid);
        },

        /** An audit snapshot was saved to git. */
        _onAuditSaved(payload) {
            const sid = payload.key;  // snapshot_id
            if (!sid) return;

            // Remove from pending tracking
            if (window._pendingAudits) {
                for (const key of Object.keys(window._pendingAudits)) {
                    window._pendingAudits[key] = window._pendingAudits[key].filter(id => id !== sid);
                    if (window._pendingAudits[key].length === 0) {
                        delete window._pendingAudits[key];
                        // Hide per-card badge(s)
                        document.querySelectorAll('.audit-pending-badge[data-audit-key="' + key + '"]')
                            .forEach(b => { b.style.display = 'none'; });
                    }
                }
            }

            _sse._updatePendingBadge();
            console.debug('[SSE] audit:saved %s', sid);
        },

        /** Update the global pending audit badges in tab headers. */
        _updatePendingBadge() {
            const pa = window._pendingAudits || {};
            let devopsTotal = 0;
            let projectTotal = 0;

            for (const [key, arr] of Object.entries(pa)) {
                if (key.startsWith('audit:')) {
                    projectTotal += arr.length;
                } else {
                    devopsTotal += arr.length;
                }
            }

            const total = devopsTotal + projectTotal;

            // DevOps tab global badge
            const badge = document.getElementById('pending-audits-badge');
            if (badge) {
                if (devopsTotal > 0) {
                    badge.textContent = devopsTotal;
                    badge.style.display = '';
                    badge.title = `${devopsTotal} unsaved devops audit(s) â€” click to manage`;
                } else {
                    badge.style.display = 'none';
                }
            }

            // Audit tab global badge
            const pBadge = document.getElementById('pending-project-audits-badge');
            if (pBadge) {
                if (projectTotal > 0) {
                    pBadge.textContent = projectTotal;
                    pBadge.style.display = '';
                    pBadge.title = `${projectTotal} unsaved project audit(s) â€” click to manage`;
                } else {
                    pBadge.style.display = 'none';
                }
            }
        },

        /** A run operation has started. */
        _onRunStarted(payload) {
            const data = payload.data || {};
            const subtype = data.subtype || data.type || '';
            console.debug('[SSE] run:started %s (%s)', payload.key, subtype);

            const cardIds = this._runSubtypeToCardIds(subtype);
            for (const cardId of cardIds) {
                const badge = this._ensureRunBadge(cardId);
                if (badge) {
                    badge.style.display = 'inline-flex';
                    badge.querySelector('.run-status-dot').className = 'run-status-dot running';
                    badge.querySelector('.run-badge-label').textContent = 'runningâ€¦';
                    badge.title = subtype + ' in progress';
                }
            }
        },

        /** A run operation has completed. */
        _onRunCompleted(payload) {
            const data = payload.data || {};
            const subtype = data.subtype || data.type || 'run';
            const status = data.status || 'ok';
            const summary = data.summary || '';
            const dur = data.duration_ms ? ` (${(data.duration_ms / 1000).toFixed(1)}s)` : '';
            const icon = status === 'ok' ? 'âœ…' : 'âŒ';
            const level = status === 'ok' ? 'success' : (status === 'failed' ? 'error' : 'info');

            if (typeof toast === 'function') {
                toast(`${icon} ${subtype}${dur}: ${summary || status}`, level);
            }
            console.debug('[SSE] run:completed %s â†’ %s%s', payload.key, status, dur);

            const cardIds = this._runSubtypeToCardIds(subtype);
            for (const cardId of cardIds) {
                const badge = this._ensureRunBadge(cardId);
                if (badge) {
                    badge.style.display = 'inline-flex';
                    const dot = badge.querySelector('.run-status-dot');
                    dot.className = 'run-status-dot ' + (status === 'ok' ? 'success' : 'failed');
                    badge.querySelector('.run-badge-label').textContent = status;
                    const runId = data.run_id || '';
                    badge.title = `${subtype}${dur} â€” ${summary || status}`
                        + (runId ? `\n@run:${runId}` : '');
                }
            }
        },

        /**
         * Map run subtype â†’ candidate card element IDs.
         * Cards live on two tabs with different prefixes:
         *   DevOps:       devops-{key}-card
         *   Integrations: int-{key}-card
         */
        _runSubtypeToCardIds(subtype) {
            if (!subtype) return [];
            const map = {
                /* K8s + Helm */
                'deploy:k8s': 'k8s', 'deploy:k8s_scale': 'k8s', 'destroy:k8s': 'k8s',
                'generate:k8s_manifests': 'k8s', 'generate:k8s_wizard': 'k8s',
                'install:helm': 'k8s', 'deploy:helm_upgrade': 'k8s', 'plan:helm_template': 'k8s',
                /* Terraform */
                'deploy:terraform': 'terraform', 'plan:terraform': 'terraform',
                'validate:terraform': 'terraform', 'destroy:terraform': 'terraform',
                'setup:terraform': 'terraform', 'format:terraform': 'terraform',
                'generate:terraform': 'terraform', 'setup:terraform_ws': 'terraform',
                /* Docker */
                'build:docker': 'docker', 'deploy:docker_up': 'docker',
                'destroy:docker_down': 'docker', 'deploy:docker_restart': 'docker',
                'destroy:docker_prune': 'docker', 'install:docker_pull': 'docker',
                'test:docker_exec': 'docker', 'destroy:docker_rm': 'docker',
                'destroy:docker_rmi': 'docker',
                'generate:dockerfile': 'docker', 'generate:dockerignore': 'docker',
                'generate:compose': 'docker', 'generate:compose_wizard': 'docker',
                'generate:docker_write': 'docker',
                /* Testing */
                'test:run': 'testing', 'test:coverage': 'testing',
                /* Quality */
                'validate:quality': 'quality', 'validate:lint': 'quality',
                'validate:typecheck': 'quality', 'test:quality': 'quality',
                'format:quality': 'quality', 'generate:quality_config': 'quality',
                /* Packages */
                'install:packages': 'packages', 'install:packages_update': 'packages',
                /* Docs */
                'generate:changelog': 'docs', 'generate:readme': 'docs',
                /* Env / Infra */
                'generate:env_example': 'env', 'generate:env': 'env',
                /* Git */
                'git:commit': 'git', 'git:pull': 'git', 'git:push': 'git',
                /* CI / GH */
                'ci:gh_dispatch': 'ci',
                'setup:gh_repo': 'gh', 'setup:gh_visibility': 'gh',
                'setup:gh_logout': 'gh', 'setup:gh_default_branch': 'gh',
                /* Pages */
                'build:pages_segment': 'pages', 'build:pages_all': 'pages',
                'build:pages_merge': 'pages', 'deploy:pages': 'pages',
                'setup:pages': 'pages', 'generate:pages_ci': 'pages',
            };
            const key = map[subtype];
            if (!key) return [];

            /* DevOps tab uses devops-{key}-card, Integrations uses int-{key}-card.
               Also handle int-tf-card (short alias for terraform). */
            const intKey = key === 'terraform' ? 'tf' : key;
            const ids = ['devops-' + key + '-card', 'int-' + intKey + '-card'];
            return ids;
        },

        /** Get-or-create a run badge element inside a card header. */
        _ensureRunBadge(cardId) {
            const badgeId = cardId + '-run-badge';
            let badge = document.getElementById(badgeId);
            if (badge) return badge;

            const card = document.getElementById(cardId);
            if (!card) return null;

            const header = card.querySelector('.card-header');
            if (!header) return null;

            badge = document.createElement('span');
            badge.id = badgeId;
            badge.className = 'run-activity-badge';
            badge.style.display = 'none';
            badge.innerHTML = '<span class="run-status-dot"></span>'
                + '<span class="run-badge-label"></span>';
            header.appendChild(badge);
            return badge;
        },


        // â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

        /** Remove loading spinner for a card (called after cache:done). */
        _clearLoadingIndicator(key) {
            // If the card still shows a spinner but we just got data,
            // the registered renderer will overwrite it.  No extra work needed.
        },

        /** Disconnect the SSE stream (for cleanup / testing). */
        disconnect() {
            if (this.source) {
                this.source.close();
                this.source = null;
                this.connected = false;
                console.debug('[SSE] disconnected (manual)');
            }
        },
    };

    // â”€â”€ Hydrate from pre-injected state (Phase 7C) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // The server embeds cached card data as __INITIAL_STATE__ in the HTML.
    // We populate _store + sessionStorage SILENTLY (no storeSet) because
    // renderers haven't been registered yet (those scripts load later).
    // When loadXxxCard() runs, storeGet() finds data â†’ instant render.

    if (window.__INITIAL_STATE__) {
        let _hydrated = 0;
        for (const [key, entry] of Object.entries(window.__INITIAL_STATE__)) {
            if (entry.data) {
                _store[key] = entry.data;        // populate in-memory store
                cardStore(key, entry.data);       // sync sessionStorage (backward compat)
                _hydrated++;
            }
        }
        console.debug('[EventStream] hydrated %d keys from __INITIAL_STATE__', _hydrated);
        delete window.__INITIAL_STATE__;          // GC
    }

    // â”€â”€ Auto-connect on page load â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // The SSE connection opens immediately.  It runs alongside the
    // existing api()-based card loading.  As cards migrate to storeRegister(),
    // the SSE-delivered data becomes the primary source.

    _sse.connect();
</script>

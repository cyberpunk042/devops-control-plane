/* Integrations Tab JS â€” Git Card
     loadGitCard(), git actions (commit, push, pull, stash, log, diff, gitignore).
     Depends on: _integrations_init.html (card registry)
*/
    // â”€â”€ Git Card â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    async function loadGitCard() {
        const badge = document.getElementById('int-git-badge');
        const detail = document.getElementById('int-git-detail');

        try {
            const cached = cardCached('git');
            const data = cached || await api('/git/status');
            if (!cached) cardStore('git', data);

            if (!data.available) {
                badge.className = 'status-badge failed';
                badge.innerHTML = '<span class="status-dot"></span>No repo';
                detail.innerHTML = cardSetupBanner('ğŸ”€', 'No Git repository',
                    'Initialize a Git repo to start tracking changes and enable other integrations.',
                    'git', 'Initialize Git â†’');
                return;
            }

            // â”€â”€ Badge â”€â”€
            if (data.dirty) {
                badge.className = 'status-badge degraded';
                badge.innerHTML = `<span class="status-dot"></span>${data.total_changes} change${data.total_changes !== 1 ? 's' : ''}`;
            } else {
                badge.className = 'status-badge ok';
                badge.innerHTML = '<span class="status-dot"></span>Clean';
            }

            // â”€â”€ Status grid â”€â”€
            const stats = [
                { label: 'Branch', value: data.branch },
                { label: 'Status', value: data.dirty ? `${data.total_changes} changes` : 'Clean', cls: data.dirty ? 'warn' : 'ok' },
            ];
            if (data.ahead > 0 || data.behind > 0) {
                stats.push({ label: 'Ahead', value: data.ahead > 0 ? `â†‘ ${data.ahead}` : 'â€”', cls: data.ahead > 0 ? 'ok' : 'muted' });
                stats.push({ label: 'Behind', value: data.behind > 0 ? `â†“ ${data.behind}` : 'â€”', cls: data.behind > 0 ? 'warn' : 'muted' });
            }

            let html = cardStatusGrid(stats);

            // â”€â”€ Detection list â”€â”€
            const detections = [];
            if (data.remote_url) detections.push({ icon: 'ğŸŒ', label: 'Remote', value: data.remote_url.replace(/^https?:\/\//, '').replace(/\.git$/, '') });
            if (data.commit) detections.push({ icon: '#ï¸âƒ£', label: 'HEAD', value: data.commit });
            if (detections.length > 0) html += cardDetectionList(detections);

            // â”€â”€ Changes summary â”€â”€
            if (data.dirty) {
                const changeParts = [];
                if (data.staged_count > 0)    changeParts.push(`<span class="card-dot ok"></span>${data.staged_count} staged`);
                if (data.modified_count > 0)  changeParts.push(`<span class="card-dot warn"></span>${data.modified_count} modified`);
                if (data.untracked_count > 0) changeParts.push(`<span class="card-dot muted"></span>${data.untracked_count} untracked`);
                html += `<div style="font-size:0.8rem;color:var(--text-secondary);display:flex;gap:0.75rem;flex-wrap:wrap;margin-bottom:var(--space-sm)">${changeParts.join('')}</div>`;
            }

            // â”€â”€ Last commit â”€â”€
            if (data.last_commit) {
                const c = data.last_commit;
                const ago = _timeAgo(c.date);
                html += `<div style="display:flex;gap:0.5rem;align-items:baseline;font-size:0.78rem;color:var(--text-muted);padding:var(--space-xs) 0">` +
                    `<code style="color:var(--accent);font-family:var(--font-mono)">${esc(c.short_hash)}</code>` +
                    `<span style="flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap">${esc(c.message)}</span>` +
                    `<span style="flex-shrink:0">${ago}</span></div>`;
            }

            // â”€â”€ Actions â”€â”€
            html += cardActionToolbar([
                { label: 'Commit', icon: 'ğŸ’¾', onclick: 'gitCommitModal()' },
                { label: 'Pull', icon: 'â¬‡ï¸', onclick: 'gitPull()' },
                { label: `Push${data.ahead > 0 ? ' (' + data.ahead + ')' : ''}`, icon: 'â¬†ï¸', onclick: 'gitPush()', disabled: data.ahead === 0 },
                { label: 'Log', icon: 'ğŸ“œ', onclick: 'gitLogModal()', cls: 'btn-ghost' },
                { label: 'Reconfigure', icon: 'âš™ï¸', onclick: 'openGitSetupWizard()', cls: 'btn-ghost' },
            ]);

            // â”€â”€ Generate â”€â”€
            html += cardGenerateToolbar([
                { label: '.gitignore', icon: 'ğŸ“', onclick: 'gitIgnoreWizard()' },
            ]);

            detail.innerHTML = html;

        } catch (e) {
            badge.className = 'status-badge failed';
            badge.innerHTML = '<span class="status-dot"></span>Error';
            detail.innerHTML = `<p class="empty-state-sm" style="color:var(--error)">${esc(e.message)}</p>`;
        }
    }

    // â”€â”€ Git Actions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    function gitCommitModal() {
        const body =
            `<div class="modal-form-grid">` +
            modalFormField({
                name: 'commit-msg', label: 'Commit Message', type: 'text',
                placeholder: 'feat: describe your change', required: true, fullWidth: true,
                hint: 'Press Enter to commit'
            }) +
            `</div>`;

        modalOpen({
            title: 'ğŸ’¾ Commit Changes',
            body,
            size: 'narrow',
            footerButtons: [
                { label: 'Cancel', cls: 'btn-secondary', onclick: 'modalClose()' },
                { label: 'Commit All', cls: 'btn-primary', id: 'git-commit-btn', onclick: 'doGitCommit()' },
            ],
        });

        // Focus the input and enable Enter to submit
        setTimeout(() => {
            const input = document.getElementById('mf-commit-msg');
            if (input) {
                input.focus();
                input.addEventListener('keydown', e => {
                    if (e.key === 'Enter') doGitCommit();
                });
            }
        }, 100);
    }

    async function doGitCommit() {
        const message = mfVal('commit-msg').trim();
        if (!message) {
            modalError('Commit message is required');
            return;
        }

        const btn = document.getElementById('git-commit-btn');
        if (btn) { btn.disabled = true; btn.textContent = 'Committingâ€¦'; }

        try {
            const data = await api('/git/commit', {
                method: 'POST',
                body: JSON.stringify({ message }),
            });
            modalClose();
            toast(`Committed ${data.hash}: ${message}`, 'success');
            cardInvalidate('git');
            await loadGitCard();
        } catch (e) {
            modalError(e.message);
            if (btn) { btn.disabled = false; btn.textContent = 'Commit All'; }
        }
    }

    async function gitPull() {
        toast('Pullingâ€¦', 'info');
        try {
            const data = await api('/git/pull', { method: 'POST', body: '{}' });
            toast('Pull complete: ' + (data.output || 'up to date'), 'success');
            cardInvalidate('git');
            await loadGitCard();
        } catch (e) {
            toast('Pull failed: ' + e.message, 'error');
        }
    }

    async function gitPush() {
        toast('Pushingâ€¦', 'info');
        try {
            const data = await api('/git/push', { method: 'POST', body: '{}' });
            toast('Push complete', 'success');
            cardInvalidate('git');
            await loadGitCard();
        } catch (e) {
            toast('Push failed: ' + e.message, 'error');
        }
    }

    async function gitLogModal() {
        modalOpen({
            title: 'ğŸ“œ Recent Commits',
            body: '<span class="spinner"></span>',
            footerButtons: [
                { label: 'Close', cls: 'btn-primary', onclick: 'modalClose()' },
            ],
        });

        try {
            const data = await api('/git/log?n=20');
            const body = document.querySelector('.modal-body');
            if (!body) return;

            if (!data.commits || data.commits.length === 0) {
                body.innerHTML = cardEmpty('ğŸ“œ', 'No commits found');
                return;
            }

            body.innerHTML = cardDataTable(
                ['Hash', 'Message', 'Author', 'When'],
                data.commits.map(c => [
                    { text: c.short_hash, cls: 'mono clickable' },
                    { text: c.message, cls: 'name' },
                    { text: c.author },
                    { text: _timeAgo(c.date) },
                ])
            );
        } catch (e) {
            const body = document.querySelector('.modal-body');
            if (body) body.innerHTML = `<div class="modal-inline-error">${esc(e.message)}</div>`;
        }
    }

    /** .gitignore wizard â€” analyze, preview, and generate/update .gitignore */
    async function gitIgnoreWizard() {
        wizardModalOpen({
            title: 'ğŸ“ .gitignore Manager',
            size: 'wide',
            steps: [
                {
                    id: 'analyze', title: 'Analyze',
                    render: async (data, el) => {
                        el.innerHTML = '<p style="text-align:center;padding:2rem"><span class="spinner"></span> Analyzing .gitignoreâ€¦</p>';
                        try {
                            const [analysis, genResult] = await Promise.all([
                                api('/security/gitignore'),
                                apiPost('/security/generate/gitignore', {}),
                            ]);
                            data._analysis = analysis;
                            data._generated = (genResult.ok && genResult.file) ? genResult.file.content : '';

                            let html = wizSection('.gitignore Analysis', 'How well your project files are protected.');
                            html += '<div class="wiz-status-grid">';
                            html += wizStatusRow('ğŸ“„', 'File',
                                analysis.exists ? 'Present' : 'Missing',
                                analysis.exists ? 'ok' : 'error');
                            if (analysis.exists) {
                                html += wizStatusRow('ğŸ“Š', 'Coverage',
                                    `${Math.round((analysis.coverage || 0) * 100)}%`,
                                    analysis.coverage >= 0.9 ? 'ok' : analysis.coverage >= 0.5 ? 'warn' : 'error');
                                html += wizStatusRow('ğŸ“‹', 'Current patterns',
                                    `${analysis.current_patterns}`, 'muted');
                                if (analysis.missing_count > 0) {
                                    html += wizStatusRow('âŒ', 'Missing patterns',
                                        `${analysis.missing_count}`, 'error');
                                }
                            }
                            html += '</div>';

                            // Show missing patterns detail
                            if (analysis.missing_patterns && analysis.missing_patterns.length > 0) {
                                html += `<div style="margin-top:var(--space-md);padding:var(--space-sm);background:var(--bg-card);border-radius:var(--radius-sm);border:1px solid var(--border-subtle)">
                                    <div style="font-size:0.82rem;font-weight:500;margin-bottom:var(--space-xs)">Missing patterns:</div>`;
                                const grouped = {};
                                for (const p of analysis.missing_patterns) {
                                    (grouped[p.category] = grouped[p.category] || []).push(p);
                                }
                                for (const [cat, patterns] of Object.entries(grouped)) {
                                    html += `<div style="margin-top:var(--space-xs)">
                                        <span style="font-size:0.75rem;font-weight:500;color:var(--text-secondary);text-transform:capitalize">${esc(cat)}</span>
                                        <div style="padding-left:var(--space-sm)">
                                            ${patterns.map(p => `<div style="font-size:0.72rem;color:var(--error)"><code>${esc(p.pattern)}</code></div>`).join('')}
                                        </div>
                                    </div>`;
                                }
                                html += '</div>';
                            }

                            el.innerHTML = html;
                        } catch (e) {
                            el.innerHTML = `<div class="wiz-step-error-panel"><span>âš ï¸</span><span>${esc(e.message)}</span></div>`;
                        }
                    },
                },
                {
                    id: 'edit', title: 'Edit & Apply',
                    render: (data, el) => {
                        const content = data._generated || '';
                        const patCount = content.split('\n').filter(l => l.trim() && !l.trim().startsWith('#')).length;
                        const exists = data._analysis && data._analysis.exists;

                        let html = wizSection(exists ? 'Replace .gitignore' : 'Create .gitignore',
                            `Generated ${patCount} patterns based on your detected stacks.`);
                        html += `<textarea id="mf-gi-content"
                            class="modal-form-textarea" style="font-family:var(--font-mono);font-size:0.72rem;min-height:300px;width:100%;line-height:1.5"
                        >${esc(content)}</textarea>`;
                        html += `<span class="modal-form-hint">Edit the content above, then click "Apply Changes" to write it to disk.</span>`;
                        el.innerHTML = html;
                    },
                    collect: (data) => {
                        data.finalContent = mfVal('gi-content');
                    },
                },
            ],
            onComplete: async (data) => {
                if (!data.finalContent || !data.finalContent.trim()) {
                    throw new Error('No content to write');
                }
                // Use the setup_git action to write the .gitignore
                const result = await apiPost('/wizard/setup', {
                    action: 'setup_git',
                    gitignore_content: data.finalContent,
                });
                if (!result.ok) throw new Error(result.error || 'Failed to write .gitignore');
                // Reload git card
                cardInvalidate('git');
                if (typeof loadGitCard === 'function') setTimeout(() => loadGitCard(), 300);
            },
            successMessage: '.gitignore updated!',
            finishLabel: 'âœ… Apply Changes',
        });
    }


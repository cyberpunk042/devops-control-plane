    // ─────────────────────────────────────────────────────────────────
    //  _secrets_init.html
    //  State variables, constants, getSecretTier, loadSecretsTab
    //  Included by: _secrets.html (Jinja2 include)
    // ─────────────────────────────────────────────────────────────────


    // ── Secrets tab ─────────────────────────────────────────────────────

    let vaultState = {};
    let ghSecrets = [];      // Secret names set on GitHub
    let ghVariables = [];    // Variable names set on GitHub
    let ghAvailable = false; // Whether gh CLI is available
    let envData = {};        // Raw env values (config keys only)
    let envKeys = [];        // Full key metadata from API
    let envSections = [];    // Section names from .env
    let secretsInitialValues = {};
    let secretsDirty = false;
    let secretsLoaded = false;
    let _recentPushResults = [];  // optimistic update buffer
    let currentTarget = 'both';

    // Auto-provided by GitHub Actions runtime — can't be set/deleted via API
    const AUTO_PROVIDED = ['GITHUB_TOKEN', 'GITHUB_REPOSITORY'];

    /**
     * Derive tier for a key based on its metadata.
     *
     * - 'auto'   → GITHUB_TOKEN / GITHUB_REPOSITORY (runtime-provided)
     * - 'local'  → key has `# local-only` comment in .env
     * - 'secret' → pushable via `gh secret set` (kind === 'secret')
     * - 'var'    → pushable via `gh variable set` (kind === 'config')
     *
     * By default everything is pushable to GitHub. Users opt-out
     * per-key by toggling the # local-only comment.
     */
    function getSecretTier(name, keyMeta) {
        if (AUTO_PROVIDED.includes(name)) return 'auto';
        // Check per-key local_only flag from API
        if (keyMeta && keyMeta.local_only) return 'local';
        // Fallback: look it up in envKeys
        const found = envKeys.find(k => k.key === name);
        if (found && found.local_only) return 'local';
        // kind-based: secret → gh secret set, config → gh variable set
        const kind = (keyMeta && keyMeta.kind) || (found && found.kind) || 'config';
        return kind === 'secret' ? 'secret' : 'var';
    }


    // ═══════════════════════════════════════════════════════════════════
    //  Load
    // ═══════════════════════════════════════════════════════════════════

    async function loadSecretsTab() {
        try {
            const [status, secrets, keys, ghStatus, ghData] = await Promise.all([
                api('/vault/status'),
                api('/vault/secrets'),
                api('/vault/keys'),
                api('/gh/status').catch(() => ({ installed: false, authenticated: false })),
                api('/gh/secrets').catch(() => ({ available: false, secrets: [], variables: [] })),
            ]);

            vaultState = status;
            ghAvailable = ghData.available || false;
            // Normalize to uppercase — GitHub stores names case-insensitively
            // and gh list returns them in UPPERCASE
            ghSecrets = (ghData.secrets || []).map(s => s.toUpperCase());
            ghVariables = (ghData.variables || []).map(s => s.toUpperCase());

            // Merge any optimistic updates from recent pushes
            // (handles race condition where gh list hasn't propagated yet)
            if (_recentPushResults.length > 0) {
                for (const r of _recentPushResults) {
                    if (!r.success) continue;
                    const upper = r.name.toUpperCase();
                    if (r.kind === 'secret' && !ghSecrets.includes(upper)) {
                        ghSecrets.push(upper);
                    }
                    if (r.kind === 'variable' && !ghVariables.includes(upper)) {
                        ghVariables.push(upper);
                    }
                }
                _recentPushResults = [];
            }

            // Build envData and envKeys from keys response
            envData = {};
            envKeys = keys.keys || [];
            envSections = (keys.sections || []).map(s => s.name);
            for (const k of envKeys) {
                envData[k.key] = k.value || '';
            }

            renderVaultStatusBar(status);
            renderGhStatusAlert(ghStatus, ghData);
            renderSecretFiles(secrets.files);
            renderSecretsForm(keys, status);

        } catch (e) {
            console.error('Failed to load secrets tab:', e);
            document.getElementById('secrets-form').innerHTML = `
            <p class="empty-state">
                <span style="font-size:2rem;display:block;margin-bottom:0.5rem">⚠️</span>
                Failed to load vault: ${esc(e.message)}
            </p>`;
        }
    }

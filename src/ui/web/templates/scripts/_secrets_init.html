    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    //  _secrets_init.html
    //  State variables, constants, getSecretTier, loadSecretsTab
    //  Included by: _secrets.html (Jinja2 include)
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€


    // â”€â”€ Secrets tab â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    let vaultState = {};
    let ghSecrets = [];      // Secret names set on GitHub
    let ghVariables = [];    // Variable names set on GitHub
    let ghAvailable = false; // Whether gh CLI is available
    let envData = {};        // Raw env values (config keys only)
    let envKeys = [];        // Full key metadata from API
    let envSections = [];    // Section names from .env
    let secretsInitialValues = {};
    let secretsDirty = false;
    let secretsLoaded = false;
    let _recentPushResults = [];  // optimistic update buffer
    let currentTarget = 'both';

    // Multi-environment support
    let selectedEnv = '';              // Which env the user is viewing/editing (set from config)
    let activeEnv = '';                // Which env is "live" (.env contains this)
    let projectEnvironments = [];     // [{name, description, default}, ...]
    let ghRemoteEnvs = [];            // GitHub environment names that exist remotely

    /** True when project has 2+ environments (multi-env mode). */
    function _isMultiEnv() {
        return projectEnvironments.length > 1;
    }

    /** The .env file name for the selected environment. */
    function _envFile() {
        if (!_isMultiEnv()) return '.env';
        return `.env.${selectedEnv}`;
    }

    /** Build query suffix for the selected environment.
     *  Single-env mode: returns '' (repo-level).
     *  Multi-env mode: always returns ?env=<name>. */
    function _envQS() {
        if (!_isMultiEnv()) return '';
        return `?env=${encodeURIComponent(selectedEnv)}`;
    }

    // Auto-provided by GitHub Actions runtime â€” can't be set/deleted via API
    const AUTO_PROVIDED = ['GITHUB_TOKEN', 'GITHUB_REPOSITORY'];

    /**
     * Derive tier for a key based on its metadata.
     *
     * - 'auto'   â†’ GITHUB_TOKEN / GITHUB_REPOSITORY (runtime-provided)
     * - 'local'  â†’ key has `# local-only` comment in .env
     * - 'secret' â†’ pushable via `gh secret set` (kind === 'secret')
     * - 'var'    â†’ pushable via `gh variable set` (kind === 'config')
     *
     * By default everything is pushable to GitHub. Users opt-out
     * per-key by toggling the # local-only comment.
     */
    function getSecretTier(name, keyMeta) {
        if (AUTO_PROVIDED.includes(name)) return 'auto';
        // Check per-key local_only flag from API
        if (keyMeta && keyMeta.local_only) return 'local';
        // Fallback: look it up in envKeys
        const found = envKeys.find(k => k.key === name);
        if (found && found.local_only) return 'local';
        // kind-based: secret â†’ gh secret set, config â†’ gh variable set
        const kind = (keyMeta && keyMeta.kind) || (found && found.kind) || 'config';
        return kind === 'secret' ? 'secret' : 'var';
    }


    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  Load
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    async function loadSecretsTab() {
        // Load environments from project config (once)
        if (projectEnvironments.length === 0) {
            try {
                const cfgData = await api('/config');
                projectEnvironments = (cfgData.config && cfgData.config.environments) || [];
                if (projectEnvironments.length === 0) {
                    projectEnvironments = [{ name: 'default', description: 'Default', default: true }];
                }
            } catch (_) {
                projectEnvironments = [{ name: 'default', description: 'Default', default: true }];
            }

            // Set selectedEnv from the default environment (if not already set by URL hash)
            if (!selectedEnv) {
                const defaultEnv = projectEnvironments.find(e => e.default) || projectEnvironments[0];
                selectedEnv = defaultEnv.name;
            }

            // Load active environment (once)
            try {
                const activeData = await api('/vault/active-env');
                activeEnv = activeData.active || selectedEnv;
            } catch (_) {
                activeEnv = selectedEnv;
            }
        }

        // Render environment selector
        renderEnvSelector();

        const qs = _envQS();

        try {
            const [status, secrets, keys, ghStatus, ghData, ghEnvData] = await Promise.all([
                api(`/vault/status${qs}`),
                api('/vault/secrets'),
                api(`/vault/keys${qs}`),
                api('/gh/status').catch(() => ({ installed: false, authenticated: false })),
                api(`/gh/secrets${qs}`).catch(() => ({ available: false, secrets: [], variables: [] })),
                api('/gh/environments').catch(() => ({ available: false, environments: [] })),
            ]);

            vaultState = status;
            ghAvailable = ghData.available || false;
            // Normalize to uppercase â€” GitHub stores names case-insensitively
            // and gh list returns them in UPPERCASE
            ghSecrets = (ghData.secrets || []).map(s => s.toUpperCase());
            ghVariables = (ghData.variables || []).map(s => s.toUpperCase());

            // Merge any optimistic updates from recent pushes
            // (handles race condition where gh list hasn't propagated yet)
            if (_recentPushResults.length > 0) {
                for (const r of _recentPushResults) {
                    if (!r.success) continue;
                    const upper = r.name.toUpperCase();
                    if (r.kind === 'secret' && !ghSecrets.includes(upper)) {
                        ghSecrets.push(upper);
                    }
                    if (r.kind === 'variable' && !ghVariables.includes(upper)) {
                        ghVariables.push(upper);
                    }
                }
                _recentPushResults = [];
            }

            // Build envData and envKeys from keys response
            envData = {};
            envKeys = keys.keys || [];
            envSections = (keys.sections || []).map(s => s.name);
            for (const k of envKeys) {
                envData[k.key] = k.value || '';
            }

            renderVaultStatusBar(status);

            // GitHub environment detection
            ghRemoteEnvs = (ghEnvData.environments || []).map(e => e.toLowerCase());

            renderSecretFiles(secrets.files);
            renderSecretsForm(keys, status);

            // GH alerts AFTER renderSecretsForm (which creates the gh-status-alert container)
            renderGhStatusAlert(ghStatus, ghData);
            renderGhEnvAlert();

        } catch (e) {
            console.error('Failed to load secrets tab:', e);
            document.getElementById('secrets-form').innerHTML = `
            <p class="empty-state">
                <span style="font-size:2rem;display:block;margin-bottom:0.5rem">âš ï¸</span>
                Failed to load vault: ${esc(e.message)}
            </p>`;
        }
    }

    /** Render the environment selector pill bar above the secrets form.
     *  Hidden in single-environment mode (only dev). */
    function renderEnvSelector() {
        let bar = document.getElementById('env-selector-bar');

        // Single-environment mode: hide selector entirely
        if (projectEnvironments.length <= 1) {
            if (bar) bar.style.display = 'none';
            return;
        }

        if (!bar) {
            // Insert before the secrets-form container
            const form = document.getElementById('secrets-form');
            if (!form) return;
            bar = document.createElement('div');
            bar.id = 'env-selector-bar';
            bar.style.cssText = 'display:flex;align-items:center;gap:0.5rem;margin-bottom:0.75rem;padding:0.5rem 0;flex-wrap:wrap;';
            form.parentNode.insertBefore(bar, form);
        }

        bar.style.display = 'flex';
        const envFile = _envFile();
        const isActive = selectedEnv === activeEnv;

        bar.innerHTML = `
            <span style="font-size:0.85rem;font-weight:600;color:var(--text-secondary);margin-right:0.25rem">ğŸŒ Environment:</span>
            ${projectEnvironments.map(e => {
                const viewing = e.name === selectedEnv;
                const live = e.name === activeEnv;
                return `
                    <button class="btn btn-sm ${viewing ? 'btn-primary' : 'btn-secondary'}" style="font-size:0.78rem;padding:0.2rem 0.6rem;border-radius:12px;"
                        onclick="switchSecretEnv('${esc(e.name)}')">
                        ${live ? 'âš¡' : ''} ${esc(e.name)}${e.default ? ' â­' : ''}
                    </button>
                `;
            }).join('')}
            <span style="margin-left:0.5rem;font-size:0.78rem;color:var(--text-muted);font-family:var(--font-mono)">${esc(envFile)}</span>
            ${!isActive ? `
                <span style="margin-left:auto;display:flex;align-items:center;gap:0.4rem">
                    <span style="font-size:0.75rem;color:var(--text-muted)">viewing only</span>
                    <button class="btn btn-sm" id="btn-activate-env"
                        style="font-size:0.72rem;padding:0.2rem 0.5rem;border-radius:8px;background:var(--warning);color:#000;font-weight:600;border:none"
                        onclick="activateEnvironment('${esc(selectedEnv)}')">
                        âš¡ Activate
                    </button>
                </span>
            ` : `
                <span style="margin-left:auto;font-size:0.72rem;color:var(--success);font-weight:600">âš¡ active</span>
            `}
        `;
    }

    /** Activate an environment â€” swaps .env files so the project uses this env. */
    async function activateEnvironment(envName) {
        const btn = document.getElementById('btn-activate-env');
        if (btn) {
            btn.disabled = true;
            btn.innerHTML = '<span class="spinner" style="width:12px;height:12px"></span> Activatingâ€¦';
        }

        try {
            const data = await api('/vault/activate-env', {
                method: 'POST',
                body: JSON.stringify({ env: envName }),
            });
            activeEnv = data.active;
            toast(`Environment activated: ${envName}`, 'success');
            renderEnvSelector();
            // Reload to reflect the new .env state
            secretsLoaded = false;
            await loadSecretsTab();
        } catch (e) {
            toast(`Failed to activate environment: ${e.message}`, 'error');
            if (btn) {
                btn.disabled = false;
                btn.innerHTML = 'âš¡ Activate';
            }
        }
    }

    /** Switch to a different environment and reload the secrets tab. */
    function switchSecretEnv(envName) {
        if (envName === selectedEnv) return;

        selectedEnv = envName;
        secretsLoaded = false;

        // Sync URL hash
        history.replaceState(null, '', `#secrets/${envName}`);

        // Show loading overlay on the form area
        const form = document.getElementById('secrets-form');
        if (form) {
            form.style.position = 'relative';
            const overlay = document.createElement('div');
            overlay.id = 'secrets-loading-overlay';
            overlay.style.cssText = 'position:absolute;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.45);display:flex;align-items:center;justify-content:center;border-radius:8px;z-index:10;backdrop-filter:blur(2px);min-height:120px;';
            const envFile = _envFile();
            overlay.innerHTML = `<div style="color:#fff;font-size:0.9rem;display:flex;align-items:center;gap:0.5rem"><span class="spinner"></span> Loading ${esc(envFile)}â€¦</div>`;
            form.appendChild(overlay);
        }

        // Update selector immediately (highlight new env)
        renderEnvSelector();

        loadSecretsTab();
    }


    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  Metadata-driven helpers (toggle, base64, regenerate)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    /** Toggle password input visibility â€” fetches raw value on first reveal */
    async function togglePasswordVis(btn) {
        const container = btn.closest('.secret-config-value');
        const input = container ? container.querySelector('input') : null;
        if (!input) return;

        if (input.type === 'text') {
            // Hide â†’ restore password mode
            input.type = 'password';
            if (input.dataset.wasEmpty === 'true') {
                input.value = '';
                delete input.dataset.wasEmpty;
            }
            btn.textContent = 'ğŸ‘ï¸';
            return;
        }

        // Reveal â†’ if input is empty (secret with no typed value), fetch the raw value
        if (!input.value && input.dataset.secretName) {
            btn.textContent = 'â³';
            try {
                const data = await api('/vault/raw-value' + _envQS(), {
                    method: 'POST',
                    body: JSON.stringify({ key: input.dataset.secretName }),
                });
                if (data.value) {
                    input.value = data.value;
                    input.dataset.wasEmpty = 'true';
                }
            } catch (e) {
                toast('Could not fetch value: ' + e.message, 'error');
                btn.textContent = 'ğŸ‘ï¸';
                return;
            }
        }

        input.type = 'text';
        btn.textContent = 'ğŸ™ˆ';
    }

    /** Show base64-decoded value in a popup */
    async function showB64Decoded(btn, keyName) {
        const origText = btn.textContent;
        btn.textContent = 'â³';
        try {
            const data = await api('/vault/raw-value' + _envQS(), {
                method: 'POST',
                body: JSON.stringify({ key: keyName }),
            });
            if (!data.value) {
                toast('No value set for this key', 'info');
                btn.textContent = origText;
                return;
            }

            let decoded;
            try {
                decoded = atob(data.value);
            } catch (e) {
                decoded = '(not valid base64)';
            }

            // Store decoded value for safe copy
            window._b64DecodedValue = decoded;

            const modal = document.createElement('div');
            modal.className = 'vault-modal-overlay';
            modal.id = 'vault-modal';
            modal.innerHTML = `
                <div class="vault-modal" style="max-width:600px">
                    <h3 style="margin-bottom:0.75rem">ï¿½ Decoded: ${esc(keyName)}</h3>
                    <div style="font-size:0.75rem;color:var(--text-muted);margin-bottom:0.5rem">${data.value.length} bytes encoded â†’ ${decoded.length} bytes decoded</div>
                    <pre style="background:var(--bg-inset);padding:1rem;border-radius:8px;font-size:0.78rem;max-height:400px;overflow:auto;white-space:pre-wrap;word-break:break-all;border:1px solid var(--border-subtle)">${esc(decoded)}</pre>
                    <div style="display:flex;gap:0.5rem;justify-content:flex-end;margin-top:1rem">
                        <button class="btn btn-sm btn-secondary" onclick="navigator.clipboard.writeText(window._b64DecodedValue).then(() => toast('Copied decoded value!','success'))" type="button">ğŸ“‹ Copy Decoded</button>
                        <button class="btn btn-sm btn-primary" onclick="closeVaultModal()" type="button">Close</button>
                    </div>
                </div>`;
            document.body.appendChild(modal);
        } catch (e) {
            toast('Failed to fetch value: ' + e.message, 'error');
        }
        btn.textContent = origText;
    }

    /** Regenerate a key using the /keys/generate endpoint */
    async function regenerateKey(keyName, genType) {
        if (!confirm('Regenerate ' + keyName + '?\n\nThis will create a new ' + genType + ' value. The old value cannot be recovered.')) return;

        try {
            const result = await api('/keys/generate', {
                method: 'POST',
                body: JSON.stringify({ type: genType }),
            });

            await api('/secret/set' + _envQS(), {
                method: 'POST',
                body: JSON.stringify({ key: keyName, value: result.value }),
            });

            if (result.meta_tags) {
                await api('/vault/set-meta' + _envQS(), {
                    method: 'POST',
                    body: JSON.stringify({ key: keyName, meta_tags: result.meta_tags }),
                });
            }

            if (result.public_value) {
                const modal = document.createElement('div');
                modal.className = 'vault-modal-overlay';
                modal.id = 'vault-modal';
                const pubVal = result.public_value;
                modal.innerHTML = `
                    <div class="vault-modal" style="max-width:600px">
                        <h3 style="margin-bottom:0.75rem">ğŸ”‘ New ${esc(genType)} Public Key</h3>
                        <p style="color:var(--text-secondary);font-size:0.85rem;margin-bottom:0.75rem">
                            Private key saved to <code>${esc(keyName)}</code>. Copy the public key below:
                        </p>
                        <pre style="background:var(--bg-inset);padding:1rem;border-radius:8px;font-size:0.78rem;overflow:auto;white-space:pre-wrap;word-break:break-all;border:1px solid var(--border-subtle)">${esc(pubVal)}</pre>
                        <div style="display:flex;gap:0.5rem;justify-content:flex-end;margin-top:1rem">
                            <button class="btn btn-sm btn-secondary" onclick="navigator.clipboard.writeText('${esc(pubVal)}').then(() => toast('Copied!','success'))" type="button">ğŸ“‹ Copy</button>
                            <button class="btn btn-sm btn-primary" onclick="closeVaultModal()" type="button">Close</button>
                        </div>
                    </div>`;
                document.body.appendChild(modal);
            }

            toast('ğŸ”„ Regenerated ' + keyName, 'success');
            secretsLoaded = false;
            await loadSecretsTab();
        } catch (e) {
            toast('Regeneration failed: ' + e.message, 'error');
        }
    }

    /** Show key configuration popover â€” lets user set type (toggle, select, password, text) and encoding */
    function showKeyConfig(event, keyName) {
        event.stopPropagation();

        // Find current meta for this key
        let currentMeta = {};
        for (const s of (envSections || [])) {
            for (const k of (s.keys || [])) {
                if (k.key === keyName) { currentMeta = k.meta || {}; break; }
            }
        }

        const currentType = currentMeta.type || 'text';
        const currentEncoding = currentMeta.encoding || 'none';
        const currentOptions = (currentMeta.options || []).join(', ');

        // Remove any existing popover
        const existing = document.getElementById('key-config-popover');
        if (existing) existing.remove();

        const pop = document.createElement('div');
        pop.id = 'key-config-popover';
        pop.className = 'vault-modal-overlay';
        pop.innerHTML = `
            <div class="vault-modal" style="max-width:400px">
                <h3 style="margin-bottom:0.75rem">âš™ï¸ Configure <code>${esc(keyName)}</code></h3>

                <div class="form-group" style="margin-bottom:var(--space-md)">
                    <label style="font-weight:600;font-size:0.85rem;margin-bottom:0.3rem;display:block">Type</label>
                    <select id="kc-type" style="width:100%" onchange="document.getElementById('kc-options-group').style.display = this.value === 'select' ? 'block' : 'none'">
                        <option value="text"${currentType === 'text' ? ' selected' : ''}>ğŸ“ Text (default)</option>
                        <option value="password"${currentType === 'password' ? ' selected' : ''}>ğŸ”’ Password</option>
                        <option value="toggle"${currentType === 'toggle' ? ' selected' : ''}>ğŸ”˜ Toggle (true/false)</option>
                        <option value="select"${currentType === 'select' ? ' selected' : ''}>ğŸ“‹ Select (ENUM)</option>
                    </select>
                </div>

                <div class="form-group" id="kc-options-group" style="margin-bottom:var(--space-md);${currentType === 'select' ? '' : 'display:none'}">
                    <label style="font-weight:600;font-size:0.85rem;margin-bottom:0.3rem;display:block">Options (comma-separated)</label>
                    <input type="text" id="kc-options" placeholder="dev, staging, production" value="${esc(currentOptions)}" style="width:100%">
                    <div style="font-size:0.72rem;color:var(--text-muted);margin-top:0.2rem">These become the dropdown choices</div>
                </div>

                <div class="form-group" style="margin-bottom:var(--space-md)">
                    <label style="font-weight:600;font-size:0.85rem;margin-bottom:0.3rem;display:block">Encoding</label>
                    <select id="kc-encoding" style="width:100%">
                        <option value="none"${currentEncoding === 'none' ? ' selected' : ''}>None</option>
                        <option value="base64"${currentEncoding === 'base64' ? ' selected' : ''}>Base64</option>
                    </select>
                </div>

                <div style="display:flex;gap:0.5rem;justify-content:flex-end;margin-top:var(--space-lg)">
                    <button class="btn btn-secondary btn-sm" onclick="document.getElementById('key-config-popover').remove()" type="button">Cancel</button>
                    <button class="btn btn-primary btn-sm" onclick="saveKeyConfig('${esc(keyName)}')" type="button">ğŸ’¾ Save</button>
                </div>
            </div>`;
        document.body.appendChild(pop);
    }

    /** Save key configuration (write @meta tags) */
    async function saveKeyConfig(keyName) {
        const type = document.getElementById('kc-type').value;
        const encoding = document.getElementById('kc-encoding').value;
        const optionsRaw = (document.getElementById('kc-options')?.value || '').trim();

        // Build meta tags string
        const tags = [];
        if (type && type !== 'text') tags.push('@type:' + type);
        if (type === 'select' && optionsRaw) tags.push('@options:' + optionsRaw.split(',').map(s => s.trim()).filter(Boolean).join(','));
        if (encoding && encoding !== 'none') tags.push('@encoding:' + encoding);

        const metaStr = tags.length > 0 ? '# ' + tags.join(' ') : '';

        try {
            if (metaStr) {
                await api('/vault/set-meta' + _envQS(), {
                    method: 'POST',
                    body: JSON.stringify({ key: keyName, meta_tags: metaStr }),
                });
            }

            const pop = document.getElementById('key-config-popover');
            if (pop) pop.remove();

            toast('âš™ï¸ Updated config for ' + keyName, 'success');
            secretsLoaded = false;
            await loadSecretsTab();
        } catch (e) {
            toast('Failed to save config: ' + e.message, 'error');
        }
    }

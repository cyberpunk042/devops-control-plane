    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    //  _secrets_sync.html
    //  Save/Push orchestrator, sync env to GitHub, remove secret, clear all, toggle local-only, refresh
    //  Included by: _secrets.html (Jinja2 include)
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€




    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  Save & Push (orchestrator-style)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    async function pushSecrets(target = 'both') {
        const inputs = document.querySelectorAll('[data-secret-name]');

        // Collect changed values and deletions
        const secrets = {};
        const deletions = [];

        inputs.forEach(input => {
            const name = input.dataset.secretName;
            const initial = secretsInitialValues[name] ?? '';
            // For toggle checkboxes, derive value from checked state
            const effectiveValue = input.dataset.metaToggle === 'true'
                ? (input.checked ? 'true' : 'false')
                : input.value;
            if (input.dataset.markedDelete === 'true') {
                deletions.push(name);
            } else if (effectiveValue && effectiveValue !== initial) {
                secrets[name] = effectiveValue;
            }
        });

        // When target is 'both', also include pushable keys missing from GitHub
        // For secret-type keys, envData won't have the raw value â€” send null
        // to signal the backend to read it from .env directly.
        const syncKeys = [];
        if (target === 'both') {
            for (const k of envKeys) {
                if (!k.has_value) continue;
                if (secrets[k.key] || deletions.includes(k.key)) continue;
                const t = getSecretTier(k.key, k);
                if (t === 'auto' || t === 'local') continue;
                const missingFromGh = (t === 'secret' && !ghSecrets.includes(k.key.toUpperCase()))
                    || (t === 'var' && !ghVariables.includes(k.key.toUpperCase()));
                if (missingFromGh) {
                    if (envData[k.key]) {
                        secrets[k.key] = envData[k.key];
                    } else {
                        // Secret-type key â€” raw value not available in frontend
                        syncKeys.push(k.key);
                    }
                }
            }
        }

        if (Object.keys(secrets).length === 0 && deletions.length === 0 && syncKeys.length === 0) return;

        // Split into gh secrets vs gh variables based on per-key tier
        const ghPush = target === 'both' || target === 'github';
        const secretsForGh = {};
        const variablesForGh = {};
        if (ghPush) {
            for (const [name, val] of Object.entries(secrets)) {
                const t = getSecretTier(name);
                if (t === 'auto' || t === 'local') continue;
                if (t === 'secret') {
                    secretsForGh[name] = val;
                } else if (t === 'var') {
                    variablesForGh[name] = val;
                }
            }
        }

        const output = document.getElementById('secrets-output');
        const terminal = document.getElementById('secrets-terminal');
        const actionCount = Object.keys(secrets).length + deletions.length + syncKeys.length;
        const targetLabel = target === 'both' ? 'local & GitHub' : target;

        output.style.display = 'block';
        terminal.className = 'terminal';
        terminal.textContent = `Saving ${actionCount} change(s) to ${targetLabel}â€¦\n`;

        // Loading state
        for (const name of [...Object.keys(secrets), ...deletions, ...syncKeys]) {
            const row = document.querySelector(`[data-key-name="${name}"]`);
            if (row) { row.style.opacity = '0.5'; row.style.pointerEvents = 'none'; }
        }

        try {
            const response = await api(`/secrets/push${_envQS()}`, {
                method: 'POST',
                body: JSON.stringify({
                    secrets: secretsForGh,
                    variables: variablesForGh,
                    env_values: (target === 'both' || target === 'local') ? secrets : {},
                    deletions: (target === 'both' || target === 'local') ? deletions : [],
                    sync_keys: syncKeys,
                    push_to_github: ghPush,
                    save_to_env: target === 'both' || target === 'local',
                    exclude_from_github: AUTO_PROVIDED,
                }),
            });

            if (response.error) {
                terminal.className = 'terminal error';
                terminal.textContent = `âŒ Error: ${response.error}\n`;
                return;
            }

            let text = '';

            // Show env save status
            if (response.env_saved) {
                const savedKeys = Object.keys(secrets);
                if (savedKeys.length > 0) text += `ğŸ“ Saved to .env: ${savedKeys.join(', ')}\n`;
                if (response.deletions_applied && response.deletions_applied.length > 0) {
                    text += `ğŸ—‘ï¸ Deleted from .env: ${response.deletions_applied.join(', ')}\n`;
                }
            }

            // Show GitHub push results
            for (const r of (response.results || [])) {
                const icon = r.kind === 'variable' ? 'ğŸ“‹' : 'â˜ï¸';
                const label = r.kind === 'variable' ? 'variable' : 'secret';
                if (r.success) {
                    text += `${icon} ${r.name}: pushed as GitHub ${label}\n`;
                } else {
                    text += `âŒ ${r.name}: ${r.error}\n`;
                }
            }

            terminal.textContent = text || 'Done!';
            terminal.className = response.all_success !== false ? 'terminal' : 'terminal error';

            // Smooth refresh
            if (response.all_success !== false) {
                // Buffer push results for optimistic gh column update
                _recentPushResults = response.results || [];

                const formEl = document.getElementById('secrets-form');
                formEl.style.position = 'relative';
                const overlay = document.createElement('div');
                overlay.id = 'secrets-loading-overlay';
                overlay.style.cssText = 'position:absolute;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.4);display:flex;align-items:center;justify-content:center;border-radius:8px;z-index:10;';
                overlay.innerHTML = '<div style="color:#fff;font-size:1rem;">ğŸ”„ Refreshingâ€¦</div>';
                formEl.appendChild(overlay);

                secretsLoaded = false;
                await loadSecretsTab();
                selectTarget(currentTarget);
            }
        } catch (error) {
            terminal.className = 'terminal error';
            terminal.textContent = `âŒ Error: ${error.message}`;
        }
    }


    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  Sync .env â†’ GitHub
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    async function syncEnvToGithub() {
        if (!envData || Object.keys(envData).length === 0) {
            toast('No local .env values found.', 'error');
            return;
        }

        // Collect all pushable keys, split by kind â†’ secret vs variable
        const secrets = {};
        const variables = {};
        for (const k of envKeys) {
            if (!k.has_value) continue;
            const t = getSecretTier(k.key, k);
            if (t === 'auto' || t === 'local') continue;
            const val = envData[k.key];
            if (!val) continue;
            if (t === 'secret') secrets[k.key] = val;
            else if (t === 'var') variables[k.key] = val;
        }

        const totalCount = Object.keys(secrets).length + Object.keys(variables).length;
        if (totalCount === 0) {
            toast('No pushable secrets/variables found. All keys may be flagged as local-only or auto-provided.', 'warning');
            return;
        }

        if (!confirm(`Push ${totalCount} value(s) from .env â†’ GitHub?\n\nThis will overwrite existing GitHub values.`)) return;

        const output = document.getElementById('secrets-output');
        const terminal = document.getElementById('secrets-terminal');
        output.style.display = 'block';
        terminal.className = 'terminal';
        terminal.textContent = `â˜ï¸ Syncing ${totalCount} value(s) from .env â†’ GitHubâ€¦\n`;

        try {
            const data = await api(`/secrets/push${_envQS()}`, {
                method: 'POST',
                body: JSON.stringify({
                    secrets,
                    variables,
                    push_to_github: true,
                    save_to_env: false,
                }),
            });

            if (data.error) {
                terminal.className = 'terminal error';
                terminal.textContent = `âŒ ${data.error}\n`;
                return;
            }

            let text = '', ok = 0, fail = 0;
            for (const r of (data.results || [])) {
                const icon = r.kind === 'variable' ? 'ğŸ“‹' : 'â˜ï¸';
                if (r.success) { text += `${icon} ${r.name}\n`; ok++; }
                else { text += `âŒ ${r.name}: ${r.error}\n`; fail++; }
            }
            terminal.textContent = `â˜ï¸ Sync complete: ${ok} pushed${fail ? `, ${fail} failed` : ''}\n\n${text}`;
            terminal.className = fail ? 'terminal error' : 'terminal';

            _recentPushResults = data.results || [];
            secretsLoaded = false;
            await loadSecretsTab();
            selectTarget(currentTarget);
        } catch (error) {
            terminal.className = 'terminal error';
            terminal.textContent = `âŒ Error: ${error.message}`;
        }
    }


    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  Remove single secret from GitHub
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    async function removeSecret(name, target, kind = 'secret') {
        const label = target === 'local' ? 'local .env' : target === 'github' ? 'GitHub' : 'local & GitHub';
        if (!confirm(`Remove ${name} from ${label}?\n\nThis cannot be undone.`)) return;

        const rowInput = document.querySelector(`[data-secret-name="${name}"]`);
        if (rowInput) {
            const rowEl = rowInput.closest('.secret-config-row');
            if (rowEl) { rowEl.style.opacity = '0.5'; rowEl.style.pointerEvents = 'none'; }
        }

        const output = document.getElementById('secrets-output');
        const terminal = document.getElementById('secrets-terminal');
        output.style.display = 'block';
        terminal.className = 'terminal';
        terminal.textContent = `ğŸ—‘ï¸ Removing ${name} from ${label}â€¦\n`;

        try {
            const data = await api(`/secret/remove${_envQS()}`, {
                method: 'POST',
                body: JSON.stringify({ name, target, kind }),
            });

            let text = `ğŸ—‘ï¸ ${name}:\n`;
            if (data.local) text += `  Local: ${data.local.success ? 'âœ… removed' : 'âŒ ' + data.local.error}\n`;
            if (data.github) text += `  GitHub: ${data.github.success ? 'âœ… removed' : 'âŒ ' + data.github.error}\n`;
            terminal.textContent = text;

            secretsLoaded = false;
            await loadSecretsTab();
            selectTarget(currentTarget);
        } catch (error) {
            terminal.className = 'terminal error';
            terminal.textContent = `âŒ Error: ${error.message}`;
        }
    }


    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  Clear all secrets
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    async function clearSecretsPrompt(target) {
        const label = target === 'local' ? 'local .env' : 'GitHub';

        let secretsToRemove;
        if (target === 'local') {
            secretsToRemove = Object.keys(envData)
                .filter(n => envData[n] && !AUTO_PROVIDED.includes(n))
                .map(n => ({ name: n, kind: 'secret' }));
        } else {
            // Include both GitHub secrets AND variables
            const items = [];
            for (const n of ghSecrets) {
                if (!AUTO_PROVIDED.includes(n)) items.push({ name: n, kind: 'secret' });
            }
            for (const n of ghVariables) {
                if (!AUTO_PROVIDED.includes(n)) items.push({ name: n, kind: 'variable' });
            }
            secretsToRemove = items;
        }

        if (secretsToRemove.length === 0) {
            toast(`No secrets to clear from ${label}.`, 'warning');
            return;
        }

        const names = secretsToRemove.map(s => s.name);
        if (!confirm(`âš ï¸ DANGER: Remove ${secretsToRemove.length} items from ${label}?\n\n${names.join(', ')}\n\nThis cannot be undone!`)) return;
        if (!confirm(`Are you absolutely sure? This will delete all secret values from ${label}.`)) return;

        const output = document.getElementById('secrets-output');
        const terminal = document.getElementById('secrets-terminal');
        output.style.display = 'block';
        terminal.className = 'terminal';
        terminal.textContent = `ğŸ—‘ï¸ Clearing ${secretsToRemove.length} items from ${label}â€¦\n`;

        let ok = 0, fail = 0;
        for (const item of secretsToRemove) {
            try {
                const data = await api(`/secret/remove${_envQS()}`, {
                    method: 'POST',
                    body: JSON.stringify({ name: item.name, target, kind: item.kind }),
                });
                const result = target === 'local' ? data.local : data.github;
                if (result?.success) { terminal.textContent += `âœ… ${item.name}\n`; ok++; }
                else { terminal.textContent += `âŒ ${item.name}: ${result?.error || 'unknown'}\n`; fail++; }
            } catch (e) {
                terminal.textContent += `âŒ ${item.name}: ${e.message}\n`;
                fail++;
            }
        }

        terminal.textContent += `\nğŸ—‘ï¸ Done: ${ok} removed${fail ? `, ${fail} failed` : ''}`;
        terminal.className = fail ? 'terminal error' : 'terminal';

        secretsLoaded = false;
        await loadSecretsTab();
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  Toggle local-only flag
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    async function toggleLocalOnly(name, localOnly) {
        const action = localOnly ? 'flag as local-only' : 'enable GitHub sync for';
        try {
            await api(`/vault/toggle-local-only${_envQS()}`, {
                method: 'POST',
                body: JSON.stringify({ key: name, local_only: localOnly }),
            });
            toast(`${name}: ${localOnly ? 'flagged as local-only' : 'GitHub sync enabled'}`, 'success');
            secretsLoaded = false;
            await loadSecretsTab();
            selectTarget(currentTarget);
        } catch (e) {
            toast(`Failed to ${action} ${name}: ${e.message}`, 'error');
        }
    }


    function refreshSecrets() {
        if (secretsDirty) {
            if (!confirm('You have unsaved secret changes. Refresh anyway?')) return;
        }
        document.getElementById('secrets-form').innerHTML = '<div class="loading">Loading secretsâ€¦</div>';
        secretsLoaded = false;
        loadSecretsTab();
    }

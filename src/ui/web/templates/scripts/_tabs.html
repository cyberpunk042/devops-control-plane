<script>
    // ── Tab switching ───────────────────────────────────────────────────

    let activeTab = 'dashboard';
    let _navDepth = 0;       // how many pushState calls we've made
    let _popstateActive = false; // suppress hashchange during popstate

    function switchTab(tabId, { fromPopstate = false } = {}) {
        // Guard unsaved editor changes before navigating away
        if (typeof monacoIsDirty === 'function' && monacoIsDirty()) {
            monacoGuardUnsaved(() => switchTab(tabId, { fromPopstate }));
            return;
        }

        // Parse compound tab IDs like 'wizard/modules' or 'content/media/docs'
        let subStep = null;
        let subParts = [];
        if (tabId.includes('/')) {
            const parts = tabId.split('/');
            tabId = parts[0];
            subStep = parts[1];
            subParts = parts.slice(1);
        }

        // Update button active states
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));

        const tabBtn = document.querySelector(`[onclick="switchTab('${tabId}')"]`);
        if (tabBtn) tabBtn.classList.add('active');
        const tabEl = document.getElementById(`tab-${tabId}`);
        if (tabEl) tabEl.classList.add('active');

        // Update URL hash — push a new history entry (not replace)
        const hashParts = [tabId, ...subParts];
        const newHash = `#${hashParts.join('/')}`;
        if (!fromPopstate) {
            // Only push if this is a user-initiated navigation, not back/forward
            if (location.hash !== newHash) {
                history.pushState({ tab: hashParts.join('/'), depth: _navDepth }, '', newHash);
                _navDepth++;
            }
        }

        activeTab = tabId;

        // Load data for the tab
        if (tabId === 'dashboard') {
            loadStatus();
            loadHealthScore();
        } else if (tabId === 'commands') {
            if (!capabilitiesLoaded) loadCapabilities();
        } else if (tabId === 'wizard') {
            if (subStep) {
                const stepIdx = wizardSteps.findIndex(s => s.id === subStep);
                if (stepIdx !== -1) currentWizardStep = stepIdx;
            }
            renderWizard();
        } else if (tabId === 'secrets') {
            if (subStep) {
                selectedEnv = subStep;
                secretsLoaded = false;
            }
            loadSecretsTab();
        } else if (tabId === 'debugging') {
            loadDebugTab();
        } else if (tabId === 'integrations') {
            loadIntegrationsTab();
        } else if (tabId === 'devops') {
            loadDevopsTab();
        } else if (tabId === 'audit') {
            loadAuditTab();
        } else if (tabId === 'content') {
            loadContentTab(subParts);
        }
    }

    // Restore tab from URL hash on page load
    function restoreFromHash() {
        const hash = location.hash.slice(1);
        if (hash) {
            // Replace current history entry with the initial state
            history.replaceState({ tab: hash, depth: 0 }, '', `#${hash}`);
            switchTab(hash, { fromPopstate: true });
        } else {
            history.replaceState({ tab: 'dashboard', depth: 0 }, '', '#dashboard');
        }
    }

    // Handle back/forward navigation
    window.addEventListener('popstate', (e) => {
        _popstateActive = true;
        if (e.state && e.state.tab) {
            _navDepth = e.state.depth || 0;
            switchTab(e.state.tab, { fromPopstate: true });
        } else {
            // No state — we've gone back past our first page. Let browser handle it.
            // (This happens naturally — we don't need to do anything.)
        }
        setTimeout(() => { _popstateActive = false; }, 50);
    });

    // Suppress hashchange during popstate (they fire together)
    window.addEventListener('hashchange', () => {
        if (_popstateActive) return;
        const hash = location.hash.slice(1);
        if (hash && hash !== activeTab) {
            switchTab(hash);
        }
    });
</script>
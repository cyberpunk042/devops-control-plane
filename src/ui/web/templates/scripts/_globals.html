<script>
    // â”€â”€ Global helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    // â”€â”€ API concurrency control â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    //
    // HTTP/1.1 browsers cap at 6 TCP connections per origin.
    // Without throttling, 15+ parallel fetch() calls cause the
    // browser to silently queue excess requests.  Our AbortController
    // timeout would tick during that invisible queue wait, killing
    // perfectly healthy requests that simply hadn't gotten a
    // connection slot yet.
    //
    // Fix: a JS-level semaphore (max 5 in-flight) keeps requests
    // queued HERE where the timeout hasn't started yet.  Slot 6
    // is left free for static assets / WebSocket / other traffic.

    const _API_MAX_CONCURRENT = 3;
    let _apiInFlight = 0;
    const _apiQueue = [];

    function _apiAcquire() {
        if (_apiInFlight < _API_MAX_CONCURRENT) {
            _apiInFlight++;
            return Promise.resolve();
        }
        return new Promise(resolve => _apiQueue.push(resolve));
    }

    function _apiRelease() {
        if (_apiQueue.length > 0) {
            _apiQueue.shift()();   // hand slot to next waiter
        } else {
            _apiInFlight--;
        }
    }

    async function api(path, opts = {}) {
        // Wait for a connection slot BEFORE starting the timeout.
        await _apiAcquire();
        const controller = new AbortController();
        const ms = opts.timeout || 30000;
        const timer = setTimeout(() => controller.abort(), ms);
        try {
            const res = await fetch('/api' + path, {
                headers: { 'Content-Type': 'application/json' },
                ...opts,
                signal: controller.signal,
            });
            clearTimeout(timer);
            const data = await res.json();
            if (!res.ok) throw new Error(data.error || `HTTP ${res.status}`);
            return data;
        } catch (e) {
            if (e.name === 'AbortError') throw new Error(`Request timed out after ${ms / 1000}s`);
            throw e;
        } finally {
            clearTimeout(timer);
            _apiRelease();
        }
    }

    /** POST JSON convenience wrapper. */
    async function apiPost(path, body = {}) {
        return api(path, {
            method: 'POST',
            body: JSON.stringify(body),
        });
    }

    function toast(message, type = 'success') {
        const container = document.getElementById('toast-container');
        const el = document.createElement('div');
        el.className = `toast ${type}`;
        el.textContent = message;
        container.appendChild(el);
        setTimeout(() => el.remove(), 6000);
    }

    function esc(str) {
        const div = document.createElement('div');
        div.textContent = str;
        return div.innerHTML;
    }

    function showRefreshBar() {
        document.getElementById('refresh-bar').classList.add('active');
    }

    function hideRefreshBar() {
        document.getElementById('refresh-bar').classList.remove('active');
    }

    // â”€â”€ Shared card cache (sessionStorage-backed) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    //
    // Client-side cache with long TTL (10 min).  Server-side cache handles
    // real freshness via mtime tracking.  Manual refresh busts BOTH caches.

    const _CARD_PREFIX = '_cc:';     // sessionStorage key prefix
    const _CARD_TTL = 600_000;    // 10 min (server checks mtimes for freshness)

    /** Return cached data if fresh, else null. */
    function cardCached(key) {
        try {
            const raw = sessionStorage.getItem(_CARD_PREFIX + key);
            if (!raw) return null;
            const c = JSON.parse(raw);
            if (Date.now() - c.ts < _CARD_TTL) return c.data;
            sessionStorage.removeItem(_CARD_PREFIX + key);
            return null;
        } catch { return null; }
    }

    /** Store data in cache with a timestamp. */
    function cardStore(key, data) {
        try {
            sessionStorage.setItem(_CARD_PREFIX + key,
                JSON.stringify({ data, ts: Date.now() }));
        } catch { /* quota exceeded â€” silently skip */ }
    }

    /** Invalidate a single card's cache. */
    function cardInvalidate(key) {
        sessionStorage.removeItem(_CARD_PREFIX + key);
    }

    /** Invalidate all cards (optionally filtered by prefix). */
    function cardInvalidateAll(prefix) {
        const keys = [];
        for (let i = 0; i < sessionStorage.length; i++) {
            const k = sessionStorage.key(i);
            if (k && k.startsWith(_CARD_PREFIX)) {
                const card = k.slice(_CARD_PREFIX.length);
                if (!prefix || card.startsWith(prefix)) keys.push(k);
            }
        }
        keys.forEach(k => sessionStorage.removeItem(k));
    }

    /** Get age of a cached entry in seconds, or null. */
    function cardAge(key) {
        try {
            const raw = sessionStorage.getItem(_CARD_PREFIX + key);
            if (!raw) return null;
            const c = JSON.parse(raw);
            // Use server-side computed_at if available (more accurate)
            if (c.data?._cache?.computed_at) {
                return Math.round(Date.now() / 1000 - c.data._cache.computed_at);
            }
            return Math.round((Date.now() - c.ts) / 1000);
        } catch { return null; }
    }

    /** Format age as human-readable string. */
    function _formatAge(secs) {
        if (secs == null) return '';
        if (secs < 5) return 'just now';
        if (secs < 60) return secs + 's ago';
        if (secs < 3600) return Math.floor(secs / 60) + 'm ago';
        return Math.floor(secs / 3600) + 'h ago';
    }

    // â”€â”€ Wizard step cache (same pattern as cards, separate namespace) â”€â”€
    const _WIZ_PREFIX = '_wz:';      // sessionStorage key prefix
    const _WIZ_TTL = 600_000;     // 10 min

    /** Return cached wizard data if fresh, else null. */
    function wizCached(key) {
        try {
            const raw = sessionStorage.getItem(_WIZ_PREFIX + key);
            if (!raw) return null;
            const c = JSON.parse(raw);
            if (Date.now() - c.ts < _WIZ_TTL) return c.data;
            sessionStorage.removeItem(_WIZ_PREFIX + key);
            return null;
        } catch { return null; }
    }

    /** Store wizard data in cache. Uses server-side computed_at if present,
     *  or explicit epochMs if provided. */
    function wizStore(key, data, epochMs) {
        try {
            // Use the server's real computation time, not "now"
            const serverAt = data?._cache?.computed_at;
            const ts = epochMs || (serverAt ? serverAt * 1000 : Date.now());
            sessionStorage.setItem(_WIZ_PREFIX + key,
                JSON.stringify({ data, ts }));
        } catch { /* quota exceeded â€” silently skip */ }
    }

    /** Invalidate a single wizard cache entry. */
    function wizInvalidate(key) {
        sessionStorage.removeItem(_WIZ_PREFIX + key);
    }

    /** Invalidate all wizard caches (optionally filtered by prefix). */
    function wizInvalidateAll(prefix) {
        const keys = [];
        for (let i = 0; i < sessionStorage.length; i++) {
            const k = sessionStorage.key(i);
            if (k && k.startsWith(_WIZ_PREFIX)) {
                const wk = k.slice(_WIZ_PREFIX.length);
                if (!prefix || wk.startsWith(prefix)) keys.push(k);
            }
        }
        keys.forEach(k => sessionStorage.removeItem(k));
    }

    /** Get age of a wizard cache entry in seconds, or null. */
    function wizAge(key) {
        try {
            const raw = sessionStorage.getItem(_WIZ_PREFIX + key);
            if (!raw) return null;
            const c = JSON.parse(raw);
            // Use server-side computed_at if available (more accurate)
            if (c.data?._cache?.computed_at) {
                return Math.round(Date.now() / 1000 - c.data._cache.computed_at);
            }
            return Math.round((Date.now() - c.ts) / 1000);
        } catch { return null; }
    }

    /** Tick all visible card-age indicators. */
    function _tickCardAges() {
        document.querySelectorAll('[data-cache-key]').forEach(el => {
            const age = cardAge(el.dataset.cacheKey);
            el.textContent = _formatAge(age);
            if (age != null && age > 600) {
                el.style.color = 'var(--warning)';
            } else {
                el.style.color = 'var(--text-muted)';
            }
        });
    }
    setInterval(_tickCardAges, 5000);

    // Cascade: when key X is refreshed, also invalidate dependent client caches.
    const _CASCADE = {
        'git': ['github', 'docker', 'ci', 'pages'],
        'docker': ['ci', 'k8s'],
        'github': ['ci'],
        'pages': ['dns'],
    };

    /**
     * Refresh a single card: bust both client + server cache (with cascade), show spinner, reload.
     */
    async function cardRefresh(cacheKey, badgeId, detailId, loadFn) {
        // Bust client cache: primary + cascade + aggregates
        cardInvalidate(cacheKey);
        for (const dep of _CASCADE[cacheKey] || []) cardInvalidate(dep);
        cardInvalidate('project-status');
        cardInvalidate('health-score');
        // Also clear the in-memory SSE store so loadFn doesn't short-circuit
        if (typeof _store !== 'undefined') {
            delete _store[cacheKey];
            for (const dep of _CASCADE[cacheKey] || []) delete _store[dep];
        }
        // Bust server-side cache (server also cascades) â€” AWAIT so loadFn gets fresh data
        try { await api('/devops/cache/bust', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ card: cacheKey }) }); } catch { }
        const badge = document.getElementById(badgeId);
        const detail = document.getElementById(detailId);
        if (badge) { badge.className = 'status-badge'; badge.textContent = 'â€”'; }
        if (detail) detail.innerHTML = '<span class="spinner"></span>';
        await loadFn();
    }

    /**
     * Load card data: check client cache, fetch from API if needed, store, handle errors.
     * Returns the data dict on success, or null on error (after rendering error state).
     */
    async function cardLoad(cacheKey, apiPath, badgeEl, detailEl) {
        const cached = cardCached(cacheKey);
        if (cached) return cached;

        const data = await api(apiPath).catch(e => ({ _err: e }));
        if (data._err) {
            if (badgeEl) {
                badgeEl.className = 'status-badge failed';
                badgeEl.innerHTML = '<span class="status-dot"></span>Error';
            }
            if (detailEl) {
                detailEl.innerHTML = `<p class="empty-state-sm" style="color:var(--error)">${esc(data._err.message)}</p>`;
            }
            return null;
        }

        cardStore(cacheKey, data);
        return data;
    }

    /**
     * Navigate to the Content Vault and open a file for viewing/editing.
     * Respects the user's preview mode preference:
     *   - 'modal'   â†’ opens a peek modal (no tab navigation)
     *   - 'forward' â†’ navigates to Content tab (original behavior)
     * @param {string} filePath - relative path to the file (e.g. "Dockerfile", "k8s/deployment.yaml")
     * @param {string} [mode='raw'] - view mode: 'raw' | 'edit' | 'preview'
     * @param {number} [line=0] - optional line number to focus
     */
    function openFileInEditor(filePath, mode = 'raw', line = 0) {
        // Open in modal unless we're in a docs/media browsing view
        const inDocsBrowser = (typeof activeTab !== 'undefined' && activeTab === 'content'
            && typeof contentCurrentMode !== 'undefined'
            && (contentCurrentMode === 'docs' || contentCurrentMode === 'media'));
        if (!inDocsBrowser
            && typeof openFileInModal === 'function') {
            openFileInModal(filePath);
            return;
        }
        const hashSuffix = line > 0 ? `@${mode}:${line}` : `@${mode}`;
        switchTab(`content/docs/${filePath}${hashSuffix}`);
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // â”€â”€ Phase 1: Reusable Card Section Builders â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    /**
     * Build a status grid HTML string.
     * @param {Array<{label:string, value:string, cls?:string}>} stats
     * @returns {string} HTML
     */
    function cardStatusGrid(stats) {
        return `<div class="card-status-grid">${stats.map(s =>
            `<div class="card-stat"><span class="card-stat-label">${esc(s.label)}</span>` +
            `<span class="card-stat-value${s.cls ? ' ' + s.cls : ''}">${esc(String(s.value))}</span></div>`
        ).join('')}</div>`;
    }

    /**
     * Build a detection list HTML string.
     * @param {Array<{icon:string, label:string, value?:string, click?:string}>} items
     * @returns {string} HTML
     */
    function cardDetectionList(items) {
        return `<div class="card-detection">${items.map(i => {
            const valCls = i.click ? ' clickable' : '';
            const valAttr = i.click ? ` onclick="${i.click}"` : '';
            return `<div class="card-detect-row">` +
                `<span class="card-detect-icon">${i.icon}</span>` +
                `<span class="card-detect-label">${esc(i.label)}</span>` +
                (i.value != null ? `<span class="card-detect-value${valCls}"${valAttr}>${esc(i.value)}</span>` : '') +
                `</div>`;
        }).join('')}</div>`;
    }

    /**
     * Build a data table HTML string (for live panels).
     * @param {string[]} columns - header labels
     * @param {Array<Array<{text:string, cls?:string, click?:string}>>} rows
     * @returns {string} HTML
     */
    function cardDataTable(columns, rows) {
        const thead = columns.map(c => `<th>${esc(c)}</th>`).join('');
        const tbody = rows.map(row =>
            `<tr>${row.map(cell => {
                const cls = cell.cls ? ` class="${cell.cls}"` : '';
                const onclick = cell.click ? ` onclick="${cell.click}" style="cursor:pointer"` : '';
                return `<td${cls}${onclick}>${esc(String(cell.text ?? 'â€”'))}</td>`;
            }).join('')}</tr>`
        ).join('');
        return `<table class="card-data-table"><thead><tr>${thead}</tr></thead><tbody>${tbody}</tbody></table>`;
    }

    /**
     * Build an action toolbar HTML string.
     * @param {Array<{label:string, icon?:string, cls?:string, onclick:string, id?:string, disabled?:boolean}>} actions
     * @returns {string} HTML
     */
    function cardActionToolbar(actions) {
        return `<div class="card-actions">${actions.map(a =>
            `<button class="btn btn-sm ${a.cls || 'btn-secondary'}" ` +
            `onclick="${a.onclick}"${a.id ? ` id="${a.id}"` : ''}${a.disabled ? ' disabled' : ''}>` +
            `${a.icon ? a.icon + ' ' : ''}${esc(a.label)}</button>`
        ).join('')}</div>`;
    }

    /**
     * Build an empty state HTML string with optional CTA button.
     * @param {string} icon - emoji
     * @param {string} text - message
     * @param {Object|null} action - optional CTA {label, onclick}
     * @returns {string} HTML
     */
    function cardEmpty(icon, text, action) {
        return `<div class="card-empty">` +
            `<div class="card-empty-icon">${icon}</div>` +
            `<div class="card-empty-text">${esc(text)}</div>` +
            (action ? `<button class="card-empty-action" onclick="${action.onclick}">${esc(action.label)}</button>` : '') +
            `</div>`;
    }

    /**
     * Build a live panel with tabs.
     * @param {string} panelId - unique ID for the panel content area
     * @param {Array<{key:string, label:string}>} tabs - tab definitions
     * @param {string} onTabClick - JS function name called with (key, panelId)
     * @returns {string} HTML
     */
    function cardLivePanel(panelId, tabs, onTabClick) {
        return `<div class="card-live">` +
            `<div class="card-live-tabs">${tabs.map(t =>
                `<button class="card-live-tab" data-tab="${t.key}" ` +
                `onclick="this.parentElement.querySelectorAll('.card-live-tab').forEach(b=>b.classList.remove('active'));` +
                `this.classList.add('active');${onTabClick}('${t.key}','${panelId}')">${t.label}</button>`
            ).join('')}</div>` +
            `<div class="card-live-panel" id="${panelId}">` +
            `<span style="color:var(--text-muted)">Select a tab above</span></div>` +
            `</div>`;
    }

    /**
     * Build a generate toolbar HTML string.
     * @param {Array<{label:string, icon?:string, onclick:string}>} items
     * @returns {string} HTML
     */
    function cardGenerateToolbar(items) {
        return `<div class="card-generate">${items.map(g =>
            `<button class="card-gen-btn" onclick="${g.onclick}">${g.icon ? g.icon + ' ' : ''}${esc(g.label)}</button>`
        ).join('')}</div>`;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // â”€â”€ Phase 1: Reusable Modal System â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    let _activeModal = null;

    /**
     * Open a standard modal.
     * @param {Object} opts
     * @param {string} opts.title - modal title (can include emoji)
     * @param {string} opts.body - innerHTML for the modal body
     * @param {string} [opts.size] - 'narrow' | 'wide' | undefined for default
     * @param {Array<{label:string, cls?:string, onclick?:string, id?:string, disabled?:boolean}>} [opts.footerButtons]
     * @param {string} [opts.footerStatus] - initial status text
     * @param {Function} [opts.onClose] - callback when modal is closed
     * @returns {HTMLElement} the overlay element
     */
    function modalOpen(opts) {
        modalClose(); // close any existing
        const overlay = document.createElement('div');
        overlay.className = 'modal-overlay';
        overlay.id = 'active-modal-overlay';

        const sizeCls = opts.size ? ` ${opts.size}` : '';
        const footerBtns = (opts.footerButtons || []).map(b =>
            `<button class="btn btn-sm ${b.cls || 'btn-secondary'}" ` +
            `onclick="${b.onclick || ''}"${b.id ? ` id="${b.id}"` : ''}${b.disabled ? ' disabled' : ''}` +
            `${b.style ? ` style="${b.style}"` : ''}>` +
            `${esc(b.label)}</button>`
        ).join('');

        overlay.innerHTML =
            `<div class="modal-box${sizeCls}">` +
            `<div class="modal-header">` +
            `<span class="modal-title">${opts.title}</span>` +
            `<button class="modal-close" onclick="modalClose()" title="Close">âœ•</button>` +
            `</div>` +
            `<div class="modal-body">${opts.body}</div>` +
            (footerBtns || opts.footerStatus ?
                `<div class="modal-footer">` +
                `<span class="modal-footer-status" id="modal-footer-status">${opts.footerStatus || ''}</span>` +
                `<div class="modal-footer-right">${footerBtns}</div>` +
                `</div>` : '') +
            `</div>`;

        // Close on overlay click (not box click)
        overlay.addEventListener('click', e => {
            if (e.target === overlay) modalClose();
        });

        // Close on Escape
        const escHandler = e => { if (e.key === 'Escape') modalClose(); };
        document.addEventListener('keydown', escHandler);

        _activeModal = { overlay, escHandler, onClose: opts.onClose };
        document.body.appendChild(overlay);
        return overlay;
    }

    /** Close the active modal. */
    function modalClose() {
        if (!_activeModal) return;
        const { overlay, escHandler, onClose } = _activeModal;
        document.removeEventListener('keydown', escHandler);
        overlay.remove();
        _activeModal = null;
        if (onClose) onClose();
    }

    /**
     * Build step indicator HTML.
     * @param {string[]} stepNames - array of step labels
     * @param {number} activeIndex - 0-based current step
     * @returns {string} HTML
     */
    function modalSteps(stepNames, activeIndex) {
        return `<div class="modal-steps">${stepNames.map((name, i) => {
            const cls = i < activeIndex ? 'done' : (i === activeIndex ? 'active' : '');
            const dot = i < activeIndex ? 'âœ“' : String(i + 1);
            return (i > 0 ? `<span class="modal-step-arrow">â†’</span>` : '') +
                `<span class="modal-step ${cls}">` +
                `<span class="modal-step-dot">${dot}</span> ${esc(name)}</span>`;
        }).join('')}</div>`;
    }

    /**
     * Build a form field HTML string (for use inside modal forms).
     * @param {Object} f - field definition
     * @param {string} f.name - input name/id
     * @param {string} f.label - label text
     * @param {string} [f.type] - 'text'|'select'|'textarea'|'checkbox'|'number'
     * @param {string} [f.value] - default value
     * @param {string} [f.placeholder] - placeholder text
     * @param {boolean} [f.required] - show required marker
     * @param {string} [f.hint] - hint text under input
     * @param {Array<{value:string, label:string}>} [f.options] - for select type
     * @param {boolean} [f.fullWidth] - span both columns
     * @returns {string} HTML
     */
    function modalFormField(f) {
        const cls = f.fullWidth ? 'modal-form-group full-width' : 'modal-form-group';
        const req = f.required ? '<span class="required">*</span>' : '';
        let input = '';

        if (f.type === 'select') {
            const opts = (f.options || []).map(o =>
                `<option value="${esc(o.value)}"${o.value === f.value ? ' selected' : ''}>${esc(o.label)}</option>`
            ).join('');
            input = `<select class="modal-form-select" id="mf-${f.name}" name="${f.name}">${opts}</select>`;
        } else if (f.type === 'textarea') {
            input = `<textarea class="modal-form-textarea" id="mf-${f.name}" name="${f.name}" ` +
                `placeholder="${esc(f.placeholder || '')}">${esc(f.value || '')}</textarea>`;
        } else if (f.type === 'checkbox') {
            return `<label class="modal-form-check ${f.fullWidth ? 'full-width' : ''}">` +
                `<input type="checkbox" id="mf-${f.name}" name="${f.name}"${f.value ? ' checked' : ''}>` +
                `${esc(f.label)}</label>`;
        } else {
            const t = f.type || 'text';
            input = `<input class="modal-form-input" type="${t}" id="mf-${f.name}" name="${f.name}" ` +
                `value="${esc(f.value || '')}" placeholder="${esc(f.placeholder || '')}">`;
        }

        return `<div class="${cls}">` +
            `<label class="modal-form-label" for="mf-${f.name}">${esc(f.label)}${req}</label>` +
            `${input}` +
            (f.hint ? `<span class="modal-form-hint">${esc(f.hint)}</span>` : '') +
            `</div>`;
    }

    /**
     * Build a preview panel HTML string.
     * @param {string} title - header label
     * @param {string} content - pre-formatted content
     * @param {string} [id] - optional ID for the body element
     * @returns {string} HTML
     */
    function modalPreview(title, content, id) {
        return `<div class="modal-preview">` +
            `<div class="modal-preview-header">${esc(title)}</div>` +
            `<div class="modal-preview-body"${id ? ` id="${id}"` : ''}>${esc(content)}</div>` +
            `</div>`;
    }

    /** Get a modal form field value by name. */
    function mfVal(name) {
        const el = document.getElementById('mf-' + name);
        if (!el) return '';
        if (el.type === 'checkbox') return el.checked;
        return el.value;
    }

    /** Set modal footer status text. */
    function modalStatus(text, type) {
        const el = document.getElementById('modal-footer-status');
        if (!el) return;
        el.textContent = text;
        el.style.color = type === 'error' ? 'var(--error)' :
            type === 'success' ? 'var(--success)' : 'var(--text-muted)';
    }

    /** Show inline error in modal body. */
    function modalError(msg) {
        // Remove previous error
        document.querySelectorAll('.modal-inline-error').forEach(e => e.remove());
        if (!msg) return;
        const body = document.querySelector('.modal-body');
        if (!body) return;
        const div = document.createElement('div');
        div.className = 'modal-inline-error';
        div.textContent = msg;
        body.appendChild(div);
    }


    // â”€â”€ Missing Tools Banner â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    //
    // Shared function to render missing tool banners with install buttons.
    // Any tab can call: renderMissingTools(data.missing_tools, 'container-id')

    /**
     * Render a missing-tools banner into a container element.
     * @param {Array} missingTools - Array of {id, label, install_type, has_recipe, needs_sudo}
     * @param {string} containerId - DOM id to render into
     * @param {Function} [onInstalled] - Optional callback after successful install
     */
    async function renderMissingTools(missingTools, containerId, onInstalled) {
        const el = document.getElementById(containerId);
        if (!el) return;
        if (!missingTools || missingTools.length === 0) {
            el.innerHTML = '';
            el.style.display = 'none';
            return;
        }
        el.style.display = 'block';

        // Fetch pending plans to show resume buttons
        var pending = await _fetchPendingPlans();

        let html = '<div class="missing-tools-banner">'
            + '<div class="missing-tools-header">'
            + '<span style="font-size:1rem">âš ï¸</span>'
            + '<span><strong>' + missingTools.length + ' tool'
            + (missingTools.length > 1 ? 's' : '') + ' missing</strong></span>'
            + '</div>'
            + '<div class="missing-tools-list">';

        for (const tool of missingTools) {
            const dataAttr = ' data-tool-id="' + esc(tool.id) + '"'
                + ' data-tool-label="' + esc(tool.label) + '"'
                + ' data-needs-sudo="' + (tool.needs_sudo ? '1' : '0') + '"';

            var pendingPlan = _getPendingPlanForTool(tool.id, pending);

            html += '<div class="missing-tool-item">'
                + '<span class="missing-tool-label">' + esc(tool.label) + '</span>';

            if (pendingPlan) {
                html += '<button class="btn btn-sm" style="background:var(--warning,#e8a735);color:#000;margin-right:4px"'
                    + ' data-plan-id="' + esc(pendingPlan.plan_id) + '"'
                    + ' data-tool-label="' + esc(tool.label) + '"'
                    + ' onclick="resumeToolFromBanner(this)">'
                    + 'ğŸ”„ Resume (' + pendingPlan.completed_count + '/' + pendingPlan.total_steps + ')</button>';
            }

            html += '<button class="btn btn-sm btn-install-tool"'
                + dataAttr
                + ' onclick="installToolFromBanner(this'
                + (onInstalled ? ',true' : '') + ')">'
                + 'ğŸ“¦ Install</button>'
                + '</div>';
        }

        html += '</div></div>';
        el.innerHTML = html;
    }

    /**
     * Return missing-tools HTML string for inline use (e.g. inside modals).
     * Does NOT need a container id.
     */
    function renderMissingToolsInline(missingTools) {
        if (!missingTools || missingTools.length === 0) return '';

        let html = '<div class="missing-tools-banner" style="margin:0.75rem 0">'
            + '<div class="missing-tools-header">'
            + '<span style="font-size:0.9rem">âš ï¸</span>'
            + '<span style="font-size:0.82rem"><strong>' + missingTools.length + ' tool'
            + (missingTools.length > 1 ? 's' : '') + ' not installed</strong></span>'
            + '</div>'
            + '<div class="missing-tools-list">';

        for (const tool of missingTools) {
            html += '<div class="missing-tool-item">'
                + '<span class="missing-tool-label">' + esc(tool.label) + '</span>'
                + '<button class="btn btn-sm btn-install-tool"'
                + ' data-tool-id="' + esc(tool.id) + '"'
                + ' data-tool-label="' + esc(tool.label) + '"'
                + ' data-needs-sudo="' + (tool.needs_sudo ? '1' : '0') + '"'
                + ' onclick="installToolFromBanner(this)">'
                + 'ğŸ“¦ Install</button>'
                + '</div>';
        }

        html += '</div></div>';
        return html;
    }

    /**
     * Install a tool via the banner install button.
     * Delegates to the plan-based flow (Phase 3).
     */
    async function installToolFromBanner(btn, triggerRefresh) {
        const toolId = btn.dataset.toolId;
        const toolLabel = btn.dataset.toolLabel;

        btn.disabled = true;
        btn.textContent = 'â³ Loadingâ€¦';

        installWithPlan(toolId, toolLabel || toolId, {
            onComplete: function() {
                btn.textContent = 'âœ… Installed';
                btn.classList.add('btn-success');
                if (triggerRefresh) _refreshAfterInstall();
            },
        });

        // Re-enable button after a short delay (modal takes over)
        setTimeout(function() {
            if (btn.textContent === 'â³ Loadingâ€¦') {
                btn.disabled = false;
                btn.textContent = 'ğŸ“¦ Install';
            }
        }, 3000);
    }

    async function resumeToolFromBanner(btn) {
        const planId = btn.dataset.planId;
        const toolLabel = btn.dataset.toolLabel;

        btn.disabled = true;
        btn.textContent = 'â³ Loadingâ€¦';

        resumeWithPlan(planId, toolLabel, {
            onComplete: function() {
                btn.textContent = 'âœ… Done';
                btn.classList.add('btn-success');
                _refreshAfterInstall();
            },
        });

        // Re-enable button after a short delay (modal takes over)
        setTimeout(function() {
            if (btn.textContent === 'â³ Loadingâ€¦') {
                btn.disabled = false;
                btn.textContent = 'ğŸ”„ Resume';
            }
        }, 3000);
    }

    // â”€â”€ Backwards-compatible wrapper (used by 6+ integration templates) â”€â”€
    function _showSudoInstallModal(toolId, toolLabel, originBtn, triggerRefresh) {
        installWithPlan(toolId, toolLabel || toolId, {
            onComplete: triggerRefresh ? () => _refreshAfterInstall() : null,
        });
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  Unified Ops Modal â€” handles Install + Auth + Interactive flows
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    /**
     * Unified modal for system operations (install, auth, interactive).
     *
     * @param {Object} config
     * @param {string} config.type           'install' | 'auth'
     *
     * Install mode:
     * @param {string} config.toolId         Tool identifier (e.g. 'gh')
     * @param {string} config.toolLabel      Display name (e.g. 'GitHub CLI')
     * @param {Function} [config.onSuccess]  Callback after successful install
     *
     * Auth mode:
     * @param {string} config.title          Modal title
     * @param {string} config.description    Explanation text
     * @param {string} config.loginEndpoint  API endpoint for auth (e.g. '/gh/auth/login')
     * @param {string} config.pollEndpoint   API endpoint to poll for completion
     * @param {Function} config.pollCheck    (data) => boolean â€” returns true when auth is done
     * @param {number} [config.pollInterval] Polling interval in ms (default 3000)
     * @param {number} [config.pollTimeout]  Polling timeout in ms (default 300000)
     * @param {string} [config.tokenHint]    Hint text for token input
     * @param {string} [config.tokenUrl]     URL to create tokens
     * @param {Function} [config.onSuccess]  Callback after successful auth
     */
    function _showOpsModal(config) {
        if (config.type === 'install') return _showInstallModal(config);
        if (config.type === 'auth')    return _showAuthModal(config);
        console.warn('_showOpsModal: unknown type', config.type);
    }

    // â”€â”€ Install Modal â€” delegates to plan-based flow (Phase 3) â”€â”€â”€â”€

    function _showInstallModal(config) {
        const { toolId, toolLabel } = config;

        installWithPlan(toolId, toolLabel || toolId, {
            onComplete: config.onSuccess || null,
        });
    }


    // â”€â”€ Remediation modal â€” shows options when install fails â”€â”€â”€â”€â”€
    //  Restored from pre-Phase-3 code. Used by both direct-install
    //  and plan-based flows when _analyse_install_failure returns options.
    //  Executes via /api/audit/remediate (SSE stream).

    function _showRemediationModal(toolId, toolLabel, remediation, onSuccess, stderr) {
        var cols = remediation.options.length;
        var gridCols = cols >= 3 ? '1fr 1fr 1fr' : cols === 2 ? '1fr 1fr' : '1fr';

        // Build option grid
        var optionsHtml = '<div style="display:grid;grid-template-columns:' + gridCols +
            ';gap:var(--space-sm);margin-bottom:var(--space-md)">';
        for (var i = 0; i < remediation.options.length; i++) {
            var opt = remediation.options[i];
            var isFirst = (i === 0);
            var borderColor = isFirst ? 'var(--accent)' : 'var(--border)';
            var bg = isFirst
                ? 'color-mix(in srgb, var(--accent) 8%, var(--bg-primary))'
                : 'var(--bg-primary)';
            optionsHtml += '<button class="btn btn-sm" id="rem-opt-' + i + '"' +
                ' style="padding:10px;display:flex;flex-direction:column;align-items:center;' +
                'gap:3px;border:2px solid ' + borderColor + ';background:' + bg + ';cursor:pointer"' +
                ' onclick="_remSelectPath(' + i + ')">' +
                '<span style="font-size:1.2rem">' + (opt.icon || 'ğŸ“¦') + '</span>' +
                '<strong style="font-size:0.74rem">' + esc(opt.label) + '</strong>' +
                (isFirst ? '<span style="font-size:0.62rem;color:var(--text-muted)">Recommended</span>' : '') +
                '</button>';
        }
        optionsHtml += '</div>';

        // Build per-option panels
        var panelsHtml = '';
        for (var i = 0; i < remediation.options.length; i++) {
            var opt = remediation.options[i];
            var display = (i === 0) ? 'block' : 'none';
            // Check if any step or the option itself needs sudo
            var optNeedsSudo = opt.needs_sudo;
            if (!optNeedsSudo && opt.steps) {
                for (var si = 0; si < opt.steps.length; si++) {
                    if (opt.steps[si].needs_sudo) { optNeedsSudo = true; break; }
                }
            }
            var sudoHtml = '';
            if (optNeedsSudo) {
                sudoHtml = '<label style="font-size:0.72rem;color:var(--text-muted);display:block;margin-bottom:3px;margin-top:var(--space-sm)">sudo password</label>' +
                    '<input id="rem-sudo-pw-' + i + '" type="password" autocomplete="off" placeholder="Required for this option" ' +
                    'style="width:100%;padding:6px 8px;border:1px solid var(--border);border-radius:var(--radius-sm);' +
                    'background:var(--bg-inset);color:var(--text-primary);font-size:0.82rem;margin-bottom:var(--space-sm);' +
                    'box-sizing:border-box" />';
            }
            panelsHtml += '<div id="rem-panel-' + i + '" style="display:' + display + '">' +
                '<div style="font-size:0.82rem;color:var(--text-secondary);margin-bottom:var(--space-sm)">' +
                esc(opt.description) + '</div>' +
                sudoHtml +
                '<button class="btn btn-sm btn-primary" id="rem-action-' + i + '" ' +
                'style="width:100%;padding:10px" ' +
                'onclick="_remExecute(' + i + ')">' +
                (opt.icon || 'ğŸ“¦') + ' ' + esc(opt.label) + '</button></div>';
        }

        var stderrHtml = '';
        if (stderr) {
            stderrHtml = '<pre style="margin-top:0.5rem;margin-bottom:var(--space-md);padding:0.5rem;background:var(--bg-inset);' +
                'border-radius:var(--radius-sm);font-size:0.72rem;max-height:150px;overflow:auto;' +
                'white-space:pre-wrap;word-break:break-word;color:var(--text-muted)">' +
                esc(stderr) + '</pre>';
        }
        var bodyHtml = '<div style="font-size:0.85rem;color:var(--text-secondary);margin-bottom:var(--space-md)">' +
            esc(remediation.reason) + '</div>' + stderrHtml +
            optionsHtml + panelsHtml +
            '<div id="rem-status" style="display:none;margin-top:var(--space-md);padding:12px;' +
            'border-radius:var(--radius-sm);background:var(--bg-inset);font-size:0.78rem;text-align:center"></div>';

        // Use stacked overlay (z-index 10001) so it renders on top of step-modal (10000)
        var existing = document.getElementById('rem-modal-overlay');
        if (existing) existing.remove();

        var overlay = document.createElement('div');
        overlay.id = 'rem-modal-overlay';
        overlay.className = 'modal-overlay';
        overlay.style.zIndex = '10001';
        overlay.innerHTML =
            '<div class="modal-box" style="max-width:520px;width:90%">' +
            '<div class="modal-header">' +
            '<span class="modal-title">ğŸ”§ Install Options â€” ' + esc(toolLabel) + '</span>' +
            '<button class="modal-close" id="rem-modal-close" title="Close">âœ•</button>' +
            '</div>' +
            '<div class="modal-body">' + bodyHtml + '</div>' +
            '</div>';

        document.body.appendChild(overlay);

        // Close handlers
        function _remClose() {
            var el = document.getElementById('rem-modal-overlay');
            if (el) el.remove();
        }
        document.getElementById('rem-modal-close').addEventListener('click', _remClose);
        overlay.addEventListener('click', function(e) {
            if (e.target === overlay) _remClose();
        });

        // Store state for handlers
        window._remState = {
            toolId: toolId,
            toolLabel: toolLabel,
            remediation: remediation,
            onSuccess: onSuccess,
            selectedPath: 0,
        };

        // Path selector
        window._remSelectPath = function(idx) {
            var opts = window._remState.remediation.options;
            for (var j = 0; j < opts.length; j++) {
                var btn = document.getElementById('rem-opt-' + j);
                var panel = document.getElementById('rem-panel-' + j);
                if (j === idx) {
                    if (btn) { btn.style.borderColor = 'var(--accent)'; btn.style.background = 'color-mix(in srgb, var(--accent) 8%, var(--bg-primary))'; }
                    if (panel) panel.style.display = 'block';
                } else {
                    if (btn) { btn.style.borderColor = 'var(--border)'; btn.style.background = 'var(--bg-primary)'; }
                    if (panel) panel.style.display = 'none';
                }
            }
            window._remState.selectedPath = idx;
        };

        // Show a modal for missing system dependencies (stacked on top)
        function _showDepsModal(missingPkgs, depOnSuccess) {
            var pkgList = missingPkgs.map(function(p) { return '<code>' + esc(p) + '</code>'; }).join(', ');

            var overlay = document.createElement('div');
            overlay.className = 'modal-overlay';
            overlay.id = 'deps-modal-overlay';
            overlay.style.zIndex = '10001';
            overlay.innerHTML =
                '<div class="modal-box">' +
                '<div class="modal-header">' +
                '<span class="modal-title">ğŸ“¦ Missing System Dependencies</span>' +
                '<button class="modal-close" onclick="document.getElementById(\'deps-modal-overlay\').remove()" title="Close">âœ•</button>' +
                '</div>' +
                '<div class="modal-body">' +
                '<div style="font-size:0.85rem;color:var(--text-secondary);margin-bottom:var(--space-md)">' +
                'The following system packages are required but not installed:</div>' +
                '<div style="font-size:0.9rem;font-weight:600;margin-bottom:var(--space-md)">' + pkgList + '</div>' +
                '<label style="font-size:0.78rem;color:var(--text-muted);display:block;margin-bottom:4px">sudo password</label>' +
                '<input id="deps-sudo-pw" type="password" autocomplete="off" ' +
                'style="width:100%;padding:8px;border:1px solid var(--border);border-radius:var(--radius-sm);' +
                'background:var(--bg-inset);color:var(--text-primary);font-size:0.85rem;margin-bottom:var(--space-md);' +
                'box-sizing:border-box" />' +
                '<div id="deps-status" style="display:none;margin-bottom:var(--space-md);padding:6px;' +
                'border-radius:var(--radius-sm);background:var(--bg-inset);font-size:0.78rem;text-align:left"></div>' +
                '<button id="deps-install-btn" onclick="_depsInstall()" ' +
                'style="width:100%;padding:10px;border-radius:var(--radius-sm);background:var(--accent);' +
                'color:#fff;border:none;cursor:pointer;font-weight:600;font-size:0.85rem">' +
                'ğŸ”’ Install</button>' +
                '</div></div>';

            overlay.addEventListener('click', function(e) {
                if (e.target === overlay) overlay.remove();
            });

            document.body.appendChild(overlay);
            setTimeout(function() {
                var pwField = document.getElementById('deps-sudo-pw');
                if (pwField) pwField.focus();
            }, 100);

            window._depsInstallPkgs = missingPkgs;
            window._depsOnSuccess = depOnSuccess;
        }

        window._depsInstall = async function() {
            var pkgs = window._depsInstallPkgs;
            var depOnSuccess = window._depsOnSuccess;
            var btn = document.getElementById('deps-install-btn');
            var statusEl = document.getElementById('deps-status');
            var pwField = document.getElementById('deps-sudo-pw');
            var pw = pwField ? pwField.value : '';

            if (!pw) {
                if (pwField) { pwField.style.borderColor = 'var(--danger)'; pwField.focus(); }
                return;
            }

            if (btn) { btn.disabled = true; btn.textContent = 'â³ Installingâ€¦'; }
            if (statusEl) {
                statusEl.style.display = 'block';
                statusEl.innerHTML = '<div id="deps-label" style="font-size:0.72rem;font-weight:600;margin-bottom:4px">â³ Installing packagesâ€¦</div>' +
                    '<pre id="deps-log" style="margin:0;padding:6px;background:var(--bg-inset);border-radius:var(--radius-sm);' +
                    'font-size:0.68rem;max-height:180px;overflow:auto;white-space:pre-wrap;word-break:break-word;' +
                    'color:var(--text-muted);font-family:var(--font-mono,monospace)"></pre>';
            }
            var logEl = document.getElementById('deps-log');

            try {
                var res = await fetch('/api/audit/remediate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        tool: 'system-deps',
                        cli: 'apt-get',
                        override_command: ['apt-get', 'install', '-y'].concat(pkgs),
                        sudo_password: pw,
                    }),
                });

                var reader = res.body.getReader();
                var decoder = new TextDecoder();
                var result = { ok: false };
                var buf = '';

                while (true) {
                    var chunk = await reader.read();
                    if (chunk.done) break;
                    buf += decoder.decode(chunk.value, { stream: true });
                    var lines = buf.split('\n');
                    buf = lines.pop() || '';
                    for (var li = 0; li < lines.length; li++) {
                        var ln = lines[li];
                        if (!ln.startsWith('data: ')) continue;
                        try {
                            var evt = JSON.parse(ln.slice(6));
                            if (evt.line !== undefined && logEl) {
                                logEl.textContent += evt.line + '\n';
                                logEl.scrollTop = logEl.scrollHeight;
                            }
                            if (evt.done) result = evt;
                        } catch (_) {}
                    }
                }

                var labelEl = document.getElementById('deps-label');
                if (result.ok) {
                    if (labelEl) labelEl.innerHTML = 'âœ… Packages installed!';
                    toast('âœ… System packages installed', 'success');
                    setTimeout(function() {
                        var depsOverlay = document.getElementById('deps-modal-overlay');
                        if (depsOverlay) depsOverlay.remove();
                        if (depOnSuccess) depOnSuccess();
                    }, 1000);
                } else {
                    if (labelEl) labelEl.innerHTML = 'âŒ Failed (exit ' + (result.exit_code || '?') + ')';
                    if (btn) { btn.disabled = false; btn.textContent = 'ğŸ”„ Retry'; }
                }
            } catch (err) {
                if (statusEl) statusEl.textContent = 'âŒ ' + err.message;
                if (btn) { btn.disabled = false; btn.textContent = 'ğŸ”„ Retry'; }
            }
        };

        // Execute the selected remediation option
        window._remExecute = async function(idx) {
            var opt = window._remState.remediation.options[idx];
            var st = window._remState;
            var statusEl = document.getElementById('rem-status');
            var actionBtn = document.getElementById('rem-action-' + idx);

            // â”€â”€ Check system_deps before running â”€â”€
            if (opt.system_deps && opt.system_deps.length > 0) {
                var depRes = await fetch('/api/audit/check-deps', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ packages: opt.system_deps }),
                });
                var depData = await depRes.json();
                if (depData.missing && depData.missing.length > 0) {
                    // Show deps modal on top
                    _showDepsModal(depData.missing, function() {
                        // After deps installed, retry the original option
                        window._remExecute(idx);
                    });
                    return;
                }
            }

            if (actionBtn) { actionBtn.disabled = true; actionBtn.textContent = 'â³ Workingâ€¦'; }
            if (statusEl) { statusEl.style.display = 'block'; statusEl.textContent = ''; statusEl.style.textAlign = 'left'; }

            // Helper: stream a command and show lines in statusEl
            async function streamCommand(command, label, needsSudo) {
                // Create label + log area (only if not already present)
                var logEl = document.getElementById('rem-log');
                if (!logEl && statusEl) {
                    statusEl.innerHTML = '<div id="rem-label" style="font-size:0.72rem;font-weight:600;margin-bottom:4px"></div>' +
                        '<pre id="rem-log" style="margin:0;padding:6px;background:var(--bg-inset);border-radius:var(--radius-sm);' +
                        'font-size:0.68rem;max-height:180px;overflow:auto;white-space:pre-wrap;word-break:break-word;' +
                        'color:var(--text-muted);font-family:var(--font-mono,monospace)"></pre>';
                    logEl = document.getElementById('rem-log');
                }
                var labelEl = document.getElementById('rem-label');
                if (labelEl) labelEl.innerHTML = 'â³ ' + esc(label);

                // Read sudo password from the option's password field
                var sudoPw = '';
                if (needsSudo) {
                    var pwField = document.getElementById('rem-sudo-pw-' + idx);
                    sudoPw = pwField ? pwField.value : '';
                    if (!sudoPw) {
                        if (pwField) { pwField.style.borderColor = 'var(--danger)'; pwField.focus(); }
                        return { ok: false, error: 'Sudo password required' };
                    }
                }

                var res = await fetch('/api/audit/remediate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        tool: st.toolId,
                        cli: st.toolId,
                        override_command: command,
                        sudo_password: sudoPw,
                    }),
                });

                var reader = res.body.getReader();
                var decoder = new TextDecoder();
                var result = { ok: false };
                var buf = '';

                while (true) {
                    var chunk = await reader.read();
                    if (chunk.done) break;
                    buf += decoder.decode(chunk.value, { stream: true });
                    var lines = buf.split('\n');
                    buf = lines.pop() || '';
                    for (var li = 0; li < lines.length; li++) {
                        var ln = lines[li];
                        if (!ln.startsWith('data: ')) continue;
                        try {
                            var evt = JSON.parse(ln.slice(6));
                            if (evt.line !== undefined && logEl) {
                                logEl.textContent += evt.line + '\n';
                                logEl.scrollTop = logEl.scrollHeight;
                            }
                            if (evt.done) result = evt;
                        } catch (_) {}
                    }
                }
                return result;
            }

            try {
                // Multi-step option (e.g. upgrade rust then install)
                if (opt.steps) {
                    for (var s = 0; s < opt.steps.length; s++) {
                        var step = opt.steps[s];
                        var stepLabel = 'Step ' + (s + 1) + '/' + opt.steps.length + ': ' + step.label;
                        var stepResult = await streamCommand(step.command, stepLabel, step.needs_sudo);
                        if (!stepResult.ok) {
                            var labelEl = document.getElementById('rem-label');
                            if (labelEl) labelEl.innerHTML = 'âŒ ' + esc(stepLabel) + ' failed (exit ' + (stepResult.exit_code || '?') + ')';
                            if (actionBtn) { actionBtn.disabled = false; actionBtn.textContent = 'ğŸ”„ Retry'; }
                            return;
                        }
                        // Mark step done in label
                        var labelEl2 = document.getElementById('rem-label');
                        if (labelEl2) labelEl2.innerHTML = 'âœ… ' + esc(stepLabel);
                    }
                    // All steps done
                    var labelElDone = document.getElementById('rem-label');
                    if (labelElDone) labelElDone.innerHTML = 'âœ… All steps complete!';
                    toast('âœ… ' + st.toolLabel + ' installed!', 'success');
                    cardInvalidate('tools-status');
                    setTimeout(function() {
                        _remClose();
                        var sm = document.getElementById('step-modal');
                        if (sm) sm.remove();
                        if (st.onSuccess) st.onSuccess();
                    }, 1500);
                    return;
                }

                // Single-command option (e.g. compatible version, build from source)
                if (opt.command) {
                    var cmdResult = await streamCommand(opt.command, opt.label, opt.needs_sudo);
                    if (cmdResult.ok) {
                        var cmdLabelOk = document.getElementById('rem-label');
                        if (cmdLabelOk) cmdLabelOk.innerHTML = 'âœ… ' + esc(st.toolLabel) + ' installed!';
                        toast('âœ… ' + st.toolLabel + ' installed!', 'success');
                        cardInvalidate('tools-status');
                        setTimeout(function() {
                            _remClose();
                            var sm = document.getElementById('step-modal');
                            if (sm) sm.remove();
                            if (st.onSuccess) st.onSuccess();
                        }, 1500);
                    } else {
                        var cmdLabelFail = document.getElementById('rem-label');
                        if (cmdLabelFail) cmdLabelFail.innerHTML = 'âŒ Failed (exit ' + (cmdResult.exit_code || '?') + ')';
                        if (actionBtn) { actionBtn.disabled = false; actionBtn.textContent = 'ğŸ”„ Retry'; }
                    }
                    return;
                }

                // Retry-sudo option
                if (opt.retry_sudo) {
                    _remClose();
                    var sm = document.getElementById('step-modal');
                    if (sm) sm.remove();
                    _showInstallModal({ toolId: st.toolId, toolLabel: st.toolLabel, needsSudo: true, onSuccess: st.onSuccess });
                    return;
                }
            } catch (err) {
                if (statusEl) statusEl.textContent = 'âŒ Error: ' + err.message;
                if (actionBtn) { actionBtn.disabled = false; actionBtn.textContent = 'ğŸ”„ Retry'; }
            }
        };
    }

    /**
     * Show modal when a tool needs a dependency installed first.
     * After installing the dep, chains back to install the original tool.
     */
    function _showDepInstallModal(toolId, toolLabel, dep, onSuccess) {
        var depTool = dep.tool;
        var depLabel = dep.label;

        modalOpen({
            title: 'ğŸ“¦ Dependency Required',
            size: 'narrow',
            body:
                '<div style="font-size:0.85rem;color:var(--text-secondary);line-height:1.5">' +
                '<p><strong>' + esc(toolLabel) + '</strong> requires <strong>' + esc(depLabel) +
                '</strong> to install.</p>' +
                '<p style="margin-top:0.5rem">' + esc(depLabel) +
                ' is not installed on this system. Install it first, then ' +
                esc(toolLabel) + ' will be installed automatically.</p>' +
                '</div>',
            footerButtons: [
                { label: 'Cancel', cls: 'btn-secondary', onclick: 'modalClose()' },
                {
                    label: 'ğŸ“¦ Install ' + depLabel,
                    cls: 'btn-primary',
                    id: 'dep-install-btn',
                    onclick: '_doDepChainInstall()',
                },
            ],
        });

        window._doDepChainInstall = async function() {
            var btn = document.getElementById('dep-install-btn');
            if (btn) { btn.disabled = true; btn.textContent = 'â³ Installing ' + depLabel + 'â€¦'; }

            try {
                var depRes = await fetch('/api/audit/install-tool', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ tool: depTool, cli: depTool }),
                });
                var depResult = await depRes.json();

                if (depResult.ok || depResult.already_installed) {
                    toast('âœ… ' + depLabel + ' installed! Now installing ' + toolLabel + 'â€¦', 'success');
                    modalClose();
                    // Chain-install the original tool
                    installWithPlan(toolId, toolLabel, { onComplete: onSuccess });
                } else if (depResult.needs_sudo) {
                    modalClose();
                    _showInstallModal({
                        toolId: depTool,
                        toolLabel: depLabel,
                        onSuccess: function() {
                            toast('âœ… ' + depLabel + ' installed! Now installing ' + toolLabel + 'â€¦', 'success');
                            setTimeout(function() {
                                installWithPlan(toolId, toolLabel, { onComplete: onSuccess });
                            }, 800);
                        },
                    });
                } else {
                    toast('âŒ ' + (depResult.error || 'Failed to install ' + depLabel), 'error');
                    if (btn) { btn.disabled = false; btn.textContent = 'ğŸ”„ Retry'; }
                }
            } catch (err) {
                toast('âŒ Error: ' + err.message, 'error');
                if (btn) { btn.disabled = false; btn.textContent = 'ğŸ”„ Retry'; }
            }
        };
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  Phase 3 â€” Plan-based step modal (coexists with old flow)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    // â”€â”€ Inject step-modal CSS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    (function _injectStepModalCSS() {
        if (document.getElementById('step-modal-css')) return;
        var style = document.createElement('style');
        style.id = 'step-modal-css';
        style.textContent = [
            '.step-modal-overlay{position:fixed;inset:0;z-index:10000;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,.55);backdrop-filter:blur(4px);animation:fadeIn .15s ease}',
            '.step-modal-box{background:var(--bg-primary);border:1px solid var(--border);border-radius:var(--radius-md,8px);max-width:520px;width:90%;max-height:80vh;display:flex;flex-direction:column;box-shadow:0 16px 48px rgba(0,0,0,.4);animation:slideUp .2s ease}',
            '@keyframes slideUp{from{opacity:0;transform:translateY(12px)}to{opacity:1;transform:none}}',
            '.step-modal-header{display:flex;align-items:center;justify-content:space-between;padding:14px 18px;border-bottom:1px solid var(--border)}',
            '.step-modal-header h3{margin:0;font-size:0.95rem;font-weight:700}',
            '.step-modal-close{background:none;border:none;color:var(--text-muted);font-size:1.1rem;cursor:pointer;padding:4px 8px;border-radius:4px}',
            '.step-modal-close:hover{color:var(--text-primary);background:var(--bg-hover)}',
            '.step-modal-body{padding:16px 18px;overflow-y:auto;flex:1}',
            '.step-modal-footer{display:flex;gap:var(--space-sm,8px);justify-content:flex-end;padding:12px 18px;border-top:1px solid var(--border)}',
            '.step-list{display:flex;flex-direction:column;gap:4px;margin-bottom:12px}',
            '.step-row{display:flex;align-items:center;gap:8px;padding:7px 10px;border-radius:var(--radius-sm,4px);background:var(--bg-inset);font-size:0.82rem;transition:background .2s,opacity .2s,box-shadow .2s}',
            '.step-row[data-status="running"]{background:var(--bg-hover);box-shadow:inset 3px 0 0 var(--accent)}',
            '.step-row[data-status="done"]{opacity:.65}',
            '.step-row[data-status="skipped"]{opacity:.5}',
            '.step-row[data-status="failed"]{background:hsl(0 40% 15%);box-shadow:inset 3px 0 0 hsl(0 70% 50%)}',
            '.step-icon{width:20px;text-align:center;flex-shrink:0;font-size:0.9rem}',
            '.step-label{flex:1;min-width:0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}',
            '.step-badge{font-size:0.62rem;padding:1px 6px;border-radius:8px;margin-left:auto;flex-shrink:0;font-weight:600;text-transform:uppercase;letter-spacing:.03em}',
            '.step-badge.sudo{background:hsl(40 60% 20%);color:hsl(40 90% 70%)}',
            '.step-badge.risk-medium{background:hsl(40 60% 20%);color:hsl(40 90% 70%)}',
            '.step-badge.risk-high{background:hsl(0 60% 20%);color:hsl(0 90% 70%)}',
            '.step-risk-dot{width:8px;height:8px;border-radius:50%;flex-shrink:0}',
            '.step-risk-dot.low{background:hsl(140 60% 45%)}',
            '.step-risk-dot.medium{background:hsl(40 90% 55%)}',
            '.step-risk-dot.high{background:hsl(0 70% 50%)}',
            '.step-elapsed{font-size:0.62rem;color:var(--text-muted);margin-left:4px;flex-shrink:0}',
            '.step-log-area{font-family:var(--font-mono,monospace);font-size:0.7rem;padding:8px 10px;border-radius:var(--radius-sm,4px);background:var(--bg-inset);max-height:140px;overflow-y:auto;white-space:pre-wrap;word-break:break-all;color:var(--text-muted);line-height:1.45}',
            '.step-sudo-row{margin-bottom:10px}',
            '.step-sudo-row input{width:100%;padding:8px 12px;border:1px solid var(--border);border-radius:var(--radius-sm,4px);background:var(--bg-inset);color:var(--text-primary);font-size:0.85rem;box-sizing:border-box}',
            '.step-sudo-row input:focus{outline:none;border-color:var(--accent);box-shadow:0 0 0 2px color-mix(in srgb, var(--accent) 20%, transparent)}',
            '.risk-banner{padding:8px 12px;border-radius:var(--radius-sm,4px);margin-bottom:12px;font-size:0.8rem}',
            '.risk-banner.risk-medium{background:hsl(40 60% 15%);border-left:3px solid hsl(40 90% 60%);color:hsl(40 90% 80%)}',
            '.risk-banner.risk-high{background:hsl(0 60% 15%);border-left:3px solid hsl(0 90% 60%);color:hsl(0 90% 80%)}',
            '.confirm-gate{padding:12px 14px;border-radius:var(--radius-sm,4px);margin-bottom:12px;font-size:0.8rem}',
            '.confirm-gate.gate-single{background:hsl(40 50% 12%);border:1px solid hsl(40 60% 30%)}',
            '.confirm-gate.gate-double{background:hsl(0 50% 12%);border:1px solid hsl(0 60% 30%)}',
            '.confirm-gate label{display:flex;align-items:center;gap:8px;cursor:pointer;font-weight:600}',
            '.confirm-gate input[type="checkbox"]{accent-color:var(--accent);width:16px;height:16px}',
            '.confirm-gate input[type="text"]{width:100%;padding:6px 10px;margin-top:8px;border:1px solid var(--border);border-radius:var(--radius-sm,4px);background:var(--bg-inset);color:var(--text-primary);font-size:0.82rem;box-sizing:border-box}',
            '.confirm-gate .gate-steps{font-size:0.72rem;color:var(--text-muted);margin-top:6px;padding-left:4px}',
            '.restart-toast{position:fixed;bottom:24px;right:24px;z-index:10100;background:hsl(220 60% 18%);border:1px solid hsl(220 60% 35%);border-radius:var(--radius-md,8px);padding:14px 18px;font-size:0.82rem;color:hsl(220 90% 85%);box-shadow:0 8px 32px rgba(0,0,0,.4);animation:slideUp .25s ease;max-width:320px}',
            '.restart-toast .restart-icon{font-size:1.1rem;margin-right:6px}',
            '.restart-toast .restart-dismiss{background:none;border:none;color:var(--text-muted);cursor:pointer;float:right;font-size:0.9rem;padding:0 4px}',
            '.restart-toast .restart-dismiss:hover{color:var(--text-primary)}',
            '.restart-toast p{margin:4px 0 0;font-size:0.74rem;color:var(--text-muted)}',
            '.step-progress{height:3px;background:var(--bg-hover);border-radius:2px;margin-top:4px;overflow:hidden;display:none}',
            '.step-progress-bar{height:100%;background:linear-gradient(90deg,var(--accent),hsl(200 90% 55%));border-radius:2px;transition:width .3s ease;width:0%}',
        ].join('\n');
        document.head.appendChild(style);
    })();

    // â”€â”€ streamSSE â€” unified SSE reader â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    /**
     * Stream SSE events from a POST endpoint.
     *
     * @param {string} url       POST endpoint URL
     * @param {Object} body      Request body (JSON)
     * @param {Object} callbacks Event handlers:
     *   onLog(line)           â€” log output line
     *   onStepStart({step, label, total}) â€” step begins
     *   onStepDone({step, skipped, elapsed_ms}) â€” step finished
     *   onStepFailed({step, error, needs_sudo}) â€” step failed
     *   onDone({ok, message, error}) â€” plan finished
     *   onError(errorString)  â€” network/parse error
     * @returns {Promise<{ok: boolean}>}
     */
    async function streamSSE(url, body, callbacks) {
        var resp;
        try {
            resp = await fetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(body),
            });
        } catch (networkErr) {
            if (callbacks.onError) callbacks.onError('Network error: ' + networkErr.message);
            return { ok: false };
        }

        if (!resp.ok) {
            // Try to parse error from JSON body
            try {
                var errBody = await resp.json();
                if (callbacks.onError) callbacks.onError(errBody.error || 'Request failed: ' + resp.status);
            } catch (_) {
                if (callbacks.onError) callbacks.onError('Request failed: ' + resp.status);
            }
            return { ok: false };
        }

        var reader = resp.body.getReader();
        var decoder = new TextDecoder();
        var buffer = '';
        var finalResult = { ok: false };

        try {
            while (true) {
                var chunk = await reader.read();
                if (chunk.done) break;

                buffer += decoder.decode(chunk.value, { stream: true });
                var lines = buffer.split('\n');
                buffer = lines.pop() || '';

                for (var li = 0; li < lines.length; li++) {
                    var ln = lines[li];
                    if (!ln.startsWith('data: ')) continue;
                    try {
                        var event = JSON.parse(ln.slice(6));
                        switch (event.type) {
                            case 'log':
                                if (callbacks.onLog) callbacks.onLog(event.line);
                                break;
                            case 'step_start':
                                if (callbacks.onStepStart) callbacks.onStepStart(event);
                                break;
                            case 'step_done':
                                if (callbacks.onStepDone) callbacks.onStepDone(event);
                                break;
                            case 'step_failed':
                                if (callbacks.onStepFailed) callbacks.onStepFailed(event);
                                break;
                            case 'progress':
                                if (callbacks.onProgress) callbacks.onProgress(event);
                                break;
                            case 'done':
                                finalResult = event;
                                if (callbacks.onDone) callbacks.onDone(event);
                                return { ok: !!event.ok };
                            case 'error':
                                if (callbacks.onError) callbacks.onError(event.error);
                                return { ok: false };
                        }
                    } catch (_parseErr) { /* skip malformed SSE lines */ }
                }
            }
        } catch (streamErr) {
            if (callbacks.onError) callbacks.onError('Stream error: ' + streamErr.message);
            return { ok: false };
        }

        return { ok: !!finalResult.ok };
    }

    // â”€â”€ showStepModal â€” plan-based install modal â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    /**
     * Show a step-by-step install modal for a resolved plan.
     *
     * @param {Object} plan    Install plan from /audit/install-plan
     * @param {Object} options
     * @param {Function} [options.onComplete] Callback on successful install
     */
    function showStepModal(plan, options) {
        options = options || {};

        // Remove existing step modal
        var existing = document.getElementById('step-modal');
        if (existing) existing.remove();

        var needsSudo = false;
        var steps = plan.steps || [];
        for (var s = 0; s < steps.length; s++) {
            if (steps[s].needs_sudo) { needsSudo = true; break; }
        }

        var riskLevel = _planRisk(plan);
        var toolLabel = plan.label || plan.tool;

        // Build step list HTML
        var stepsHtml = '';
        for (var i = 0; i < steps.length; i++) {
            var st = steps[i];
            var stepRisk = st.risk || 'low';
            stepsHtml += '<div class="step-row" id="step-row-' + i + '" data-status="pending">' +
                '<span class="step-icon">â³</span>' +
                '<span class="step-risk-dot ' + stepRisk + '" title="' + stepRisk + ' risk"></span>' +
                '<span class="step-label">' + esc(st.label || ('Step ' + (i + 1))) + '</span>';
            if (st.needs_sudo) {
                stepsHtml += '<span class="step-badge sudo">sudo</span>';
            }
            if (stepRisk !== 'low') {
                stepsHtml += '<span class="step-badge risk-' + stepRisk + '">' + esc(stepRisk) + '</span>';
            }
            stepsHtml += '</div>';
        }

        // Progress parser â€” extracts percentage from build/download log lines
        function _parseProgress(line) {
            // ninja: [42/100]
            var ninjaMatch = line.match(/\[(\d+)\/(\d+)\]/);
            if (ninjaMatch) return Math.round(parseInt(ninjaMatch[1]) / parseInt(ninjaMatch[2]) * 100);
            // cmake/make/pip: XX%
            var pctMatch = line.match(/(\d{1,3})%/);
            if (pctMatch) {
                var pct = parseInt(pctMatch[1]);
                if (pct >= 0 && pct <= 100) return pct;
            }
            return null;
        }

        // Risk banner
        var riskHtml = '';
        if (riskLevel === 'high') {
            riskHtml = '<div class="risk-banner risk-high">ğŸ”´ This plan contains high-risk operations</div>';
        } else if (riskLevel === 'medium') {
            riskHtml = '<div class="risk-banner risk-medium">âš ï¸ This plan contains medium-risk operations</div>';
        }

        // Confirmation gate
        var gateHtml = '';
        var gate = plan.confirmation_gate;
        if (gate && gate.required) {
            if (gate.level === 'double') {
                gateHtml = '<div class="confirm-gate gate-double">' +
                    '<div style="font-weight:700;margin-bottom:4px">ğŸ”´ High-risk confirmation required</div>' +
                    '<div style="font-size:0.76rem;margin-bottom:6px">' + esc(gate.reason) + '</div>';
                if (gate.high_risk_steps && gate.high_risk_steps.length) {
                    gateHtml += '<div class="gate-steps">Steps requiring confirmation:';
                    for (var gi = 0; gi < gate.high_risk_steps.length; gi++) {
                        var gs = gate.high_risk_steps[gi];
                        gateHtml += '<br/>â€¢ ' + esc(gs.label || gs);
                    }
                    gateHtml += '</div>';
                }
                gateHtml += '<input type="text" id="step-modal-confirm" placeholder=\'Type "I understand" to proceed\' ' +
                    'oninput="document.getElementById(\'step-modal-go\').disabled = this.value !== \'I understand\'" />' +
                    '</div>';
            } else {
                gateHtml = '<div class="confirm-gate gate-single">' +
                    '<label><input type="checkbox" id="step-modal-confirm" ' +
                    'onchange="document.getElementById(\'step-modal-go\').disabled = !this.checked" />' +
                    '<span>âš ï¸ I confirm this plan modifies system components</span></label>' +
                    '</div>';
            }
        }

        // Sudo input
        var sudoHtml = '';
        if (needsSudo) {
            sudoHtml = '<div class="step-sudo-row">' +
                '<label style="font-size:0.75rem;font-weight:600;display:block;margin-bottom:4px">ğŸ”‘ Sudo password:</label>' +
                '<input id="step-modal-pw" type="password" placeholder="Enter your password" autocomplete="off" ' +
                'onkeydown="if(event.key===\'Enter\'){document.getElementById(\'step-modal-go\')?.click()}" />' +
                '</div>';
        }

        var overlay = document.createElement('div');
        overlay.id = 'step-modal';
        overlay.className = 'step-modal-overlay';

        overlay.innerHTML = '<div class="step-modal-box">' +
            '<div class="step-modal-header">' +
            '<h3>ğŸ“¦ Install ' + esc(toolLabel) + '</h3>' +
            '<button class="step-modal-close" id="step-modal-close-btn" title="Close">âœ•</button>' +
            '</div>' +
            '<div class="step-modal-body">' +
            riskHtml +
            gateHtml +
            '<div class="step-list" id="step-list">' + stepsHtml + '</div>' +
            sudoHtml +
            '<div class="step-log-area" id="step-log" style="display:none"></div>' +
            '</div>' +
            '<div class="step-modal-footer">' +
            '<button class="btn btn-sm btn-secondary" id="step-modal-cancel">Cancel</button>' +
            '<button class="btn btn-sm btn-primary" id="step-modal-go"' +
            (gate && gate.required ? ' disabled' : '') +
            ' style="min-width:110px">ğŸ“¦ Install</button>' +
            '</div>' +
            '</div>';

        document.body.appendChild(overlay);

        // Focus password field if present
        if (needsSudo) {
            setTimeout(function() {
                var pw = document.getElementById('step-modal-pw');
                if (pw) pw.focus();
            }, 100);
        }

        // Backdrop click to close
        overlay.addEventListener('click', function(e) {
            if (e.target === overlay) overlay.remove();
        });

        // Close button
        document.getElementById('step-modal-close-btn').addEventListener('click', function() {
            overlay.remove();
        });

        // Cancel button
        document.getElementById('step-modal-cancel').addEventListener('click', function() {
            overlay.remove();
        });

        // Wire install button
        document.getElementById('step-modal-go').addEventListener('click', function() {
            _executeStepModalPlan(plan, options);
        });
    }

    // â”€â”€ _executeStepModalPlan â€” internal driver â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    async function _executeStepModalPlan(plan, options) {
        var btn = document.getElementById('step-modal-go');
        var cancelBtn = document.getElementById('step-modal-cancel');
        var logEl = document.getElementById('step-log');
        var pwInput = document.getElementById('step-modal-pw');
        var pw = pwInput ? pwInput.value : '';
        var currentStep = 0;

        // Validate sudo password
        var needsSudo = false;
        var steps = plan.steps || [];
        for (var s = 0; s < steps.length; s++) {
            if (steps[s].needs_sudo) { needsSudo = true; break; }
        }
        if (needsSudo && !pw) {
            if (pwInput) {
                pwInput.style.borderColor = 'var(--error,#e55)';
                pwInput.placeholder = 'âš ï¸ Password required';
                pwInput.focus();
            }
            return;
        }

        // Lock UI
        if (btn) { btn.disabled = true; btn.textContent = 'â³ Installingâ€¦'; }
        if (cancelBtn) cancelBtn.style.display = 'none';
        if (logEl) { logEl.style.display = 'block'; logEl.textContent = ''; }

        // Clear password from DOM immediately
        if (pwInput) {
            pwInput.value = '';
            pwInput.disabled = true;
        }

        var result = await streamSSE('/api/audit/install-plan/execute', {
            tool: plan.tool,
            sudo_password: pw,
            answers: plan._answers || {},
        }, {
            onLog: function(line) {
                if (logEl) {
                    logEl.textContent += line + '\n';
                    logEl.scrollTop = logEl.scrollHeight;
                }
                // Parse progress from log lines
                var pct = _parseProgress(line);
                if (pct !== null) {
                    _updateStepProgress(currentStep, pct);
                }
            },
            onStepStart: function(event) {
                currentStep = event.step;
                _updateStepRowStatus(event.step, 'running', 'ğŸ”„');
            },
            onProgress: function(event) {
                if (event.percent != null) {
                    _updateStepProgress(event.step, event.percent);
                }
            },
            onStepDone: function(event) {
                var icon = event.skipped ? 'â­ï¸' : 'âœ…';
                _updateStepRowStatus(event.step, event.skipped ? 'skipped' : 'done', icon);
                // Show elapsed time
                if (event.elapsed_ms) {
                    var row = document.getElementById('step-row-' + event.step);
                    if (row) {
                        var elapsed = document.createElement('span');
                        elapsed.className = 'step-elapsed';
                        elapsed.textContent = (event.elapsed_ms / 1000).toFixed(1) + 's';
                        row.appendChild(elapsed);
                    }
                }
            },
            onStepFailed: function(event) {
                _updateStepRowStatus(event.step, 'failed', 'âŒ');
                if (logEl && event.error) {
                    logEl.textContent += 'ERROR: ' + event.error + '\n';
                }
            },
            onDone: function(event) {
                if (event.ok) {
                    if (btn) {
                        btn.textContent = 'âœ… Installed';
                        btn.className = 'btn btn-sm btn-success';
                        btn.style.minWidth = '110px';
                    }
                    toast((plan.label || plan.tool) + ' installed successfully!', 'success');

                    // Restart notification
                    if (plan.restart_required) {
                        _showRestartNotification(plan.restart_required, plan.label || plan.tool);
                    }

                    setTimeout(function() {
                        var modal = document.getElementById('step-modal');
                        if (modal) modal.remove();
                        // Clear client-side caches
                        cardInvalidate('tools-status');
                        try { sessionStorage.removeItem('l0_detection'); } catch (_) {}
                        try { sessionStorage.removeItem('system_deps_cache'); } catch (_) {}
                        if (options && options.onComplete) options.onComplete();
                    }, 1500);
                } else {
                    if (btn) {
                        btn.disabled = false;
                        btn.textContent = 'ğŸ”„ Retry';
                        btn.className = 'btn btn-sm btn-primary';
                    }
                    if (cancelBtn) cancelBtn.style.display = '';
                    // Re-enable password for retry
                    if (pwInput) pwInput.disabled = false;

                    // Handle wrong sudo password
                    if (event.needs_sudo) {
                        if (pwInput) {
                            pwInput.style.borderColor = 'var(--warning,#e8a735)';
                            pwInput.placeholder = 'ğŸ”‘ Wrong password â€” try again';
                            pwInput.focus();
                        }
                        // Reset step rows for retry
                        for (var r = 0; r < steps.length; r++) {
                            _updateStepRowStatus(r, 'pending', 'â³');
                        }
                    }

                    // â”€â”€ Remediation options â€” open stacked remediation modal â”€â”€
                    // Step modal stays visible behind (shows failure/logs).
                    // Remediation overlay at z-index 10001, on top of step modal (10000).
                    if (event.remediation && event.remediation.options && event.remediation.options.length) {
                        _showRemediationModal(
                            plan.tool,
                            plan.label || plan.tool,
                            event.remediation,
                            options && options.onComplete,
                            event.error || ''
                        );
                    }

                    // Show Resume button if plan_id is available
                    if (event.plan_id && !event.needs_sudo) {
                        var footer = document.querySelector('.step-modal-footer');
                        if (footer && !document.getElementById('step-modal-resume')) {
                            var resumeBtn = document.createElement('button');
                            resumeBtn.id = 'step-modal-resume';
                            resumeBtn.className = 'btn btn-sm btn-primary';
                            resumeBtn.style.cssText = 'margin-right:auto';
                            resumeBtn.textContent = 'ğŸ”„ Resume';
                            resumeBtn.title = 'Resume from last completed step';
                            resumeBtn.addEventListener('click', function() {
                                var modal = document.getElementById('step-modal');
                                if (modal) modal.remove();
                                resumeWithPlan(event.plan_id, plan.label || plan.tool, {
                                    onComplete: options && options.onComplete,
                                });
                            });
                            footer.prepend(resumeBtn);
                        }
                    }
                }
            },
            onError: function(error) {
                if (btn) {
                    btn.disabled = false;
                    btn.textContent = 'ğŸ”„ Retry';
                }
                if (cancelBtn) cancelBtn.style.display = '';
                if (pwInput) pwInput.disabled = false;
                if (logEl) logEl.textContent += 'ERROR: ' + error + '\n';
                toast('Install failed: ' + error, 'error');
            },
        });
    }



    // â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function _updateStepRowStatus(index, status, icon) {
        var row = document.getElementById('step-row-' + index);
        if (!row) return;
        row.dataset.status = status;
        var iconEl = row.querySelector('.step-icon');
        if (iconEl) iconEl.textContent = icon;
    }

    function _updateStepProgress(index, percent) {
        var row = document.getElementById('step-row-' + index);
        if (!row) return;
        var bar = row.querySelector('.step-progress');
        if (!bar) {
            bar = document.createElement('div');
            bar.className = 'step-progress';
            bar.innerHTML = '<div class="step-progress-bar"></div>';
            row.appendChild(bar);
        }
        bar.style.display = 'block';
        var fill = bar.querySelector('.step-progress-bar');
        if (fill) fill.style.width = Math.min(percent, 100) + '%';
    }

    function _planRisk(plan) {
        var steps = plan.steps || [];
        var hasHigh = false;
        var hasMedium = false;
        for (var i = 0; i < steps.length; i++) {
            var risk = steps[i].risk || 'low';
            if (risk === 'high') hasHigh = true;
            if (risk === 'medium') hasMedium = true;
        }
        if (hasHigh) return 'high';
        if (hasMedium) return 'medium';
        return 'low';
    }

    function _showRestartNotification(restartType, toolLabel) {
        // Remove existing
        var old = document.getElementById('restart-toast');
        if (old) old.remove();

        var msgs = {
            'session': 'Log out and back in for changes to take effect.',
            'system':  'A system reboot is required for changes to take effect.',
            'service': 'Related services may need restarting.',
        };
        var icons = { 'session': 'ğŸ”„', 'system': 'ğŸ”ƒ', 'service': 'âš™ï¸' };

        var msg = msgs[restartType] || 'A restart may be required.';
        var icon = icons[restartType] || 'ğŸ”„';

        var toast = document.createElement('div');
        toast.id = 'restart-toast';
        toast.className = 'restart-toast';
        toast.innerHTML =
            '<button class="restart-dismiss" onclick="this.parentElement.remove()" title="Dismiss">âœ•</button>' +
            '<span class="restart-icon">' + icon + '</span>' +
            '<strong>Restart required</strong>' +
            '<p>' + esc(msg) + '</p>';
        document.body.appendChild(toast);

        // Auto-dismiss after 30 seconds
        setTimeout(function() {
            var el = document.getElementById('restart-toast');
            if (el) el.remove();
        }, 30000);
    }

    /**
     * Plan-based install entry point.
     *
     * Fetches the install plan, then shows the step modal.
     * Drop-in replacement for _showInstallModal where callers
     * want the new plan-based UI.
     *
     * Phase 4: Now does two-pass resolution:
     *   Pass 1: POST /audit/resolve-choices â†’ get choices
     *   If auto_resolve â†’ skip to plan (original flow)
     *   If choices â†’ show choice modal â†’ collect answers
     *   Pass 2: POST /audit/install-plan with answers â†’ plan
     *
     * @param {string} toolId     Tool identifier
     * @param {string} toolLabel  Display name
     * @param {Object} [opts]     Options: { onComplete }
     */

    // â”€â”€ Phase 4: Choice modal CSS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    (function _injectChoiceModalCSS() {
        if (document.getElementById('choice-modal-css')) return;
        var style = document.createElement('style');
        style.id = 'choice-modal-css';
        style.textContent = [
            '.choice-group{margin-bottom:16px}',
            '.choice-label{font-size:0.88rem;font-weight:600;color:var(--text-primary);margin-bottom:4px;display:block}',
            '.choice-desc{font-size:0.78rem;color:var(--text-muted);margin:0 0 8px;line-height:1.4}',
            '.choice-options{display:flex;flex-direction:column;gap:6px}',
            '.choice-option{display:flex;align-items:flex-start;gap:10px;padding:10px 12px;border:1px solid var(--border);border-radius:var(--radius-sm,4px);cursor:pointer;transition:border-color .15s,background .15s}',
            '.choice-option:hover:not(.disabled){border-color:var(--accent);background:var(--bg-hover)}',
            '.choice-option.disabled{opacity:.5;cursor:not-allowed}',
            '.choice-option input[type="radio"],.choice-option input[type="checkbox"]{margin-top:2px;flex-shrink:0;accent-color:var(--accent)}',
            '.choice-option-content{display:flex;flex-direction:column;gap:2px;min-width:0}',
            '.choice-option-label{font-size:0.84rem;font-weight:600;color:var(--text-primary)}',
            '.choice-option-desc{font-size:0.74rem;color:var(--text-muted);line-height:1.35}',
            '.choice-option-meta{display:flex;gap:10px;align-items:center;font-size:0.7rem;margin-top:2px}',
            '.choice-meta-time{color:var(--text-muted);opacity:0.8}',
            '.choice-meta-risk{font-weight:600;padding:1px 6px;border-radius:3px}',
            '.choice-meta-risk.risk-medium{color:hsl(40 90% 65%);background:hsl(40 90% 65% / .12)}',
            '.choice-meta-risk.risk-high{color:hsl(0 75% 65%);background:hsl(0 75% 65% / .12)}',
            '.choice-disabled-reason{font-size:0.72rem;color:hsl(40 90% 65%);display:flex;align-items:center;gap:4px;margin-top:2px}',
            '.choice-option.selected:not(.disabled){border-color:var(--accent);background:color-mix(in srgb, var(--accent) 8%, transparent);box-shadow:inset 3px 0 0 var(--accent)}',
            '.choice-toggle{display:flex;align-items:center;gap:10px;cursor:pointer;font-size:0.84rem;font-weight:600;color:var(--text-primary);padding:8px 0}',
            '.choice-toggle input[type="checkbox"]{width:18px;height:18px;accent-color:var(--accent)}',
            '.choice-version-select{width:100%;padding:8px 12px;border:1px solid var(--border);border-radius:var(--radius-sm,4px);background:var(--bg-inset);color:var(--text-primary);font-size:0.84rem}',
            '.choice-version-select:focus{outline:none;border-color:var(--accent);box-shadow:0 0 0 2px color-mix(in srgb, var(--accent) 20%, transparent)}',
            '.choice-input-group{margin-bottom:12px}',
            '.choice-input-group label{display:block;font-size:0.84rem;font-weight:600;color:var(--text-primary);margin-bottom:4px}',
            '.choice-input-group .input-desc{font-size:0.74rem;color:var(--text-muted);margin-bottom:6px}',
            '.choice-input-group input,.choice-input-group select{width:100%;padding:8px 12px;border:1px solid var(--border);border-radius:var(--radius-sm,4px);background:var(--bg-inset);color:var(--text-primary);font-size:0.84rem;box-sizing:border-box}',
            '.choice-input-group input:focus,.choice-input-group select:focus{outline:none;border-color:var(--accent);box-shadow:0 0 0 2px color-mix(in srgb, var(--accent) 20%, transparent)}',
            '.choice-all-disabled{padding:16px;text-align:center;color:var(--text-muted);font-size:0.85rem;background:var(--bg-inset);border-radius:var(--radius-sm,4px)}',
        ].join('\n');
        document.head.appendChild(style);
    })();

    // â”€â”€ Choice renderers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    function _renderChoice(choice, defaults) {
        defaults = defaults || {};
        var h = '<div class="choice-group">';
        h += '<span class="choice-label">' + esc(choice.label) + '</span>';
        if (choice.description) {
            h += '<p class="choice-desc">' + esc(choice.description) + '</p>';
        }

        if (choice.type === 'select_one' || choice.type === 'single') {
            h += '<div class="choice-options">';
            for (var i = 0; i < choice.options.length; i++) {
                var opt = choice.options[i];
                var optId = opt.id || opt.value;
                var isDefault = defaults[choice.id] === optId;
                var isDisabled = opt.available === false;
                h += '<label class="choice-option' +
                    (isDisabled ? ' disabled' : '') +
                    (isDefault && !isDisabled ? ' selected' : '') +
                    '"' +
                    ' data-choice-id="' + esc(choice.id) + '"' +
                    ' data-opt-id="' + esc(optId) + '"' +
                    (opt.disabled_reason ? ' title="' + esc(opt.disabled_reason) + '"' : '') +
                    '>' +
                    '<input type="radio" name="choice_' + esc(choice.id) + '"' +
                    ' value="' + esc(optId) + '"' +
                    (isDefault && !isDisabled ? ' checked' : '') +
                    (isDisabled ? ' disabled' : '') + ' />' +
                    '<div class="choice-option-content">' +
                    '<span class="choice-option-label">' + esc(opt.label) + '</span>';
                if (opt.description) {
                    h += '<span class="choice-option-desc">' + esc(opt.description) + '</span>';
                }
                if (opt.estimated_time || opt.risk) {
                    h += '<span class="choice-option-meta">';
                    if (opt.estimated_time) {
                        h += '<span class="choice-meta-time">â± ' + esc(opt.estimated_time) + '</span>';
                    }
                    if (opt.risk && opt.risk !== 'low') {
                        h += '<span class="choice-meta-risk risk-' + esc(opt.risk) + '">' +
                            (opt.risk === 'high' ? 'ğŸ”´' : 'âš ï¸') + ' ' + esc(opt.risk) + ' risk</span>';
                    }
                    h += '</span>';
                }
                if (opt.warning) {
                    h += '<span class="choice-option-desc" style="color:hsl(40 90% 65%)">âš ï¸ ' + esc(opt.warning) + '</span>';
                }
                if (isDisabled && opt.disabled_reason) {
                    h += '<span class="choice-disabled-reason">âš ï¸ ' + esc(opt.disabled_reason);
                    if (opt.enable_hint) {
                        h += ' â€” ' + esc(opt.enable_hint);
                    }
                    h += '</span>';
                }
                h += '</div></label>';
            }
            h += '</div>';
        }

        else if (choice.type === 'toggle') {
            var isChecked = defaults[choice.id] ? true : false;
            h += '<label class="choice-toggle">' +
                '<input type="checkbox" name="choice_' + esc(choice.id) + '"' +
                (isChecked ? ' checked' : '') + ' />' +
                '<span>' + esc(choice.label) + '</span>' +
                '</label>';
        }

        else if (choice.type === 'select_version') {
            h += '<select name="choice_' + esc(choice.id) + '" class="choice-version-select">';
            var versions = choice.versions || choice.options || [];
            for (var j = 0; j < versions.length; j++) {
                var v = versions[j];
                var vId = v.id || v.value;
                var vDisabled = v.available === false;
                h += '<option value="' + esc(vId) + '"' +
                    (v.default ? ' selected' : '') +
                    (vDisabled ? ' disabled' : '') + '>' +
                    esc(v.label) + (v.tag ? ' ' + esc(v.tag) : '') +
                    '</option>';
            }
            h += '</select>';
        }

        else if (choice.type === 'select_multi' || choice.type === 'multi') {
            h += '<div class="choice-options">';
            for (var k = 0; k < choice.options.length; k++) {
                var mOpt = choice.options[k];
                var mId = mOpt.id || mOpt.value;
                var mDisabled = mOpt.available === false;
                var mChecked = mOpt.default || false;
                h += '<label class="choice-option' +
                    (mDisabled ? ' disabled' : '') +
                    '">' +
                    '<input type="checkbox" name="choice_' + esc(choice.id) + '_multi"' +
                    ' value="' + esc(mId) + '"' +
                    (mChecked ? ' checked' : '') +
                    (mDisabled ? ' disabled' : '') + ' />' +
                    '<div class="choice-option-content">' +
                    '<span class="choice-option-label">' + esc(mOpt.label) + '</span>';
                if (mOpt.description) {
                    h += '<span class="choice-option-desc">' + esc(mOpt.description) + '</span>';
                }
                if (mOpt.size) {
                    h += '<span class="choice-option-desc">ğŸ“¦ ' + esc(mOpt.size) + '</span>';
                }
                if (mDisabled && mOpt.disabled_reason) {
                    h += '<span class="choice-disabled-reason">âš ï¸ ' + esc(mOpt.disabled_reason) + '</span>';
                }
                h += '</div></label>';
            }
            h += '</div>';
        }

        h += '</div>';
        return h;
    }

    function _renderInput(inp) {
        var h = '<div class="choice-input-group" data-input-id="' + esc(inp.id) + '">';
        h += '<label for="input_' + esc(inp.id) + '">' + esc(inp.label) + '</label>';
        if (inp.description) {
            h += '<div class="input-desc">' + esc(inp.description) + '</div>';
        }

        if (inp.type === 'select') {
            h += '<select name="input_' + esc(inp.id) + '" id="input_' + esc(inp.id) + '">';
            var options = inp.options || [];
            for (var i = 0; i < options.length; i++) {
                var o = typeof options[i] === 'string' ? { value: options[i], label: options[i] } : options[i];
                h += '<option value="' + esc(o.value || o) + '"' +
                    ((o.value || o) === inp.default ? ' selected' : '') + '>' +
                    esc(o.label || o) + '</option>';
            }
            h += '</select>';
        } else if (inp.type === 'boolean') {
            h += '<label class="choice-toggle">' +
                '<input type="checkbox" name="input_' + esc(inp.id) + '"' +
                ' id="input_' + esc(inp.id) + '"' +
                (inp.default ? ' checked' : '') + ' />' +
                '<span>' + esc(inp.label) + '</span></label>';
        } else if (inp.type === 'password') {
            h += '<input type="password" name="input_' + esc(inp.id) + '"' +
                ' id="input_' + esc(inp.id) + '"' +
                ' placeholder="' + esc(inp.placeholder || '') + '"' +
                ' autocomplete="off" />';
        } else {
            // text, number, path
            var inputType = inp.type === 'number' ? 'number' : 'text';
            h += '<input type="' + inputType + '" name="input_' + esc(inp.id) + '"' +
                ' id="input_' + esc(inp.id) + '"' +
                ' value="' + esc(inp.default != null ? String(inp.default) : '') + '"' +
                ' placeholder="' + esc(inp.placeholder || '') + '"';
            if (inp.type === 'number' && inp.validation) {
                if (inp.validation.min != null) h += ' min="' + inp.validation.min + '"';
                if (inp.validation.max != null) h += ' max="' + inp.validation.max + '"';
            }
            h += ' />';
        }

        h += '</div>';
        return h;
    }

    function _collectAnswers(choiceData) {
        var answers = {};

        // Collect choice answers
        for (var i = 0; i < (choiceData.choices || []).length; i++) {
            var choice = choiceData.choices[i];
            var cid = choice.id;

            if (choice.type === 'toggle') {
                var cb = document.querySelector('[name="choice_' + cid + '"]');
                answers[cid] = cb ? cb.checked : false;
            } else if (choice.type === 'select_multi' || choice.type === 'multi') {
                var checked = document.querySelectorAll('[name="choice_' + cid + '_multi"]:checked');
                var vals = [];
                for (var j = 0; j < checked.length; j++) {
                    vals.push(checked[j].value);
                }
                answers[cid] = vals;
            } else {
                // select_one, select_version
                var selected = document.querySelector('[name="choice_' + cid + '"]:checked') ||
                               document.querySelector('select[name="choice_' + cid + '"]');
                if (selected) {
                    answers[cid] = selected.value;
                }
            }
        }

        // Collect input answers
        for (var k = 0; k < (choiceData.inputs || []).length; k++) {
            var inp = choiceData.inputs[k];
            var el = document.getElementById('input_' + inp.id);
            if (el) {
                if (inp.type === 'boolean') {
                    answers[inp.id] = el.checked;
                } else if (inp.type === 'number') {
                    answers[inp.id] = el.value ? Number(el.value) : inp.default;
                } else {
                    answers[inp.id] = el.value;
                }
            }
        }

        return answers;
    }

    function showChoiceModal(choiceData, opts) {
        opts = opts || {};
        var toolLabel = choiceData.label || choiceData.tool;

        // Check if all options are disabled
        var allDisabled = true;
        for (var i = 0; i < (choiceData.choices || []).length; i++) {
            var choice = choiceData.choices[i];
            for (var j = 0; j < (choice.options || []).length; j++) {
                if (choice.options[j].available !== false) {
                    allDisabled = false;
                    break;
                }
            }
            if (!allDisabled) break;
        }

        // Build body
        var bodyHtml = '';
        if (allDisabled && choiceData.choices && choiceData.choices.length) {
            bodyHtml += '<div class="choice-all-disabled">' +
                '<p>âš ï¸ No install options are available for <strong>' +
                esc(toolLabel) + '</strong> on this system.</p>';
            // Still render them so user can see WHY
            for (var d = 0; d < choiceData.choices.length; d++) {
                bodyHtml += _renderChoice(choiceData.choices[d], choiceData.defaults);
            }
            bodyHtml += '</div>';
        } else {
            for (var c = 0; c < (choiceData.choices || []).length; c++) {
                bodyHtml += _renderChoice(choiceData.choices[c], choiceData.defaults);
            }
            for (var inp = 0; inp < (choiceData.inputs || []).length; inp++) {
                bodyHtml += _renderInput(choiceData.inputs[inp]);
            }
        }

        modalOpen({
            title: 'âš™ï¸ Configure ' + esc(toolLabel),
            size: 'narrow',
            body: bodyHtml,
            footerButtons: [
                { label: 'Cancel', cls: 'btn-secondary', onclick: 'modalClose()' },
                {
                    label: 'Continue â†’',
                    cls: 'btn-primary',
                    id: 'choice-modal-go',
                    onclick: '_doChoiceInstall()',
                    disabled: allDisabled,
                },
            ],
        });

        // Wire up radio button visual selection
        setTimeout(function() {
            var radios = document.querySelectorAll('.choice-option input[type="radio"]');
            for (var r = 0; r < radios.length; r++) {
                radios[r].addEventListener('change', function() {
                    // Deselect siblings
                    var parent = this.closest('.choice-options');
                    if (parent) {
                        var siblings = parent.querySelectorAll('.choice-option');
                        for (var s = 0; s < siblings.length; s++) {
                            siblings[s].classList.remove('selected');
                        }
                    }
                    var label = this.closest('.choice-option');
                    if (label) label.classList.add('selected');
                });
            }
        }, 50);

        // Expose the install callback
        window._choiceModalData = choiceData;
        window._choiceModalOpts = opts;
        window._doChoiceInstall = async function() {
            var answers = _collectAnswers(choiceData);
            modalClose();

            // Now get the plan with answers (Pass 2)
            toast('â³ Resolving install planâ€¦', 'info');
            try {
                var resp = await fetch('/api/audit/install-plan', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ tool: choiceData.tool, answers: answers }),
                });
                var plan = await resp.json();

                if (plan.error) {
                    toast('âŒ ' + plan.error, 'error');
                    return;
                }

                if (plan.already_installed) {
                    toast('âœ… ' + (toolLabel) + ' is already installed', 'success');
                    if (opts.onComplete) opts.onComplete();
                    return;
                }

                // Attach answers to plan so execute endpoint gets them
                plan._answers = answers;

                showStepModal(plan, {
                    onComplete: opts.onComplete || null,
                });
            } catch (err) {
                toast('âŒ Failed to resolve plan: ' + err.message, 'error');
            }
        };
    }

    async function installWithPlan(toolId, toolLabel, opts) {
        opts = opts || {};
        toast('â³ Loading install plan for ' + (toolLabel || toolId) + 'â€¦', 'info');

        try {
            // Phase 4: Pass 1 â€” resolve choices first
            var choicesResp = await fetch('/api/audit/resolve-choices', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ tool: toolId }),
            });
            var choiceData = await choicesResp.json();

            if (choiceData.error) {
                toast('âŒ ' + choiceData.error, 'error');
                return;
            }

            if (choiceData.already_installed) {
                toast('âœ… ' + (toolLabel || toolId) + ' is already installed', 'success');
                if (opts.onComplete) opts.onComplete();
                return;
            }

            // If tool has choices to make â†’ show choice modal
            if (!choiceData.auto_resolve && choiceData.choices && choiceData.choices.length) {
                showChoiceModal(choiceData, {
                    onComplete: opts.onComplete || null,
                });
                return;
            }

            // No choices â†’ fetch plan directly (original flow)
            var planResp = await fetch('/api/audit/install-plan', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    tool: toolId,
                    answers: choiceData.defaults || {},
                }),
            });
            var plan = await planResp.json();

            if (plan.error) {
                toast('âŒ ' + plan.error, 'error');
                return;
            }

            if (plan.already_installed) {
                toast('âœ… ' + (toolLabel || toolId) + ' is already installed', 'success');
                if (opts.onComplete) opts.onComplete();
                return;
            }

            // Attach default answers to plan so execute endpoint gets them
            plan._answers = choiceData.defaults || {};

            showStepModal(plan, {
                onComplete: opts.onComplete || null,
            });
        } catch (err) {
            toast('âŒ Failed to load install plan: ' + err.message, 'error');
        }
    }

    // â”€â”€ Resume a saved plan â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    /**
     * Resume a paused/failed plan by its plan_id.
     * Opens a step modal and streams from /audit/install-plan/resume.
     *
     * @param {string} planId  - Saved plan UUID
     * @param {string} toolLabel - Display name
     * @param {Object} opts   - {onComplete: fn}
     */
    async function resumeWithPlan(planId, toolLabel, opts) {
        opts = opts || {};

        // Fetch plan state to know remaining steps
        try {
            var resp = await fetch('/api/audit/install-plan/pending');
            var data = await resp.json();
            var planInfo = (data.plans || []).find(function(p) { return p.plan_id === planId; });

            if (!planInfo) {
                toast('âŒ Plan not found or already completed', 'error');
                return;
            }

            var remaining = planInfo.total_steps - planInfo.completed_count;
            var fakeSteps = [];
            for (var si = 0; si < remaining; si++) {
                fakeSteps.push({
                    label: 'Step ' + (planInfo.completed_count + si + 1),
                    type: 'tool',
                });
            }

            // Build a synthetic plan object for showStepModal
            var resumePlan = {
                tool: planInfo.tool,
                label: toolLabel || planInfo.tool,
                steps: fakeSteps,
                needs_sudo: false,
                _resumePlanId: planId,
                _resumeOffset: planInfo.completed_count,
            };

            // Step modal CSS is already injected on page load by the IIFE

            // Build the step modal
            var existing = document.getElementById('step-modal');
            if (existing) existing.remove();

            var stepsHtml = '';
            for (var ri = 0; ri < fakeSteps.length; ri++) {
                stepsHtml += '<div class="step-row" id="step-row-' + ri + '" data-status="pending">'
                    + '<span class="step-icon">â³</span>'
                    + '<span class="step-label">Step ' + (planInfo.completed_count + ri + 1) + '</span>'
                    + '</div>';
            }

            var headerText = 'ğŸ”„ Resume: ' + esc(toolLabel || planInfo.tool)
                + ' (' + planInfo.completed_count + '/' + planInfo.total_steps + ' done)';

            var overlay = document.createElement('div');
            overlay.id = 'step-modal';
            overlay.className = 'step-modal-overlay';
            overlay.innerHTML = '<div class="step-modal-box">'
                + '<div class="step-modal-header">'
                + '<h3>' + headerText + '</h3>'
                + '<button class="step-modal-close" id="step-modal-close-btn" title="Close">âœ•</button>'
                + '</div>'
                + '<div class="step-modal-body">'
                + '<div class="step-list">' + stepsHtml + '</div>'
                + '<div class="sudo-gate" style="margin-top:8px">'
                + '<input id="step-modal-pw" type="password" placeholder="Sudo password (if needed)" autocomplete="off" '
                + 'onkeydown="if(event.key===\'Enter\'){document.getElementById(\'step-modal-go\')?.click()}" />'
                + '</div>'
                + '<pre id="step-log" class="step-log" style="display:none"></pre>'
                + '</div>'
                + '<div class="step-modal-footer">'
                + '<button class="btn btn-sm btn-secondary" id="step-modal-cancel">Cancel</button>'
                + '<button class="btn btn-sm btn-primary" id="step-modal-go">â–¶ Resume</button>'
                + '</div></div>';
            document.body.appendChild(overlay);

            // Wire up buttons
            document.getElementById('step-modal-close-btn').addEventListener('click', function() {
                overlay.remove();
            });
            document.getElementById('step-modal-cancel').addEventListener('click', function() {
                overlay.remove();
            });
            document.getElementById('step-modal-go').addEventListener('click', function() {
                _executeResumePlan(planId, resumePlan, opts);
            });

        } catch (err) {
            toast('âŒ Failed to resume: ' + err.message, 'error');
        }
    }

    /**
     * Execute a resume plan via SSE streaming.
     */
    async function _executeResumePlan(planId, plan, options) {
        var btn = document.getElementById('step-modal-go');
        var cancelBtn = document.getElementById('step-modal-cancel');
        var logEl = document.getElementById('step-log');
        var pwInput = document.getElementById('step-modal-pw');
        var pw = pwInput ? pwInput.value : '';

        // Lock UI
        if (btn) { btn.disabled = true; btn.textContent = 'â³ Resumingâ€¦'; }
        if (cancelBtn) cancelBtn.style.display = 'none';
        if (logEl) { logEl.style.display = 'block'; logEl.textContent = ''; }
        if (pwInput) { pwInput.value = ''; pwInput.disabled = true; }

        var result = await streamSSE('/api/audit/install-plan/resume', {
            plan_id: planId,
            sudo_password: pw,
        }, {
            onLog: function(line) {
                if (logEl) {
                    logEl.textContent += line + '\n';
                    logEl.scrollTop = logEl.scrollHeight;
                }
            },
            onStepStart: function(event) {
                _updateStepRowStatus(event.step, 'running', 'ğŸ”„');
            },
            onStepDone: function(event) {
                var icon = event.skipped ? 'â­ï¸' : 'âœ…';
                _updateStepRowStatus(event.step, event.skipped ? 'skipped' : 'done', icon);
                if (event.elapsed_ms) {
                    var row = document.getElementById('step-row-' + event.step);
                    if (row) {
                        var elapsed = document.createElement('span');
                        elapsed.className = 'step-elapsed';
                        elapsed.textContent = (event.elapsed_ms / 1000).toFixed(1) + 's';
                        row.appendChild(elapsed);
                    }
                }
            },
            onStepFailed: function(event) {
                _updateStepRowStatus(event.step, 'failed', 'âŒ');
                if (logEl && event.error) {
                    logEl.textContent += 'ERROR: ' + event.error + '\n';
                }
            },
            onDone: function(event) {
                if (event.ok) {
                    if (btn) {
                        btn.textContent = 'âœ… Completed';
                        btn.className = 'btn btn-sm btn-success';
                    }
                    toast((plan.label || plan.tool) + ' resumed and completed!', 'success');
                    setTimeout(function() {
                        var modal = document.getElementById('step-modal');
                        if (modal) modal.remove();
                        try { sessionStorage.removeItem('l0_detection'); } catch (_) {}
                        try { sessionStorage.removeItem('system_deps_cache'); } catch (_) {}
                        // Clear pending plans cache
                        _pendingPlansCache = null;
                        if (options && options.onComplete) options.onComplete();
                    }, 1500);
                } else {
                    if (btn) {
                        btn.disabled = false;
                        btn.textContent = 'ğŸ”„ Retry Resume';
                        btn.className = 'btn btn-sm btn-primary';
                    }
                    if (cancelBtn) cancelBtn.style.display = '';
                    if (pwInput) pwInput.disabled = false;
                }
            },
            onError: function(error) {
                if (btn) { btn.disabled = false; btn.textContent = 'ğŸ”„ Retry'; }
                if (cancelBtn) cancelBtn.style.display = '';
                if (pwInput) pwInput.disabled = false;
                if (logEl) logEl.textContent += 'ERROR: ' + error + '\n';
                toast('Resume failed: ' + error, 'error');
            },
        });
    }

    // â”€â”€ Pending Plans Cache â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    var _pendingPlansCache = null;

    /**
     * Fetch pending plans (cached for the page lifetime).
     * Returns: [{plan_id, tool, status, completed_count, total_steps}]
     */
    async function _fetchPendingPlans() {
        if (_pendingPlansCache) return _pendingPlansCache;
        try {
            var resp = await fetch('/api/audit/install-plan/pending');
            var data = await resp.json();
            _pendingPlansCache = data.plans || [];
        } catch (_) {
            _pendingPlansCache = [];
        }
        return _pendingPlansCache;
    }

    /**
     * Get a pending plan for a specific tool.
     * Returns the plan summary or null.
     */
    function _getPendingPlanForTool(toolId, pending) {
        if (!pending || !pending.length) return null;
        for (var pi = 0; pi < pending.length; pi++) {
            if (pending[pi].tool === toolId) return pending[pi];
        }
        return null;
    }

    // â”€â”€ Auth Modal (multi-path: browser + terminal + token) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€


    let _opsPollingTimer = null;
    let _opsDeviceSession = null;

    function _showAuthModal(config) {
        const {
            title = 'ğŸ”‘ Authenticate',
            description = '',
            loginEndpoint = '/gh/auth/login',
            pollEndpoint = '/integrations/gh/status',
            pollCheck = (d) => d.authenticated === true,
            pollInterval = 3000,
            pollTimeout = 300000,
            tokenHint = 'Paste a Personal Access Token',
            tokenUrl = 'https://github.com/settings/tokens',
            onSuccess = null,
        } = config;

        document.getElementById('ops-modal')?.remove();
        if (_opsPollingTimer) { clearInterval(_opsPollingTimer); _opsPollingTimer = null; }
        _opsDeviceSession = null;

        const modal = document.createElement('div');
        modal.id = 'ops-modal';
        modal.className = 'vault-modal-overlay';
        modal.innerHTML = `<div class="vault-modal" style="max-width:520px">
            <div class="vault-modal-header">
                <span class="vault-modal-title">${esc(title)}</span>
                <button class="vault-modal-close" onclick="_opsModalClose()">âœ•</button>
            </div>
            <div class="vault-modal-body" id="ops-auth-body">
                ${description ? `<div style="font-size:0.82rem;color:var(--text-secondary);margin-bottom:var(--space-md)">${description}</div>` : ''}

                <!-- 3-path selector -->
                <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:var(--space-sm);margin-bottom:var(--space-md)">
                    <button class="btn btn-sm" id="ops-path-browser"
                            style="padding:10px;display:flex;flex-direction:column;align-items:center;gap:3px;border:2px solid var(--accent);background:color-mix(in srgb, var(--accent) 8%, var(--bg-primary))"
                            onclick="_opsAuthSelectPath('browser')">
                        <span style="font-size:1.2rem">ğŸŒ</span>
                        <strong style="font-size:0.74rem">Browser Auth</strong>
                        <span style="font-size:0.62rem;color:var(--text-muted)">Recommended</span>
                    </button>
                    <button class="btn btn-sm" id="ops-path-terminal"
                            style="padding:10px;display:flex;flex-direction:column;align-items:center;gap:3px;border:2px solid var(--border);background:var(--bg-primary)"
                            onclick="_opsAuthSelectPath('terminal')">
                        <span style="font-size:1.2rem">ğŸ–¥ï¸</span>
                        <strong style="font-size:0.74rem">Open Terminal</strong>
                        <span style="font-size:0.62rem;color:var(--text-muted)">Interactive</span>
                    </button>
                    <button class="btn btn-sm" id="ops-path-token"
                            style="padding:10px;display:flex;flex-direction:column;align-items:center;gap:3px;border:2px solid var(--border);background:var(--bg-primary)"
                            onclick="_opsAuthSelectPath('token')">
                        <span style="font-size:1.2rem">ğŸ”‘</span>
                        <strong style="font-size:0.74rem">Paste Token</strong>
                        <span style="font-size:0.62rem;color:var(--text-muted)">Manual PAT</span>
                    </button>
                </div>

                <!-- Browser auth panel (default) -->
                <div id="ops-panel-browser">
                    <div style="font-size:0.82rem;color:var(--text-secondary);margin-bottom:var(--space-sm)">
                        Click below to start authentication. A GitHub page will open where you
                        enter a one-time code. No terminal needed.
                    </div>
                    <button class="btn btn-sm btn-primary" id="ops-auth-device-start" style="width:100%;padding:10px"
                            onclick="_opsAuthDeviceStart()">ğŸŒ Start Browser Authentication</button>
                </div>

                <!-- Terminal path panel (hidden) -->
                <div id="ops-panel-terminal" style="display:none">
                    <div style="font-size:0.82rem;color:var(--text-secondary);margin-bottom:var(--space-sm)">
                        Opens a terminal window for interactive <code>gh auth login</code>.
                    </div>
                    <label style="display:flex;align-items:center;gap:0.5rem;margin-bottom:var(--space-sm);cursor:pointer;font-size:0.78rem"
                           title="When checked: auto-selects GitHub.com, HTTPS, and web browser options for you. Detects the auth URL and opens it in your browser. Terminal stays open on errors so you can see what happened.">
                        <input type="checkbox" id="ops-term-auto" checked
                               style="accent-color:var(--accent);margin:0" />
                        <span>ğŸ¤– <strong>Auto-drive</strong> â€” select options &amp; open URL automatically</span>
                    </label>
                    <button class="btn btn-sm btn-primary" id="ops-auth-spawn" style="width:100%;padding:10px"
                            onclick="_opsAuthSpawnTerminal()">ğŸ–¥ï¸ Launch Terminal Authentication</button>
                </div>

                <!-- Token path panel (hidden) -->
                <div id="ops-panel-token" style="display:none">
                    <div style="font-size:0.82rem;color:var(--text-secondary);margin-bottom:var(--space-sm)">
                        ${esc(tokenHint)}.
                        <a href="${esc(tokenUrl)}" target="_blank" rel="noopener" style="color:var(--accent)">Create one here â†’</a>
                    </div>
                    <input id="ops-auth-token" type="password" placeholder="ghp_xxxxxxxxxxâ€¦"
                           style="width:100%;padding:8px 12px;border:1px solid var(--border);border-radius:var(--radius-sm);background:var(--bg-primary);color:var(--text-primary);font-size:0.85rem;box-sizing:border-box;font-family:var(--font-mono,monospace)"
                           onkeydown="if(event.key==='Enter'){document.getElementById('ops-auth-token-go').click()}" />
                    <button class="btn btn-sm btn-primary" id="ops-auth-token-go" style="width:100%;margin-top:var(--space-sm);padding:10px"
                            onclick="_opsAuthWithToken()">ğŸ”‘ Authenticate</button>
                </div>

                <!-- Status / log area -->
                <div id="ops-auth-status" style="display:none;margin-top:var(--space-md);padding:12px;border-radius:var(--radius-sm);background:var(--bg-inset);font-size:0.78rem;text-align:center">
                </div>
            </div>
        </div>`;

        // Store config in a global so panel functions can access it
        window._opsAuthConfig = config;

        document.body.appendChild(modal);
        modal.addEventListener('click', e => { if (e.target === modal) _opsModalClose(); });
    }

    function _opsModalClose() {
        if (_opsPollingTimer) { clearInterval(_opsPollingTimer); _opsPollingTimer = null; }
        _opsDeviceSession = null;
        document.getElementById('ops-modal')?.remove();
        window._opsAuthConfig = null;
    }

    function _opsAuthSelectPath(path) {
        const paths = ['browser', 'terminal', 'token'];
        for (const p of paths) {
            const btn = document.getElementById('ops-path-' + p);
            const panel = document.getElementById('ops-panel-' + p);
            if (!btn || !panel) continue;

            if (p === path) {
                btn.style.borderColor = 'var(--accent)';
                btn.style.background = 'color-mix(in srgb, var(--accent) 8%, var(--bg-primary))';
                panel.style.display = '';
            } else {
                btn.style.borderColor = 'var(--border)';
                btn.style.background = 'var(--bg-primary)';
                panel.style.display = 'none';
            }
        }
        if (path === 'token') {
            setTimeout(() => document.getElementById('ops-auth-token')?.focus(), 100);
        }
    }

    // â”€â”€ Browser Auth (device flow) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    async function _opsAuthDeviceStart() {
        const cfg = window._opsAuthConfig;
        if (!cfg) return;
        const btn = document.getElementById('ops-auth-device-start');
        const statusEl = document.getElementById('ops-auth-status');
        if (btn) { btn.disabled = true; btn.textContent = 'â³ Startingâ€¦'; }

        try {
            const res = await apiPost('/gh/auth/device');

            if (res.ok && res.user_code) {
                _opsDeviceSession = res.session_id;

                // Replace the browser panel with the code display + polling
                const panel = document.getElementById('ops-panel-browser');
                if (panel) {
                    panel.innerHTML = `
                        <div style="text-align:center;padding:var(--space-sm) 0">
                            <div style="font-size:0.78rem;color:var(--text-secondary);margin-bottom:var(--space-sm)">
                                Enter this one-time code on GitHub:
                            </div>
                            <div id="ops-device-code"
                                 style="font-size:2rem;font-weight:800;letter-spacing:0.15em;font-family:var(--font-mono,monospace);
                                        color:var(--accent);background:var(--bg-inset);padding:16px 24px;border-radius:var(--radius-md);
                                        display:inline-block;cursor:pointer;border:2px solid var(--accent);user-select:all;
                                        transition:transform 0.15s"
                                 title="Click to copy"
                                 onclick="navigator.clipboard.writeText('${esc(res.user_code)}').then(()=>{this.style.transform='scale(1.05)';setTimeout(()=>this.style.transform='',200);document.getElementById('ops-code-hint').textContent='âœ“ Copied!'})">
                                ${esc(res.user_code)}
                            </div>
                            <div id="ops-code-hint" style="font-size:0.68rem;color:var(--text-muted);margin-top:6px">
                                Click the code to copy it
                            </div>
                        </div>

                        <div style="margin-top:var(--space-md);text-align:center">
                            <div style="font-size:0.78rem;color:var(--text-secondary);margin-bottom:var(--space-sm)">
                                A GitHub page should have opened in your browser.
                                <a href="${esc(res.verification_url)}" target="_blank" rel="noopener"
                                   style="color:var(--accent)">Open it again â†’</a>
                            </div>
                        </div>

                        <div id="ops-device-poll-status" style="margin-top:var(--space-md);padding:12px;border-radius:var(--radius-sm);background:var(--bg-inset);text-align:center">
                            <div style="display:flex;align-items:center;justify-content:center;gap:0.5rem">
                                <span id="ops-device-spinner">ğŸ”„</span>
                                <span style="font-size:0.82rem">Waiting for you to authorize on GitHubâ€¦</span>
                            </div>
                            <div style="font-size:0.68rem;color:var(--text-muted);margin-top:6px" id="ops-device-elapsed">0s elapsed</div>
                        </div>
                    `;
                }

                // â”€â”€ CRITICAL ORDER: start polling FIRST, then open URL â”€â”€
                // DO NOT await clipboard â€” window.open() steals focus,
                // and clipboard API hangs when document isn't focused.

                // 1) Start polling immediately
                _opsDeviceStartPolling(cfg);

                // 2) Copy code to clipboard (fire-and-forget, no await)
                navigator.clipboard.writeText(res.user_code).then(() => {
                    const hint = document.getElementById('ops-code-hint');
                    if (hint) {
                        hint.style.color = 'var(--success)';
                        hint.style.fontWeight = '600';
                        hint.style.fontSize = '0.78rem';
                        hint.innerHTML = 'âœ… Code copied to clipboard! Just <strong>Ctrl+V paste</strong> it on GitHub';
                    }
                }).catch(() => {
                    const hint = document.getElementById('ops-code-hint');
                    if (hint) hint.textContent = 'âš  Click the code above to copy it, then paste on GitHub';
                });

                // 3) Open GitHub URL LAST (steals focus)
                try {
                    window.open(res.verification_url, '_blank', 'noopener');
                } catch { /* popup blocked â€” user can click the link */ }
            } else {
                if (btn) { btn.disabled = false; btn.textContent = 'ğŸŒ Start Browser Authentication'; }
                const errMsg = res.error || 'Failed to start device flow';
                if (statusEl) {
                    statusEl.style.display = 'block';
                    statusEl.style.color = 'var(--error)';
                    statusEl.textContent = 'âŒ ' + errMsg;
                }
                if (res.raw_output) {
                    console.warn('Device flow raw output:', res.raw_output);
                }
                toast(errMsg, 'error');
            }
        } catch (err) {
            if (btn) { btn.disabled = false; btn.textContent = 'ğŸŒ Start Browser Authentication'; }
            toast('Error: ' + err.message, 'error');
        }
    }

    function _opsDeviceStartPolling(cfg) {
        if (_opsPollingTimer) clearInterval(_opsPollingTimer);

        const startTime = Date.now();
        const emojis = ['ğŸ”„', 'â³', 'ğŸ”', 'ğŸ“¡'];
        let emojiIdx = 0;

        _opsPollingTimer = setInterval(async () => {
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            const mins = Math.floor(elapsed / 60);
            const secs = elapsed % 60;

            // Update UI
            const elapsedEl = document.getElementById('ops-device-elapsed');
            if (elapsedEl) elapsedEl.textContent = mins > 0 ? `${mins}m ${secs}s elapsed` : `${secs}s elapsed`;
            const spinnerEl = document.getElementById('ops-device-spinner');
            if (spinnerEl) { emojiIdx = (emojiIdx + 1) % emojis.length; spinnerEl.textContent = emojis[emojiIdx]; }

            if (!_opsDeviceSession) return;

            try {
                const data = await api('/gh/auth/device/poll?session=' + _opsDeviceSession);

                if (data.complete && data.authenticated) {
                    clearInterval(_opsPollingTimer);
                    _opsPollingTimer = null;
                    _opsAuthSuccess(cfg);
                } else if (data.complete && !data.authenticated) {
                    clearInterval(_opsPollingTimer);
                    _opsPollingTimer = null;
                    const pollEl = document.getElementById('ops-device-poll-status');
                    if (pollEl) {
                        pollEl.innerHTML = `<span style="color:var(--error)">âŒ ${esc(data.error || 'Authentication failed')}</span>
                            <br><button class="btn btn-xs btn-primary" style="margin-top:var(--space-sm)"
                                onclick="_opsAuthDeviceStart()">ğŸ”„ Try Again</button>`;
                    }
                }
                // else: still waiting, do nothing
            } catch { /* ignore poll errors */ }
        }, 3000);
    }

    // â”€â”€ Terminal Spawn â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    async function _opsAuthSpawnTerminal() {
        const cfg = window._opsAuthConfig;
        if (!cfg) return;
        const btn = document.getElementById('ops-auth-spawn');
        const statusEl = document.getElementById('ops-auth-status');
        if (btn) { btn.disabled = true; btn.textContent = 'â³ Launchingâ€¦'; }

        // Check auto-drive checkbox
        const autoDrive = document.getElementById('ops-term-auto')?.checked ?? false;

        try {
            const res = await apiPost(cfg.loginEndpoint, { mode: 'interactive', auto_drive: autoDrive });

            if (res.ok && res.terminal) {
                // Terminal spawned
                if (btn) { btn.textContent = 'âœ… Terminal opened'; }

                if (autoDrive) {
                    // Auto-drive: poll signal file for code + URL
                    _opsTerminalSignalPoll(cfg, statusEl);
                } else {
                    // Manual: just poll gh auth status
                    _opsAuthStartPolling(cfg, statusEl);
                }

            } else if (res.no_terminal) {
                // No working terminal â€” show install options
                _opsShowTerminalInstall(res, cfg);

            } else if (res.fallback && res.command) {
                // Legacy fallback â€” show command to copy
                _opsShowCopyFallback(res, statusEl, btn);
            } else {
                if (btn) { btn.disabled = false; btn.textContent = 'ğŸ–¥ï¸ Launch Terminal Authentication'; }
                toast(res.error || 'Failed to spawn terminal', 'error');
            }
        } catch (err) {
            if (btn) { btn.disabled = false; btn.textContent = 'ğŸ–¥ï¸ Launch Terminal Authentication'; }
            toast('Error: ' + err.message, 'error');
        }
    }

    /** Show terminal emulator install options when no working terminal found. */
    function _opsShowTerminalInstall(res, cfg) {
        const body = document.getElementById('ops-auth-body');
        if (!body) return;

        const broken = res.broken || [];
        const installable = res.installable || [];
        const command = res.command || 'gh auth login';

        // Build broken info
        let brokenHtml = '';
        if (broken.length > 0) {
            const names = broken.map(b => {
                const extra = b.real_binary ? ` â†’ ${esc(b.real_binary)}` : '';
                return `<code>${esc(b.name)}</code>${extra} (${esc(b.reason)})`;
            }).join(', ');
            brokenHtml = `<div style="font-size:0.72rem;color:var(--warning);margin-bottom:var(--space-sm)">
                âš  Found but broken: ${names}
            </div>`;
        }

        // Build installable options
        let installHtml = '';
        if (installable.length > 0) {
            const recommended = installable.find(t => t.name === 'xterm') || installable[0];
            const options = installable.map(t => {
                const isRec = t.name === recommended.name;
                const checked = isRec ? 'checked' : '';
                const badge = isRec ? ' <span style="font-size:0.65rem;background:var(--accent);color:#fff;padding:1px 6px;border-radius:8px;margin-left:4px">recommended</span>' : '';
                return `<label style="display:flex;align-items:center;gap:0.5rem;padding:8px 10px;border-radius:var(--radius-sm);cursor:pointer;font-size:0.82rem;border:1px solid var(--border);background:var(--bg-primary);transition:all 0.15s"
                    onmouseover="this.style.borderColor='var(--accent)'" onmouseout="this.style.borderColor='var(--border)'">
                    <input type="radio" name="ops-term-choice" value="${esc(t.name)}" ${checked}
                           style="accent-color:var(--accent);margin:0" />
                    <div style="flex:1">
                        <strong>${esc(t.label)}</strong>${badge}
                        <div style="font-size:0.7rem;color:var(--text-muted)">${esc(t.description)} â€” <code>${esc(t.apt_package)}</code></div>
                    </div>
                </label>`;
            }).join('');

            installHtml = `
                <div style="font-size:0.82rem;font-weight:600;margin-bottom:var(--space-sm)">Install a terminal emulator:</div>
                <div style="display:flex;flex-direction:column;gap:6px;margin-bottom:var(--space-md)">${options}</div>
                <button class="btn btn-sm btn-primary" id="ops-term-install-btn" style="width:100%;padding:10px"
                    onclick="_opsInstallTerminal()">ğŸ“¦ Install Selected Terminal</button>
            `;
        }

        // Fallback: copy command
        const fallbackHtml = `
            <div style="margin-top:var(--space-md);padding-top:var(--space-md);border-top:1px solid var(--border)">
                <div style="font-size:0.78rem;color:var(--text-secondary);margin-bottom:var(--space-sm)">
                    Or run the command manually:
                </div>
                <div style="display:flex;align-items:center;gap:0.5rem">
                    <code style="flex:1;background:var(--bg-tertiary);padding:6px 10px;border-radius:4px;font-size:0.78rem">${esc(command)}</code>
                    <button class="btn btn-xs btn-secondary" style="font-size:0.68rem;padding:3px 8px;white-space:nowrap"
                        onclick="navigator.clipboard.writeText('${command.replace(/'/g, "\\'")}').then(()=>this.textContent='âœ“ Copied').catch(()=>{});setTimeout(()=>this.textContent='ğŸ“‹ Copy',2000)">ğŸ“‹ Copy</button>
                </div>
                <button class="btn btn-xs btn-primary" style="margin-top:var(--space-sm);width:100%;padding:8px"
                    onclick="_opsAuthPollOnce()">ğŸ”„ Check Status</button>
            </div>
        `;

        // Replace the terminal panel content
        body.innerHTML = `
            <div style="font-size:0.85rem;color:var(--warning);margin-bottom:var(--space-md)">
                <strong>âš  No working terminal emulator found.</strong>
            </div>
            <div style="font-size:0.78rem;color:var(--text-secondary);margin-bottom:var(--space-md)">
                A terminal emulator is needed for the interactive authentication flow.
                Install one below, or paste a token instead.
            </div>
            ${brokenHtml}
            ${installHtml}
            ${installable.length === 0 ? '<div style="font-size:0.82rem;color:var(--error);margin-bottom:var(--space-sm)">No terminal emulators available to install.</div>' : ''}
            ${fallbackHtml}
            <div style="margin-top:var(--space-md);text-align:center">
                <button class="btn btn-xs btn-secondary" style="font-size:0.72rem"
                    onclick="_opsShowTokenFromInstall()">ğŸ”‘ Switch to Token Paste</button>
            </div>

            <!-- Status / log area (reused by polling) -->
            <div id="ops-auth-status" style="display:none;margin-top:var(--space-md);padding:12px;border-radius:var(--radius-sm);background:var(--bg-inset);font-size:0.78rem;text-align:center"></div>
        `;
    }

    /** Install a selected terminal emulator, then retry terminal spawn. */
    async function _opsInstallTerminal() {
        const selected = document.querySelector('input[name="ops-term-choice"]:checked');
        if (!selected) { toast('Select a terminal emulator first', 'warning'); return; }

        const termName = selected.value;
        const btn = document.getElementById('ops-term-install-btn');

        // Use the existing install modal flow â€” but with a callback to retry spawn
        const cfg = window._opsAuthConfig;
        _opsModalClose(); // Close auth modal temporarily

        _showOpsModal({
            type: 'install',
            toolId: termName,
            toolLabel: termName,
            needsSudo: true,
            onSuccess: () => {
                // Terminal installed â€” re-open the auth modal and auto-retry
                toast(termName + ' installed! Retrying terminal spawnâ€¦', 'success');
                setTimeout(() => {
                    if (cfg) {
                        _showAuthModal(cfg);
                        // Auto-click the spawn button after modal renders
                        setTimeout(() => _opsAuthSpawnTerminal(), 300);
                    }
                }, 800);
            },
        });
    }

    /** Show copy-command fallback (legacy path). */
    function _opsShowCopyFallback(res, statusEl, btn) {
        if (statusEl) {
            statusEl.style.display = 'block';
            statusEl.style.textAlign = 'left';
            statusEl.innerHTML = `
                <div style="font-size:0.82rem;color:var(--warning);margin-bottom:var(--space-sm)">
                    <strong>âš  No terminal emulator found.</strong> Run this in your terminal:
                </div>
                <div style="display:flex;align-items:center;gap:0.5rem">
                    <code style="flex:1;background:var(--bg-tertiary);padding:6px 10px;border-radius:4px;font-size:0.78rem">${esc(res.command)}</code>
                    <button class="btn btn-xs btn-secondary" style="font-size:0.68rem;padding:3px 8px;white-space:nowrap"
                        onclick="navigator.clipboard.writeText('${res.command.replace(/'/g, "\\'")}').then(()=>this.textContent='âœ“ Copied').catch(()=>{});setTimeout(()=>this.textContent='ğŸ“‹ Copy',2000)">ğŸ“‹ Copy</button>
                </div>
                <div style="font-size:0.72rem;color:var(--text-muted);margin-top:var(--space-sm)">
                    After completing auth, click <strong>Check Status</strong> below.
                </div>
                <button class="btn btn-xs btn-primary" style="margin-top:var(--space-sm);width:100%;padding:8px"
                    onclick="_opsAuthPollOnce()">ğŸ”„ Check Status</button>
            `;
        }
        if (btn) { btn.disabled = false; btn.textContent = 'ğŸ–¥ï¸ Launch Terminal Authentication'; }
    }

    /** Re-open auth modal on token tab (from terminal install flow where DOM was replaced). */
    function _opsShowTokenFromInstall() {
        const cfg = window._opsAuthConfig;
        if (!cfg) return;
        _opsModalClose();
        _showAuthModal(cfg);
        // Auto-switch to token tab after render
        setTimeout(() => _opsAuthSelectPath('token'), 100);
    }
    /**
     * Poll terminal signal file for device code, URL, and completion.
     * When code_ready: show code in modal + open GitHub URL.
     * When success: trigger auth success.
     */
    function _opsTerminalSignalPoll(cfg, statusEl) {
        if (_opsPollingTimer) clearInterval(_opsPollingTimer);

        let codeShown = false;
        const startTime = Date.now();
        const emojis = ['ğŸ”„', 'â³', 'ğŸ”', 'ğŸ“¡'];
        let emojiIdx = 0;

        if (statusEl) {
            statusEl.style.display = 'block';
            statusEl.innerHTML = `
                <div style="display:flex;align-items:center;justify-content:center;gap:0.5rem;margin-bottom:0.5rem">
                    <span id="ops-poll-spinner">${emojis[0]}</span>
                    <span>Waiting for device code from terminalâ€¦</span>
                </div>
                <div style="font-family:monospace;font-size:0.72rem;color:var(--text-muted)" id="ops-poll-elapsed">0s elapsed</div>
                <div style="font-size:0.68rem;color:var(--text-muted);margin-top:0.4rem">Complete the Y/n prompt in the terminal window.</div>
            `;
        }

        _opsPollingTimer = setInterval(async () => {
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            const mins = Math.floor(elapsed / 60);
            const secs = elapsed % 60;

            const elapsedEl = document.getElementById('ops-poll-elapsed');
            if (elapsedEl) elapsedEl.textContent = mins > 0 ? `${mins}m ${secs}s elapsed` : `${secs}s elapsed`;
            const spinnerEl = document.getElementById('ops-poll-spinner');
            if (spinnerEl) { emojiIdx = (emojiIdx + 1) % emojis.length; spinnerEl.textContent = emojis[emojiIdx]; }

            // Timeout after 5 minutes
            if (Date.now() - startTime > 300000) {
                clearInterval(_opsPollingTimer);
                _opsPollingTimer = null;
                if (statusEl) {
                    statusEl.innerHTML = `<span style="color:var(--warning)">â±ï¸ Timed out. <button class="btn btn-xs btn-primary" onclick="_opsAuthPollOnce()">ğŸ”„ Check Now</button></span>`;
                }
                return;
            }

            try {
                const data = await api('/gh/auth/terminal/poll');

                if (data.status === 'code_ready' && !codeShown) {
                    codeShown = true;
                    // Show device code + open-link in the modal panel
                    const panel = document.getElementById('ops-panel-terminal');
                    if (panel) {
                        const codeHtml = `
                            <div style="text-align:center;margin-top:var(--space-md)">
                                <div style="font-size:0.82rem;color:var(--text-secondary);margin-bottom:var(--space-xs)">Your one-time code:</div>
                                <div style="font-size:2rem;font-weight:800;letter-spacing:0.15em;font-family:monospace;
                                    background:var(--bg-tertiary);padding:12px 24px;border-radius:var(--radius-md);display:inline-block;
                                    cursor:pointer;user-select:all;border:2px solid var(--accent)"
                                    title="Click to copy"
                                    onclick="navigator.clipboard.writeText('${data.code}').then(()=>toast('Copied!','success'))">
                                    ${data.code}
                                </div>
                                <div id="ops-code-hint" style="font-size:0.72rem;color:var(--text-muted);margin-top:var(--space-xs)">
                                    Click code to copy â€¢ Paste it on GitHub
                                </div>
                                <a href="${data.url}" target="_blank" rel="noopener"
                                    style="display:inline-block;margin-top:var(--space-sm);padding:8px 20px;
                                    background:var(--accent);color:#fff;border-radius:var(--radius-md);
                                    font-weight:700;font-size:0.88rem;text-decoration:none;
                                    transition:opacity 0.2s"
                                    onmouseover="this.style.opacity='0.85'"
                                    onmouseout="this.style.opacity='1'"
                                    >ğŸ”— Open GitHub to paste code</a>
                            </div>
                        `;
                        // Insert before the status element
                        if (statusEl) {
                            statusEl.insertAdjacentHTML('beforebegin', codeHtml);
                            statusEl.innerHTML = `
                                <div style="display:flex;align-items:center;justify-content:center;gap:0.5rem;margin-bottom:0.5rem">
                                    <span id="ops-poll-spinner">ğŸ“¡</span>
                                    <span>Waiting for you to authorize on GitHubâ€¦</span>
                                </div>
                                <div style="font-family:monospace;font-size:0.72rem;color:var(--text-muted)" id="ops-poll-elapsed">${secs}s elapsed</div>
                            `;
                        }
                    }

                    // Try to copy code to clipboard
                    navigator.clipboard.writeText(data.code).then(() => {
                        const hint = document.getElementById('ops-code-hint');
                        if (hint) {
                            hint.style.color = 'var(--success)';
                            hint.style.fontWeight = '600';
                            hint.innerHTML = 'âœ… Code copied! Just <strong>Ctrl+V paste</strong> it on GitHub';
                        }
                    }).catch(() => {});
                }

                if (data.status === 'success') {
                    clearInterval(_opsPollingTimer);
                    _opsPollingTimer = null;
                    _opsAuthSuccess(cfg);
                    return;
                }

                if (data.status === 'failed') {
                    clearInterval(_opsPollingTimer);
                    _opsPollingTimer = null;
                    if (statusEl) {
                        statusEl.innerHTML = `<span style="color:var(--error)">âŒ Authentication failed in terminal. Check the terminal window for details.</span>`;
                    }
                    return;
                }
            } catch { /* ignore poll errors */ }
        }, 2000);
    }

    function _opsAuthStartPolling(cfg, statusEl) {
        if (_opsPollingTimer) clearInterval(_opsPollingTimer);

        const startTime = Date.now();
        const timeout = cfg.pollTimeout || 300000;
        const interval = cfg.pollInterval || 3000;
        const pollCheck = cfg.pollCheck || (() => false);
        const pollEndpoint = cfg.pollEndpoint || '/integrations/gh/status';
        const emojis = ['ğŸ”„', 'â³', 'ğŸ”', 'ğŸ“¡'];
        let emojiIdx = 0;

        if (statusEl) {
            statusEl.style.display = 'block';
            statusEl.innerHTML = `
                <div style="display:flex;align-items:center;justify-content:center;gap:0.5rem;margin-bottom:0.5rem">
                    <span id="ops-poll-spinner">${emojis[0]}</span>
                    <span>Waiting for authentication to completeâ€¦</span>
                </div>
                <div style="font-family:monospace;font-size:0.72rem;color:var(--text-muted)" id="ops-poll-elapsed">0s elapsed</div>
                <div style="font-size:0.68rem;color:var(--text-muted);margin-top:0.4rem">Complete the login in the terminal window that opened.</div>
            `;
        }

        _opsPollingTimer = setInterval(async () => {
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            const mins = Math.floor(elapsed / 60);
            const secs = elapsed % 60;

            // Update UI
            const elapsedEl = document.getElementById('ops-poll-elapsed');
            if (elapsedEl) elapsedEl.textContent = mins > 0 ? `${mins}m ${secs}s elapsed` : `${secs}s elapsed`;
            const spinnerEl = document.getElementById('ops-poll-spinner');
            if (spinnerEl) { emojiIdx = (emojiIdx + 1) % emojis.length; spinnerEl.textContent = emojis[emojiIdx]; }

            // Timeout check
            if (Date.now() - startTime > timeout) {
                clearInterval(_opsPollingTimer);
                _opsPollingTimer = null;
                if (statusEl) {
                    statusEl.innerHTML = `<span style="color:var(--warning)">â±ï¸ Polling timed out. <button class="btn btn-xs btn-primary" onclick="_opsAuthPollOnce()">ğŸ”„ Check Now</button></span>`;
                }
                return;
            }

            // Poll
            try {
                const data = await api(pollEndpoint);
                if (pollCheck(data)) {
                    clearInterval(_opsPollingTimer);
                    _opsPollingTimer = null;
                    _opsAuthSuccess(cfg);
                }
            } catch { /* ignore poll errors */ }
        }, interval);
    }

    async function _opsAuthPollOnce() {
        const cfg = window._opsAuthConfig;
        if (!cfg) return;
        const statusEl = document.getElementById('ops-auth-status');
        try {
            const data = await api(cfg.pollEndpoint || '/integrations/gh/status');
            const check = cfg.pollCheck || (() => false);
            if (check(data)) {
                _opsAuthSuccess(cfg);
            } else {
                if (statusEl) {
                    statusEl.innerHTML = `<span style="color:var(--warning)">âš  Not authenticated yet. Complete the login flow and try again.</span>
                    <button class="btn btn-xs btn-primary" style="margin-top:var(--space-sm);width:100%;padding:8px"
                        onclick="_opsAuthPollOnce()">ğŸ”„ Check Again</button>`;
                }
            }
        } catch (err) {
            if (statusEl) {
                statusEl.innerHTML = `<span style="color:var(--error)">âŒ ${esc(err.message)}</span>`;
            }
        }
    }

    async function _opsAuthWithToken() {
        const cfg = window._opsAuthConfig;
        if (!cfg) return;
        const tokenInput = document.getElementById('ops-auth-token');
        const btn = document.getElementById('ops-auth-token-go');
        const statusEl = document.getElementById('ops-auth-status');
        const token = tokenInput?.value?.trim();

        if (!token) {
            if (tokenInput) { tokenInput.style.borderColor = 'var(--error)'; tokenInput.placeholder = 'âš ï¸ Token required'; tokenInput.focus(); }
            return;
        }

        if (btn) { btn.disabled = true; btn.textContent = 'â³ Authenticatingâ€¦'; }
        if (statusEl) { statusEl.style.display = 'block'; statusEl.textContent = 'ğŸ”„ Authenticatingâ€¦'; statusEl.style.color = ''; }

        try {
            const res = await apiPost(cfg.loginEndpoint, { token });

            if (res.ok && res.authenticated) {
                _opsAuthSuccess(cfg);
            } else {
                if (statusEl) { statusEl.textContent = 'âŒ ' + (res.error || 'Authentication failed'); statusEl.style.color = 'var(--error)'; }
                if (btn) { btn.disabled = false; btn.textContent = 'ğŸ”‘ Authenticate'; }
                if (tokenInput) { tokenInput.value = ''; tokenInput.focus(); tokenInput.style.borderColor = 'var(--warning)'; }
            }
        } catch (err) {
            if (statusEl) { statusEl.textContent = 'âŒ ' + err.message; statusEl.style.color = 'var(--error)'; }
            if (btn) { btn.disabled = false; btn.textContent = 'ğŸ”‘ Authenticate'; }
        }
    }

    function _opsAuthSuccess(cfg) {
        // Replace the entire modal body with a success state
        const body = document.getElementById('ops-auth-body');
        if (body) {
            body.innerHTML = `
                <div style="text-align:center;padding:var(--space-lg) 0">
                    <div style="font-size:2.5rem;margin-bottom:var(--space-sm)">âœ…</div>
                    <div style="font-size:1.1rem;font-weight:700;color:var(--success);margin-bottom:var(--space-sm)">
                        Authenticated successfully!
                    </div>
                    <div style="font-size:0.78rem;color:var(--text-muted)">
                        Closing in a momentâ€¦
                    </div>
                </div>
            `;
        }
        toast('Authentication successful!', 'success');

        // Silent background cache bust â€” ONLY the github card changed
        (async () => {
            try {
                await apiPost('/devops/cache/bust', { card: 'github' }).catch(() => {});
            } catch { /* ignore */ }

            // Clear ONLY github-related client-side caches
            if (typeof _store !== 'undefined') {
                for (const k of Object.keys(_store)) {
                    if (k.startsWith('gh:') || k === 'github' || k === 'capabilities') {
                        delete _store[k];
                    }
                }
            }
            if (typeof wizInvalidate === 'function') {
                try { wizInvalidate('detect'); wizInvalidate('gh:detect'); } catch {}
            }

            // Reload ONLY the GitHub card â€” not all integrations
            cardInvalidate('github');  // clear sessionStorage
            if (typeof loadGitHubCard === 'function') {
                // Show spinner on GH card while re-fetching
                const ghDetail = document.getElementById('int-gh-detail');
                const ghBadge = document.getElementById('int-gh-badge');
                if (ghDetail) ghDetail.innerHTML = '<span class="spinner"></span>';
                if (ghBadge) { ghBadge.className = 'status-badge'; ghBadge.textContent = 'â€”'; }
                await loadGitHubCard();
            }
        })();

        setTimeout(() => {
            _opsModalClose();
            if (cfg.onSuccess) cfg.onSuccess();
        }, 2000);
    }

    // â”€â”€ Convenience helpers for GitHub auth â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    function _showGhAuthModal(onSuccess) {
        _showOpsModal({
            type: 'auth',
            title: 'ğŸ”‘ Authenticate GitHub',
            description: 'Connect your GitHub account via the <code>gh</code> CLI.',
            loginEndpoint: '/gh/auth/login',
            pollEndpoint: '/integrations/gh/status',
            pollCheck: (d) => d.authenticated === true,
            tokenHint: 'Use a GitHub Personal Access Token (classic or fine-grained)',
            tokenUrl: 'https://github.com/settings/tokens',
            onSuccess: onSuccess || null,  // _opsAuthSuccess already handles cache bust
        });
    }

    // â”€â”€ After-install refresh â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    /** After a tool install/auth, bust caches and re-load the active tab instead of full page reload. */
    async function _refreshAfterInstall() {
        try {
            // Bust server-side cache so next fetch re-runs detection
            await apiPost('/devops/cache/bust', { card: 'integrations' }).catch(() => {});
            await apiPost('/devops/cache/bust', { card: 'devops' }).catch(() => {});
        } catch { /* ignore */ }

        // Clear ONLY integration/devops client-side caches (not everything!)
        if (typeof _store !== 'undefined') {
            for (const k of Object.keys(_store)) {
                if (k.startsWith('int:') || k.startsWith('gh:') || k.startsWith('devops:') || k === 'integrations' || k === 'capabilities') {
                    delete _store[k];
                }
            }
        }

        // Invalidate wizard caches too (if wizard is open)
        if (typeof wizInvalidate === 'function') {
            try { wizInvalidate('detect'); wizInvalidate('gh:detect'); } catch {}
        }

        // Re-load whichever tab is active
        if (typeof _intLoaded !== 'undefined') { _intLoaded = false; _intPrefs = null; }
        const activeTab = document.querySelector('.tab-btn.active')?.dataset?.tab;
        if (activeTab === 'integrations' && typeof loadIntegrationsTab === 'function') {
            await loadIntegrationsTab(true);
        } else if (activeTab === 'devops' && typeof loadDevOpsTab === 'function') {
            await loadDevOpsTab(true);
        } else if (activeTab === 'audit' && typeof loadAuditTab === 'function') {
            await loadAuditTab(true);
        } else {
            // Fallback: reload current tab by clicking it
            document.querySelector('.tab-btn.active')?.click();
        }
    }

</script>
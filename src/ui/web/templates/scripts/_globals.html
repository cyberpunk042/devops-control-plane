<script>
    // â”€â”€ Global helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    // â”€â”€ API concurrency control â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    //
    // HTTP/1.1 browsers cap at 6 TCP connections per origin.
    // Without throttling, 15+ parallel fetch() calls cause the
    // browser to silently queue excess requests.  Our AbortController
    // timeout would tick during that invisible queue wait, killing
    // perfectly healthy requests that simply hadn't gotten a
    // connection slot yet.
    //
    // Fix: a JS-level semaphore (max 5 in-flight) keeps requests
    // queued HERE where the timeout hasn't started yet.  Slot 6
    // is left free for static assets / WebSocket / other traffic.

    const _API_MAX_CONCURRENT = 3;
    let _apiInFlight = 0;
    const _apiQueue = [];

    function _apiAcquire() {
        if (_apiInFlight < _API_MAX_CONCURRENT) {
            _apiInFlight++;
            return Promise.resolve();
        }
        return new Promise(resolve => _apiQueue.push(resolve));
    }

    function _apiRelease() {
        if (_apiQueue.length > 0) {
            _apiQueue.shift()();   // hand slot to next waiter
        } else {
            _apiInFlight--;
        }
    }

    async function api(path, opts = {}) {
        // Wait for a connection slot BEFORE starting the timeout.
        await _apiAcquire();
        const controller = new AbortController();
        const ms = opts.timeout || 30000;
        const timer = setTimeout(() => controller.abort(), ms);
        try {
            const res = await fetch('/api' + path, {
                headers: { 'Content-Type': 'application/json' },
                ...opts,
                signal: controller.signal,
            });
            clearTimeout(timer);
            const data = await res.json();
            if (!res.ok) throw new Error(data.error || `HTTP ${res.status}`);
            return data;
        } catch (e) {
            if (e.name === 'AbortError') throw new Error(`Request timed out after ${ms / 1000}s`);
            throw e;
        } finally {
            clearTimeout(timer);
            _apiRelease();
        }
    }

    /** POST JSON convenience wrapper. */
    async function apiPost(path, body = {}) {
        return api(path, {
            method: 'POST',
            body: JSON.stringify(body),
        });
    }

    function toast(message, type = 'success') {
        const container = document.getElementById('toast-container');
        const el = document.createElement('div');
        el.className = `toast ${type}`;
        el.textContent = message;
        container.appendChild(el);
        setTimeout(() => el.remove(), 6000);
    }

    function esc(str) {
        const div = document.createElement('div');
        div.textContent = str;
        return div.innerHTML;
    }

    function showRefreshBar() {
        document.getElementById('refresh-bar').classList.add('active');
    }

    function hideRefreshBar() {
        document.getElementById('refresh-bar').classList.remove('active');
    }

    // â”€â”€ Shared card cache (sessionStorage-backed) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    //
    // Client-side cache with long TTL (10 min).  Server-side cache handles
    // real freshness via mtime tracking.  Manual refresh busts BOTH caches.

    const _CARD_PREFIX = '_cc:';     // sessionStorage key prefix
    const _CARD_TTL = 600_000;    // 10 min (server checks mtimes for freshness)

    /** Return cached data if fresh, else null. */
    function cardCached(key) {
        try {
            const raw = sessionStorage.getItem(_CARD_PREFIX + key);
            if (!raw) return null;
            const c = JSON.parse(raw);
            if (Date.now() - c.ts < _CARD_TTL) return c.data;
            sessionStorage.removeItem(_CARD_PREFIX + key);
            return null;
        } catch { return null; }
    }

    /** Store data in cache with a timestamp. */
    function cardStore(key, data) {
        try {
            sessionStorage.setItem(_CARD_PREFIX + key,
                JSON.stringify({ data, ts: Date.now() }));
        } catch { /* quota exceeded â€” silently skip */ }
    }

    /** Invalidate a single card's cache. */
    function cardInvalidate(key) {
        sessionStorage.removeItem(_CARD_PREFIX + key);
    }

    /** Invalidate all cards (optionally filtered by prefix). */
    function cardInvalidateAll(prefix) {
        const keys = [];
        for (let i = 0; i < sessionStorage.length; i++) {
            const k = sessionStorage.key(i);
            if (k && k.startsWith(_CARD_PREFIX)) {
                const card = k.slice(_CARD_PREFIX.length);
                if (!prefix || card.startsWith(prefix)) keys.push(k);
            }
        }
        keys.forEach(k => sessionStorage.removeItem(k));
    }

    /** Get age of a cached entry in seconds, or null. */
    function cardAge(key) {
        try {
            const raw = sessionStorage.getItem(_CARD_PREFIX + key);
            if (!raw) return null;
            const c = JSON.parse(raw);
            // Use server-side computed_at if available (more accurate)
            if (c.data?._cache?.computed_at) {
                return Math.round(Date.now() / 1000 - c.data._cache.computed_at);
            }
            return Math.round((Date.now() - c.ts) / 1000);
        } catch { return null; }
    }

    /** Format age as human-readable string. */
    function _formatAge(secs) {
        if (secs == null) return '';
        if (secs < 5) return 'just now';
        if (secs < 60) return secs + 's ago';
        if (secs < 3600) return Math.floor(secs / 60) + 'm ago';
        return Math.floor(secs / 3600) + 'h ago';
    }

    // â”€â”€ Wizard step cache (same pattern as cards, separate namespace) â”€â”€
    const _WIZ_PREFIX = '_wz:';      // sessionStorage key prefix
    const _WIZ_TTL = 600_000;     // 10 min

    /** Return cached wizard data if fresh, else null. */
    function wizCached(key) {
        try {
            const raw = sessionStorage.getItem(_WIZ_PREFIX + key);
            if (!raw) return null;
            const c = JSON.parse(raw);
            if (Date.now() - c.ts < _WIZ_TTL) return c.data;
            sessionStorage.removeItem(_WIZ_PREFIX + key);
            return null;
        } catch { return null; }
    }

    /** Store wizard data in cache. Uses server-side computed_at if present,
     *  or explicit epochMs if provided. */
    function wizStore(key, data, epochMs) {
        try {
            // Use the server's real computation time, not "now"
            const serverAt = data?._cache?.computed_at;
            const ts = epochMs || (serverAt ? serverAt * 1000 : Date.now());
            sessionStorage.setItem(_WIZ_PREFIX + key,
                JSON.stringify({ data, ts }));
        } catch { /* quota exceeded â€” silently skip */ }
    }

    /** Invalidate a single wizard cache entry. */
    function wizInvalidate(key) {
        sessionStorage.removeItem(_WIZ_PREFIX + key);
    }

    /** Invalidate all wizard caches (optionally filtered by prefix). */
    function wizInvalidateAll(prefix) {
        const keys = [];
        for (let i = 0; i < sessionStorage.length; i++) {
            const k = sessionStorage.key(i);
            if (k && k.startsWith(_WIZ_PREFIX)) {
                const wk = k.slice(_WIZ_PREFIX.length);
                if (!prefix || wk.startsWith(prefix)) keys.push(k);
            }
        }
        keys.forEach(k => sessionStorage.removeItem(k));
    }

    /** Get age of a wizard cache entry in seconds, or null. */
    function wizAge(key) {
        try {
            const raw = sessionStorage.getItem(_WIZ_PREFIX + key);
            if (!raw) return null;
            const c = JSON.parse(raw);
            // Use server-side computed_at if available (more accurate)
            if (c.data?._cache?.computed_at) {
                return Math.round(Date.now() / 1000 - c.data._cache.computed_at);
            }
            return Math.round((Date.now() - c.ts) / 1000);
        } catch { return null; }
    }

    /** Tick all visible card-age indicators. */
    function _tickCardAges() {
        document.querySelectorAll('[data-cache-key]').forEach(el => {
            const age = cardAge(el.dataset.cacheKey);
            el.textContent = _formatAge(age);
            if (age != null && age > 600) {
                el.style.color = 'var(--warning)';
            } else {
                el.style.color = 'var(--text-muted)';
            }
        });
    }
    setInterval(_tickCardAges, 5000);

    // Cascade: when key X is refreshed, also invalidate dependent client caches.
    const _CASCADE = {
        'git': ['github', 'docker', 'ci', 'pages'],
        'docker': ['ci', 'k8s'],
        'github': ['ci'],
        'pages': ['dns'],
    };

    /**
     * Refresh a single card: bust both client + server cache (with cascade), show spinner, reload.
     */
    async function cardRefresh(cacheKey, badgeId, detailId, loadFn) {
        // Bust client cache: primary + cascade + aggregates
        cardInvalidate(cacheKey);
        for (const dep of _CASCADE[cacheKey] || []) cardInvalidate(dep);
        cardInvalidate('project-status');
        cardInvalidate('health-score');
        // Also clear the in-memory SSE store so loadFn doesn't short-circuit
        if (typeof _store !== 'undefined') {
            delete _store[cacheKey];
            for (const dep of _CASCADE[cacheKey] || []) delete _store[dep];
        }
        // Bust server-side cache (server also cascades) â€” AWAIT so loadFn gets fresh data
        try { await api('/devops/cache/bust', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ card: cacheKey }) }); } catch { }
        const badge = document.getElementById(badgeId);
        const detail = document.getElementById(detailId);
        if (badge) { badge.className = 'status-badge'; badge.textContent = 'â€”'; }
        if (detail) detail.innerHTML = '<span class="spinner"></span>';
        await loadFn();
    }

    /**
     * Load card data: check client cache, fetch from API if needed, store, handle errors.
     * Returns the data dict on success, or null on error (after rendering error state).
     */
    async function cardLoad(cacheKey, apiPath, badgeEl, detailEl) {
        const cached = cardCached(cacheKey);
        if (cached) return cached;

        const data = await api(apiPath).catch(e => ({ _err: e }));
        if (data._err) {
            if (badgeEl) {
                badgeEl.className = 'status-badge failed';
                badgeEl.innerHTML = '<span class="status-dot"></span>Error';
            }
            if (detailEl) {
                detailEl.innerHTML = `<p class="empty-state-sm" style="color:var(--error)">${esc(data._err.message)}</p>`;
            }
            return null;
        }

        cardStore(cacheKey, data);
        return data;
    }

    /**
     * Navigate to the Content Vault and open a file for viewing/editing.
     * Respects the user's preview mode preference:
     *   - 'modal'   â†’ opens a peek modal (no tab navigation)
     *   - 'forward' â†’ navigates to Content tab (original behavior)
     * @param {string} filePath - relative path to the file (e.g. "Dockerfile", "k8s/deployment.yaml")
     * @param {string} [mode='raw'] - view mode: 'raw' | 'edit' | 'preview'
     * @param {number} [line=0] - optional line number to focus
     */
    function openFileInEditor(filePath, mode = 'raw', line = 0) {
        // Open in modal unless we're in a docs/media browsing view
        const inDocsBrowser = (typeof activeTab !== 'undefined' && activeTab === 'content'
            && typeof contentCurrentMode !== 'undefined'
            && (contentCurrentMode === 'docs' || contentCurrentMode === 'media'));
        if (!inDocsBrowser
            && typeof openFileInModal === 'function') {
            openFileInModal(filePath);
            return;
        }
        const hashSuffix = line > 0 ? `@${mode}:${line}` : `@${mode}`;
        switchTab(`content/docs/${filePath}${hashSuffix}`);
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // â”€â”€ Phase 1: Reusable Card Section Builders â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    /**
     * Build a status grid HTML string.
     * @param {Array<{label:string, value:string, cls?:string}>} stats
     * @returns {string} HTML
     */
    function cardStatusGrid(stats) {
        return `<div class="card-status-grid">${stats.map(s =>
            `<div class="card-stat"><span class="card-stat-label">${esc(s.label)}</span>` +
            `<span class="card-stat-value${s.cls ? ' ' + s.cls : ''}">${esc(String(s.value))}</span></div>`
        ).join('')}</div>`;
    }

    /**
     * Build a detection list HTML string.
     * @param {Array<{icon:string, label:string, value?:string, click?:string}>} items
     * @returns {string} HTML
     */
    function cardDetectionList(items) {
        return `<div class="card-detection">${items.map(i => {
            const valCls = i.click ? ' clickable' : '';
            const valAttr = i.click ? ` onclick="${i.click}"` : '';
            return `<div class="card-detect-row">` +
                `<span class="card-detect-icon">${i.icon}</span>` +
                `<span class="card-detect-label">${esc(i.label)}</span>` +
                (i.value != null ? `<span class="card-detect-value${valCls}"${valAttr}>${esc(i.value)}</span>` : '') +
                `</div>`;
        }).join('')}</div>`;
    }

    /**
     * Build a data table HTML string (for live panels).
     * @param {string[]} columns - header labels
     * @param {Array<Array<{text:string, cls?:string, click?:string}>>} rows
     * @returns {string} HTML
     */
    function cardDataTable(columns, rows) {
        const thead = columns.map(c => `<th>${esc(c)}</th>`).join('');
        const tbody = rows.map(row =>
            `<tr>${row.map(cell => {
                const cls = cell.cls ? ` class="${cell.cls}"` : '';
                const onclick = cell.click ? ` onclick="${cell.click}" style="cursor:pointer"` : '';
                return `<td${cls}${onclick}>${esc(String(cell.text ?? 'â€”'))}</td>`;
            }).join('')}</tr>`
        ).join('');
        return `<table class="card-data-table"><thead><tr>${thead}</tr></thead><tbody>${tbody}</tbody></table>`;
    }

    /**
     * Build an action toolbar HTML string.
     * @param {Array<{label:string, icon?:string, cls?:string, onclick:string, id?:string, disabled?:boolean}>} actions
     * @returns {string} HTML
     */
    function cardActionToolbar(actions) {
        return `<div class="card-actions">${actions.map(a =>
            `<button class="btn btn-sm ${a.cls || 'btn-secondary'}" ` +
            `onclick="${a.onclick}"${a.id ? ` id="${a.id}"` : ''}${a.disabled ? ' disabled' : ''}>` +
            `${a.icon ? a.icon + ' ' : ''}${esc(a.label)}</button>`
        ).join('')}</div>`;
    }

    /**
     * Build an empty state HTML string with optional CTA button.
     * @param {string} icon - emoji
     * @param {string} text - message
     * @param {Object|null} action - optional CTA {label, onclick}
     * @returns {string} HTML
     */
    function cardEmpty(icon, text, action) {
        return `<div class="card-empty">` +
            `<div class="card-empty-icon">${icon}</div>` +
            `<div class="card-empty-text">${esc(text)}</div>` +
            (action ? `<button class="card-empty-action" onclick="${action.onclick}">${esc(action.label)}</button>` : '') +
            `</div>`;
    }

    /**
     * Build a live panel with tabs.
     * @param {string} panelId - unique ID for the panel content area
     * @param {Array<{key:string, label:string}>} tabs - tab definitions
     * @param {string} onTabClick - JS function name called with (key, panelId)
     * @returns {string} HTML
     */
    function cardLivePanel(panelId, tabs, onTabClick) {
        return `<div class="card-live">` +
            `<div class="card-live-tabs">${tabs.map(t =>
                `<button class="card-live-tab" data-tab="${t.key}" ` +
                `onclick="this.parentElement.querySelectorAll('.card-live-tab').forEach(b=>b.classList.remove('active'));` +
                `this.classList.add('active');${onTabClick}('${t.key}','${panelId}')">${t.label}</button>`
            ).join('')}</div>` +
            `<div class="card-live-panel" id="${panelId}">` +
            `<span style="color:var(--text-muted)">Select a tab above</span></div>` +
            `</div>`;
    }

    /**
     * Build a generate toolbar HTML string.
     * @param {Array<{label:string, icon?:string, onclick:string}>} items
     * @returns {string} HTML
     */
    function cardGenerateToolbar(items) {
        return `<div class="card-generate">${items.map(g =>
            `<button class="card-gen-btn" onclick="${g.onclick}">${g.icon ? g.icon + ' ' : ''}${esc(g.label)}</button>`
        ).join('')}</div>`;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // â”€â”€ Phase 1: Reusable Modal System â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    let _activeModal = null;

    /**
     * Open a standard modal.
     * @param {Object} opts
     * @param {string} opts.title - modal title (can include emoji)
     * @param {string} opts.body - innerHTML for the modal body
     * @param {string} [opts.size] - 'narrow' | 'wide' | undefined for default
     * @param {Array<{label:string, cls?:string, onclick?:string, id?:string, disabled?:boolean}>} [opts.footerButtons]
     * @param {string} [opts.footerStatus] - initial status text
     * @param {Function} [opts.onClose] - callback when modal is closed
     * @returns {HTMLElement} the overlay element
     */
    function modalOpen(opts) {
        modalClose(); // close any existing
        const overlay = document.createElement('div');
        overlay.className = 'modal-overlay';
        overlay.id = 'active-modal-overlay';

        const sizeCls = opts.size ? ` ${opts.size}` : '';
        const footerBtns = (opts.footerButtons || []).map(b =>
            `<button class="btn btn-sm ${b.cls || 'btn-secondary'}" ` +
            `onclick="${b.onclick || ''}"${b.id ? ` id="${b.id}"` : ''}${b.disabled ? ' disabled' : ''}` +
            `${b.style ? ` style="${b.style}"` : ''}>` +
            `${esc(b.label)}</button>`
        ).join('');

        overlay.innerHTML =
            `<div class="modal-box${sizeCls}">` +
            `<div class="modal-header">` +
            `<span class="modal-title">${opts.title}</span>` +
            `<button class="modal-close" onclick="modalClose()" title="Close">âœ•</button>` +
            `</div>` +
            `<div class="modal-body">${opts.body}</div>` +
            (footerBtns || opts.footerStatus ?
                `<div class="modal-footer">` +
                `<span class="modal-footer-status" id="modal-footer-status">${opts.footerStatus || ''}</span>` +
                `<div class="modal-footer-right">${footerBtns}</div>` +
                `</div>` : '') +
            `</div>`;

        // Close on overlay click (not box click)
        overlay.addEventListener('click', e => {
            if (e.target === overlay) modalClose();
        });

        // Close on Escape
        const escHandler = e => { if (e.key === 'Escape') modalClose(); };
        document.addEventListener('keydown', escHandler);

        _activeModal = { overlay, escHandler, onClose: opts.onClose };
        document.body.appendChild(overlay);
        return overlay;
    }

    /** Close the active modal. */
    function modalClose() {
        if (!_activeModal) return;
        const { overlay, escHandler, onClose } = _activeModal;
        document.removeEventListener('keydown', escHandler);
        overlay.remove();
        _activeModal = null;
        if (onClose) onClose();
    }

    /**
     * Build step indicator HTML.
     * @param {string[]} stepNames - array of step labels
     * @param {number} activeIndex - 0-based current step
     * @returns {string} HTML
     */
    function modalSteps(stepNames, activeIndex) {
        return `<div class="modal-steps">${stepNames.map((name, i) => {
            const cls = i < activeIndex ? 'done' : (i === activeIndex ? 'active' : '');
            const dot = i < activeIndex ? 'âœ“' : String(i + 1);
            return (i > 0 ? `<span class="modal-step-arrow">â†’</span>` : '') +
                `<span class="modal-step ${cls}">` +
                `<span class="modal-step-dot">${dot}</span> ${esc(name)}</span>`;
        }).join('')}</div>`;
    }

    /**
     * Build a form field HTML string (for use inside modal forms).
     * @param {Object} f - field definition
     * @param {string} f.name - input name/id
     * @param {string} f.label - label text
     * @param {string} [f.type] - 'text'|'select'|'textarea'|'checkbox'|'number'
     * @param {string} [f.value] - default value
     * @param {string} [f.placeholder] - placeholder text
     * @param {boolean} [f.required] - show required marker
     * @param {string} [f.hint] - hint text under input
     * @param {Array<{value:string, label:string}>} [f.options] - for select type
     * @param {boolean} [f.fullWidth] - span both columns
     * @returns {string} HTML
     */
    function modalFormField(f) {
        const cls = f.fullWidth ? 'modal-form-group full-width' : 'modal-form-group';
        const req = f.required ? '<span class="required">*</span>' : '';
        let input = '';

        if (f.type === 'select') {
            const opts = (f.options || []).map(o =>
                `<option value="${esc(o.value)}"${o.value === f.value ? ' selected' : ''}>${esc(o.label)}</option>`
            ).join('');
            input = `<select class="modal-form-select" id="mf-${f.name}" name="${f.name}">${opts}</select>`;
        } else if (f.type === 'textarea') {
            input = `<textarea class="modal-form-textarea" id="mf-${f.name}" name="${f.name}" ` +
                `placeholder="${esc(f.placeholder || '')}">${esc(f.value || '')}</textarea>`;
        } else if (f.type === 'checkbox') {
            return `<label class="modal-form-check ${f.fullWidth ? 'full-width' : ''}">` +
                `<input type="checkbox" id="mf-${f.name}" name="${f.name}"${f.value ? ' checked' : ''}>` +
                `${esc(f.label)}</label>`;
        } else {
            const t = f.type || 'text';
            input = `<input class="modal-form-input" type="${t}" id="mf-${f.name}" name="${f.name}" ` +
                `value="${esc(f.value || '')}" placeholder="${esc(f.placeholder || '')}">`;
        }

        return `<div class="${cls}">` +
            `<label class="modal-form-label" for="mf-${f.name}">${esc(f.label)}${req}</label>` +
            `${input}` +
            (f.hint ? `<span class="modal-form-hint">${esc(f.hint)}</span>` : '') +
            `</div>`;
    }

    /**
     * Build a preview panel HTML string.
     * @param {string} title - header label
     * @param {string} content - pre-formatted content
     * @param {string} [id] - optional ID for the body element
     * @returns {string} HTML
     */
    function modalPreview(title, content, id) {
        return `<div class="modal-preview">` +
            `<div class="modal-preview-header">${esc(title)}</div>` +
            `<div class="modal-preview-body"${id ? ` id="${id}"` : ''}>${esc(content)}</div>` +
            `</div>`;
    }

    /** Get a modal form field value by name. */
    function mfVal(name) {
        const el = document.getElementById('mf-' + name);
        if (!el) return '';
        if (el.type === 'checkbox') return el.checked;
        return el.value;
    }

    /** Set modal footer status text. */
    function modalStatus(text, type) {
        const el = document.getElementById('modal-footer-status');
        if (!el) return;
        el.textContent = text;
        el.style.color = type === 'error' ? 'var(--error)' :
            type === 'success' ? 'var(--success)' : 'var(--text-muted)';
    }

    /** Show inline error in modal body. */
    function modalError(msg) {
        // Remove previous error
        document.querySelectorAll('.modal-inline-error').forEach(e => e.remove());
        if (!msg) return;
        const body = document.querySelector('.modal-body');
        if (!body) return;
        const div = document.createElement('div');
        div.className = 'modal-inline-error';
        div.textContent = msg;
        body.appendChild(div);
    }


    // â”€â”€ Missing Tools Banner â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    //
    // Shared function to render missing tool banners with install buttons.
    // Any tab can call: renderMissingTools(data.missing_tools, 'container-id')

    /**
     * Render a missing-tools banner into a container element.
     * @param {Array} missingTools - Array of {id, label, install_type, has_recipe, needs_sudo}
     * @param {string} containerId - DOM id to render into
     * @param {Function} [onInstalled] - Optional callback after successful install
     */
    function renderMissingTools(missingTools, containerId, onInstalled) {
        const el = document.getElementById(containerId);
        if (!el) return;
        if (!missingTools || missingTools.length === 0) {
            el.innerHTML = '';
            el.style.display = 'none';
            return;
        }
        el.style.display = 'block';

        let html = '<div class="missing-tools-banner">'
            + '<div class="missing-tools-header">'
            + '<span style="font-size:1rem">âš ï¸</span>'
            + '<span><strong>' + missingTools.length + ' tool'
            + (missingTools.length > 1 ? 's' : '') + ' missing</strong></span>'
            + '</div>'
            + '<div class="missing-tools-list">';

        for (const tool of missingTools) {
            html += '<div class="missing-tool-item">'
                + '<span class="missing-tool-label">' + esc(tool.label) + '</span>';

            if (tool.has_recipe) {
                const dataAttr = ' data-tool-id="' + esc(tool.id) + '"'
                    + ' data-tool-label="' + esc(tool.label) + '"'
                    + ' data-needs-sudo="' + (tool.needs_sudo ? '1' : '0') + '"';
                html += '<button class="btn btn-sm btn-install-tool"'
                    + dataAttr
                    + ' onclick="installToolFromBanner(this'
                    + (onInstalled ? ',true' : '') + ')">'
                    + 'ğŸ“¦ Install</button>';
            } else {
                html += '<span class="missing-tool-manual">Manual install required</span>';
            }

            html += '</div>';
        }

        html += '</div></div>';
        el.innerHTML = html;
    }

    /**
     * Return missing-tools HTML string for inline use (e.g. inside modals).
     * Does NOT need a container id.
     */
    function renderMissingToolsInline(missingTools) {
        if (!missingTools || missingTools.length === 0) return '';

        let html = '<div class="missing-tools-banner" style="margin:0.75rem 0">'
            + '<div class="missing-tools-header">'
            + '<span style="font-size:0.9rem">âš ï¸</span>'
            + '<span style="font-size:0.82rem"><strong>' + missingTools.length + ' tool'
            + (missingTools.length > 1 ? 's' : '') + ' not installed</strong></span>'
            + '</div>'
            + '<div class="missing-tools-list">';

        for (const tool of missingTools) {
            html += '<div class="missing-tool-item">'
                + '<span class="missing-tool-label">' + esc(tool.label) + '</span>';

            if (tool.has_recipe) {
                html += '<button class="btn btn-sm btn-install-tool"'
                    + ' data-tool-id="' + esc(tool.id) + '"'
                    + ' data-tool-label="' + esc(tool.label) + '"'
                    + ' data-needs-sudo="' + (tool.needs_sudo ? '1' : '0') + '"'
                    + ' onclick="installToolFromBanner(this)">'
                    + 'ğŸ“¦ Install</button>';
            } else {
                html += '<span class="missing-tool-manual">Manual install</span>';
            }
            html += '</div>';
        }

        html += '</div></div>';
        return html;
    }

    /**
     * Install a tool via the banner install button.
     * Handles sudo password prompt if needed.
     */
    async function installToolFromBanner(btn, triggerRefresh) {
        const toolId = btn.dataset.toolId;
        const toolLabel = btn.dataset.toolLabel;
        const needsSudo = btn.dataset.needsSudo === '1';

        if (needsSudo) {
            _showOpsModal({
                type: 'install', toolId, toolLabel: toolLabel || toolId, needsSudo: true,
                onSuccess: triggerRefresh ? () => _refreshAfterInstall() : null,
            });
            return;
        }

        btn.disabled = true;
        btn.textContent = 'â³ Installing...';

        try {
            const res = await apiPost('/audit/install-tool', {
                tool: toolId,
                cli: toolId,
            });

            if (res.ok || res.already_installed) {
                btn.textContent = 'âœ… Installed';
                btn.classList.add('btn-success');
                toast(toolLabel + ' installed successfully!', 'success');
                if (triggerRefresh) setTimeout(() => _refreshAfterInstall(), 1200);
            } else if (res.needs_sudo) {
                _showOpsModal({
                    type: 'install', toolId, toolLabel: toolLabel || toolId, needsSudo: true,
                    onSuccess: triggerRefresh ? () => _refreshAfterInstall() : null,
                });
            } else {
                btn.disabled = false;
                btn.textContent = 'âŒ Failed';
                toast(res.error || 'Install failed', 'error');
                setTimeout(() => { btn.textContent = 'ğŸ“¦ Retry'; }, 3000);
            }
        } catch (err) {
            btn.disabled = false;
            btn.textContent = 'âŒ Error';
            toast('Install error: ' + err.message, 'error');
            setTimeout(() => { btn.textContent = 'ğŸ“¦ Retry'; }, 3000);
        }
    }

    // â”€â”€ Backwards-compatible wrapper â”€â”€
    function _showSudoInstallModal(toolId, toolLabel, originBtn, triggerRefresh) {
        _showOpsModal({
            type: 'install', toolId, toolLabel: toolLabel || toolId, needsSudo: true,
            onSuccess: triggerRefresh ? () => _refreshAfterInstall() : null,
        });
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  Unified Ops Modal â€” handles Install + Auth + Interactive flows
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    /**
     * Unified modal for system operations (install, auth, interactive).
     *
     * @param {Object} config
     * @param {string} config.type           'install' | 'auth'
     *
     * Install mode:
     * @param {string} config.toolId         Tool identifier (e.g. 'gh')
     * @param {string} config.toolLabel      Display name (e.g. 'GitHub CLI')
     * @param {Function} [config.onSuccess]  Callback after successful install
     *
     * Auth mode:
     * @param {string} config.title          Modal title
     * @param {string} config.description    Explanation text
     * @param {string} config.loginEndpoint  API endpoint for auth (e.g. '/gh/auth/login')
     * @param {string} config.pollEndpoint   API endpoint to poll for completion
     * @param {Function} config.pollCheck    (data) => boolean â€” returns true when auth is done
     * @param {number} [config.pollInterval] Polling interval in ms (default 3000)
     * @param {number} [config.pollTimeout]  Polling timeout in ms (default 300000)
     * @param {string} [config.tokenHint]    Hint text for token input
     * @param {string} [config.tokenUrl]     URL to create tokens
     * @param {Function} [config.onSuccess]  Callback after successful auth
     */
    function _showOpsModal(config) {
        if (config.type === 'install') return _showInstallModal(config);
        if (config.type === 'auth')    return _showAuthModal(config);
        console.warn('_showOpsModal: unknown type', config.type);
    }

    // â”€â”€ Install Modal (sudo password only when needed) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    function _showInstallModal(config) {
        const { toolId, toolLabel, needsSudo } = config;

        if (!needsSudo) {
            // No sudo needed â€” install directly, no modal
            _doDirectInstall(toolId, toolLabel, config.onSuccess);
            return;
        }

        // Sudo needed â€” show password modal
        document.getElementById('ops-modal')?.remove();

        const modal = document.createElement('div');
        modal.id = 'ops-modal';
        modal.className = 'vault-modal-overlay';
        modal.innerHTML = `<div class="vault-modal" style="max-width:420px">
            <div class="vault-modal-header">
                <span class="vault-modal-title">ğŸ”’ Install ${esc(toolLabel)}</span>
                <button class="vault-modal-close" onclick="document.getElementById('ops-modal')?.remove()">âœ•</button>
            </div>
            <div class="vault-modal-body">
                <div style="font-size:0.82rem;color:var(--text-secondary);margin-bottom:var(--space-md)">
                    <strong>${esc(toolLabel)}</strong> requires sudo privileges to install.
                </div>
                <label style="font-size:0.75rem;font-weight:600;display:block;margin-bottom:4px">ğŸ”‘ Sudo password:</label>
                <input id="ops-modal-pw" type="password" placeholder="Enter your password"
                       style="width:100%;padding:8px 12px;border:1px solid var(--border);border-radius:var(--radius-sm);background:var(--bg-primary);color:var(--text-primary);font-size:0.85rem;box-sizing:border-box"
                       onkeydown="if(event.key==='Enter'){document.getElementById('ops-modal-action').click()}" />
                <div id="ops-modal-log" style="display:none;margin-top:var(--space-sm);font-size:0.72rem;padding:8px;border-radius:var(--radius-sm);background:var(--bg-inset);max-height:100px;overflow:auto;font-family:var(--font-mono,monospace)"></div>
                <div style="display:flex;gap:var(--space-sm);justify-content:flex-end;margin-top:var(--space-md)">
                    <button class="btn btn-sm btn-secondary" onclick="document.getElementById('ops-modal')?.remove()">Cancel</button>
                    <button class="btn btn-sm btn-primary" id="ops-modal-action" style="min-width:100px">ğŸ“¦ Install</button>
                </div>
            </div>
        </div>`;
        document.body.appendChild(modal);
        modal.addEventListener('click', e => { if (e.target === modal) modal.remove(); });
        setTimeout(() => document.getElementById('ops-modal-pw')?.focus(), 100);

        // Wire install button
        document.getElementById('ops-modal-action').addEventListener('click', () => {
            _doSudoInstallAction(toolId, toolLabel, config.onSuccess);
        });
    }

    async function _doDirectInstall(toolId, toolLabel, onSuccess) {
        toast('â³ Installing ' + toolLabel + 'â€¦', 'info');
        try {
            const res = await apiPost('/audit/install-tool', { tool: toolId, cli: toolId });
            if (res.ok || res.already_installed) {
                toast('âœ… ' + (res.message || toolLabel + ' installed!'), 'success');
                if (onSuccess) setTimeout(onSuccess, 500);
            } else if (res.needs_sudo) {
                // Backend says sudo IS needed after all â€” show the modal
                _showInstallModal({ toolId, toolLabel, onSuccess, _forceSudo: true });
            } else {
                toast('âŒ ' + (res.error || 'Install failed'), 'error');
            }
        } catch (err) {
            toast('âŒ Install error: ' + err.message, 'error');
        }
    }

    async function _doSudoInstallAction(toolId, toolLabel, onSuccess) {
        const pw = document.getElementById('ops-modal-pw')?.value;
        const btn = document.getElementById('ops-modal-action');
        const log = document.getElementById('ops-modal-log');
        if (!pw) {
            const input = document.getElementById('ops-modal-pw');
            if (input) { input.style.borderColor = 'var(--error)'; input.placeholder = 'âš ï¸ Password required'; input.focus(); }
            return;
        }
        if (btn) { btn.disabled = true; btn.textContent = 'â³ Installingâ€¦'; }
        if (log) { log.style.display = 'block'; log.textContent = 'Installing ' + toolLabel + 'â€¦'; log.style.color = ''; }

        try {
            const res = await apiPost('/audit/install-tool', {
                tool: toolId, cli: toolId, sudo_password: pw,
            });

            if (res.ok || res.already_installed) {
                if (log) { log.textContent = 'âœ… ' + (res.message || toolLabel + ' installed!'); log.style.color = 'var(--success)'; }
                if (btn) { btn.textContent = 'âœ… Installed'; btn.classList.add('btn-success'); }
                toast(toolLabel + ' installed successfully!', 'success');
                setTimeout(() => {
                    document.getElementById('ops-modal')?.remove();
                    if (onSuccess) onSuccess();
                }, 1200);
            } else if (res.needs_sudo) {
                if (log) { log.textContent = 'ğŸ”‘ ' + (res.error || 'Wrong password â€” try again'); log.style.color = 'var(--warning)'; }
                const input = document.getElementById('ops-modal-pw');
                if (input) { input.value = ''; input.focus(); input.style.borderColor = 'var(--warning)'; }
                if (btn) { btn.disabled = false; btn.textContent = 'ğŸ“¦ Install'; }
            } else {
                if (log) { log.textContent = 'âŒ ' + (res.error || 'Install failed'); log.style.color = 'var(--error)'; }
                if (btn) { btn.disabled = false; btn.textContent = 'ğŸ“¦ Retry'; }
            }
        } catch (err) {
            if (log) { log.textContent = 'âŒ ' + err.message; log.style.color = 'var(--error)'; }
            if (btn) { btn.disabled = false; btn.textContent = 'ğŸ“¦ Retry'; }
        }
    }

    // â”€â”€ Auth Modal (multi-path: browser + terminal + token) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    let _opsPollingTimer = null;
    let _opsDeviceSession = null;

    function _showAuthModal(config) {
        const {
            title = 'ğŸ”‘ Authenticate',
            description = '',
            loginEndpoint = '/gh/auth/login',
            pollEndpoint = '/integrations/gh/status',
            pollCheck = (d) => d.authenticated === true,
            pollInterval = 3000,
            pollTimeout = 300000,
            tokenHint = 'Paste a Personal Access Token',
            tokenUrl = 'https://github.com/settings/tokens',
            onSuccess = null,
        } = config;

        document.getElementById('ops-modal')?.remove();
        if (_opsPollingTimer) { clearInterval(_opsPollingTimer); _opsPollingTimer = null; }
        _opsDeviceSession = null;

        const modal = document.createElement('div');
        modal.id = 'ops-modal';
        modal.className = 'vault-modal-overlay';
        modal.innerHTML = `<div class="vault-modal" style="max-width:520px">
            <div class="vault-modal-header">
                <span class="vault-modal-title">${esc(title)}</span>
                <button class="vault-modal-close" onclick="_opsModalClose()">âœ•</button>
            </div>
            <div class="vault-modal-body" id="ops-auth-body">
                ${description ? `<div style="font-size:0.82rem;color:var(--text-secondary);margin-bottom:var(--space-md)">${description}</div>` : ''}

                <!-- 3-path selector -->
                <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:var(--space-sm);margin-bottom:var(--space-md)">
                    <button class="btn btn-sm" id="ops-path-browser"
                            style="padding:10px;display:flex;flex-direction:column;align-items:center;gap:3px;border:2px solid var(--accent);background:color-mix(in srgb, var(--accent) 8%, var(--bg-primary))"
                            onclick="_opsAuthSelectPath('browser')">
                        <span style="font-size:1.2rem">ğŸŒ</span>
                        <strong style="font-size:0.74rem">Browser Auth</strong>
                        <span style="font-size:0.62rem;color:var(--text-muted)">Recommended</span>
                    </button>
                    <button class="btn btn-sm" id="ops-path-terminal"
                            style="padding:10px;display:flex;flex-direction:column;align-items:center;gap:3px;border:2px solid var(--border);background:var(--bg-primary)"
                            onclick="_opsAuthSelectPath('terminal')">
                        <span style="font-size:1.2rem">ğŸ–¥ï¸</span>
                        <strong style="font-size:0.74rem">Open Terminal</strong>
                        <span style="font-size:0.62rem;color:var(--text-muted)">Interactive</span>
                    </button>
                    <button class="btn btn-sm" id="ops-path-token"
                            style="padding:10px;display:flex;flex-direction:column;align-items:center;gap:3px;border:2px solid var(--border);background:var(--bg-primary)"
                            onclick="_opsAuthSelectPath('token')">
                        <span style="font-size:1.2rem">ğŸ”‘</span>
                        <strong style="font-size:0.74rem">Paste Token</strong>
                        <span style="font-size:0.62rem;color:var(--text-muted)">Manual PAT</span>
                    </button>
                </div>

                <!-- Browser auth panel (default) -->
                <div id="ops-panel-browser">
                    <div style="font-size:0.82rem;color:var(--text-secondary);margin-bottom:var(--space-sm)">
                        Click below to start authentication. A GitHub page will open where you
                        enter a one-time code. No terminal needed.
                    </div>
                    <button class="btn btn-sm btn-primary" id="ops-auth-device-start" style="width:100%;padding:10px"
                            onclick="_opsAuthDeviceStart()">ğŸŒ Start Browser Authentication</button>
                </div>

                <!-- Terminal path panel (hidden) -->
                <div id="ops-panel-terminal" style="display:none">
                    <div style="font-size:0.82rem;color:var(--text-secondary);margin-bottom:var(--space-sm)">
                        Opens a terminal window for interactive <code>gh auth login</code>.
                    </div>
                    <label style="display:flex;align-items:center;gap:0.5rem;margin-bottom:var(--space-sm);cursor:pointer;font-size:0.78rem"
                           title="When checked: auto-selects GitHub.com, HTTPS, and web browser options for you. Detects the auth URL and opens it in your browser. Terminal stays open on errors so you can see what happened.">
                        <input type="checkbox" id="ops-term-auto" checked
                               style="accent-color:var(--accent);margin:0" />
                        <span>ğŸ¤– <strong>Auto-drive</strong> â€” select options &amp; open URL automatically</span>
                    </label>
                    <button class="btn btn-sm btn-primary" id="ops-auth-spawn" style="width:100%;padding:10px"
                            onclick="_opsAuthSpawnTerminal()">ğŸ–¥ï¸ Launch Terminal Authentication</button>
                </div>

                <!-- Token path panel (hidden) -->
                <div id="ops-panel-token" style="display:none">
                    <div style="font-size:0.82rem;color:var(--text-secondary);margin-bottom:var(--space-sm)">
                        ${esc(tokenHint)}.
                        <a href="${esc(tokenUrl)}" target="_blank" rel="noopener" style="color:var(--accent)">Create one here â†’</a>
                    </div>
                    <input id="ops-auth-token" type="password" placeholder="ghp_xxxxxxxxxxâ€¦"
                           style="width:100%;padding:8px 12px;border:1px solid var(--border);border-radius:var(--radius-sm);background:var(--bg-primary);color:var(--text-primary);font-size:0.85rem;box-sizing:border-box;font-family:var(--font-mono,monospace)"
                           onkeydown="if(event.key==='Enter'){document.getElementById('ops-auth-token-go').click()}" />
                    <button class="btn btn-sm btn-primary" id="ops-auth-token-go" style="width:100%;margin-top:var(--space-sm);padding:10px"
                            onclick="_opsAuthWithToken()">ğŸ”‘ Authenticate</button>
                </div>

                <!-- Status / log area -->
                <div id="ops-auth-status" style="display:none;margin-top:var(--space-md);padding:12px;border-radius:var(--radius-sm);background:var(--bg-inset);font-size:0.78rem;text-align:center">
                </div>
            </div>
        </div>`;

        // Store config in a global so panel functions can access it
        window._opsAuthConfig = config;

        document.body.appendChild(modal);
        modal.addEventListener('click', e => { if (e.target === modal) _opsModalClose(); });
    }

    function _opsModalClose() {
        if (_opsPollingTimer) { clearInterval(_opsPollingTimer); _opsPollingTimer = null; }
        _opsDeviceSession = null;
        document.getElementById('ops-modal')?.remove();
        window._opsAuthConfig = null;
    }

    function _opsAuthSelectPath(path) {
        const paths = ['browser', 'terminal', 'token'];
        for (const p of paths) {
            const btn = document.getElementById('ops-path-' + p);
            const panel = document.getElementById('ops-panel-' + p);
            if (!btn || !panel) continue;

            if (p === path) {
                btn.style.borderColor = 'var(--accent)';
                btn.style.background = 'color-mix(in srgb, var(--accent) 8%, var(--bg-primary))';
                panel.style.display = '';
            } else {
                btn.style.borderColor = 'var(--border)';
                btn.style.background = 'var(--bg-primary)';
                panel.style.display = 'none';
            }
        }
        if (path === 'token') {
            setTimeout(() => document.getElementById('ops-auth-token')?.focus(), 100);
        }
    }

    // â”€â”€ Browser Auth (device flow) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    async function _opsAuthDeviceStart() {
        const cfg = window._opsAuthConfig;
        if (!cfg) return;
        const btn = document.getElementById('ops-auth-device-start');
        const statusEl = document.getElementById('ops-auth-status');
        if (btn) { btn.disabled = true; btn.textContent = 'â³ Startingâ€¦'; }

        try {
            const res = await apiPost('/gh/auth/device');

            if (res.ok && res.user_code) {
                _opsDeviceSession = res.session_id;

                // Replace the browser panel with the code display + polling
                const panel = document.getElementById('ops-panel-browser');
                if (panel) {
                    panel.innerHTML = `
                        <div style="text-align:center;padding:var(--space-sm) 0">
                            <div style="font-size:0.78rem;color:var(--text-secondary);margin-bottom:var(--space-sm)">
                                Enter this one-time code on GitHub:
                            </div>
                            <div id="ops-device-code"
                                 style="font-size:2rem;font-weight:800;letter-spacing:0.15em;font-family:var(--font-mono,monospace);
                                        color:var(--accent);background:var(--bg-inset);padding:16px 24px;border-radius:var(--radius-md);
                                        display:inline-block;cursor:pointer;border:2px solid var(--accent);user-select:all;
                                        transition:transform 0.15s"
                                 title="Click to copy"
                                 onclick="navigator.clipboard.writeText('${esc(res.user_code)}').then(()=>{this.style.transform='scale(1.05)';setTimeout(()=>this.style.transform='',200);document.getElementById('ops-code-hint').textContent='âœ“ Copied!'})">
                                ${esc(res.user_code)}
                            </div>
                            <div id="ops-code-hint" style="font-size:0.68rem;color:var(--text-muted);margin-top:6px">
                                Click the code to copy it
                            </div>
                        </div>

                        <div style="margin-top:var(--space-md);text-align:center">
                            <div style="font-size:0.78rem;color:var(--text-secondary);margin-bottom:var(--space-sm)">
                                A GitHub page should have opened in your browser.
                                <a href="${esc(res.verification_url)}" target="_blank" rel="noopener"
                                   style="color:var(--accent)">Open it again â†’</a>
                            </div>
                        </div>

                        <div id="ops-device-poll-status" style="margin-top:var(--space-md);padding:12px;border-radius:var(--radius-sm);background:var(--bg-inset);text-align:center">
                            <div style="display:flex;align-items:center;justify-content:center;gap:0.5rem">
                                <span id="ops-device-spinner">ğŸ”„</span>
                                <span style="font-size:0.82rem">Waiting for you to authorize on GitHubâ€¦</span>
                            </div>
                            <div style="font-size:0.68rem;color:var(--text-muted);margin-top:6px" id="ops-device-elapsed">0s elapsed</div>
                        </div>
                    `;
                }

                // â”€â”€ CRITICAL ORDER: start polling FIRST, then open URL â”€â”€
                // DO NOT await clipboard â€” window.open() steals focus,
                // and clipboard API hangs when document isn't focused.

                // 1) Start polling immediately
                _opsDeviceStartPolling(cfg);

                // 2) Copy code to clipboard (fire-and-forget, no await)
                navigator.clipboard.writeText(res.user_code).then(() => {
                    const hint = document.getElementById('ops-code-hint');
                    if (hint) {
                        hint.style.color = 'var(--success)';
                        hint.style.fontWeight = '600';
                        hint.style.fontSize = '0.78rem';
                        hint.innerHTML = 'âœ… Code copied to clipboard! Just <strong>Ctrl+V paste</strong> it on GitHub';
                    }
                }).catch(() => {
                    const hint = document.getElementById('ops-code-hint');
                    if (hint) hint.textContent = 'âš  Click the code above to copy it, then paste on GitHub';
                });

                // 3) Open GitHub URL LAST (steals focus)
                try {
                    window.open(res.verification_url, '_blank', 'noopener');
                } catch { /* popup blocked â€” user can click the link */ }
            } else {
                if (btn) { btn.disabled = false; btn.textContent = 'ğŸŒ Start Browser Authentication'; }
                const errMsg = res.error || 'Failed to start device flow';
                if (statusEl) {
                    statusEl.style.display = 'block';
                    statusEl.style.color = 'var(--error)';
                    statusEl.textContent = 'âŒ ' + errMsg;
                }
                if (res.raw_output) {
                    console.warn('Device flow raw output:', res.raw_output);
                }
                toast(errMsg, 'error');
            }
        } catch (err) {
            if (btn) { btn.disabled = false; btn.textContent = 'ğŸŒ Start Browser Authentication'; }
            toast('Error: ' + err.message, 'error');
        }
    }

    function _opsDeviceStartPolling(cfg) {
        if (_opsPollingTimer) clearInterval(_opsPollingTimer);

        const startTime = Date.now();
        const emojis = ['ğŸ”„', 'â³', 'ğŸ”', 'ğŸ“¡'];
        let emojiIdx = 0;

        _opsPollingTimer = setInterval(async () => {
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            const mins = Math.floor(elapsed / 60);
            const secs = elapsed % 60;

            // Update UI
            const elapsedEl = document.getElementById('ops-device-elapsed');
            if (elapsedEl) elapsedEl.textContent = mins > 0 ? `${mins}m ${secs}s elapsed` : `${secs}s elapsed`;
            const spinnerEl = document.getElementById('ops-device-spinner');
            if (spinnerEl) { emojiIdx = (emojiIdx + 1) % emojis.length; spinnerEl.textContent = emojis[emojiIdx]; }

            if (!_opsDeviceSession) return;

            try {
                const data = await api('/gh/auth/device/poll?session=' + _opsDeviceSession);

                if (data.complete && data.authenticated) {
                    clearInterval(_opsPollingTimer);
                    _opsPollingTimer = null;
                    _opsAuthSuccess(cfg);
                } else if (data.complete && !data.authenticated) {
                    clearInterval(_opsPollingTimer);
                    _opsPollingTimer = null;
                    const pollEl = document.getElementById('ops-device-poll-status');
                    if (pollEl) {
                        pollEl.innerHTML = `<span style="color:var(--error)">âŒ ${esc(data.error || 'Authentication failed')}</span>
                            <br><button class="btn btn-xs btn-primary" style="margin-top:var(--space-sm)"
                                onclick="_opsAuthDeviceStart()">ğŸ”„ Try Again</button>`;
                    }
                }
                // else: still waiting, do nothing
            } catch { /* ignore poll errors */ }
        }, 3000);
    }

    // â”€â”€ Terminal Spawn â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    async function _opsAuthSpawnTerminal() {
        const cfg = window._opsAuthConfig;
        if (!cfg) return;
        const btn = document.getElementById('ops-auth-spawn');
        const statusEl = document.getElementById('ops-auth-status');
        if (btn) { btn.disabled = true; btn.textContent = 'â³ Launchingâ€¦'; }

        // Check auto-drive checkbox
        const autoDrive = document.getElementById('ops-term-auto')?.checked ?? false;

        try {
            const res = await apiPost(cfg.loginEndpoint, { mode: 'interactive', auto_drive: autoDrive });

            if (res.ok && res.terminal) {
                // Terminal spawned
                if (btn) { btn.textContent = 'âœ… Terminal opened'; }

                if (autoDrive) {
                    // Auto-drive: poll signal file for code + URL
                    _opsTerminalSignalPoll(cfg, statusEl);
                } else {
                    // Manual: just poll gh auth status
                    _opsAuthStartPolling(cfg, statusEl);
                }

            } else if (res.no_terminal) {
                // No working terminal â€” show install options
                _opsShowTerminalInstall(res, cfg);

            } else if (res.fallback && res.command) {
                // Legacy fallback â€” show command to copy
                _opsShowCopyFallback(res, statusEl, btn);
            } else {
                if (btn) { btn.disabled = false; btn.textContent = 'ğŸ–¥ï¸ Launch Terminal Authentication'; }
                toast(res.error || 'Failed to spawn terminal', 'error');
            }
        } catch (err) {
            if (btn) { btn.disabled = false; btn.textContent = 'ğŸ–¥ï¸ Launch Terminal Authentication'; }
            toast('Error: ' + err.message, 'error');
        }
    }

    /** Show terminal emulator install options when no working terminal found. */
    function _opsShowTerminalInstall(res, cfg) {
        const body = document.getElementById('ops-auth-body');
        if (!body) return;

        const broken = res.broken || [];
        const installable = res.installable || [];
        const command = res.command || 'gh auth login';

        // Build broken info
        let brokenHtml = '';
        if (broken.length > 0) {
            const names = broken.map(b => {
                const extra = b.real_binary ? ` â†’ ${esc(b.real_binary)}` : '';
                return `<code>${esc(b.name)}</code>${extra} (${esc(b.reason)})`;
            }).join(', ');
            brokenHtml = `<div style="font-size:0.72rem;color:var(--warning);margin-bottom:var(--space-sm)">
                âš  Found but broken: ${names}
            </div>`;
        }

        // Build installable options
        let installHtml = '';
        if (installable.length > 0) {
            const recommended = installable.find(t => t.name === 'xterm') || installable[0];
            const options = installable.map(t => {
                const isRec = t.name === recommended.name;
                const checked = isRec ? 'checked' : '';
                const badge = isRec ? ' <span style="font-size:0.65rem;background:var(--accent);color:#fff;padding:1px 6px;border-radius:8px;margin-left:4px">recommended</span>' : '';
                return `<label style="display:flex;align-items:center;gap:0.5rem;padding:8px 10px;border-radius:var(--radius-sm);cursor:pointer;font-size:0.82rem;border:1px solid var(--border);background:var(--bg-primary);transition:all 0.15s"
                    onmouseover="this.style.borderColor='var(--accent)'" onmouseout="this.style.borderColor='var(--border)'">
                    <input type="radio" name="ops-term-choice" value="${esc(t.name)}" ${checked}
                           style="accent-color:var(--accent);margin:0" />
                    <div style="flex:1">
                        <strong>${esc(t.label)}</strong>${badge}
                        <div style="font-size:0.7rem;color:var(--text-muted)">${esc(t.description)} â€” <code>${esc(t.apt_package)}</code></div>
                    </div>
                </label>`;
            }).join('');

            installHtml = `
                <div style="font-size:0.82rem;font-weight:600;margin-bottom:var(--space-sm)">Install a terminal emulator:</div>
                <div style="display:flex;flex-direction:column;gap:6px;margin-bottom:var(--space-md)">${options}</div>
                <button class="btn btn-sm btn-primary" id="ops-term-install-btn" style="width:100%;padding:10px"
                    onclick="_opsInstallTerminal()">ğŸ“¦ Install Selected Terminal</button>
            `;
        }

        // Fallback: copy command
        const fallbackHtml = `
            <div style="margin-top:var(--space-md);padding-top:var(--space-md);border-top:1px solid var(--border)">
                <div style="font-size:0.78rem;color:var(--text-secondary);margin-bottom:var(--space-sm)">
                    Or run the command manually:
                </div>
                <div style="display:flex;align-items:center;gap:0.5rem">
                    <code style="flex:1;background:var(--bg-tertiary);padding:6px 10px;border-radius:4px;font-size:0.78rem">${esc(command)}</code>
                    <button class="btn btn-xs btn-secondary" style="font-size:0.68rem;padding:3px 8px;white-space:nowrap"
                        onclick="navigator.clipboard.writeText('${command.replace(/'/g, "\\'")}').then(()=>this.textContent='âœ“ Copied').catch(()=>{});setTimeout(()=>this.textContent='ğŸ“‹ Copy',2000)">ğŸ“‹ Copy</button>
                </div>
                <button class="btn btn-xs btn-primary" style="margin-top:var(--space-sm);width:100%;padding:8px"
                    onclick="_opsAuthPollOnce()">ğŸ”„ Check Status</button>
            </div>
        `;

        // Replace the terminal panel content
        body.innerHTML = `
            <div style="font-size:0.85rem;color:var(--warning);margin-bottom:var(--space-md)">
                <strong>âš  No working terminal emulator found.</strong>
            </div>
            <div style="font-size:0.78rem;color:var(--text-secondary);margin-bottom:var(--space-md)">
                A terminal emulator is needed for the interactive authentication flow.
                Install one below, or paste a token instead.
            </div>
            ${brokenHtml}
            ${installHtml}
            ${installable.length === 0 ? '<div style="font-size:0.82rem;color:var(--error);margin-bottom:var(--space-sm)">No terminal emulators available to install.</div>' : ''}
            ${fallbackHtml}
            <div style="margin-top:var(--space-md);text-align:center">
                <button class="btn btn-xs btn-secondary" style="font-size:0.72rem"
                    onclick="_opsShowTokenFromInstall()">ğŸ”‘ Switch to Token Paste</button>
            </div>

            <!-- Status / log area (reused by polling) -->
            <div id="ops-auth-status" style="display:none;margin-top:var(--space-md);padding:12px;border-radius:var(--radius-sm);background:var(--bg-inset);font-size:0.78rem;text-align:center"></div>
        `;
    }

    /** Install a selected terminal emulator, then retry terminal spawn. */
    async function _opsInstallTerminal() {
        const selected = document.querySelector('input[name="ops-term-choice"]:checked');
        if (!selected) { toast('Select a terminal emulator first', 'warning'); return; }

        const termName = selected.value;
        const btn = document.getElementById('ops-term-install-btn');

        // Use the existing install modal flow â€” but with a callback to retry spawn
        const cfg = window._opsAuthConfig;
        _opsModalClose(); // Close auth modal temporarily

        _showOpsModal({
            type: 'install',
            toolId: termName,
            toolLabel: termName,
            needsSudo: true,
            onSuccess: () => {
                // Terminal installed â€” re-open the auth modal and auto-retry
                toast(termName + ' installed! Retrying terminal spawnâ€¦', 'success');
                setTimeout(() => {
                    if (cfg) {
                        _showAuthModal(cfg);
                        // Auto-click the spawn button after modal renders
                        setTimeout(() => _opsAuthSpawnTerminal(), 300);
                    }
                }, 800);
            },
        });
    }

    /** Show copy-command fallback (legacy path). */
    function _opsShowCopyFallback(res, statusEl, btn) {
        if (statusEl) {
            statusEl.style.display = 'block';
            statusEl.style.textAlign = 'left';
            statusEl.innerHTML = `
                <div style="font-size:0.82rem;color:var(--warning);margin-bottom:var(--space-sm)">
                    <strong>âš  No terminal emulator found.</strong> Run this in your terminal:
                </div>
                <div style="display:flex;align-items:center;gap:0.5rem">
                    <code style="flex:1;background:var(--bg-tertiary);padding:6px 10px;border-radius:4px;font-size:0.78rem">${esc(res.command)}</code>
                    <button class="btn btn-xs btn-secondary" style="font-size:0.68rem;padding:3px 8px;white-space:nowrap"
                        onclick="navigator.clipboard.writeText('${res.command.replace(/'/g, "\\'")}').then(()=>this.textContent='âœ“ Copied').catch(()=>{});setTimeout(()=>this.textContent='ğŸ“‹ Copy',2000)">ğŸ“‹ Copy</button>
                </div>
                <div style="font-size:0.72rem;color:var(--text-muted);margin-top:var(--space-sm)">
                    After completing auth, click <strong>Check Status</strong> below.
                </div>
                <button class="btn btn-xs btn-primary" style="margin-top:var(--space-sm);width:100%;padding:8px"
                    onclick="_opsAuthPollOnce()">ğŸ”„ Check Status</button>
            `;
        }
        if (btn) { btn.disabled = false; btn.textContent = 'ğŸ–¥ï¸ Launch Terminal Authentication'; }
    }

    /** Re-open auth modal on token tab (from terminal install flow where DOM was replaced). */
    function _opsShowTokenFromInstall() {
        const cfg = window._opsAuthConfig;
        if (!cfg) return;
        _opsModalClose();
        _showAuthModal(cfg);
        // Auto-switch to token tab after render
        setTimeout(() => _opsAuthSelectPath('token'), 100);
    }
    /**
     * Poll terminal signal file for device code, URL, and completion.
     * When code_ready: show code in modal + open GitHub URL.
     * When success: trigger auth success.
     */
    function _opsTerminalSignalPoll(cfg, statusEl) {
        if (_opsPollingTimer) clearInterval(_opsPollingTimer);

        let codeShown = false;
        const startTime = Date.now();
        const emojis = ['ğŸ”„', 'â³', 'ğŸ”', 'ğŸ“¡'];
        let emojiIdx = 0;

        if (statusEl) {
            statusEl.style.display = 'block';
            statusEl.innerHTML = `
                <div style="display:flex;align-items:center;justify-content:center;gap:0.5rem;margin-bottom:0.5rem">
                    <span id="ops-poll-spinner">${emojis[0]}</span>
                    <span>Waiting for device code from terminalâ€¦</span>
                </div>
                <div style="font-family:monospace;font-size:0.72rem;color:var(--text-muted)" id="ops-poll-elapsed">0s elapsed</div>
                <div style="font-size:0.68rem;color:var(--text-muted);margin-top:0.4rem">Complete the Y/n prompt in the terminal window.</div>
            `;
        }

        _opsPollingTimer = setInterval(async () => {
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            const mins = Math.floor(elapsed / 60);
            const secs = elapsed % 60;

            const elapsedEl = document.getElementById('ops-poll-elapsed');
            if (elapsedEl) elapsedEl.textContent = mins > 0 ? `${mins}m ${secs}s elapsed` : `${secs}s elapsed`;
            const spinnerEl = document.getElementById('ops-poll-spinner');
            if (spinnerEl) { emojiIdx = (emojiIdx + 1) % emojis.length; spinnerEl.textContent = emojis[emojiIdx]; }

            // Timeout after 5 minutes
            if (Date.now() - startTime > 300000) {
                clearInterval(_opsPollingTimer);
                _opsPollingTimer = null;
                if (statusEl) {
                    statusEl.innerHTML = `<span style="color:var(--warning)">â±ï¸ Timed out. <button class="btn btn-xs btn-primary" onclick="_opsAuthPollOnce()">ğŸ”„ Check Now</button></span>`;
                }
                return;
            }

            try {
                const data = await api('/gh/auth/terminal/poll');

                if (data.status === 'code_ready' && !codeShown) {
                    codeShown = true;
                    // Show device code + open-link in the modal panel
                    const panel = document.getElementById('ops-panel-terminal');
                    if (panel) {
                        const codeHtml = `
                            <div style="text-align:center;margin-top:var(--space-md)">
                                <div style="font-size:0.82rem;color:var(--text-secondary);margin-bottom:var(--space-xs)">Your one-time code:</div>
                                <div style="font-size:2rem;font-weight:800;letter-spacing:0.15em;font-family:monospace;
                                    background:var(--bg-tertiary);padding:12px 24px;border-radius:var(--radius-md);display:inline-block;
                                    cursor:pointer;user-select:all;border:2px solid var(--accent)"
                                    title="Click to copy"
                                    onclick="navigator.clipboard.writeText('${data.code}').then(()=>toast('Copied!','success'))">
                                    ${data.code}
                                </div>
                                <div id="ops-code-hint" style="font-size:0.72rem;color:var(--text-muted);margin-top:var(--space-xs)">
                                    Click code to copy â€¢ Paste it on GitHub
                                </div>
                                <a href="${data.url}" target="_blank" rel="noopener"
                                    style="display:inline-block;margin-top:var(--space-sm);padding:8px 20px;
                                    background:var(--accent);color:#fff;border-radius:var(--radius-md);
                                    font-weight:700;font-size:0.88rem;text-decoration:none;
                                    transition:opacity 0.2s"
                                    onmouseover="this.style.opacity='0.85'"
                                    onmouseout="this.style.opacity='1'"
                                    >ğŸ”— Open GitHub to paste code</a>
                            </div>
                        `;
                        // Insert before the status element
                        if (statusEl) {
                            statusEl.insertAdjacentHTML('beforebegin', codeHtml);
                            statusEl.innerHTML = `
                                <div style="display:flex;align-items:center;justify-content:center;gap:0.5rem;margin-bottom:0.5rem">
                                    <span id="ops-poll-spinner">ğŸ“¡</span>
                                    <span>Waiting for you to authorize on GitHubâ€¦</span>
                                </div>
                                <div style="font-family:monospace;font-size:0.72rem;color:var(--text-muted)" id="ops-poll-elapsed">${secs}s elapsed</div>
                            `;
                        }
                    }

                    // Try to copy code to clipboard
                    navigator.clipboard.writeText(data.code).then(() => {
                        const hint = document.getElementById('ops-code-hint');
                        if (hint) {
                            hint.style.color = 'var(--success)';
                            hint.style.fontWeight = '600';
                            hint.innerHTML = 'âœ… Code copied! Just <strong>Ctrl+V paste</strong> it on GitHub';
                        }
                    }).catch(() => {});
                }

                if (data.status === 'success') {
                    clearInterval(_opsPollingTimer);
                    _opsPollingTimer = null;
                    _opsAuthSuccess(cfg);
                    return;
                }

                if (data.status === 'failed') {
                    clearInterval(_opsPollingTimer);
                    _opsPollingTimer = null;
                    if (statusEl) {
                        statusEl.innerHTML = `<span style="color:var(--error)">âŒ Authentication failed in terminal. Check the terminal window for details.</span>`;
                    }
                    return;
                }
            } catch { /* ignore poll errors */ }
        }, 2000);
    }

    function _opsAuthStartPolling(cfg, statusEl) {
        if (_opsPollingTimer) clearInterval(_opsPollingTimer);

        const startTime = Date.now();
        const timeout = cfg.pollTimeout || 300000;
        const interval = cfg.pollInterval || 3000;
        const pollCheck = cfg.pollCheck || (() => false);
        const pollEndpoint = cfg.pollEndpoint || '/integrations/gh/status';
        const emojis = ['ğŸ”„', 'â³', 'ğŸ”', 'ğŸ“¡'];
        let emojiIdx = 0;

        if (statusEl) {
            statusEl.style.display = 'block';
            statusEl.innerHTML = `
                <div style="display:flex;align-items:center;justify-content:center;gap:0.5rem;margin-bottom:0.5rem">
                    <span id="ops-poll-spinner">${emojis[0]}</span>
                    <span>Waiting for authentication to completeâ€¦</span>
                </div>
                <div style="font-family:monospace;font-size:0.72rem;color:var(--text-muted)" id="ops-poll-elapsed">0s elapsed</div>
                <div style="font-size:0.68rem;color:var(--text-muted);margin-top:0.4rem">Complete the login in the terminal window that opened.</div>
            `;
        }

        _opsPollingTimer = setInterval(async () => {
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            const mins = Math.floor(elapsed / 60);
            const secs = elapsed % 60;

            // Update UI
            const elapsedEl = document.getElementById('ops-poll-elapsed');
            if (elapsedEl) elapsedEl.textContent = mins > 0 ? `${mins}m ${secs}s elapsed` : `${secs}s elapsed`;
            const spinnerEl = document.getElementById('ops-poll-spinner');
            if (spinnerEl) { emojiIdx = (emojiIdx + 1) % emojis.length; spinnerEl.textContent = emojis[emojiIdx]; }

            // Timeout check
            if (Date.now() - startTime > timeout) {
                clearInterval(_opsPollingTimer);
                _opsPollingTimer = null;
                if (statusEl) {
                    statusEl.innerHTML = `<span style="color:var(--warning)">â±ï¸ Polling timed out. <button class="btn btn-xs btn-primary" onclick="_opsAuthPollOnce()">ğŸ”„ Check Now</button></span>`;
                }
                return;
            }

            // Poll
            try {
                const data = await api(pollEndpoint);
                if (pollCheck(data)) {
                    clearInterval(_opsPollingTimer);
                    _opsPollingTimer = null;
                    _opsAuthSuccess(cfg);
                }
            } catch { /* ignore poll errors */ }
        }, interval);
    }

    async function _opsAuthPollOnce() {
        const cfg = window._opsAuthConfig;
        if (!cfg) return;
        const statusEl = document.getElementById('ops-auth-status');
        try {
            const data = await api(cfg.pollEndpoint || '/integrations/gh/status');
            const check = cfg.pollCheck || (() => false);
            if (check(data)) {
                _opsAuthSuccess(cfg);
            } else {
                if (statusEl) {
                    statusEl.innerHTML = `<span style="color:var(--warning)">âš  Not authenticated yet. Complete the login flow and try again.</span>
                    <button class="btn btn-xs btn-primary" style="margin-top:var(--space-sm);width:100%;padding:8px"
                        onclick="_opsAuthPollOnce()">ğŸ”„ Check Again</button>`;
                }
            }
        } catch (err) {
            if (statusEl) {
                statusEl.innerHTML = `<span style="color:var(--error)">âŒ ${esc(err.message)}</span>`;
            }
        }
    }

    async function _opsAuthWithToken() {
        const cfg = window._opsAuthConfig;
        if (!cfg) return;
        const tokenInput = document.getElementById('ops-auth-token');
        const btn = document.getElementById('ops-auth-token-go');
        const statusEl = document.getElementById('ops-auth-status');
        const token = tokenInput?.value?.trim();

        if (!token) {
            if (tokenInput) { tokenInput.style.borderColor = 'var(--error)'; tokenInput.placeholder = 'âš ï¸ Token required'; tokenInput.focus(); }
            return;
        }

        if (btn) { btn.disabled = true; btn.textContent = 'â³ Authenticatingâ€¦'; }
        if (statusEl) { statusEl.style.display = 'block'; statusEl.textContent = 'ğŸ”„ Authenticatingâ€¦'; statusEl.style.color = ''; }

        try {
            const res = await apiPost(cfg.loginEndpoint, { token });

            if (res.ok && res.authenticated) {
                _opsAuthSuccess(cfg);
            } else {
                if (statusEl) { statusEl.textContent = 'âŒ ' + (res.error || 'Authentication failed'); statusEl.style.color = 'var(--error)'; }
                if (btn) { btn.disabled = false; btn.textContent = 'ğŸ”‘ Authenticate'; }
                if (tokenInput) { tokenInput.value = ''; tokenInput.focus(); tokenInput.style.borderColor = 'var(--warning)'; }
            }
        } catch (err) {
            if (statusEl) { statusEl.textContent = 'âŒ ' + err.message; statusEl.style.color = 'var(--error)'; }
            if (btn) { btn.disabled = false; btn.textContent = 'ğŸ”‘ Authenticate'; }
        }
    }

    function _opsAuthSuccess(cfg) {
        // Replace the entire modal body with a success state
        const body = document.getElementById('ops-auth-body');
        if (body) {
            body.innerHTML = `
                <div style="text-align:center;padding:var(--space-lg) 0">
                    <div style="font-size:2.5rem;margin-bottom:var(--space-sm)">âœ…</div>
                    <div style="font-size:1.1rem;font-weight:700;color:var(--success);margin-bottom:var(--space-sm)">
                        Authenticated successfully!
                    </div>
                    <div style="font-size:0.78rem;color:var(--text-muted)">
                        Closing in a momentâ€¦
                    </div>
                </div>
            `;
        }
        toast('Authentication successful!', 'success');

        // Silent background cache bust â€” ONLY the github card changed
        (async () => {
            try {
                await apiPost('/devops/cache/bust', { card: 'github' }).catch(() => {});
            } catch { /* ignore */ }

            // Clear ONLY github-related client-side caches
            if (typeof _store !== 'undefined') {
                for (const k of Object.keys(_store)) {
                    if (k.startsWith('gh:') || k === 'github' || k === 'capabilities') {
                        delete _store[k];
                    }
                }
            }
            if (typeof wizInvalidate === 'function') {
                try { wizInvalidate('detect'); wizInvalidate('gh:detect'); } catch {}
            }

            // Reload ONLY the GitHub card â€” not all integrations
            cardInvalidate('github');  // clear sessionStorage
            if (typeof loadGitHubCard === 'function') {
                // Show spinner on GH card while re-fetching
                const ghDetail = document.getElementById('int-gh-detail');
                const ghBadge = document.getElementById('int-gh-badge');
                if (ghDetail) ghDetail.innerHTML = '<span class="spinner"></span>';
                if (ghBadge) { ghBadge.className = 'status-badge'; ghBadge.textContent = 'â€”'; }
                await loadGitHubCard();
            }
        })();

        setTimeout(() => {
            _opsModalClose();
            if (cfg.onSuccess) cfg.onSuccess();
        }, 2000);
    }

    // â”€â”€ Convenience helpers for GitHub auth â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    function _showGhAuthModal(onSuccess) {
        _showOpsModal({
            type: 'auth',
            title: 'ğŸ”‘ Authenticate GitHub',
            description: 'Connect your GitHub account via the <code>gh</code> CLI.',
            loginEndpoint: '/gh/auth/login',
            pollEndpoint: '/integrations/gh/status',
            pollCheck: (d) => d.authenticated === true,
            tokenHint: 'Use a GitHub Personal Access Token (classic or fine-grained)',
            tokenUrl: 'https://github.com/settings/tokens',
            onSuccess: onSuccess || null,  // _opsAuthSuccess already handles cache bust
        });
    }

    // â”€â”€ After-install refresh â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    /** After a tool install/auth, bust caches and re-load the active tab instead of full page reload. */
    async function _refreshAfterInstall() {
        try {
            // Bust server-side cache so next fetch re-runs detection
            await apiPost('/devops/cache/bust', { card: 'integrations' }).catch(() => {});
            await apiPost('/devops/cache/bust', { card: 'devops' }).catch(() => {});
        } catch { /* ignore */ }

        // Clear ONLY integration/devops client-side caches (not everything!)
        if (typeof _store !== 'undefined') {
            for (const k of Object.keys(_store)) {
                if (k.startsWith('int:') || k.startsWith('gh:') || k.startsWith('devops:') || k === 'integrations' || k === 'capabilities') {
                    delete _store[k];
                }
            }
        }

        // Invalidate wizard caches too (if wizard is open)
        if (typeof wizInvalidate === 'function') {
            try { wizInvalidate('detect'); wizInvalidate('gh:detect'); } catch {}
        }

        // Re-load whichever tab is active
        if (typeof _intLoaded !== 'undefined') { _intLoaded = false; _intPrefs = null; }
        const activeTab = document.querySelector('.tab-btn.active')?.dataset?.tab;
        if (activeTab === 'integrations' && typeof loadIntegrationsTab === 'function') {
            await loadIntegrationsTab(true);
        } else if (activeTab === 'devops' && typeof loadDevOpsTab === 'function') {
            await loadDevOpsTab(true);
        } else if (activeTab === 'audit' && typeof loadAuditTab === 'function') {
            await loadAuditTab(true);
        } else {
            // Fallback: reload current tab by clicking it
            document.querySelector('.tab-btn.active')?.click();
        }
    }

</script>
<!-- Integrations â€” K8s Setup Wizard Helpers
     Pure utility functions used by the K8s wizard.
     Must load BEFORE _integrations_setup_k8s.html.
     Depends on: _integrations_setup_shared.html
-->
<script>

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // â”€â”€ K8s Wizard Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    /** Classify a module for K8s (same logic as Docker wizard). */
    window._k8sModClass = function(mod) {
        const dom = (mod.domain || '').toLowerCase();
        const st  = (mod.stack  || '').toLowerCase();
        if (dom === 'library')  return 'library';
        if (dom === 'docs' || st === 'markdown') return 'docs';
        if (['kubernetes', 'helm', 'terraform', 'docker-compose'].includes(st)) return 'ops-tool';
        return 'deployable';
    };

    /**
     * Classify a compose service as 'application' or 'infrastructure'.
     * Infrastructure = well-known DB/cache/broker images with no build context.
     * Application = has build context, or image matches project/module name.
     */
    window._k8sSvcClass = function(svc, moduleNames) {
        // Has build config â†’ definitely an application
        if (svc.build) return 'application';
        // Image matches a project module name â†’ application
        if (svc.image && moduleNames.some(n => svc.image.includes(n))) return 'application';
        // Well-known infrastructure image prefixes
        const infraImages = [
            'postgres', 'mysql', 'mariadb', 'mongo', 'redis', 'valkey', 'memcached',
            'rabbitmq', 'kafka', 'nats', 'mosquitto', 'elasticsearch', 'opensearch',
            'nginx', 'traefik', 'haproxy', 'envoy', 'caddy',
            'grafana', 'prometheus', 'jaeger', 'zipkin', 'loki',
            'minio', 'vault', 'consul', 'etcd', 'zookeeper',
            'mailpit', 'adminer', 'pgadmin', 'neo4j', 'cassandra',
            'cockroachdb', 'couchdb', 'influxdb', 'clickhouse', 'timescale',
            'redpanda', 'activemq', 'pulsar', 'celery',
            'gitea', 'portainer', 'seq', 'vector', 'fluentd', 'logstash',
            'keycloak', 'dex', 'hydra',
            'localstack', 'dynamodb-local', 'azurite',
            'dragonfly', 'keydb', 'arangodb', 'surrealdb',
        ];
        const imgLower = (svc.image || '').toLowerCase();
        if (infraImages.some(prefix => imgLower.includes(prefix))) return 'infrastructure';
        // No build + no known infra image â†’ treat as application (external image)
        return 'application';
    };

    /**
     * Classify what K8s workload kind a compose service should default to.
     * Returns: 'Deployment' | 'StatefulSet' | 'DaemonSet' | 'Job' | 'CronJob'
     */
    window._classifyWorkloadKind = function(svc) {
        const img = (svc.image || '').split(':')[0].split('/').pop().toLowerCase();
        const name = (svc.name || '').toLowerCase();

        // 1. Well-known stateful databases / brokers â†’ StatefulSet
        const statefulImages = new Set([
            'postgres', 'mysql', 'mariadb', 'mongo', 'mongodb', 'redis', 'valkey',
            'cassandra', 'cockroachdb', 'couchdb', 'neo4j', 'influxdb', 'clickhouse',
            'timescaledb', 'surrealdb', 'arangodb', 'dragonfly', 'keydb',
            'elasticsearch', 'opensearch', 'kafka', 'rabbitmq', 'nats',
            'redpanda', 'activemq', 'pulsar', 'zookeeper', 'etcd', 'consul',
            'minio', 'vault',
        ]);
        if (statefulImages.has(img)) return 'StatefulSet';

        // 2. Well-known node-level agents â†’ DaemonSet
        const daemonImages = new Set([
            'fluentd', 'fluent-bit', 'fluentbit', 'logstash', 'vector',
            'filebeat', 'metricbeat', 'node-exporter', 'promtail',
            'datadog-agent', 'newrelic-infra', 'falco',
        ]);
        if (daemonImages.has(img)) return 'DaemonSet';

        // 3. Compose deploy.mode: global â†’ DaemonSet
        if (svc.deploy && svc.deploy.mode === 'global') return 'DaemonSet';

        // 4. No ports + one-shot signals â†’ Job
        const noPorts = !svc.ports || svc.ports.length === 0;
        const isOneShot = svc.restart === 'no' || svc.restart === 'on-failure';
        const jobNamePatterns = ['migrate', 'migration', 'seed', 'init-db', 'setup', 'import'];
        const nameIsJob = jobNamePatterns.some(p => name.includes(p));
        if (noPorts && (isOneShot || nameIsJob)) return 'Job';

        // 5. Default â†’ Deployment
        return 'Deployment';
    };

    /** Map workload kind â†’ icon for display. */
    window._kindIcon = function(kind) {
        const icons = {
            'Deployment': 'ğŸš€', 'StatefulSet': 'ğŸ—„ï¸', 'DaemonSet': 'ğŸŒ',
            'Job': 'âš¡', 'CronJob': 'â°', 'Managed': 'â˜ï¸', 'Skip': 'â­ï¸',
        };
        return icons[kind] || 'ğŸ“¦';
    };

    /** Map workload kind â†’ hint text explaining the heuristic. */
    window._kindHint = function(kind, svc) {
        const img = (svc.image || '').split(':')[0].split('/').pop().toLowerCase();
        switch (kind) {
            case 'StatefulSet': return 'ğŸ’¡ Database/stateful image detected â†’ stable identity + per-pod storage';
            case 'DaemonSet':
                if (svc.deploy && svc.deploy.mode === 'global') return 'ğŸ’¡ Compose deploy.mode: global â†’ one pod per node';
                return 'ğŸ’¡ Node-level agent detected â†’ one pod per node';
            case 'Job': return 'ğŸ’¡ No ports + one-shot restart â†’ run-to-completion task';
            case 'Deployment': return '';
            default: return '';
        }
    };

    /** Resolve best image name for a service in K8s context. */
    window._k8sImageName = function(svc, ghRepo) {
        // 1. If compose has explicit image â†’ use it
        if (svc.image) return svc.image;
        // 2. If we have a GitHub repo â†’ construct from registry
        if (ghRepo && ghRepo.owner && ghRepo.name) {
            return `ghcr.io/${ghRepo.owner}/${ghRepo.name}-${svc.name}:latest`;
        }
        // 3. Fallback
        return `${svc.name}:latest`;
    };

    /** Get the primary container port from a compose service. */
    window._k8sPrimaryPort = function(svc) {
        if (svc.ports && svc.ports.length > 0) return svc.ports[0].container;
        return 8080;
    };

</script>
